<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Destruction Engine V53 - Three.js Hybrid</title>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #080808;
            color: #ccc;
            font-family: 'Segoe UI', monospace;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: auto;
            background: rgba(15, 25, 40, 0.95);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #446;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
        }

        h3 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .key {
            color: #4db8ff;
            font-weight: bold;
        }

        .warn {
            color: #55ff55;
        }

        .feature {
            color: #ffaa00;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            color: #888;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        #perfPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            pointer-events: none;
            background: rgba(5, 10, 20, 0.92);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #335;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.7);
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 12px;
            color: #aab;
            min-width: 220px;
            transition: opacity 0.3s;
        }

        #perfPanel.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #perfPanel .perf-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #667;
            margin-bottom: 6px;
        }

        #perfPanel .perf-fps {
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
            margin-bottom: 4px;
        }

        #perfPanel .perf-fps.good {
            color: #4f8;
        }

        #perfPanel .perf-fps.ok {
            color: #fd4;
        }

        #perfPanel .perf-fps.bad {
            color: #f44;
        }

        #perfPanel .perf-row {
            display: flex;
            justify-content: space-between;
            padding: 1px 0;
        }

        #perfPanel .perf-label {
            color: #778;
        }

        #perfPanel .perf-val {
            color: #bbc;
            font-weight: bold;
        }

        #perfPanel .perf-bar-bg {
            height: 3px;
            background: #223;
            border-radius: 2px;
            margin: 2px 0;
            overflow: hidden;
        }

        #perfPanel .perf-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s;
        }

        #perfPanel .perf-sep {
            border-top: 1px solid #223;
            margin: 5px 0;
        }

        #perfGraph {
            margin-top: 6px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h3>Hybrid Engine V52 (Fixed)</h3>
        <div><span class="key">[W / S]</span> - Silnik</div>
        <div><span class="key">[A / D]</span> - ObrĂłt</div>
        <div><span class="key">[LPM]</span> - <b>PRZECIÄ„GNIJ: ASTEROIDA</b></div>
        <div><span class="key">[PPM]</span> - <b>LASER TNÄ„CY</b></div>
        <div><span class="key">[Spacja]</span> - Reset</div>
        <div style="margin-top: 10px; font-size: 13px;">
            <span class="feature">Hybrid Physics:</span><br>
            Low Impulse -> Rigid Body Bounce<br>
            High Impulse -> Soft Body Crush<br>
            <span class="warn">Yield Point: 1,000J</span>
        </div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #446;">
            <span class="feature">WĹASNY SPRITE:</span><br>
            <input type="file" id="shipPicker" accept="image/*" style="margin-top: 5px; font-size: 12px; color: #ccc;">
        </div>
    </div>
    <div id="status">Inicjalizacja...</div>
    <div id="perfPanel">
        <div class="perf-title">WYDAJNOĹšÄ† <span style="float:right;color:#556">[P] toggle</span></div>
        <div class="perf-fps good" id="perfFps">--</div>
        <div style="color:#556;font-size:10px;margin-bottom:6px" id="perfFrameTime">-- ms/frame</div>
        <div class="perf-sep"></div>
        <div class="perf-row"><span class="perf-label">Fizyka</span><span class="perf-val" id="perfPhysics">--</span>
        </div>
        <div class="perf-bar-bg">
            <div class="perf-bar" id="barPhysics" style="width:0%;background:#4af"></div>
        </div>
        <div class="perf-row"><span class="perf-label"> â”” Kolizje</span><span class="perf-val"
                id="perfCollisions">--</span></div>
        <div class="perf-bar-bg">
            <div class="perf-bar" id="barCollisions" style="width:0%;background:#f84"></div>
        </div>
        <div class="perf-row"><span class="perf-label"> â”” Deformacja</span><span class="perf-val"
                id="perfDeform">--</span></div>
        <div class="perf-bar-bg">
            <div class="perf-bar" id="barDeform" style="width:0%;background:#8f4"></div>
        </div>
        <div class="perf-row"><span class="perf-label">Rysowanie</span><span class="perf-val" id="perfDraw">--</span>
        </div>
        <div class="perf-bar-bg">
            <div class="perf-bar" id="barDraw" style="width:0%;background:#f4f"></div>
        </div>
        <div class="perf-sep"></div>
        <div class="perf-row"><span class="perf-label">Entities</span><span class="perf-val" id="perfEntities">--</span>
        </div>
        <div class="perf-row"><span class="perf-label">Shardy (aktywne)</span><span class="perf-val"
                id="perfShards">--</span></div>
        <div class="perf-row"><span class="perf-label">Debris</span><span class="perf-val" id="perfDebris">--</span>
        </div>
        <div class="perf-row"><span class="perf-label">Kontakty/klatka</span><span class="perf-val"
                id="perfContacts">--</span></div>
        <canvas id="perfGraph" width="220" height="40"></canvas>
    </div>
    <div id="game-root" style="position:relative;width:100vw;height:100vh;overflow:hidden;background:#080808;">
        <canvas id="webgl-layer" style="position:absolute;top:0;left:0;z-index:0;width:100%;height:100%;"></canvas>
        <canvas id="c" style="position:absolute;top:0;left:0;z-index:1;"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const camera = { x: 0, y: 0, zoom: 0.5 };

        // --- PERFORMANCE PROFILER ---
        const Perf = {
            // Timing accumulators (reset every update interval)
            physicsTime: 0,
            collisionTime: 0,
            deformTime: 0,
            drawTime: 0,
            frameCount: 0,
            contactsThisFrame: 0,
            contactsAccum: 0,

            // Displayed values (updated every interval)
            fps: 0,
            avgFrameTime: 0,
            dPhysics: 0,
            dCollisions: 0,
            dDeform: 0,
            dDraw: 0,
            dEntities: 0,
            dShards: 0,
            dDebris: 0,
            dContacts: 0,

            // Frame time history for graph
            history: new Float32Array(110),
            histIdx: 0,

            // DOM refs (cached)
            els: null,
            graphCtx: null,
            visible: true,
            lastUpdate: 0,
            updateInterval: 500, // ms between display refreshes

            init() {
                this.els = {
                    fps: document.getElementById('perfFps'),
                    frameTime: document.getElementById('perfFrameTime'),
                    physics: document.getElementById('perfPhysics'),
                    collisions: document.getElementById('perfCollisions'),
                    deform: document.getElementById('perfDeform'),
                    draw: document.getElementById('perfDraw'),
                    entities: document.getElementById('perfEntities'),
                    shards: document.getElementById('perfShards'),
                    debris: document.getElementById('perfDebris'),
                    contacts: document.getElementById('perfContacts'),
                    barPhysics: document.getElementById('barPhysics'),
                    barCollisions: document.getElementById('barCollisions'),
                    barDeform: document.getElementById('barDeform'),
                    barDraw: document.getElementById('barDraw'),
                    panel: document.getElementById('perfPanel'),
                };
                const graphCanvas = document.getElementById('perfGraph');
                this.graphCtx = graphCanvas.getContext('2d');
                this.history.fill(16.67);
            },

            toggle() {
                this.visible = !this.visible;
                this.els.panel.classList.toggle('hidden', !this.visible);
            },

            startFrame() {
                this.contactsThisFrame = 0;
            },

            recordFrameTime(totalMs) {
                this.history[this.histIdx % this.history.length] = totalMs;
                this.histIdx++;
                this.frameCount++;
            },

            flush(now) {
                if (now - this.lastUpdate < this.updateInterval) return;
                const n = this.frameCount || 1;
                this.fps = Math.round(1000 / ((now - this.lastUpdate) / n));
                this.avgFrameTime = (now - this.lastUpdate) / n;
                this.dPhysics = this.physicsTime / n;
                this.dCollisions = this.collisionTime / n;
                this.dDeform = this.deformTime / n;
                this.dDraw = this.drawTime / n;
                this.dContacts = this.contactsAccum / n;

                // Count objects
                let totalShards = 0;
                for (const e of entities) {
                    if (e.hexGrid) {
                        const sh = e.hexGrid.shards;
                        for (let i = 0, l = sh.length; i < l; i++) {
                            if (sh[i].active && !sh[i].isDebris) totalShards++;
                        }
                    }
                }
                this.dEntities = entities.length;
                this.dShards = totalShards;
                this.dDebris = DestructorSystem.debris.length;

                this.updateDOM();
                this.drawGraph();

                // Reset accumulators
                this.physicsTime = 0;
                this.collisionTime = 0;
                this.deformTime = 0;
                this.drawTime = 0;
                this.contactsAccum = 0;
                this.frameCount = 0;
                this.lastUpdate = now;
            },

            updateDOM() {
                if (!this.visible) return;
                const e = this.els;
                // FPS number + color
                e.fps.textContent = this.fps;
                e.fps.className = 'perf-fps ' + (this.fps >= 55 ? 'good' : this.fps >= 30 ? 'ok' : 'bad');
                e.frameTime.textContent = this.avgFrameTime.toFixed(1) + ' ms/frame';

                // Timing rows
                e.physics.textContent = this.dPhysics.toFixed(2) + ' ms';
                e.collisions.textContent = this.dCollisions.toFixed(2) + ' ms';
                e.deform.textContent = this.dDeform.toFixed(2) + ' ms';
                e.draw.textContent = this.dDraw.toFixed(2) + ' ms';

                // Bars (scale: 16.67ms = 100%)
                const barScale = 100 / 16.67;
                e.barPhysics.style.width = Math.min(100, this.dPhysics * barScale).toFixed(0) + '%';
                e.barCollisions.style.width = Math.min(100, this.dCollisions * barScale).toFixed(0) + '%';
                e.barDeform.style.width = Math.min(100, this.dDeform * barScale).toFixed(0) + '%';
                e.barDraw.style.width = Math.min(100, this.dDraw * barScale).toFixed(0) + '%';

                // Counts
                e.entities.textContent = this.dEntities;
                e.shards.textContent = this.dShards;
                e.debris.textContent = this.dDebris;
                e.contacts.textContent = Math.round(this.dContacts);
            },

            drawGraph() {
                if (!this.visible) return;
                const gCtx = this.graphCtx;
                const w = 220, h = 40;
                gCtx.clearRect(0, 0, w, h);

                // Background
                gCtx.fillStyle = '#0a0e18';
                gCtx.fillRect(0, 0, w, h);

                // 60fps line (16.67ms)
                const y60 = h - (16.67 / 50) * h;
                gCtx.strokeStyle = '#2a3a2a';
                gCtx.lineWidth = 1;
                gCtx.setLineDash([3, 3]);
                gCtx.beginPath();
                gCtx.moveTo(0, y60);
                gCtx.lineTo(w, y60);
                gCtx.stroke();
                gCtx.setLineDash([]);

                // 30fps line (33.33ms)
                const y30 = h - (33.33 / 50) * h;
                gCtx.strokeStyle = '#3a2a2a';
                gCtx.beginPath();
                gCtx.setLineDash([3, 3]);
                gCtx.moveTo(0, y30);
                gCtx.lineTo(w, y30);
                gCtx.stroke();
                gCtx.setLineDash([]);

                // Frame time bars
                const len = this.history.length;
                const barW = w / len;
                const startIdx = this.histIdx;
                for (let i = 0; i < len; i++) {
                    const idx = (startIdx + i) % len;
                    const ms = this.history[idx];
                    const barH = Math.min(h, (ms / 50) * h);
                    const x = i * barW;

                    // Color based on frame time
                    if (ms < 17) gCtx.fillStyle = '#2a6a3a';
                    else if (ms < 33) gCtx.fillStyle = '#6a6a2a';
                    else gCtx.fillStyle = '#6a2a2a';

                    gCtx.fillRect(x, h - barH, barW - 0.5, barH);
                }
            }
        };

        function worldToScreen(wx, wy, cam) {
            return {
                x: (wx - cam.x) * cam.zoom + width / 2,
                y: (wy - cam.y) * cam.zoom + height / 2
            };
        }

        function screenToWorld(sx, sy, cam) {
            return {
                x: (sx - width / 2) / cam.zoom + cam.x,
                y: (sy - height / 2) / cam.zoom + cam.y
            };
        }

        const DESTRUCTOR_CONFIG = {
            gridDivisions: 4,
            shardHP: 100,
            armorThreshold: 0.4,
            maxDeform: 120.0,
            tearThreshold: 180.0,
            bendingRadius: 100.0,
            playerStartingMass: 800000,
            friction: 0.99,
            shardMass: 10.0,
            visualRotationOffset: 0,
            yieldPoint: 200.0,
            restitution: 0.05,
            plasticity: 0.00002,
            collisionDeformScale: 1.0, // startowo 0.25
            collisionSearchRadius: 5,  // ile kratek wokĂłĹ‚ sprawdzamy w mapie (wiÄ™ksze = lepsze przy duĹĽych deformacjach)
            collisionIterations: 4,
            crushMinSpeed: 1.5,          // minimalna prÄ™dkoĹ›Ä‡ kontaktu dla deformacji (m/s w twoich jednostkach)
            crushPenetrationMin: 0.15,   // minimalna penetracja, ĹĽeby zaczÄ…Ä‡ wgniatanie "na docisk"
            crushVelK: 0.15,             // jak mocno prÄ™dkoĹ›Ä‡ wzglÄ™dna wgniata (stara wersja miaĹ‚a ~0.15)
            crushPenK: 10.0,             // jak mocno penetracja wgniata (docisk)
            shearK: 0.06,                // jak mocno "szorowanie" gniecie (skĹ‚adowa styczna)
            crushSeparation: 0.25,       // mniejsza separacja = dĹ‚uĹĽszy kontakt = pĹ‚ynniejsze wgniatanie
            crushImpulseScale: 0.45,     // ile impulsu zostaje przy niszczeniu (mniej = mniej "odbijania" celu)
            dummyMass: 20000,       // Masa kukĹ‚y
            debrisMass: 50,         // Masa odĹ‚amkĂłw
            asteroidMass: 1000000,  // Masa asteroidy
            asteroidSpeedMult: 10,  // MnoĹĽnik prÄ™dkoĹ›ci asteroidy
            asteroidMaxSpeed: 4000, // Limit prÄ™dkoĹ›ci asteroidy
            asteroidHPMult: 10,     // MnoĹĽnik HP szardĂłw asteroidy

            recoverSpeed: 1.0,      // SzybkoĹ›Ä‡ powrotu do ksztaĹ‚tu (elastycznoĹ›Ä‡ wizualna)
            repairRate: 100,        // SzybkoĹ›Ä‡ naprawy HP (klawisz R)
            visualLerpSpeed: 5.0,   // PĹ‚ynnoĹ›Ä‡ animacji deformacji

            softBodyTension: 0.15,  // NapiÄ™cie powierzchniowe (0.0 - 1.0)
            tearSensitivity: 0.15,  // WraĹĽliwoĹ›Ä‡ na strzÄ™pienie krawÄ™dzi
            maxFray: 15.0,          // Maksymalne postrzÄ™pienie (px)
            deformMul: 0.6,         // MnoĹĽnik deformacji od uderzenia
            cleaveForce: 1.5,
            // --- PLASTYCZNOĹšÄ† (TrwaĹ‚e odksztaĹ‚cenia) ---
            plasticYield: 15.0,     // PrĂłg siĹ‚y, od ktĂłrego blacha gnie siÄ™ na staĹ‚e
            maxPlastic: 60.0,       // Maksymalne trwaĹ‚e wgniecenie (ĹĽeby statek nie zapadĹ‚ siÄ™ w punkt)
            plasticityRate: 0.8,    // SzybkoĹ›Ä‡ pochĹ‚aniania siĹ‚y w staĹ‚e wgniecenie
            inflictedDamageMult: 1.0, // MnoĹĽnik obraĹĽeĹ„ od siĹ‚y uderzenia

            // CRUMPLE ZONE (GPU 3D accordion deformation)
            crumpleStiffnessXY: 0.3,   // XY spring stiffness between neighbors
            crumpleStiffnessZ: 0.5,    // Z spring stiffness (accordion)
            crumpleDamping: 0.92,      // velocity damping per step (1.0 = no damping)
            crumpleAccordion: 0.8,     // alternating Z sign strength (0=none, 1=full)
            crumpleMaxZ: 15.0,         // max Z deformation (px)
            crumpleMaxXY: 30.0,        // max XY deformation (px)

            beamWidth: 12,          // SzerokoĹ›Ä‡ lasera
            beamForce: 400,         // SiĹ‚a odepchniÄ™cia lasera

            playerSpeed: 600,       // SiĹ‚a silnikĂłw gracza
            playerTurnAccel: 10.0,  // Przyspieszenie obrotu
            playerMaxTurn: 2.5,     // Maksymalna prÄ™dkoĹ›Ä‡ obrotu
            zoomSpeed: 0.001        // CzuĹ‚oĹ›Ä‡ zoomu
        };

        // --- PRECOMPUTED CONSTANTS (hoisted out of hot loops) ---
        const HEX_R = DESTRUCTOR_CONFIG.gridDivisions;
        const HEX_HEIGHT = Math.sqrt(3) * HEX_R;
        const HEX_SPACING = HEX_R * 1.5;
        const HIT_RAD_SQ = (HEX_R * 1.3) ** 2;
        const HIT_RAD = HEX_R * 1.3;
        const BENDING_RAD_SQ = DESTRUCTOR_CONFIG.bendingRadius * DESTRUCTOR_CONFIG.bendingRadius;

        // Precomputed offset lists for collision neighborhood searches (avoid nested loops + string keys in hot path)
        const _SEARCH_OFFSETS_CACHE = Object.create(null);
        function getSearchOffsets(radius) {
            const r = radius | 0;
            let arr = _SEARCH_OFFSETS_CACHE[r];
            if (arr) return arr;
            const list = [];
            const r2 = r * r;
            for (let dc = -r; dc <= r; dc++) {
                for (let dr = -r; dr <= r; dr++) {
                    if (dc * dc + dr * dr <= r2) {
                        list.push(dc, dr);
                    }
                }
            }
            // Int8Array is enough for our typical radii (<= 16); Int16Array fallback if bigger
            arr = (r <= 127) ? new Int8Array(list) : new Int16Array(list);
            _SEARCH_OFFSETS_CACHE[r] = arr;
            return arr;
        }


        // ====================================================================
        // THREE.JS HEX RENDERER â€” Instanced GPU rendering of hex shards
        // ====================================================================
        const HexRenderer = {
            renderer: null,
            scene: null,
            camera: null,
            entityMeshes: new Map(),
            _dummy: null, // reusable Object3D for matrix computation

            HEX_VERTEX: `
                attribute vec2 aGridPos;
                attribute float aHPRatio;
                attribute float aStress;

                uniform vec2 uSpriteSize;

                varying vec2 vSpriteUV;
                varying float vHPRatio;
                varying float vStress;

                void main() {
                    vHPRatio = aHPRatio;
                    vStress = aStress;
                    // UV into sprite based on original grid position (not deformed)
                    vSpriteUV = (aGridPos + position.xy) / uSpriteSize;

                    // instanceMatrix handles: translate(gridX+deformX-cx, gridY+deformY-cy)
                    // modelMatrix handles: entity world position + rotation
                    vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(position.xy, 0.0, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,

            HEX_FRAGMENT: `
                uniform sampler2D uArmorTex;
                uniform sampler2D uDamagedTex;
                uniform float uArmorThreshold;
                uniform float uHasArmorTex;
                uniform float uHasDamagedTex;
                uniform float uIsProjectile;
                uniform vec3 uColor;

                varying vec2 vSpriteUV;
                varying float vHPRatio;
                varying float vStress;

                void main() {
                    // Discard outside sprite bounds
                    if (vSpriteUV.x < -0.01 || vSpriteUV.x > 1.01 ||
                        vSpriteUV.y < -0.01 || vSpriteUV.y > 1.01) discard;

                    vec3 color;
                    float alpha = 1.0;

                    if (uIsProjectile > 0.5) {
                        color = uColor;
                    } else {
                        // Base: damaged texture or dark fallback
                        vec4 damaged = vec4(0.133, 0.133, 0.133, 1.0);
                        if (uHasDamagedTex > 0.5) {
                            damaged = texture2D(uDamagedTex, vSpriteUV);
                        }
                        color = damaged.rgb;
                        alpha = damaged.a;

                        // Armor overlay blended by HP
                        if (uHasArmorTex > 0.5) {
                            float armorAlpha = 0.0;
                            if (vHPRatio > uArmorThreshold) {
                                armorAlpha = (vHPRatio - uArmorThreshold) / (1.0 - uArmorThreshold);
                            }
                            if (armorAlpha > 0.01) {
                                vec4 armor = texture2D(uArmorTex, vSpriteUV);
                                color = mix(color, armor.rgb, armorAlpha * armor.a);
                                alpha = max(alpha, armor.a * armorAlpha);
                            }
                        }
                    }

                    // Stress glow (deformation heat)
                    if (vStress > 5.0) {
                        float ratio = min(1.0, vStress / 100.0);
                        color = mix(color, vec3(1.0, ratio * 0.4, 0.0), ratio * 0.6);
                    }

                    if (alpha < 0.01) discard;
                    gl_FragColor = vec4(color, alpha);
                }
            `,

            init() {
                const webglCanvas = document.getElementById('webgl-layer');
                this.renderer = new THREE.WebGLRenderer({
                    canvas: webglCanvas,
                    alpha: true,
                    antialias: false,
                    powerPreference: 'high-performance'
                });
                this.renderer.setSize(width, height);
                this.renderer.setClearColor(0x080808, 1);
                this.renderer.setPixelRatio(1);

                this.scene = new THREE.Scene();
                // OrthographicCamera â€” top/bottom flipped to match Canvas 2D Y-down
                this.camera = new THREE.OrthographicCamera(
                    -width / 2, width / 2,
                    -height / 2, height / 2,
                    0.1, 10000
                );
                this.camera.position.z = 1000;

                this._dummy = new THREE.Object3D();
            },

            createEntityMesh(entity) {
                if (!entity.hexGrid) return null;
                const grid = entity.hexGrid;
                const shards = grid.shards;
                const count = shards.length;

                // Base hex geometry (6 segments = hexagon, overlap 1.08)
                const hexGeo = new THREE.CircleGeometry(HEX_R * 1.08, 6);

                // Textures from shard image sources (canvas elements)
                const firstShard = shards[0];
                let armorTex = null, damagedTex = null;
                if (firstShard && firstShard.img) {
                    armorTex = new THREE.CanvasTexture(firstShard.img);
                    armorTex.flipY = false;
                    armorTex.minFilter = THREE.LinearFilter;
                    armorTex.magFilter = THREE.LinearFilter;
                }
                if (firstShard && firstShard.damagedImg) {
                    damagedTex = new THREE.CanvasTexture(firstShard.damagedImg);
                    damagedTex.flipY = false;
                    damagedTex.minFilter = THREE.LinearFilter;
                    damagedTex.magFilter = THREE.LinearFilter;
                }

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        uSpriteSize: { value: new THREE.Vector2(grid.srcWidth, grid.srcHeight) },
                        uArmorTex: { value: armorTex || new THREE.Texture() },
                        uDamagedTex: { value: damagedTex || new THREE.Texture() },
                        uArmorThreshold: { value: DESTRUCTOR_CONFIG.armorThreshold },
                        uHasArmorTex: { value: armorTex ? 1.0 : 0.0 },
                        uHasDamagedTex: { value: damagedTex ? 1.0 : 0.0 },
                        uIsProjectile: { value: entity.isProjectile ? 1.0 : 0.0 },
                        uColor: { value: new THREE.Color(firstShard?.color || '#ffcc00') }
                    },
                    vertexShader: this.HEX_VERTEX,
                    fragmentShader: this.HEX_FRAGMENT,
                    transparent: true,
                    depthWrite: false,
                    depthTest: false,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.InstancedMesh(hexGeo, material, count);
                mesh.frustumCulled = false;

                // Custom per-instance attributes
                const gridPosArr = new Float32Array(count * 2);
                const hpArr = new Float32Array(count);
                const stressArr = new Float32Array(count);

                for (let i = 0; i < count; i++) {
                    const s = shards[i];
                    gridPosArr[i * 2] = s.gridX;
                    gridPosArr[i * 2 + 1] = s.gridY;

                    // IMPORTANT: initialize visual state from current simulation state.
                    // This avoids 1-frame "undamaged sprite" flicker when meshes are rebuilt after splits.
                    const hpRatio = (s.maxHp > 0) ? (s.hp / s.maxHp) : 0.0;
                    hpArr[i] = Math.max(0.0, Math.min(1.0, hpRatio));

                    const dx = s.deformation ? s.deformation.x : 0.0;
                    const dy = s.deformation ? s.deformation.y : 0.0;
                    stressArr[i] = Math.sqrt(dx * dx + dy * dy);
                }

                mesh.geometry.setAttribute('aGridPos',
                    new THREE.InstancedBufferAttribute(gridPosArr, 2));
                mesh.geometry.setAttribute('aHPRatio',
                    new THREE.InstancedBufferAttribute(hpArr, 1));
                mesh.geometry.setAttribute('aStress',
                    new THREE.InstancedBufferAttribute(stressArr, 1));

                // Set initial instance matrices
                const centerX = grid.srcWidth / 2;
                const centerY = grid.srcHeight / 2;
                const pivotX = grid.pivot ? grid.pivot.x : 0;
                const pivotY = grid.pivot ? grid.pivot.y : 0;
                const dummy = this._dummy;

                for (let i = 0; i < count; i++) {
                    const s = shards[i];
                    if (s.active && !s.isDebris) {
                        dummy.position.set(
                            s.gridX + s.deformation.x - centerX - pivotX,
                            s.gridY + s.deformation.y - centerY - pivotY, 0);
                    } else {
                        dummy.position.set(0, 0, -99999);
                    }
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;

                // Entity world transform
                mesh.position.set(entity.x, entity.y, 0);
                mesh.rotation.z = entity.angle + DESTRUCTOR_CONFIG.visualRotationOffset;

                this.scene.add(mesh);

                const data = {
                    mesh,
                    shards,
                    centerX,
                    centerY,
                    hpAttr: mesh.geometry.getAttribute('aHPRatio'),
                    stressAttr: mesh.geometry.getAttribute('aStress')
                };
                this.entityMeshes.set(entity, data);
                return data;
            },

            updateEntityMesh(entity) {
                let data = this.entityMeshes.get(entity);
                if (!data) return;

                // Detect if shards array was replaced (by split/rebuild)
                if (data.shards !== entity.hexGrid.shards) {
                    this.scene.remove(data.mesh);
                    data.mesh.geometry.dispose();
                    this.entityMeshes.delete(entity);

                    // Recreate and continue updating in the same frame (prevents any transient visual mismatch).
                    data = this.createEntityMesh(entity);
                    if (!data) return;
                }

                const { mesh, shards, centerX, centerY, hpAttr, stressAttr } = data;
                const dummy = this._dummy;
                const pivotX = entity.hexGrid.pivot ? entity.hexGrid.pivot.x : 0;
                const pivotY = entity.hexGrid.pivot ? entity.hexGrid.pivot.y : 0;

                for (let i = 0; i < shards.length; i++) {
                    const s = shards[i];
                    if (s.active && !s.isDebris) {
                        dummy.position.set(
                            s.gridX + s.deformation.x - centerX - pivotX,
                            s.gridY + s.deformation.y - centerY - pivotY,
                            s.deformZ || 0);
                        dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix);
                        hpAttr.array[i] = s.hp / s.maxHp;
                        const dx = s.deformation.x, dy = s.deformation.y, dz = s.deformZ || 0;
                        stressAttr.array[i] = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    } else {
                        dummy.position.set(0, 0, -99999);
                        dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix);
                    }
                }

                mesh.instanceMatrix.needsUpdate = true;
                hpAttr.needsUpdate = true;
                stressAttr.needsUpdate = true;

                // Entity world transform
                mesh.position.set(entity.x, entity.y, 0);
                mesh.rotation.z = entity.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
            },

            syncCamera() {
                const cam = camera;
                const z = cam.zoom;
                const halfW = width / (2 * z);
                const halfH = height / (2 * z);
                this.camera.left = -halfW;
                this.camera.right = halfW;
                this.camera.top = -halfH;   // flipped Y to match canvas
                this.camera.bottom = halfH;
                this.camera.position.set(cam.x, cam.y, 1000);
                this.camera.lookAt(cam.x, cam.y, 0);
                this.camera.updateProjectionMatrix();
            },

            update(entitiesArr) {
                this.syncCamera();
                const alive = new Set(entitiesArr);

                // Remove meshes for deleted entities
                for (const [ent, data] of this.entityMeshes) {
                    if (!alive.has(ent)) {
                        this.scene.remove(data.mesh);
                        data.mesh.geometry.dispose();
                        this.entityMeshes.delete(ent);
                    }
                }

                // Create/update meshes
                for (const ent of entitiesArr) {
                    if (!ent.hexGrid) continue;
                    if (!this.entityMeshes.has(ent)) {
                        this.createEntityMesh(ent);
                    }
                    this.updateEntityMesh(ent);
                }
            },

            render() {
                if (this.renderer) {
                    this.renderer.render(this.scene, this.camera);
                }
            },

            resize() {
                if (this.renderer) this.renderer.setSize(width, height);
            }
        };

        class HexShard {
            constructor(img, damagedImg, gridX, gridY, radius, c, r, color = null) {
                this.img = img;
                this.damagedImg = damagedImg;
                this.gridX = gridX;
                this.gridY = gridY;
                this.radius = radius;
                this.c = c;
                this.r = r;
                this.color = color;
                this.active = true;
                this.isDebris = false;
                this.maxHp = DESTRUCTOR_CONFIG.shardHP;
                this.hp = this.maxHp;
                this.deformation = { x: 0, y: 0 };
                this.targetDeformation = { x: 0, y: 0 };
                // CRUMPLE ZONE: 3D accordion deformation
                this.deformZ = 0;
                this.velX = 0;
                this.velY = 0;
                this.velZ = 0;

                // --- NOWOĹšÄ†: Tablica deformacji wierzchoĹ‚kĂłw (efekt strzÄ™pienia) ---
                this.frays = [];
                for (let i = 0; i < 6; i++) this.frays.push({ x: 0, y: 0 });
                // ------------------------------------------------------------------

                this.worldX = 0; this.worldY = 0;
                this.dvx = 0; this.dvy = 0; this.drot = 0;
                this.alpha = 1;
                this.angle = 0;
                this.scale = 1.0;
                this.neighbors = [];
                this.verts = [];
                for (let i = 0; i < 6; i++) {
                    const a = i * Math.PI / 3;
                    this.verts.push({ x: Math.cos(a) * radius, y: Math.sin(a) * radius });
                }
            }
            repair(dt) {
                if (!this.active || this.isDebris) return;
                const recoverSpeed = DESTRUCTOR_CONFIG.recoverSpeed;
                this.targetDeformation.x *= (1.0 - Math.min(1.0, recoverSpeed * dt));
                this.targetDeformation.y *= (1.0 - Math.min(1.0, recoverSpeed * dt));

                // Opcjonalnie: Powolne naprawianie strzÄ™pienia (bardzo wolne, ĹĽeby Ĺ›lady walki zostawaĹ‚y)
                // JeĹ›li chcesz trwaĹ‚e zniszczenia, usuĹ„ poniĹĽszÄ… pÄ™tlÄ™.
                /*
                for(let i=0; i<6; i++) {
                    this.frays[i].x *= 0.99;
                    this.frays[i].y *= 0.99;
                }
                */

                this.hp = Math.min(this.maxHp, this.hp + DESTRUCTOR_CONFIG.repairRate * dt);
            }
            updateAnimation(dt) {
                const lerpSpeed = DESTRUCTOR_CONFIG.visualLerpSpeed;
                const dx = this.targetDeformation.x - this.deformation.x;
                const dy = this.targetDeformation.y - this.deformation.y;
                if (Math.abs(dx) > 0.05 || Math.abs(dy) > 0.05) {
                    this.deformation.x += dx * lerpSpeed * dt;
                    this.deformation.y += dy * lerpSpeed * dt;
                    return true;
                }
                return false;
            }
            applyDeformation(vecX, vecY) {
                this.targetDeformation.x += vecX;
                this.targetDeformation.y += vecY;

                // --- EFEKT PLASTYCZNOĹšCI (TrwaĹ‚e zgniatanie statku) ---
                // Po przekroczeniu progu (yieldPoint) metal zapamiÄ™tuje nowy ksztaĹ‚t.
                const yieldPoint = DESTRUCTOR_CONFIG.plasticYield || 15.0;
                const maxPlastic = DESTRUCTOR_CONFIG.maxPlastic || 60.0;
                const plasticityRate = DESTRUCTOR_CONFIG.plasticityRate || 0.8;

                const currentDefSq = this.targetDeformation.x ** 2 + this.targetDeformation.y ** 2;

                if (currentDefSq > yieldPoint * yieldPoint) {
                    const currentDef = Math.sqrt(currentDefSq);
                    const excess = currentDef - yieldPoint;

                    // Obliczamy wektor trwaĹ‚ego przesuniÄ™cia (jak mocno blacha siÄ™ poddaĹ‚a)
                    const shiftX = (this.targetDeformation.x / currentDef) * excess * plasticityRate;
                    const shiftY = (this.targetDeformation.y / currentDef) * excess * plasticityRate;

                    // Obliczamy oryginalnÄ… pozycjÄ™ heksa w siatce
                    const hexHeight = Math.sqrt(3) * this.radius;
                    const origGridX = this.c * this.radius * 1.5;
                    const origGridY = this.r * hexHeight + (this.c % 2 !== 0 ? hexHeight / 2 : 0);

                    // Zabezpieczenie: limitujemy max wgniecenie, ĹĽeby nie zepsuÄ‡ hit-boxĂłw (Search Radius)
                    const totalShiftX = (this.gridX + shiftX) - origGridX;
                    const totalShiftY = (this.gridY + shiftY) - origGridY;
                    const totalShiftSq = totalShiftX * totalShiftX + totalShiftY * totalShiftY;

                    if (totalShiftSq < maxPlastic * maxPlastic) {
                        // Metal siÄ™ wygina! Przemieszczamy punkt zerowy heksa na staĹ‚e.
                        this.gridX += shiftX;
                        this.gridY += shiftY;

                        // RozĹ‚adowujemy napiÄ™cie sprÄ™ĹĽyste, bo siatka przyjÄ™Ĺ‚a juĹĽ nowy ksztaĹ‚t.
                        // Zmniejszamy teĹĽ deformacjÄ™ wizualnÄ…, ĹĽeby nie byĹ‚o przeskoku klatki.
                        this.targetDeformation.x -= shiftX;
                        this.targetDeformation.y -= shiftY;
                        this.deformation.x -= shiftX;
                        this.deformation.y -= shiftY;
                    }
                }

                // --- LIMITY SPRÄĹ»YSTE ---
                const maxD = DESTRUCTOR_CONFIG.maxDeform;
                const tx = this.targetDeformation.x;
                const ty = this.targetDeformation.y;
                const d2 = tx * tx + ty * ty;

                if (d2 > maxD * maxD) {
                    const s = maxD / Math.sqrt(d2);
                    this.targetDeformation.x *= s;
                    this.targetDeformation.y *= s;
                }

                // tear check
                const tt = DESTRUCTOR_CONFIG.tearThreshold;
                if (this.targetDeformation.x ** 2 + this.targetDeformation.y ** 2 > tt * tt) this.hp = 0;
            }
            becomeDebris(impulseX, impulseY, parentEntity, scale = 1.0) {
                if (this.isDebris) return;
                this.scale = scale;
                const px = parentEntity.x;
                const py = parentEntity.y;
                const rotation = parentEntity.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const c = Math.cos(rotation);
                const s = Math.sin(rotation);
                const centerX = parentEntity.hexGrid.srcWidth / 2;
                const centerY = parentEntity.hexGrid.srcHeight / 2;
                const pX = parentEntity.hexGrid.pivot ? parentEntity.hexGrid.pivot.x : 0;
                const pY = parentEntity.hexGrid.pivot ? parentEntity.hexGrid.pivot.y : 0;
                const startLx = (this.gridX - centerX) + this.deformation.x - pX;
                const startLy = (this.gridY - centerY) + this.deformation.y - pY;
                this.worldX = px + (startLx * scale) * c - (startLy * scale) * s;
                this.worldY = py + (startLx * scale) * s + (startLy * scale) * c;
                let vx = parentEntity.vx || 0;
                let vy = parentEntity.vy || 0;
                const angVel = parentEntity.angVel || 0;
                const rx = (startLx * scale) * c - (startLy * scale) * s;
                const ry = (startLx * scale) * s + (startLy * scale) * c;
                vx += -angVel * ry;
                vy += angVel * rx;
                this.dvx = vx + impulseX + (this.deformation.x * 3.0);
                this.dvy = vy + impulseY + (this.deformation.y * 3.0);
                this.drot = (Math.random() - 0.5) * 8.0;
                this.angle = rotation;
                this.alpha = 1.0;
                this.isDebris = true;
                this.active = true;
                DestructorSystem.debris.push(this);
                if (parentEntity.mass) {
                    parentEntity.mass -= DESTRUCTOR_CONFIG.shardMass;
                    if (parentEntity.mass < 10) parentEntity.mass = 10;
                }
            }
            updateDebris(dt) {
                this.worldX += this.dvx * dt;
                this.worldY += this.dvy * dt;
                this.angle += this.drot * dt;
                this.dvx *= DESTRUCTOR_CONFIG.friction;
                this.dvy *= DESTRUCTOR_CONFIG.friction;
                this.alpha -= dt * 0.2;
                if (this.alpha <= 0) this.active = false;
            }
            drawDebris(ctx, camera) {
                if (!this.active || !this.isDebris) return;
                const p = worldToScreen(this.worldX, this.worldY, camera);
                if (p.x < -100 || p.x > ctx.canvas.width + 100 || p.y < -100 || p.y > ctx.canvas.height + 100) return;
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(this.angle);
                const s = camera.zoom * (this.scale || 1.0);
                ctx.scale(s, s);
                ctx.globalAlpha = Math.max(0, this.alpha);
                this._drawHexPath(ctx);
                ctx.clip();
                if (this.damagedImg) ctx.drawImage(this.damagedImg, -this.gridX, -this.gridY);
                else if (this.img) ctx.drawImage(this.img, -this.gridX, -this.gridY);
                else { ctx.fillStyle = '#444'; ctx.fill(); }
                ctx.restore();
            }
            drawShape(ctx) {
                // (Ta metoda pozostaje bez zmian, ale wklejam dla kontekstu)
                ctx.save();
                ctx.translate(this.gridX + this.deformation.x, this.gridY + this.deformation.y);
                this._drawHexPath(ctx); // To wywoĹ‚a naszÄ… nowÄ… funkcjÄ™
                ctx.save();
                ctx.clip();
                if (this.color) { ctx.fillStyle = this.color; ctx.fill(); }
                else {
                    if (this.damagedImg) ctx.drawImage(this.damagedImg, -this.gridX, -this.gridY);
                    else { ctx.fillStyle = '#222'; ctx.fill(); }
                    if (this.img) {
                        const hpRatio = this.hp / this.maxHp;
                        const threshold = DESTRUCTOR_CONFIG.armorThreshold;
                        let armorAlpha = 0;
                        if (hpRatio > threshold) armorAlpha = (hpRatio - threshold) / (1.0 - threshold);
                        if (armorAlpha > 0.01) {
                            ctx.globalAlpha = armorAlpha;
                            ctx.drawImage(this.img, -this.gridX, -this.gridY);
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                ctx.restore();
                const stressSq = this.deformation.x * this.deformation.x + this.deformation.y * this.deformation.y;
                if (stressSq > 25.0) { // 5.0^2
                    const stress = Math.sqrt(stressSq);
                    const ratio = Math.min(1.0, stress / DESTRUCTOR_CONFIG.tearThreshold);
                    const alpha = ratio * 0.6;
                    ctx.fillStyle = `rgba(255, ${Math.floor(ratio * 100)}, 0, ${alpha})`;
                    ctx.fill();
                }
                ctx.restore();
            }

            _drawHexPath(ctx) {
                ctx.beginPath();
                const overlap = 1.08;

                // --- NOWOĹšÄ†: Rysowanie z uwzglÄ™dnieniem strzÄ™pĂłw (this.frays) ---
                // Pierwszy punkt
                let fx = this.verts[0].x + this.frays[0].x;
                let fy = this.verts[0].y + this.frays[0].y;
                ctx.moveTo(fx * overlap, fy * overlap);

                // Reszta punktĂłw
                for (let i = 1; i < 6; i++) {
                    fx = this.verts[i].x + this.frays[i].x;
                    fy = this.verts[i].y + this.frays[i].y;
                    ctx.lineTo(fx * overlap, fy * overlap);
                }
                // ----------------------------------------------------------------
                ctx.closePath();
            }
        }
        // ====================================================================
        // WEBGPU PHYSICS MANAGER (PHASE 3: PROPAGATION + COLLISIONS + DEFORMATION)
        // ====================================================================
        const WebGPUPhysics = {
            device: null,
            active: false,

            propagationPipeline: null,
            propagationBindLayout: null,
            propagationUniform: null,

            collisionPipeline: null,
            collisionBindLayout: null,
            contactsBuffer: null,
            contactCountBuffer: null,
            readbackContactsBuffer: null,

            async init() {
                if (!navigator.gpu) return false;
                try {
                    const adapter = await navigator.gpu.requestAdapter({ powerPreference: "high-performance" });
                    if (!adapter) return false;
                    this.device = await adapter.requestDevice();

                    // --- 1. PIPELINE: CRUMPLE PROPAGATION (Spring-mass + accordion Z) ---
                    this.propagationBindLayout = this.device.createBindGroupLayout({
                        entries: [
                            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },        // shards (read_write)
                            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } }, // neighbors
                            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } }          // params
                        ]
                    });

                    const propagationShader = `
                // Extended shard: 16 floats (64 bytes, aligned)
                struct Shard {
                    gridX: f32, gridY: f32,
                    defX: f32, defY: f32,
                    tgtDefX: f32, tgtDefY: f32,
                    hp: f32, maxHp: f32,
                    defZ: f32,                    // accordion Z deformation
                    velX: f32, velY: f32, velZ: f32, // deformation velocities
                    _pad0: f32, _pad1: f32, _pad2: f32, _pad3: f32  // padding to 16 floats
                };
                @group(0) @binding(0) var<storage, read_write> shards: array<Shard>;
                @group(0) @binding(1) var<storage, read> neighbors: array<i32>;

                // params: (dt, damping, stiffnessXY, stiffnessZ, accordion, maxZ, maxXY, 0)
                struct Params { dt: f32, damping: f32, kXY: f32, kZ: f32, accordion: f32, maxZ: f32, maxXY: f32, _pad: f32 };
                @group(0) @binding(2) var<uniform> params: Params;

                @compute @workgroup_size(64)
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    let idx = id.x;
                    if (idx >= arrayLength(&shards)) { return; }
                    var me = shards[idx];
                    if (me.hp <= 0.0) { return; }

                    let dt = params.dt;
                    let damping = params.damping;
                    let kXY = params.kXY;
                    let kZ = params.kZ;
                    let accordion = params.accordion;

                    // Accumulate spring forces from 6 hex neighbors
                    var forceX = 0.0;
                    var forceY = 0.0;
                    var forceZ = 0.0;
                    var neighborCount = 0u;
                    let nBase = idx * 6u;

                    for (var i = 0u; i < 6u; i = i + 1u) {
                        let nIdx = neighbors[nBase + i];
                        if (nIdx < 0) { continue; }
                        let n = shards[u32(nIdx)];
                        if (n.hp <= 0.0) { continue; }
                        neighborCount = neighborCount + 1u;

                        // XY spring: pull toward neighbor's deformation (averaging)
                        forceX += (n.tgtDefX - me.tgtDefX) * kXY;
                        forceY += (n.tgtDefY - me.tgtDefY) * kXY;

                        // Z accordion spring: INVERTED sign creates alternating pattern
                        // If neighbor goes +Z, force pulls me toward -Z (and vice versa)
                        let normalZ = (n.defZ - me.defZ) * kZ;        // normal spring
                        let accordionZ = (-n.defZ - me.defZ) * accordion; // accordion spring
                        forceZ += normalZ + accordionZ;
                    }

                    // Scale by neighbor count for stability
                    if (neighborCount > 0u) {
                        let invN = 1.0 / f32(neighborCount);
                        forceX *= invN;
                        forceY *= invN;
                        forceZ *= invN;
                    }

                    // Update velocities with forces + damping
                    var vx = (me.velX + forceX * dt) * damping;
                    var vy = (me.velY + forceY * dt) * damping;
                    var vz = (me.velZ + forceZ * dt) * damping;

                    // Update deformations
                    var newDefX = me.tgtDefX + vx * dt;
                    var newDefY = me.tgtDefY + vy * dt;
                    var newDefZ = me.defZ + vz * dt;

                    // Clamp XY deformation
                    let xyLen = sqrt(newDefX * newDefX + newDefY * newDefY);
                    if (xyLen > params.maxXY) {
                        let s = params.maxXY / xyLen;
                        newDefX *= s;
                        newDefY *= s;
                    }

                    // Clamp Z deformation
                    newDefZ = clamp(newDefZ, -params.maxZ, params.maxZ);

                    // Write back
                    shards[idx].tgtDefX = newDefX;
                    shards[idx].tgtDefY = newDefY;
                    shards[idx].defZ = newDefZ;
                    shards[idx].velX = vx;
                    shards[idx].velY = vy;
                    shards[idx].velZ = vz;
                }
            `;
                    this.propagationPipeline = this.device.createComputePipeline({
                        layout: this.device.createPipelineLayout({ bindGroupLayouts: [this.propagationBindLayout] }),
                        compute: { module: this.device.createShaderModule({ code: propagationShader }), entryPoint: "main" }
                    });
                    // params: dt, damping, kXY, kZ, accordion, maxZ, maxXY, pad = 8 floats = 32 bytes
                    this.propagationUniform = this.device.createBuffer({ size: 32, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

                    // --- 2. PIPELINE: DETEKCJA KOLIZJI (Narrowphase) ---
                    this.collisionBindLayout = this.device.createBindGroupLayout({
                        entries: [
                            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } }, // Shards A
                            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } }, // Shards B
                            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } },           // Transforms (A & B)
                            { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },           // Zwracane kontakty
                            { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },           // Licznik kontaktów
                            { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } }  // GridMap B (grid→dense)
                        ]
                    });

                    // Dynamiczne stałe z konfigu (zamiast hardcoded)
                    const hexR = DESTRUCTOR_CONFIG.gridDivisions;
                    const hexSpacing = hexR * 1.5;
                    const hexHeightGPU = Math.sqrt(3) * hexR;
                    const hitRad = hexR * 1.3;
                    const hitRadSq = hitRad * hitRad;

                    // Shader Kolizji — FIX: gridMap lookup, dynamiczne stałe, poprawny alignment
                    const collisionShader = `
                struct Shard {
                    gridX: f32, gridY: f32,
                    defX: f32, defY: f32,
                    tgtDefX: f32, tgtDefY: f32,
                    hp: f32, maxHp: f32,
                    defZ: f32,
                    velX: f32, velY: f32, velZ: f32,
                    _pad0: f32, _pad1: f32, _pad2: f32, _pad3: f32
                };
                // FIX alignment: pad after scale so vec2 gridSize aligns to 8 bytes
                struct Transform { pos: vec2<f32>, rot: vec2<f32>, scale: f32, _pad: f32, gridSize: vec2<f32>, cx_cy: vec2<f32>, pivot: vec2<f32>, pad: vec2<f32> };
                struct Contact { idxA: u32, idxB: u32, nx: f32, ny: f32, pen: f32, pad1: f32, pad2: f32, pad3: f32 }; // 32 bytes

                @group(0) @binding(0) var<storage, read> shardsA: array<Shard>;
                @group(0) @binding(1) var<storage, read> shardsB: array<Shard>;
                @group(0) @binding(2) var<uniform> transforms: array<Transform, 2>;
                @group(0) @binding(3) var<storage, read_write> contactsOut: array<Contact>;
                @group(0) @binding(4) var<storage, read_write> contactCount: atomic<u32>;
                @group(0) @binding(5) var<storage, read> gridMapB: array<i32>;

                const HEX_SPACING: f32 = ${hexSpacing.toFixed(4)};
                const HEX_HEIGHT: f32 = ${hexHeightGPU.toFixed(4)};
                const HIT_RAD: f32 = ${hitRad.toFixed(4)};
                const HIT_RAD_SQ: f32 = ${hitRadSq.toFixed(4)};

                @compute @workgroup_size(64)
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    let idxA = id.x;
                    if (idxA >= arrayLength(&shardsA)) { return; }
                    let sA = shardsA[idxA];
                    if (sA.hp <= 0.0) { return; }

                    let tA = transforms[0];
                    let tB = transforms[1];

                    let relAx = (sA.gridX - tA.cx_cy.x) + sA.defX - tA.pivot.x;
                    let relAy = (sA.gridY - tA.cx_cy.y) + sA.defY - tA.pivot.y;
                    let worldAx = tA.pos.x + (relAx * tA.scale) * tA.rot.x - (relAy * tA.scale) * tA.rot.y;
                    let worldAy = tA.pos.y + (relAx * tA.scale) * tA.rot.y + (relAy * tA.scale) * tA.rot.x;

                    let dx = worldAx - tB.pos.x;
                    let dy = worldAy - tB.pos.y;
                    let localBx = (dx * tB.rot.x + dy * tB.rot.y) / tB.scale;
                    let localBy = (-dx * tB.rot.y + dy * tB.rot.x) / tB.scale;
                    
                    let gridBx = localBx + tB.cx_cy.x + tB.pivot.x;
                    let gridBy = localBy + tB.cx_cy.y + tB.pivot.y;

                    let approxC = i32(round(gridBx / HEX_SPACING));
                    let approxR = i32(round(gridBy / HEX_HEIGHT));

                    let colsB = i32(tB.gridSize.x);
                    let rowsB = i32(tB.gridSize.y);
                    let searchR = 2;

                    for(var r = approxR - searchR; r <= approxR + searchR; r++) {
                        for(var c = approxC - searchR; c <= approxC + searchR; c++) {
                            if (c >= 0 && c < colsB && r >= 0 && r < rowsB) {
                                // FIX: use gridMap to go from grid coords → dense array index
                                let gridIdx = u32(c + r * colsB);
                                let denseIdx = gridMapB[gridIdx];
                                if (denseIdx < 0) { continue; } // empty cell
                                let idxB = u32(denseIdx);
                                let sB = shardsB[idxB];
                                if (sB.hp > 0.0) {
                                    let bRelX = (sB.gridX - tB.cx_cy.x) + sB.defX - tB.pivot.x;
                                    let bRelY = (sB.gridY - tB.cx_cy.y) + sB.defY - tB.pivot.y;
                                    let worldBx = tB.pos.x + (bRelX * tB.scale) * tB.rot.x - (bRelY * tB.scale) * tB.rot.y;
                                    let worldBy = tB.pos.y + (bRelX * tB.scale) * tB.rot.y + (bRelY * tB.scale) * tB.rot.x;

                                    let nx = worldAx - worldBx;
                                    let ny = worldAy - worldBy;
                                    let distSq = nx*nx + ny*ny;

                                    if (distSq < HIT_RAD_SQ) {
                                        let dist = sqrt(distSq);
                                        let cIdx = atomicAdd(&contactCount, 1u);
                                        if (cIdx < 1024u) {
                                            contactsOut[cIdx].idxA = idxA;
                                            contactsOut[cIdx].idxB = idxB;
                                            contactsOut[cIdx].nx = nx;
                                            contactsOut[cIdx].ny = ny;
                                            contactsOut[cIdx].pen = HIT_RAD - dist;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            `;
                    this.collisionPipeline = this.device.createComputePipeline({
                        layout: this.device.createPipelineLayout({ bindGroupLayouts: [this.collisionBindLayout] }),
                        compute: { module: this.device.createShaderModule({ code: collisionShader }), entryPoint: "main" }
                    });

                    // Bufory na wyniki kolizji (Max 1024 kontakty per zderzenie)
                    this.contactsBuffer = this.device.createBuffer({ size: 1024 * 32, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC });
                    this.contactCountBuffer = this.device.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST });
                    this.readbackContactsBuffer = this.device.createBuffer({ size: (1024 * 32) + 4, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });

                    // --- 3. PIPELINE: GPU DEFORMATION (per-contact force application) ---
                    this.deformBindLayout = this.device.createBindGroupLayout({
                        entries: [
                            { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },           // shardsA (read_write — we write vel/def)
                            { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: "storage" } },           // shardsB (read_write)
                            { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },  // contacts
                            { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: "read-only-storage" } },  // contactCount
                            { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: "uniform" } }            // deform params
                        ]
                    });

                    const deformShader = `
                struct Shard {
                    gridX: f32, gridY: f32,
                    defX: f32, defY: f32,
                    tgtDefX: f32, tgtDefY: f32,
                    hp: f32, maxHp: f32,
                    defZ: f32,
                    velX: f32, velY: f32, velZ: f32,
                    _pad0: f32, _pad1: f32, _pad2: f32, _pad3: f32
                };
                struct Contact { idxA: u32, idxB: u32, nx: f32, ny: f32, pen: f32, pad1: f32, pad2: f32, pad3: f32 };
                struct DeformParams {
                    forceScale: f32,          // overall deformation strength
                    accordionStrength: f32,   // Z accordion force multiplier
                    ratioA: f32,              // massB / totalMass — how much A deforms
                    ratioB: f32,              // massA / totalMass
                    normalX: f32,             // collision normal (entity-level)
                    normalY: f32,
                    contactCount: u32,
                    _pad: u32
                };

                @group(0) @binding(0) var<storage, read_write> shardsA: array<Shard>;
                @group(0) @binding(1) var<storage, read_write> shardsB: array<Shard>;
                @group(0) @binding(2) var<storage, read> contacts: array<Contact>;
                @group(0) @binding(3) var<storage, read> countBuf: array<u32>;
                @group(0) @binding(4) var<uniform> params: DeformParams;

                @compute @workgroup_size(64)
                fn main(@builtin(global_invocation_id) id: vec3<u32>) {
                    let ci = id.x;
                    let totalContacts = min(params.contactCount, 1024u);
                    if (ci >= totalContacts) { return; }

                    let contact = contacts[ci];
                    let idxA = contact.idxA;
                    let idxB = contact.idxB;

                    // Skip dead shards
                    if (shardsA[idxA].hp <= 0.0 || shardsB[idxB].hp <= 0.0) { return; }

                    let pen = max(contact.pen, 0.0);
                    if (pen < 0.01) { return; }

                    // Normalize contact normal
                    var nx = contact.nx;
                    var ny = contact.ny;
                    let nLen = sqrt(nx * nx + ny * ny);
                    if (nLen > 0.001) {
                        nx = nx / nLen;
                        ny = ny / nLen;
                    } else {
                        nx = params.normalX;
                        ny = params.normalY;
                    }

                    let force = pen * params.forceScale;

                    // --- XY deformation: push shards along collision normal ---
                    let pushAx = -nx * force * params.ratioA;
                    let pushAy = -ny * force * params.ratioA;
                    let pushBx = nx * force * params.ratioB;
                    let pushBy = ny * force * params.ratioB;

                    // --- Z accordion: alternating sign based on contact index ---
                    // Odd contacts go +Z, even go -Z → creates crumple waves
                    let zSign = select(-1.0, 1.0, (ci % 2u) == 0u);
                    let zForce = pen * params.accordionStrength * zSign;

                    // Apply to shard A velocities (atomic-unsafe but GPU race is acceptable for softbody)
                    shardsA[idxA].velX += pushAx;
                    shardsA[idxA].velY += pushAy;
                    shardsA[idxA].velZ += zForce * params.ratioA;
                    shardsA[idxA].tgtDefX += pushAx * 0.5;
                    shardsA[idxA].tgtDefY += pushAy * 0.5;

                    // Apply to shard B velocities
                    shardsB[idxB].velX += pushBx;
                    shardsB[idxB].velY += pushBy;
                    shardsB[idxB].velZ -= zForce * params.ratioB;
                    shardsB[idxB].tgtDefX += pushBx * 0.5;
                    shardsB[idxB].tgtDefY += pushBy * 0.5;

                    // HP damage proportional to penetration
                    let dmg = pen * 0.5;
                    shardsA[idxA].hp -= dmg * params.ratioA;
                    shardsB[idxB].hp -= dmg * params.ratioB;
                }
            `;
                    this.deformPipeline = this.device.createComputePipeline({
                        layout: this.device.createPipelineLayout({ bindGroupLayouts: [this.deformBindLayout] }),
                        compute: { module: this.device.createShaderModule({ code: deformShader }), entryPoint: "main" }
                    });
                    this.deformUniform = this.device.createBuffer({ size: 32, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

                    this.active = true;
                    console.log("🚀 WebGPU Phase 2 (Collisions) gotowe!");
                    return true;
                } catch (e) {
                    console.error("Błąd WebGPU:", e);
                    return false;
                }
            },

            createBuffersForEntity(entity) {
                if (!this.active || !entity.hexGrid || !entity.hexGrid.shards) return;

                const shards = entity.hexGrid.shards;
                const count = shards.length;
                const cols = entity.hexGrid.cols || 0;
                const rows = entity.hexGrid.rows || 0;

                const shardData = new Float32Array(count * 16);
                const neighborData = new Int32Array(count * 6);
                neighborData.fill(-1);

                // FIX: gridMap — maps grid[c + r*cols] → dense shard index (or -1)
                const gridMapSize = cols * rows;
                const gridMapData = new Int32Array(Math.max(1, gridMapSize));
                gridMapData.fill(-1);

                for (let i = 0; i < count; i++) shards[i]._gpuIndex = i;

                for (let i = 0; i < count; i++) {
                    const s = shards[i];
                    const offset = i * 16;
                    shardData[offset + 0] = s.gridX;
                    shardData[offset + 1] = s.gridY;
                    shardData[offset + 2] = s.deformation.x;
                    shardData[offset + 3] = s.deformation.y;
                    shardData[offset + 4] = s.targetDeformation.x;
                    shardData[offset + 5] = s.targetDeformation.y;
                    shardData[offset + 6] = s.hp;
                    shardData[offset + 7] = s.maxHp;
                    shardData[offset + 8] = s.deformZ || 0;
                    shardData[offset + 9] = s.velX || 0;
                    shardData[offset + 10] = s.velY || 0;
                    shardData[offset + 11] = s.velZ || 0;
                    // 12-15 = padding (zeros)

                    const nOffset = i * 6;
                    for (let n = 0; n < s.neighbors.length && n < 6; n++) {
                        if (s.neighbors[n] && s.neighbors[n]._gpuIndex !== undefined) {
                            neighborData[nOffset + n] = s.neighbors[n]._gpuIndex;
                        }
                    }

                    // Fill gridMap
                    if (s.c >= 0 && s.c < cols && s.r >= 0 && s.r < rows) {
                        gridMapData[s.c + s.r * cols] = i;
                    }
                }

                const shardBuffer = this.device.createBuffer({
                    size: shardData.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST
                });
                this.device.queue.writeBuffer(shardBuffer, 0, shardData);

                const neighborBuffer = this.device.createBuffer({
                    size: neighborData.byteLength,
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
                });
                this.device.queue.writeBuffer(neighborBuffer, 0, neighborData);

                const gridMapBuffer = this.device.createBuffer({
                    size: Math.max(4, gridMapData.byteLength),
                    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
                });
                this.device.queue.writeBuffer(gridMapBuffer, 0, gridMapData);

                const readbackBuffer = this.device.createBuffer({
                    size: shardData.byteLength,
                    usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
                });

                const propagationBindGroup = this.device.createBindGroup({
                    layout: this.propagationBindLayout,
                    entries: [
                        { binding: 0, resource: { buffer: shardBuffer } },
                        { binding: 1, resource: { buffer: neighborBuffer } },
                        { binding: 2, resource: { buffer: this.propagationUniform } }
                    ]
                });

                entity.gpuData = {
                    shardsRef: shards,
                    shardData, count,
                    shardBuffer, neighborBuffer, gridMapBuffer, readbackBuffer, propagationBindGroup,
                    isMapping: false
                };
            },

            // FIX: syncToGPU — uploads gridX/gridY (plasticity) + deformation + hp
            syncToGPU(entity) {
                if (!this.active || !entity?.hexGrid || !entity.gpuData) return;
                const gd = entity.gpuData;
                if (gd.isMapping) return;

                if (gd.shardsRef !== entity.hexGrid.shards) {

                    if (gd.shardBuffer) gd.shardBuffer.destroy();
                    if (gd.neighborBuffer) gd.neighborBuffer.destroy();
                    if (gd.gridMapBuffer) gd.gridMapBuffer.destroy();
                    if (gd.readbackBuffer) gd.readbackBuffer.destroy();

                    this.createBuffersForEntity(entity);
                    return;
                }

                const shards = entity.hexGrid.shards;
                const liveCount = Math.min(gd.count, shards.length);
                for (let i = 0; i < liveCount; i++) {
                    const s = shards[i];
                    if (!s) continue;
                    const offset = i * 16;
                    gd.shardData[offset + 0] = s.gridX;
                    gd.shardData[offset + 1] = s.gridY;
                    gd.shardData[offset + 2] = s.deformation.x;
                    gd.shardData[offset + 3] = s.deformation.y;
                    gd.shardData[offset + 4] = s.targetDeformation.x;
                    gd.shardData[offset + 5] = s.targetDeformation.y;
                    gd.shardData[offset + 6] = s.hp;
                    gd.shardData[offset + 7] = s.maxHp;
                    gd.shardData[offset + 8] = s.deformZ || 0;
                    gd.shardData[offset + 9] = s.velX || 0;
                    gd.shardData[offset + 10] = s.velY || 0;
                    gd.shardData[offset + 11] = s.velZ || 0;
                }
                this.device.queue.writeBuffer(gd.shardBuffer, 0, gd.shardData);
            },

            computePropagation(entity, dt) {
                if (!this.active || !entity.gpuData || entity.gpuData.isMapping) return;
                const gd = entity.gpuData;

                if (gd.shardsRef !== entity.hexGrid.shards) {

                    if (gd.shardBuffer) gd.shardBuffer.destroy();
                    if (gd.neighborBuffer) gd.neighborBuffer.destroy();
                    if (gd.gridMapBuffer) gd.gridMapBuffer.destroy();
                    if (gd.readbackBuffer) gd.readbackBuffer.destroy();

                    this.createBuffersForEntity(entity);
                    return;
                }

                // Upload current CPU state to GPU
                this.syncToGPU(entity);

                // Write propagation params: dt, damping, kXY, kZ, accordion, maxZ, maxXY, pad
                const cfg = DESTRUCTOR_CONFIG;
                this.device.queue.writeBuffer(this.propagationUniform, 0, new Float32Array([
                    dt, cfg.crumpleDamping, cfg.crumpleStiffnessXY, cfg.crumpleStiffnessZ,
                    cfg.crumpleAccordion, cfg.crumpleMaxZ, cfg.crumpleMaxXY, 0
                ]));

                const commandEncoder = this.device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(this.propagationPipeline);
                passEncoder.setBindGroup(0, gd.propagationBindGroup);
                passEncoder.dispatchWorkgroups(Math.ceil(gd.count / 64));
                passEncoder.end();

                commandEncoder.copyBufferToBuffer(gd.shardBuffer, 0, gd.readbackBuffer, 0, gd.shardData.byteLength);
                this.device.queue.submit([commandEncoder.finish()]);

                gd.isMapping = true;
                gd.readbackBuffer.mapAsync(GPUMapMode.READ).then(() => {
                    const mappedData = new Float32Array(gd.readbackBuffer.getMappedRange());
                    let changed = false;
                    for (let i = 0; i < gd.count; i++) {
                        const s = entity.hexGrid.shards[i];
                        if (s.active && !s.isDebris) {
                            const off = i * 16;
                            s.targetDeformation.x = mappedData[off + 4];
                            s.targetDeformation.y = mappedData[off + 5];
                            s.deformZ = mappedData[off + 8];
                            s.velX = mappedData[off + 9];
                            s.velY = mappedData[off + 10];
                            s.velZ = mappedData[off + 11];
                            changed = true;
                        }
                    }
                    gd.readbackBuffer.unmap();
                    gd.isMapping = false;
                    if (changed) entity.hexGrid.cacheDirty = true;
                }).catch(() => { gd.isMapping = false; });
            },

            // --- GPU DEFORMATION: Apply per-contact forces directly on GPU ---
            applyGPUDeformation(A, B, contactCount, nx, ny) {
                if (!this.active || !A.gpuData || !B.gpuData) return;
                if (contactCount <= 0) return;

                const massA = A.mass || 1;
                const massB = B.mass || 1;
                const totalMass = massA + massB;
                const ratioA = massB / totalMass; // heavier B = more deformation on A
                const ratioB = massA / totalMass;

                const cfg = DESTRUCTOR_CONFIG;
                const forceScale = cfg.crushVelK * cfg.collisionDeformScale;
                const accordionStr = cfg.crumpleAccordion * cfg.crumpleStiffnessZ;

                // Upload params: forceScale, accordionStrength, ratioA, ratioB, normalX, normalY, contactCount, pad
                const paramsData = new Float32Array(8);
                paramsData[0] = forceScale;
                paramsData[1] = accordionStr;
                paramsData[2] = ratioA;
                paramsData[3] = ratioB;
                paramsData[4] = nx;
                paramsData[5] = ny;
                // contactCount is u32, write as int view
                const paramsU32 = new Uint32Array(paramsData.buffer);
                paramsU32[6] = contactCount;
                paramsU32[7] = 0;
                this.device.queue.writeBuffer(this.deformUniform, 0, paramsData);

                // Create bind group for this pair
                const deformBindGroup = this.device.createBindGroup({
                    layout: this.deformBindLayout,
                    entries: [
                        { binding: 0, resource: { buffer: A.gpuData.shardBuffer } },
                        { binding: 1, resource: { buffer: B.gpuData.shardBuffer } },
                        { binding: 2, resource: { buffer: this.contactsBuffer } },
                        { binding: 3, resource: { buffer: this.contactCountBuffer } },
                        { binding: 4, resource: { buffer: this.deformUniform } }
                    ]
                });

                const commandEncoder = this.device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(this.deformPipeline);
                passEncoder.setBindGroup(0, deformBindGroup);
                passEncoder.dispatchWorkgroups(Math.ceil(contactCount / 64));
                passEncoder.end();
                this.device.queue.submit([commandEncoder.finish()]);
            },

            // --- GPU COLLISION DETECTION (naprawione) ---
            async getGPUContacts(A, B) {
                if (!this.active || !A.gpuData || !B.gpuData) return null;
                if (A.gpuData.isMapping || B.gpuData.isMapping) return null;

                // FIX: sync CPU→GPU before detection
                this.syncToGPU(A);
                this.syncToGPU(B);

                // Resetowanie licznika kontaktów do zera
                this.device.queue.writeBuffer(this.contactCountBuffer, 0, new Uint32Array([0]));

                // FIX alignment: Transform struct has _pad after scale (16 floats = 64 bytes per transform)
                const getTransformData = (ent) => {
                    const ang = ent.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                    return [
                        ent.x, ent.y,                     // pos (vec2)
                        Math.cos(ang), Math.sin(ang),     // rot (vec2)
                        1.0,                              // scale (f32)
                        0.0,                              // _pad (f32) — alignment for gridSize vec2
                        ent.hexGrid.cols, ent.hexGrid.rows, // gridSize (vec2)
                        ent.hexGrid.srcWidth * 0.5, ent.hexGrid.srcHeight * 0.5, // cx_cy (vec2)
                        ent.hexGrid.pivot ? ent.hexGrid.pivot.x : 0, ent.hexGrid.pivot ? ent.hexGrid.pivot.y : 0, // pivot (vec2)
                        0, 0                              // pad (vec2) → 14 floats = 56 bytes per Transform
                    ];
                };

                const transformData = new Float32Array([...getTransformData(A), ...getTransformData(B)]);
                const transformBuffer = this.device.createBuffer({
                    size: transformData.byteLength,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                });
                this.device.queue.writeBuffer(transformBuffer, 0, transformData);

                // Bind group z gridMapBuffer dla B
                const bindGroup = this.device.createBindGroup({
                    layout: this.collisionBindLayout,
                    entries: [
                        { binding: 0, resource: { buffer: A.gpuData.shardBuffer } },
                        { binding: 1, resource: { buffer: B.gpuData.shardBuffer } },
                        { binding: 2, resource: { buffer: transformBuffer } },
                        { binding: 3, resource: { buffer: this.contactsBuffer } },
                        { binding: 4, resource: { buffer: this.contactCountBuffer } },
                        { binding: 5, resource: { buffer: B.gpuData.gridMapBuffer } }
                    ]
                });

                // Dispatch Compute Shader
                const commandEncoder = this.device.createCommandEncoder();
                const passEncoder = commandEncoder.beginComputePass();
                passEncoder.setPipeline(this.collisionPipeline);
                passEncoder.setBindGroup(0, bindGroup);
                passEncoder.dispatchWorkgroups(Math.ceil(A.gpuData.count / 64));
                passEncoder.end();

                // Kopiowanie wyników
                commandEncoder.copyBufferToBuffer(this.contactCountBuffer, 0, this.readbackContactsBuffer, 0, 4);
                commandEncoder.copyBufferToBuffer(this.contactsBuffer, 0, this.readbackContactsBuffer, 4, 1024 * 32);
                this.device.queue.submit([commandEncoder.finish()]);

                // Czekamy na wyniki z GPU
                await this.readbackContactsBuffer.mapAsync(GPUMapMode.READ);

                const countArray = new Uint32Array(this.readbackContactsBuffer.getMappedRange(0, 4));
                const count = Math.min(countArray[0], 1024);

                const contactsArray = new Float32Array(this.readbackContactsBuffer.getMappedRange(4, count * 32));
                const uintArray = new Uint32Array(this.readbackContactsBuffer.getMappedRange(4, count * 32));

                const results = [];
                for (let i = 0; i < count; i++) {
                    results.push({
                        shardA: A.hexGrid.shards[uintArray[i * 8 + 0]],
                        shardB: B.hexGrid.shards[uintArray[i * 8 + 1]],
                        nx: contactsArray[i * 8 + 2],
                        ny: contactsArray[i * 8 + 3],
                        pen: contactsArray[i * 8 + 4]
                    });
                }

                this.readbackContactsBuffer.unmap();

                return results;
            }
        };

        const DestructorSystem = {
            debris: [],
            splitQueue: [],
            _tick: 0,
            _nextEid: 0,
            async update(dt, entities) {
                const debris = this.debris;
                for (let i = debris.length - 1; i >= 0; i--) {
                    debris[i].updateDebris(dt);
                    if (!debris[i].active) {
                        debris[i] = debris[debris.length - 1];
                        debris.pop();
                    }
                }
                this._tick++;

                const t0col = performance.now();
                this.simulateElasticity(entities, dt);

                // Pre-fetch GPU contacts once per frame (async)
                let gpuCache = null;
                if (WebGPUPhysics.active) {
                    gpuCache = new Map();
                    const len = entities.length;
                    for (let i = 0; i < len; i++) {
                        const A = entities[i];
                        if (!A.hexGrid || !A.gpuData) continue;
                        if (A._eid === undefined) A._eid = this._nextEid++;
                        for (let j = i + 1; j < len; j++) {
                            const B = entities[j];
                            if (!B.hexGrid || !B.gpuData) continue;
                            if (A.owner === B || B.owner === A) continue;
                            if (B._eid === undefined) B._eid = this._nextEid++;
                            const dx = A.x - B.x, dy = A.y - B.y;
                            const radSum = (A.radius || 100) + (B.radius || 100);
                            if (dx * dx + dy * dy > radSum * radSum) continue;
                            try {
                                const contacts = await WebGPUPhysics.getGPUContacts(A, B);
                                if (contacts && contacts.length > 0) {
                                    gpuCache.set(A._eid + '|' + B._eid, contacts);
                                }
                            } catch (e) { /* GPU fail - CPU fallback */ }
                        }
                    }
                }

                const iterations = DESTRUCTOR_CONFIG.collisionIterations || 4; // moĹĽesz zaczÄ…Ä‡ od 3-4
                for (let i = 0; i < iterations; i++) {
                    const doDamage = (i === 0);
                    this.resolveCollisions(entities, dt, doDamage, gpuCache);
                }
                Perf.collisionTime += performance.now() - t0col;
                if (this._tick % 10 === 0 && this.splitQueue.length > 0) this.processSplits(entities);
            },

            updateVisualDeformation(entities, dt) {
                for (const e of entities) {
                    if (e.hexGrid) {
                        let moving = false;
                        for (const s of e.hexGrid.shards) {
                            if (!s.active || s.isDebris) continue;
                            if (s.updateAnimation(dt)) moving = true;
                        }
                        if (moving) e.hexGrid.cacheDirty = true;
                    }
                }
            },

            simulateElasticity(entities, dt) {
                // JeĹ›li WebGPU jest dostÄ™pne, puszczamy wszystko na kartÄ™ graficznÄ….
                if (WebGPUPhysics.active) {
                    for (const e of entities) {
                        if (e.hexGrid) WebGPUPhysics.computePropagation(e, dt);
                    }
                    return;
                }

                const tension = DESTRUCTOR_CONFIG.softBodyTension;
                if (tension <= 0) return;

                // frame-rate independent krok
                const k = 1.0 - Math.exp(-tension * dt * 60);

                for (const e of entities) {
                    if (!e.hexGrid) continue;

                    for (const s of e.hexGrid.shards) {
                        if (!s.active || s.isDebris) continue;

                        for (const n of s.neighbors) {
                            if (!n.active || n.isDebris) continue;

                            // ĹĽeby nie liczyÄ‡ pary 2x (prosty warunek deterministyczny)
                            if (n.c < s.c || (n.c === s.c && n.r <= s.r)) continue;

                            const ax = s.targetDeformation.x;
                            const ay = s.targetDeformation.y;
                            const bx = n.targetDeformation.x;
                            const by = n.targetDeformation.y;

                            const avgX = (ax + bx) * 0.5;
                            const avgY = (ay + by) * 0.5;

                            s.targetDeformation.x += (avgX - ax) * k;
                            s.targetDeformation.y += (avgY - ay) * k;

                            n.targetDeformation.x += (avgX - bx) * k;
                            n.targetDeformation.y += (avgY - by) * k;
                        }
                    }

                    e.hexGrid.cacheDirty = true;
                }
            },

            repair(entities, dt) {
                for (const e of entities) {
                    if (e.hexGrid && e.hexGrid.shards) {
                        let anyFix = false;
                        for (const s of e.hexGrid.shards) {
                            if (s.active && !s.isDebris) {
                                if (Math.abs(s.deformation.x) > 0.1 || Math.abs(s.deformation.y) > 0.1 || s.hp < s.maxHp) {
                                    s.repair(dt);
                                    anyFix = true;
                                }
                            }
                        }
                        if (anyFix) e.hexGrid.cacheDirty = true;
                    }
                }
            },

            distributeStructuralDamage(entity, impactLocalX, impactLocalY, forceX, forceY, damageScale = 1.0) {
                const radius = DESTRUCTOR_CONFIG.bendingRadius;
                const radiusSq = BENDING_RAD_SQ;
                const invRadius = 1.0 / radius;
                const deformMul = DESTRUCTOR_CONFIG.deformMul;
                let anyDestroyed = false;

                const pivotX = entity.hexGrid.pivot ? entity.hexGrid.pivot.x : 0;
                const pivotY = entity.hexGrid.pivot ? entity.hexGrid.pivot.y : 0;
                const adjustedImpactX = impactLocalX + pivotX;
                const adjustedImpactY = impactLocalY + pivotY;

                // Parametry strzÄ™pienia - precomputed
                const tearSensitivity = DESTRUCTOR_CONFIG.tearSensitivity;
                const maxFray = DESTRUCTOR_CONFIG.maxFray;
                const maxFraySq = maxFray * maxFray;

                // Precompute force magnitude and direction ONCE (nie w pÄ™tli!)
                const forceMagSq = forceX * forceX + forceY * forceY;
                const forceMag = Math.sqrt(forceMagSq);
                const doFray = (damageScale > 0) && (forceMag > 2.0);

                // ZMIANA: Normalizujemy wektor siĹ‚y zawsze, gdy tylko siĹ‚a istnieje
                const fnx = forceMag > 0 ? forceX / forceMag : 0;
                const fny = forceMag > 0 ? forceY / forceMag : 0;
                const hpDmgBase = (Math.abs(forceX) + Math.abs(forceY)) * DESTRUCTOR_CONFIG.inflictedDamageMult * damageScale;

                const cx = entity.hexGrid.srcWidth * 0.5;
                const cy = entity.hexGrid.srcHeight * 0.5;

                // FAST PATH: iterate only cells around impact (instead of scanning all shards)
                const cols = entity.hexGrid.cols;
                const rows = entity.hexGrid.rows;
                const grid = entity.hexGrid.grid;

                const invHexSpacing = 1.0 / HEX_SPACING;
                const invHexHeight = 1.0 / HEX_HEIGHT;

                const impactGX = adjustedImpactX + cx;
                const impactGY = adjustedImpactY + cy;

                const approxC = Math.round(impactGX * invHexSpacing);
                const approxR = Math.round(impactGY * invHexHeight);

                const cellRadC = Math.ceil(radius * invHexSpacing) + 2;
                const cellRadR = Math.ceil(radius * invHexHeight) + 2;

                if (grid && cols && rows) {
                    let c0 = approxC - cellRadC;
                    let c1 = approxC + cellRadC;
                    let r0 = approxR - cellRadR;
                    let r1 = approxR + cellRadR;

                    if (c0 < 0) c0 = 0;
                    if (r0 < 0) r0 = 0;
                    if (c1 >= cols) c1 = cols - 1;
                    if (r1 >= rows) r1 = rows - 1;

                    for (let r = r0; r <= r1; r++) {
                        const rowBase = r * cols;
                        for (let c = c0; c <= c1; c++) {
                            const shard = grid[rowBase + c];
                            if (!shard || !shard.active || shard.isDebris) continue;

                            const dx = (shard.gridX - cx) - adjustedImpactX;
                            const dy = (shard.gridY - cy) - adjustedImpactY;
                            const d2 = dx * dx + dy * dy;
                            if (d2 >= radiusSq) continue;

                            const dist = Math.sqrt(d2);
                            const factor = 1 - dist * invRadius;
                            if (factor <= 0) continue;
                            const influence = factor * factor * (3 - 2 * factor);

                            // Softbody deformation - BAZOWA
                            let defX = forceX * influence * deformMul;
                            let defY = forceY * influence * deformMul;

                            // --- EFEKT ROZĹUPYWANIA (CLEAVE) I WYBRZUSZANIA (BULGE) ---
                            // Dodano zabezpieczenie "|| 0.8" w razie braku zmiennej w konfigu
                            const cleaveForce = DESTRUCTOR_CONFIG.cleaveForce || 0.8;
                            if (forceMag > 0.5) {
                                // 1. Wektor prostopadĹ‚y do osi siĹ‚y uderzenia (lokalnej)
                                const perpX = -fny;
                                const perpY = fnx;

                                // 2. Po ktĂłrej stronie osi uderzenia znajduje siÄ™ ten heks? (Iloczyn skalarny)
                                const lateralDist = dx * perpX + dy * perpY;

                                // 3. Kierunek wypchniÄ™cia (zabezpieczenie przed 0, spychamy zawsze na boki)
                                const side = lateralDist >= 0 ? 1 : -1;

                                // 4. Skalowanie efektu (uĹĽywamy teĹĽ deformMul, ĹĽeby siĹ‚a boczna nie dominowaĹ‚a!)
                                const lateralMul = cleaveForce * influence * deformMul;

                                // Rozpychanie na boki
                                defX += perpX * side * forceMag * lateralMul;
                                defY += perpY * side * forceMag * lateralMul;
                            }

                            shard.applyDeformation(defX, defY);

                            // Efekt strzÄ™pienia (shredding)
                            if (doFray) {
                                const tearBase = forceMag * influence * tearSensitivity;
                                for (let i = 0; i < 6; i++) {
                                    const randomTear = Math.random() * tearBase;
                                    const f = shard.frays[i];
                                    f.x += fnx * randomTear + (Math.random() - 0.5) * randomTear * 0.5;
                                    f.y += fny * randomTear + (Math.random() - 0.5) * randomTear * 0.5;

                                    const fraySq = f.x * f.x + f.y * f.y;
                                    if (fraySq > maxFraySq) {
                                        const scale = maxFray / Math.sqrt(fraySq);
                                        f.x *= scale;
                                        f.y *= scale;
                                    }
                                }
                            }

                            if (damageScale > 0) {
                                shard.hp -= hpDmgBase * influence;
                                if (shard.hp <= 0) {
                                    this.destroyShard(entity, shard, { x: entity.vx, y: entity.vy });
                                    anyDestroyed = true;
                                }
                            }
                        }
                    }
                } else {
                    // Fallback (should rarely happen)
                    const shards = entity.hexGrid.shards;
                    for (let si = 0, sLen = shards.length; si < sLen; si++) {
                        const shard = shards[si];
                        if (!shard.active || shard.isDebris) continue;

                        const dx = (shard.gridX - cx) - adjustedImpactX;
                        const dy = (shard.gridY - cy) - adjustedImpactY;
                        const d2 = dx * dx + dy * dy;
                        if (d2 < radiusSq) {
                            const dist = Math.sqrt(d2);
                            const factor = 1 - dist * invRadius;
                            if (factor <= 0) continue;
                            const influence = factor * factor * (3 - 2 * factor);

                            // Softbody deformation - BAZOWA
                            let defX = forceX * influence * deformMul;
                            let defY = forceY * influence * deformMul;

                            // --- EFEKT ROZĹUPYWANIA (CLEAVE) I WYBRZUSZANIA (BULGE) ---
                            // Dodano zabezpieczenie "|| 0.8" w razie braku zmiennej w konfigu
                            const cleaveForce = DESTRUCTOR_CONFIG.cleaveForce || 0.8;
                            if (forceMag > 0.5) {
                                // 1. Wektor prostopadĹ‚y do osi siĹ‚y uderzenia (lokalnej)
                                const perpX = -fny;
                                const perpY = fnx;

                                // 2. Po ktĂłrej stronie osi uderzenia znajduje siÄ™ ten heks? (Iloczyn skalarny)
                                const lateralDist = dx * perpX + dy * perpY;

                                // 3. Kierunek wypchniÄ™cia (zabezpieczenie przed 0, spychamy zawsze na boki)
                                const side = lateralDist >= 0 ? 1 : -1;

                                // 4. Skalowanie efektu (uĹĽywamy teĹĽ deformMul, ĹĽeby siĹ‚a boczna nie dominowaĹ‚a!)
                                const lateralMul = cleaveForce * influence * deformMul;

                                // Rozpychanie na boki
                                defX += perpX * side * forceMag * lateralMul;
                                defY += perpY * side * forceMag * lateralMul;
                            }

                            shard.applyDeformation(defX, defY);

                            // Efekt strzÄ™pienia (shredding)
                            if (doFray) {
                                const tearBase = forceMag * influence * tearSensitivity;
                                for (let i = 0; i < 6; i++) {
                                    const randomTear = Math.random() * tearBase;
                                    const f = shard.frays[i];
                                    f.x += fnx * randomTear + (Math.random() - 0.5) * randomTear * 0.5;
                                    f.y += fny * randomTear + (Math.random() - 0.5) * randomTear * 0.5;

                                    const fraySq = f.x * f.x + f.y * f.y;
                                    if (fraySq > maxFraySq) {
                                        const scale = maxFray / Math.sqrt(fraySq);
                                        f.x *= scale;
                                        f.y *= scale;
                                    }
                                }
                            }

                            if (damageScale > 0) {
                                shard.hp -= hpDmgBase * influence;
                                if (shard.hp <= 0) {
                                    this.destroyShard(entity, shard, { x: entity.vx, y: entity.vy });
                                    anyDestroyed = true;
                                }
                            }
                        }
                    }
                }

                if (damageScale > 0 && anyDestroyed) this.splitQueue.push(entity);
                entity.hexGrid.cacheDirty = true;
            },

            resolveCollisions(entities, dt, doDamage, gpuCache) {
                const len = entities.length;
                for (let i = 0; i < len; i++) {
                    const A = entities[i];
                    if (!A.hexGrid) continue;
                    const ax = A.x, ay = A.y;
                    const ar = A.radius || 100;
                    for (let j = i + 1; j < len; j++) {
                        const B = entities[j];
                        if (!B.hexGrid) continue;
                        if (A.owner === B || B.owner === A) continue;
                        const dx = ax - B.x, dy = ay - B.y;
                        const radSum = ar + (B.radius || 100);
                        if (dx * dx + dy * dy > radSum * radSum) continue;
                        // Look up pre-fetched GPU contacts
                        let gpuContacts = null;
                        if (gpuCache && A._eid !== undefined && B._eid !== undefined) {
                            gpuContacts = gpuCache.get(A._eid + '|' + B._eid) || null;
                        }
                        this.collideEntities(A, B, dt, doDamage, gpuContacts);
                    }
                }
            },

            // --- HYBRID COLLISION SOLVER (V36 Detection + V46 Impulse Physics) ---
            // Reusable contacts buffer to avoid GC pressure (pre-allocated objects â€” no per-frame GC)
            _contactsBuf: Array.from({ length: 64 }, () => ({
                shardA: null, shardB: null,
                worldAx: 0, worldAy: 0,
                worldBx: 0, worldBy: 0,
                normalX: 0, normalY: 0,
                penetration: 0
            })),
            _contactsCount: 0,

            collideEntities(A, B, dt, doDamage, gpuContacts) {
                // OPTIMIZATION: Smaller object iterates (from destructor.js)
                // Swap so that 'iterator' has fewer shards â€” much fewer hex lookups
                let iterator = A, gridHolder = B;
                if (A.hexGrid.shards.length > B.hexGrid.shards.length) {
                    iterator = B;
                    gridHolder = A;
                }

                const massA = A.mass || 100;
                const massB = B.mass || 100;
                const angIter = iterator.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const angGrid = gridHolder.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const cosI = Math.cos(angIter), sinI = Math.sin(angIter);
                const cosG = Math.cos(angGrid), sinG = Math.sin(angGrid);
                // Inverse rotation for gridHolder: cos(-x)=cos(x), sin(-x)=-sin(x)
                const cosG_inv = cosG, sinG_inv = -sinG;

                const cxI = iterator.hexGrid.srcWidth * 0.5;
                const cyI = iterator.hexGrid.srcHeight * 0.5;
                const cxG = gridHolder.hexGrid.srcWidth * 0.5;
                const cyG = gridHolder.hexGrid.srcHeight * 0.5;
                const pivotIx = iterator.hexGrid.pivot ? iterator.hexGrid.pivot.x : 0;
                const pivotIy = iterator.hexGrid.pivot ? iterator.hexGrid.pivot.y : 0;
                const pivotGx = gridHolder.hexGrid.pivot ? gridHolder.hexGrid.pivot.x : 0;
                const pivotGy = gridHolder.hexGrid.pivot ? gridHolder.hexGrid.pivot.y : 0;

                // --- BOUNDS INTERSECTION (from destructor.js) ---
                // Compute bounding box of iterator in gridHolder's local grid space
                const iterRadius = iterator.radius || 100;
                const ix = iterator.x, iy = iterator.y;
                const gx = gridHolder.x, gy = gridHolder.y;

                // corners implicit (avoid per-frame allocations)

                let minC = Infinity, maxC = -Infinity, minR = Infinity, maxR = -Infinity;
                const invHexSpacing = 1.0 / HEX_SPACING;
                const invHexHeight = 1.0 / HEX_HEIGHT;


                // Ile sÄ…siednich komĂłrek sprawdzamy w mapie (musi byÄ‡ >= przesuniÄ™cie od deformacji / spacing)
                const searchR = (DESTRUCTOR_CONFIG.collisionSearchRadius ?? 4);
                for (let k = 0; k < 4; k++) {
                    const sx = (k === 0 || k === 3) ? -iterRadius : iterRadius;
                    const sy = (k < 2) ? -iterRadius : iterRadius;
                    // Iterator local -> world
                    const wx = ix + sx;
                    const wy = iy + sy;
                    // World -> gridHolder local
                    const dx = wx - gx;
                    const dy = wy - gy;
                    const hlx = dx * cosG_inv - dy * sinG_inv;
                    const hly = dx * sinG_inv + dy * cosG_inv;
                    const gridBx = hlx + cxG + pivotGx;
                    const gridBy = hly + cyG + pivotGy;
                    // Grid index
                    const c = Math.floor(gridBx * invHexSpacing);
                    const r = Math.floor(gridBy * invHexHeight);
                    if (c < minC) minC = c;
                    if (c > maxC) maxC = c;
                    if (r < minR) minR = r;
                    if (r > maxR) maxR = r;
                }

                // Padding for rotation + deform error
                const pad = searchR + 2;
                minC -= pad; maxC += pad; minR -= pad; maxR += pad;

                // --- COLLISION DETECTION ---
                let contactsCount = 0;
                const maxContacts = 64;
                let contacts = this._contactsBuf;

                // GPU PATH: use pre-fetched contacts if available
                if (gpuContacts && gpuContacts.length > 0) {
                    contacts = []; // GPU contacts - fresh array
                    const angA_ = A.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                    const angB_ = B.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                    const cosA_ = Math.cos(angA_), sinA_ = Math.sin(angA_);
                    const cosB_ = Math.cos(angB_), sinB_ = Math.sin(angB_);
                    const cxA_ = A.hexGrid.srcWidth * 0.5, cyA_ = A.hexGrid.srcHeight * 0.5;
                    const cxB_ = B.hexGrid.srcWidth * 0.5, cyB_ = B.hexGrid.srcHeight * 0.5;
                    const pivAxG = A.hexGrid.pivot ? A.hexGrid.pivot.x : 0;
                    const pivAyG = A.hexGrid.pivot ? A.hexGrid.pivot.y : 0;
                    const pivBxG = B.hexGrid.pivot ? B.hexGrid.pivot.x : 0;
                    const pivByG = B.hexGrid.pivot ? B.hexGrid.pivot.y : 0;
                    const cds_ = DESTRUCTOR_CONFIG.collisionDeformScale ?? 1.0;

                    for (let gi = 0; gi < gpuContacts.length && contactsCount < maxContacts; gi++) {
                        const gc = gpuContacts[gi];
                        if (!gc.shardA || !gc.shardB) continue;
                        if (!gc.shardA.active || gc.shardA.isDebris) continue;
                        if (!gc.shardB.active || gc.shardB.isDebris) continue;

                        // Compute world positions (same math as CPU path)
                        const defAx = gc.shardA.deformation.x * cds_;
                        const defAy = gc.shardA.deformation.y * cds_;
                        const rAx = (gc.shardA.gridX - cxA_) + defAx - pivAxG;
                        const rAy = (gc.shardA.gridY - cyA_) + defAy - pivAyG;
                        const wAx = A.x + rAx * cosA_ - rAy * sinA_;
                        const wAy = A.y + rAx * sinA_ + rAy * cosA_;

                        const defBx = gc.shardB.deformation.x * cds_;
                        const defBy = gc.shardB.deformation.y * cds_;
                        const rBx = (gc.shardB.gridX - cxB_) + defBx - pivBxG;
                        const rBy = (gc.shardB.gridY - cyB_) + defBy - pivByG;
                        const wBx = B.x + rBx * cosB_ - rBy * sinB_;
                        const wBy = B.y + rBx * sinB_ + rBy * cosB_;

                        const nxG = wAx - wBx, nyG = wAy - wBy;
                        const distG = Math.sqrt(nxG * nxG + nyG * nyG);
                        const penG = Math.max(0, HIT_RAD - distG);

                        // Grow contacts buffer if needed
                        while (contacts.length <= contactsCount) {
                            contacts.push({ shardA: null, shardB: null, worldAx: 0, worldAy: 0, worldBx: 0, worldBy: 0, normalX: 0, normalY: 0, penetration: 0 });
                        }
                        const cObj = contacts[contactsCount];
                        cObj.shardA = gc.shardA;
                        cObj.shardB = gc.shardB;
                        cObj.worldAx = wAx; cObj.worldAy = wAy;
                        cObj.worldBx = wBx; cObj.worldBy = wBy;
                        cObj.normalX = nxG; cObj.normalY = nyG;
                        cObj.penetration = penG;
                        contactsCount++;
                    }

                    if (contactsCount === 0) return;
                    // Skip CPU detection — jump to physics solver
                } else {
                    // CPU PATH (fallback)
                    contacts = this._contactsBuf;

                    // Fast grids (flattened) â€” avoids string keys + reduces GC pressure
                    const holderGrid = gridHolder.hexGrid.grid;
                    const iterGrid = iterator.hexGrid.grid;
                    const holderCols = gridHolder.hexGrid.cols || 0;
                    const holderRows = gridHolder.hexGrid.rows || 0;
                    const iterCols = iterator.hexGrid.cols || 0;
                    const iterRows = iterator.hexGrid.rows || 0;

                    // Precompute inverse transform for gridHolder->world->iterator
                    const cosI_inv = cosI, sinI_inv = -sinI;

                    // NOWOĹšÄ†: Skalowanie deformacji do kolizji
                    const cds = DESTRUCTOR_CONFIG.collisionDeformScale ?? 1.0;

                    // Clamp search window to holder grid (huge speed-up; outside is always empty)
                    if (holderGrid && holderCols && holderRows) {
                        if (minC < 0) minC = 0;
                        if (minR < 0) minR = 0;
                        if (maxC >= holderCols) maxC = holderCols - 1;
                        if (maxR >= holderRows) maxR = holderRows - 1;
                        if (minC > maxC || minR > maxR) return;
                    }

                    const offsets = getSearchOffsets(searchR);

                    for (let r = minR; r <= maxR; r++) {
                        const rowBase = r * holderCols;
                        for (let c = minC; c <= maxC; c++) {
                            const shardG = holderGrid ? holderGrid[rowBase + c] : null;
                            if (!shardG || !shardG.active || shardG.isDebris) continue;

                            const defGx = shardG.deformation.x * cds;
                            const defGy = shardG.deformation.y * cds;

                            // gridHolder shard -> world
                            const relGx = (shardG.gridX - cxG) + defGx - pivotGx;
                            const relGy = (shardG.gridY - cyG) + defGy - pivotGy;
                            const worldGx = gx + relGx * cosG - relGy * sinG;
                            const worldGy = gy + relGx * sinG + relGy * cosG;

                            // world -> iterator local grid
                            const dx = worldGx - ix;
                            const dy = worldGy - iy;
                            const localIx = dx * cosI_inv - dy * sinI_inv;
                            const localIy = dx * sinI_inv + dy * cosI_inv;
                            const gridIx = localIx + cxI + pivotIx;
                            const gridIy = localIy + cyI + pivotIy;

                            const approxC_I = Math.round(gridIx * invHexSpacing);
                            const approxR_I = Math.round(gridIy * invHexHeight);

                            // Quick reject if far outside iterator grid
                            if (iterGrid && iterCols && iterRows) {
                                if (approxC_I < -searchR || approxC_I >= iterCols + searchR ||
                                    approxR_I < -searchR || approxR_I >= iterRows + searchR) {
                                    continue;
                                }
                            }

                            // Search in iterator grid (neighborhood offsets)
                            for (let oi = 0; oi < offsets.length; oi += 2) {
                                const ic = approxC_I + offsets[oi];
                                const ir = approxR_I + offsets[oi + 1];
                                if (ic < 0 || ir < 0 || ic >= iterCols || ir >= iterRows) continue;

                                const shardI = iterGrid ? iterGrid[ic + ir * iterCols] : null;
                                if (!shardI || !shardI.active || shardI.isDebris) continue;

                                const defIx = shardI.deformation.x * cds;
                                const defIy = shardI.deformation.y * cds;

                                const gi = shardI.gridX + defIx;
                                const giy = shardI.gridY + defIy;
                                const ddx = gi - gridIx, ddy = giy - gridIy;
                                if (ddx * ddx + ddy * ddy < HIT_RAD_SQ) {
                                    // Compute world position of iterator shard
                                    const relIx = (shardI.gridX - cxI) + defIx - pivotIx;
                                    const relIy = (shardI.gridY - cyI) + defIy - pivotIy;
                                    const worldIx = ix + relIx * cosI - relIy * sinI;
                                    const worldIy = iy + relIx * sinI + relIy * cosI;

                                    const normalX = worldIx - worldGx;
                                    const normalY = worldIy - worldGy;
                                    const hexDistSq = normalX * normalX + normalY * normalY;
                                    const hexDist = Math.sqrt(hexDistSq);

                                    // Map shardA/shardB consistently: A is always first entity arg
                                    const isSwapped = (iterator !== A);
                                    const cObj = contacts[contactsCount];
                                    cObj.shardA = isSwapped ? shardG : shardI;
                                    cObj.shardB = isSwapped ? shardI : shardG;
                                    cObj.worldAx = isSwapped ? worldGx : worldIx;
                                    cObj.worldAy = isSwapped ? worldGy : worldIy;
                                    cObj.worldBx = isSwapped ? worldIx : worldGx;
                                    cObj.worldBy = isSwapped ? worldIy : worldGy;
                                    cObj.normalX = isSwapped ? -normalX : normalX;
                                    cObj.normalY = isSwapped ? -normalY : normalY;
                                    cObj.penetration = Math.max(0, HIT_RAD - hexDist);

                                    contactsCount++;
                                    if (contactsCount >= maxContacts) break;
                                }
                            }
                            if (contactsCount >= maxContacts) break;
                        }
                        if (contactsCount >= maxContacts) break;
                    }

                    if (contactsCount === 0) return;
                } // end CPU path else

                Perf.contactsAccum += contactsCount;

                const sA = contacts[0].shardA;
                const hitB = contacts[0].shardB;

                let worldHitX = 0;
                let worldHitY = 0;
                let nx = 0;
                let ny = 0;
                let penetration = 0;

                for (let ci = 0; ci < contactsCount; ci++) {
                    const contact = contacts[ci];
                    worldHitX += (contact.worldAx + contact.worldBx) * 0.5;
                    worldHitY += (contact.worldAy + contact.worldBy) * 0.5;
                    nx += contact.normalX;
                    ny += contact.normalY;
                    if (contact.penetration > penetration) penetration = contact.penetration;
                }

                const invCount = 1.0 / contactsCount;
                worldHitX *= invCount;
                worldHitY *= invCount;

                let normalLenSq = nx * nx + ny * ny;
                if (normalLenSq < 1e-12) {
                    nx = A.x - B.x;
                    ny = A.y - B.y;
                    normalLenSq = nx * nx + ny * ny;
                    if (normalLenSq < 1e-12) normalLenSq = 1;
                }
                const invNormalLen = 1.0 / Math.sqrt(normalLenSq);
                nx *= invNormalLen;
                ny *= invNormalLen;

                // --- 2. V46 PHYSICS SOLVER (Rigid Body Impulse) ---

                const cxA = A.hexGrid.srcWidth * 0.5;
                const cyA = A.hexGrid.srcHeight * 0.5;
                const cxB = B.hexGrid.srcWidth * 0.5;
                const cyB = B.hexGrid.srcHeight * 0.5;
                const pivotAx = A.hexGrid.pivot ? A.hexGrid.pivot.x : 0;
                const pivotAy = A.hexGrid.pivot ? A.hexGrid.pivot.y : 0;
                const pivotBx = B.hexGrid.pivot ? B.hexGrid.pivot.x : 0;
                const pivotBy = B.hexGrid.pivot ? B.hexGrid.pivot.y : 0;


                // Wektory ramienia siĹ‚y
                const rAx = worldHitX - A.x;
                const rAy = worldHitY - A.y;
                const rBx = worldHitX - B.x;
                const rBy = worldHitY - B.y;

                // PrÄ™dkoĹ›ci w punkcie zderzenia
                const vAx = A.vx - A.angVel * rAy;
                const vAy = A.vy + A.angVel * rAx;
                const vBx = B.vx - B.angVel * rBy;
                const vBy = B.vy + B.angVel * rBx;

                const dvx = vAx - vBx;
                const dvy = vAy - vBy;

                // Baza kontaktu (normalna + styczna)
                const velAlongNormal = dvx * nx + dvy * ny;
                const tx = -ny, ty = nx;
                const velTangent = dvx * tx + dvy * ty;

                const invMassA = 1 / massA;
                const invMassB = 1 / massB;

                const slop = 0.01;
                const pen = Math.max(0, penetration - slop);

                // ---- 1) IMPULS RIGID BODY (tylko gdy obiekty siÄ™ zbliĹĽajÄ…) ----
                let isDestruction = false;
                let impactForceTest = 0;

                if (velAlongNormal < 0) {
                    const restitutionBase = DESTRUCTOR_CONFIG.restitution;
                    const inertiaScale = 0.5;
                    const effectiveRadiusA = Math.max(1, A.radius || Math.max(cxA, cyA, 1));
                    const effectiveRadiusB = Math.max(1, B.radius || Math.max(cxB, cyB, 1));
                    const invIa = 1 / (inertiaScale * massA * effectiveRadiusA * effectiveRadiusA);
                    const invIb = 1 / (inertiaScale * massB * effectiveRadiusB * effectiveRadiusB);

                    const rnA = rAx * ny - rAy * nx;
                    const rnB = rBx * ny - rBy * nx;

                    const normalDenom = invMassA + invMassB + rnA * rnA * invIa + rnB * rnB * invIb;
                    if (Number.isFinite(normalDenom) && normalDenom > 1e-8) {

                        // Testowy impuls dla restitution podstawowego (do sprawdzenia yield)
                        let jTest = -(1 + restitutionBase) * velAlongNormal;
                        jTest /= normalDenom;
                        impactForceTest = Math.abs(jTest);

                        const yieldPoint = DESTRUCTOR_CONFIG.yieldPoint;
                        isDestruction = impactForceTest > yieldPoint;

                        // Brak odbicia przy destrukcji
                        const restitutionEff = isDestruction ? 0.0 : restitutionBase;

                        // Impuls wĹ‚aĹ›ciwy
                        let j = -(1 + restitutionEff) * velAlongNormal;
                        j /= normalDenom;

                        // Opcjonalnie: pochĹ‚oniÄ™cie czÄ™Ĺ›ci impulsu, ĹĽeby nie "wystrzeliwaÄ‡" celu (bardziej car-crash)
                        if (isDestruction) {
                            const crushImpulseScale = DESTRUCTOR_CONFIG.crushImpulseScale ?? 0.45;
                            j *= crushImpulseScale;
                        }

                        const impulseX = j * nx;
                        const impulseY = j * ny;

                        A.vx += impulseX * invMassA;
                        A.vy += impulseY * invMassA;
                        B.vx -= impulseX * invMassB;
                        B.vy -= impulseY * invMassB;

                        A.angVel += rnA * j * invIa;
                        B.angVel -= rnB * j * invIb;

                        // Tarcie (dla niszczenia nie schodzimy do zera, ĹĽeby byĹ‚o "scrape")
                        let jt = -velTangent;
                        const tangentDenom = invMassA + invMassB + (rAx * ty - rAy * tx) ** 2 * invIa + (rBx * ty - rBy * tx) ** 2 * invIb;
                        if (Number.isFinite(tangentDenom) && tangentDenom > 1e-8) jt /= tangentDenom;
                        else jt = 0;

                        const mu = 0.5;
                        const maxFriction = Math.abs(j) * mu;
                        if (Math.abs(jt) > maxFriction) jt = -maxFriction * Math.sign(velTangent);

                        const frictionScale = isDestruction ? 0.25 : 0.8;
                        jt *= frictionScale;

                        const fImpulseX = jt * tx;
                        const fImpulseY = jt * ty;

                        A.vx += fImpulseX * invMassA;
                        A.vy += fImpulseY * invMassA;
                        B.vx -= fImpulseX * invMassB;
                        B.vy -= fImpulseY * invMassB;

                        A.angVel += (rAx * ty - rAy * tx) * jt * invIa;
                        B.angVel -= (rBx * ty - rBy * tx) * jt * invIb;
                    }
                }

                // ---- 2) SOFTBODY CRUSH (ciÄ…gĹ‚e wgniatanie) ----
                // Startujemy zgniatanie gdy:
                // - yield zostaĹ‚ przekroczony (duĹĽy impuls) LUB
                // - nadal mamy wyraĹşnÄ… penetracjÄ™ (dociĹ›niÄ™cie, nawet przy maĹ‚ej prÄ™dkoĹ›ci)
                const penMin = DESTRUCTOR_CONFIG.crushPenetrationMin ?? 0.15;
                const crushActive = isDestruction || (pen > penMin);

                const impactSpeed = Math.hypot(dvx, dvy);
                const minCrushSpeed = DESTRUCTOR_CONFIG.crushMinSpeed ?? 1.5;
                const allowCrush = (impactSpeed > minCrushSpeed) || (pen > penMin);

                if (crushActive && allowCrush) {
                    const angA = A.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                    const angB = B.angle + DESTRUCTOR_CONFIG.visualRotationOffset;

                    // Skalowanie pod iteracje solvera (ĹĽeby 4 iteracje nie dawaĹ‚y 4x wiÄ™kszego wgniatania)
                    const iterScale = 1.0 / (DESTRUCTOR_CONFIG.collisionIterations || 1);
                    const dtScale = dt * 60 * iterScale;

                    const totalMass = massA + massB;
                    const ratioA = massB / totalMass;
                    const ratioB = massA / totalMass;

                    // ===== GPU DEFORMATION PATH =====
                    if (WebGPUPhysics.active && A.gpuData && B.gpuData && gpuContacts) {
                        // GPU path: apply per-contact forces on the GPU
                        WebGPUPhysics.applyGPUDeformation(A, B, contactsCount, nx, ny);
                    } else {
                        // ===== CPU FALLBACK =====
                        // Kontakt w lokalnych ukĹ‚adach (uwzglÄ™dnij aktualnÄ… deformacjÄ™)
                        const relX_A = (sA.gridX - cxA) + sA.deformation.x - pivotAx;
                        const relY_A = (sA.gridY - cyA) + sA.deformation.y - pivotAy;
                        const relX_B = (hitB.gridX - cxB) + hitB.deformation.x - pivotBx;
                        const relY_B = (hitB.gridY - cyB) + hitB.deformation.y - pivotBy;

                        const ca_inv = Math.cos(-angA), sa_inv = Math.sin(-angA);
                        const cb_inv = Math.cos(-angB), sb_inv = Math.sin(-angB);

                        const velK = DESTRUCTOR_CONFIG.crushVelK ?? 0.15;
                        const penK = DESTRUCTOR_CONFIG.crushPenK ?? 10.0;
                        const shearK = DESTRUCTOR_CONFIG.shearK ?? 0.06;

                        // (A dostaje -dv, B dostaje +dv) + dokĹ‚adka od penetracji (docisk)
                        let forceAx = (-dvx * ca_inv - -dvy * sa_inv) * velK * dtScale;
                        let forceAy = (-dvx * sa_inv + -dvy * ca_inv) * velK * dtScale;

                        let forceBx = (dvx * cb_inv - dvy * sb_inv) * velK * dtScale;
                        let forceBy = (dvx * sb_inv + dvy * cb_inv) * velK * dtScale;

                        // Penetracja -> wgniatanie wzdĹ‚uĹĽ normalnej (nie zaleĹĽy od prÄ™dkoĹ›ci)
                        if (pen > 0) {
                            const penForce = pen * penK * dtScale;

                            // A: +n (normal jest od B do A)
                            const wPenAx = nx * penForce;
                            const wPenAy = ny * penForce;

                            // B: -n
                            const wPenBx = -nx * penForce;
                            const wPenBy = -ny * penForce;

                            forceAx += wPenAx * ca_inv - wPenAy * sa_inv;
                            forceAy += wPenAx * sa_inv + wPenAy * ca_inv;

                            forceBx += wPenBx * cb_inv - wPenBy * sb_inv;
                            forceBy += wPenBx * sb_inv + wPenBy * cb_inv;
                        }

                        // Shear -> wyginanie przy "szorowaniu"
                        if (Math.abs(velTangent) > 0.1) {
                            const shear = velTangent * shearK * dtScale;

                            const wShearAx = tx * shear;
                            const wShearAy = ty * shear;
                            const wShearBx = -tx * shear;
                            const wShearBy = -ty * shear;

                            forceAx += wShearAx * ca_inv - wShearAy * sa_inv;
                            forceAy += wShearAx * sa_inv + wShearAy * ca_inv;

                            forceBx += wShearBx * cb_inv - wShearBy * sb_inv;
                            forceBy += wShearBx * sb_inv + wShearBy * cb_inv;
                        }

                        // Skala deformacji zaleĹĽna od tego czy przekroczyliĹ›my yield
                        const crushScale = isDestruction ? 1.0 : 0.35;
                        const dmgScale = doDamage ? 1.0 : 0.0;

                        this.distributeStructuralDamage(
                            A, relX_A, relY_A,
                            forceAx * (ratioA * 2) * crushScale,
                            forceAy * (ratioA * 2) * crushScale,
                            dmgScale
                        );
                        this.distributeStructuralDamage(
                            B, relX_B, relY_B,
                            forceBx * (ratioB * 2) * crushScale,
                            forceBy * (ratioB * 2) * crushScale,
                            dmgScale
                        );
                    }
                }

                // --- 3. SEPARATION ---
                const percent = crushActive ? (DESTRUCTOR_CONFIG.crushSeparation ?? 0.25) : 0.8;
                if (penetration > slop) {
                    const correctionMag = Math.max(penetration - slop, 0.0) / (invMassA + invMassB) * percent;
                    const cx = nx * correctionMag;
                    const cy = ny * correctionMag;
                    A.x += cx * invMassA;
                    A.y += cy * invMassA;
                    B.x -= cx * invMassB;
                    B.y -= cy * invMassB;
                }
            },

            // eraseShard: Gumka â€” wytnij dziurÄ™ z cache bez peĹ‚nego redraw (from destructor.js)
            eraseShard(entity, shard) {
                if (!entity.hexGrid || !entity.hexGrid.cacheCtx) return;
                const ctx = entity.hexGrid.cacheCtx;
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.translate(shard.gridX + shard.deformation.x, shard.gridY + shard.deformation.y);
                ctx.beginPath();
                const r = shard.radius * 1.15;
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                ctx.globalCompositeOperation = 'source-over';
            },

            destroyShard(entity, shard, velVector) {
                shard.hp = 0;
                const ctx = entity.hexGrid.cacheCtx;
                if (ctx) {
                    ctx.save();
                    ctx.translate(shard.gridX + shard.deformation.x, shard.gridY + shard.deformation.y);
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(0, 0, shard.radius * 1.05, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    ctx.globalCompositeOperation = 'source-over';
                }
                const deformVelX = shard.deformation.x * 2.0;
                const deformVelY = shard.deformation.y * 2.0;
                shard.becomeDebris(velVector.x * 0.3 + deformVelX, velVector.y * 0.3 + deformVelY, entity, 1.0);
            },
            processSplits(entities) {
                const queue = [...new Set(this.splitQueue)];
                this.splitQueue = [];
                for (const entity of queue) {
                    if (!entity.hexGrid || !entities.includes(entity)) continue;
                    const groups = this.findIslands(entity.hexGrid);
                    if (groups.length <= 1) continue;
                    groups.sort((a, b) => b.length - a.length);
                    const mainGroup = groups[0];
                    const looseGroups = groups.slice(1);
                    this.rebuildEntityGrid(entity, mainGroup);
                    for (const group of looseGroups) {
                        if (group.length < 3) {
                            for (const s of group) this.destroyShard(entity, s, { x: entity.vx, y: entity.vy });
                            continue;
                        }
                        this.spawnWreckEntity(entity, group, entities);
                    }
                }
            },
            findIslands(grid) {
                const activeShards = grid.shards.filter(s => s.active && !s.isDebris);
                if (activeShards.length === 0) return [];
                const map = {};
                for (const s of activeShards) map[s.c + "," + s.r] = s;
                const visited = new Set();
                const groups = [];
                for (const seed of activeShards) {
                    if (visited.has(seed)) continue;
                    const group = [];
                    const stack = [seed];
                    visited.add(seed);
                    while (stack.length > 0) {
                        const curr = stack.pop();
                        group.push(curr);
                        if (curr.neighbors) {
                            for (const neighbor of curr.neighbors) {
                                if (neighbor && neighbor.active && !neighbor.isDebris && !visited.has(neighbor)) {
                                    visited.add(neighbor);
                                    stack.push(neighbor);
                                }
                            }
                        }
                    }
                    groups.push(group);
                }
                return groups;
            },
            getNeighborCoords(c, r) {
                const odd = (c % 2 !== 0);
                const offsets = odd
                    ? [[0, -1], [0, 1], [-1, 0], [-1, 1], [1, 0], [1, 1]]
                    : [[0, -1], [0, 1], [-1, -1], [-1, 0], [1, -1], [1, 0]];
                return offsets.map(o => ({ c: c + o[0], r: r + o[1] }));
            },
            rebuildEntityGrid(entity, shards) {
                const cols = entity.hexGrid.cols || Math.ceil(entity.hexGrid.srcWidth / HEX_SPACING);
                const rows = entity.hexGrid.rows || Math.ceil(entity.hexGrid.srcHeight / HEX_HEIGHT);
                const map = {};
                const grid = new Array(cols * rows);

                for (let i = 0; i < shards.length; i++) {
                    const s = shards[i];
                    map[s.c + "," + s.r] = s;
                    if (s.c >= 0 && s.c < cols && s.r >= 0 && s.r < rows) {
                        grid[s.c + s.r * cols] = s;
                    }
                }

                entity.hexGrid.shards = shards;
                entity.hexGrid.map = map;
                entity.hexGrid.grid = grid;
                entity.hexGrid.cols = cols;
                entity.hexGrid.rows = rows;
                entity.hexGrid.cacheDirty = true;
                entity.mass = shards.length * DESTRUCTOR_CONFIG.shardMass;
            },
            spawnWreckEntity(parent, shards, entities) {
                // 1. Obliczanie Ĺ›rodka masy (Pivot)
                let sumX = 0, sumY = 0;
                for (const s of shards) {
                    sumX += (s.gridX + s.deformation.x);
                    sumY += (s.gridY + s.deformation.y);
                }
                const avgX = sumX / shards.length;
                const avgY = sumY / shards.length;

                const cx = parent.hexGrid.srcWidth / 2;
                const cy = parent.hexGrid.srcHeight / 2;
                const relX = avgX - cx;
                const relY = avgY - cy;

                // --- FIX: OBLICZANIE NOWEGO PROMIENIA (RADIUS) ---
                // Sprawdzamy jak daleko najdalszy heks leĹĽy od nowego Ĺ›rodka (avgX, avgY)
                let maxDistSq = 0;
                for (const s of shards) {
                    const dx = (s.gridX + s.deformation.x) - avgX;
                    const dy = (s.gridY + s.deformation.y) - avgY;
                    const d2 = dx * dx + dy * dy;
                    if (d2 > maxDistSq) maxDistSq = d2;
                }
                const newRadius = Math.sqrt(maxDistSq) + DESTRUCTOR_CONFIG.gridDivisions * 2.0;
                // --------------------------------------------------

                const ang = parent.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const c = Math.cos(ang);
                const s = Math.sin(ang);
                const worldX = parent.x + relX * c - relY * s;
                const worldY = parent.y + relX * s + relY * c;

                // Grid dimensions for fast lookups (kept from parent)
                const cols = parent.hexGrid.cols || Math.ceil(parent.hexGrid.srcWidth / HEX_SPACING);
                const rows = parent.hexGrid.rows || Math.ceil(parent.hexGrid.srcHeight / HEX_HEIGHT);

                const wreck = {
                    x: worldX, y: worldY,
                    vx: parent.vx, vy: parent.vy,
                    angle: parent.angle, angVel: parent.angVel,

                    radius: newRadius, // <--- TUTAJ PRZYPISUJEMY OBLICZONY PROMIEĹ

                    mass: shards.length * DESTRUCTOR_CONFIG.shardMass,
                    isWreck: true,
                    hexGrid: {
                        shards: shards,
                        map: {},
                        grid: new Array(cols * rows),
                        cols,
                        rows,
                        srcWidth: parent.hexGrid.srcWidth,
                        srcHeight: parent.hexGrid.srcHeight,
                        cacheCanvas: parent.hexGrid.cacheCanvas.cloneNode(),
                        cacheCtx: null,
                        cacheDirty: true,
                        pivot: { x: relX, y: relY }
                    }
                };
                wreck.hexGrid.cacheCtx = wreck.hexGrid.cacheCanvas.getContext('2d');
                const wGrid = wreck.hexGrid.grid;
                for (let i = 0; i < shards.length; i++) {
                    const hs = shards[i];
                    wreck.hexGrid.map[hs.c + "," + hs.r] = hs;
                    if (hs.c >= 0 && hs.c < cols && hs.r >= 0 && hs.r < rows) {
                        wGrid[hs.c + hs.r * cols] = hs;
                    }
                }
                entities.push(wreck);
            },
            cutByBeam(entity, p1, p2, beamWidth) {
                if (!entity.hexGrid) return;
                const ang = -(entity.angle + DESTRUCTOR_CONFIG.visualRotationOffset);
                const cos = Math.cos(ang);
                const sin = Math.sin(ang);
                const ex = entity.x;
                const ey = entity.y;
                const dx1 = p1.x - ex; const dy1 = p1.y - ey;
                const dx2 = p2.x - ex; const dy2 = p2.y - ey;
                const l1x = dx1 * cos - dy1 * sin; const l1y = dx1 * sin + dy1 * cos;
                const l2x = dx2 * cos - dy2 * sin; const l2y = dx2 * sin + dy2 * cos;
                const cx = entity.hexGrid.srcWidth / 2;
                const cy = entity.hexGrid.srcHeight / 2;
                const pivotX = entity.hexGrid.pivot ? entity.hexGrid.pivot.x : 0;
                const pivotY = entity.hexGrid.pivot ? entity.hexGrid.pivot.y : 0;
                const lineStart = { x: l1x + cx + pivotX, y: l1y + cy + pivotY };
                const lineEnd = { x: l2x + cx + pivotX, y: l2y + cy + pivotY };
                const minX = Math.min(lineStart.x, lineEnd.x) - beamWidth * 2;
                const maxX = Math.max(lineStart.x, lineEnd.x) + beamWidth * 2;
                const minY = Math.min(lineStart.y, lineEnd.y) - beamWidth * 2;
                const maxY = Math.max(lineStart.y, lineEnd.y) + beamWidth * 2;
                const lineVecX = lineEnd.x - lineStart.x;
                const lineVecY = lineEnd.y - lineStart.y;
                const lineLenSq = lineVecX * lineVecX + lineVecY * lineVecY;
                const perpX = -lineVecY;
                const perpY = lineVecX;
                const perpLen = Math.sqrt(perpX * perpX + perpY * perpY) || 1;
                const pushDirX = perpX / perpLen;
                const pushDirY = perpY / perpLen;
                const rotBack = -ang;
                const cosB = Math.cos(rotBack);
                const sinB = Math.sin(rotBack);
                let anyHit = false;
                for (const shard of entity.hexGrid.shards) {
                    if (!shard.active || shard.isDebris) continue;
                    const px = shard.gridX + shard.deformation.x;
                    const py = shard.gridY + shard.deformation.y;
                    if (px < minX || px > maxX || py < minY || py > maxY) continue;
                    let t = ((px - lineStart.x) * lineVecX + (py - lineStart.y) * lineVecY) / lineLenSq;
                    t = Math.max(0, Math.min(1, t));
                    const closestX = lineStart.x + t * lineVecX;
                    const closestY = lineStart.y + t * lineVecY;
                    const distSq = (px - closestX) ** 2 + (py - closestY) ** 2;
                    if (distSq < (beamWidth + shard.radius * 1.2) ** 2) {
                        const cross = (px - lineStart.x) * lineVecY - (py - lineStart.y) * lineVecX;
                        const side = cross > 0 ? 1 : -1;
                        const worldImpulseLocalX = pushDirX * side * DESTRUCTOR_CONFIG.beamForce;
                        const worldImpulseLocalY = pushDirY * side * DESTRUCTOR_CONFIG.beamForce;
                        const wImpX = worldImpulseLocalX * cosB - worldImpulseLocalY * sinB;
                        const wImpY = worldImpulseLocalX * sinB + worldImpulseLocalY * cosB;
                        this.destroyShard(entity, shard, { x: entity.vx + wImpX * 0.05, y: entity.vy + wImpY * 0.05 });
                        entity.hexGrid.cacheDirty = true;
                        anyHit = true;
                    }
                }
                if (anyHit) this.splitQueue.push(entity);
            },
            draw(ctx, camera) {
                for (const d of this.debris) {
                    d.drawDebris(ctx, camera);
                }
            }
        };

        function createProjectileImage() {
            const size = 64;
            const c = document.createElement('canvas');
            c.width = size; c.height = size;
            const ctx = c.getContext('2d');
            const grad = ctx.createRadialGradient(size / 2, size / 2, 4, size / 2, size / 2, size / 2);
            grad.addColorStop(0, '#ffffaa');
            grad.addColorStop(0.4, '#ffaa00');
            grad.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 3, 0, Math.PI * 2);
            ctx.stroke();
            return c;
        }
        const projectileImg = createProjectileImage();

        function createProceduralShipImage(color) {
            const c = document.createElement('canvas');
            c.width = 160; c.height = 300;
            const x = c.getContext('2d');
            x.fillStyle = color || '#445566';
            x.fillRect(40, 20, 80, 260);
            x.fillStyle = '#667788';
            x.fillRect(20, 180, 120, 80);
            x.fillStyle = '#33ccff';
            x.fillRect(60, 40, 40, 40);
            return c;
        }

        function createDebrisObstacle() {
            const c = document.createElement('canvas');
            c.width = 80; c.height = 80;
            const x = c.getContext('2d');
            x.fillStyle = '#554433';
            x.beginPath();
            x.arc(40, 40, 35, 0, Math.PI * 2);
            x.fill();
            return c;
        }

        function createAsteroidImage(radius) {
            const c = document.createElement('canvas');
            c.width = radius * 2; c.height = radius * 2;
            const ctx = c.getContext('2d');
            const cx = radius; const cy = radius;
            ctx.fillStyle = '#665544';
            ctx.beginPath();
            for (let a = 0; a < Math.PI * 2; a += 0.4) {
                const r = radius * (0.8 + Math.random() * 0.2);
                const x = cx + Math.cos(a) * r;
                const y = cy + Math.sin(a) * r;
                if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#554433' : '#776655';
                const s = Math.random() * radius * 0.4;
                const x = Math.random() * c.width;
                const y = Math.random() * c.height;
                if (Math.hypot(x - cx, y - cy) < radius * 0.7) {
                    ctx.beginPath(); ctx.arc(x, y, s, 0, Math.PI * 2); ctx.fill();
                }
            }
            return c;
        }

        function initHexBody(entity, image, damagedImage, isProjectile = false, massOverride = null) {
            const w = Math.ceil(image.width / 2) * 2;
            const h = Math.ceil(image.height / 2) * 2;
            const r = DESTRUCTOR_CONFIG.gridDivisions;
            const hexHeight = Math.sqrt(3) * r;
            let data = null;
            let ctx = null;
            const cvs = document.createElement('canvas');
            cvs.width = w; cvs.height = h;
            ctx = cvs.getContext('2d');
            let dmgCvs = null;
            if (damagedImage) {
                dmgCvs = document.createElement('canvas');
                dmgCvs.width = w; dmgCvs.height = h;
                dmgCvs.getContext('2d').drawImage(damagedImage, 0, 0, w, h);
            }
            try {
                ctx.drawImage(image, 0, 0, w, h);
                data = ctx.getImageData(0, 0, w, h).data;
            } catch (e) { }
            const shards = [];
            const map = {};
            const cols = Math.ceil(w / (r * 1.5));
            const rows = Math.ceil(h / hexHeight);
            // Fast lookup grid (flattened 2D) â€” avoids string keys in hot paths
            const grid = new Array(cols * rows);
            for (let c = 0; c < cols; c++) {
                for (let ro = 0; ro < rows; ro++) {
                    const x = c * r * 1.5;
                    let y = ro * hexHeight;
                    if (c % 2 !== 0) y += hexHeight / 2;
                    const px = Math.floor(x);
                    const py = Math.floor(y);
                    if (px >= 0 && px < w && py >= 0 && py < h) {
                        const alpha = data[(py * w + px) * 4 + 3];
                        if (alpha > 40) {
                            const color = isProjectile ? '#ffcc00' : null;
                            const s = new HexShard(isProjectile ? null : cvs, dmgCvs, x, y, r, c, ro, color);
                            shards.push(s);
                            grid[c + ro * cols] = s;
                            map[c + "," + ro] = s;
                        }
                    }
                }
            }

            // --- PRE-CALCULATE NEIGHBORS (Softbody optimization) ---
            // Use numeric grid lookups (no string keys)
            for (const s of shards) {
                const nCoords = DestructorSystem.getNeighborCoords(s.c, s.r);
                for (let ni = 0; ni < nCoords.length; ni++) {
                    const nc = nCoords[ni];
                    if (nc.c < 0 || nc.c >= cols || nc.r < 0 || nc.r >= rows) continue;
                    const ns = grid[nc.c + nc.r * cols];
                    if (ns) s.neighbors.push(ns);
                }
            }
            // -------------------------------------------------------

            const cacheCvs = document.createElement('canvas');
            cacheCvs.width = w; cacheCvs.height = h;
            const cCtx = cacheCvs.getContext('2d');
            if (isProjectile) {
                cCtx.drawImage(image, 0, 0);
            } else {
                for (const s of shards) {
                    s.drawShape(cCtx);
                }
            }
            entity.hexGrid = {
                shards,
                map,
                grid,
                cols,
                rows,
                srcWidth: w,
                srcHeight: h,
                cacheCanvas: cacheCvs,
                cacheCtx: cCtx,
                cacheDirty: false
            };
            entity.radius = Math.max(w, h) / 2;
            entity.isProjectile = isProjectile;
            if (massOverride) {
                entity.mass = massOverride;
            } else {
                entity.mass = shards.length * DESTRUCTOR_CONFIG.shardMass;
            }
        }

        // drawHexBody â€” now a no-op stub; Three.js HexRenderer handles all entity rendering.
        // Kept for API compatibility (physics code references cacheDirty etc.)
        function drawHexBody(ctx, entity, camera) {
            // Three.js rendering is handled by HexRenderer.update() + HexRenderer.render()
        }

        let entities = [];
        const SHIP_URL = 'https://raw.githubusercontent.com/bazylowybazyl/statki/refs/heads/main/assets/capital_ship_rect_v1.png';
        const DAMAGED_URL = 'https://raw.githubusercontent.com/bazylowybazyl/statki/refs/heads/main/assets/damaged.png';
        const player = { x: -1200, y: 0, vx: 0, vy: 0, angle: 0, angVel: 0, radius: 100 };
        const dummy = { x: 1200, y: 0, vx: 0, vy: 0, angle: Math.PI, angVel: 0, radius: 100 };
        let mouse = { x: 0, y: 0, down: false, dragStart: null, dragCurrent: null };
        const keys = {};

        async function init() {
            statusEl.textContent = "Inicjalizacja WebGPU...";

            // Odpalamy kartÄ™ graficznÄ… zanim zaĹ‚adujemy cokolwiek innego
            await WebGPUPhysics.init();

            if (WebGPUPhysics.active) {
                statusEl.innerHTML = "WebGPU <span style='color:#4f8'>AKTYWNE</span>. Ĺadowanie tekstur...";
            } else {
                statusEl.innerHTML = "WebGPU <span style='color:#f44'>BRAK</span>. Fallback na CPU...";
            }

            const shipImg = new Image();
            const damagedImg = new Image();
            shipImg.crossOrigin = "Anonymous";
            damagedImg.crossOrigin = "Anonymous";
            let loaded = 0;
            const onLoaded = () => {
                loaded++;
                if (loaded === 2) {
                    statusEl.textContent = "Obrazy zaĹ‚adowane.";
                    setupScene(shipImg, damagedImg);
                }
            };
            shipImg.onload = onLoaded;
            damagedImg.onload = onLoaded;
            shipImg.onerror = () => useFallback();
            damagedImg.onerror = () => useFallback();
            shipImg.src = SHIP_URL;
            damagedImg.src = DAMAGED_URL;
        }

        function setupScene(img, dmgImg) {
            initHexBody(player, img, dmgImg, false, 800000);
            initHexBody(dummy, img, dmgImg, false, DESTRUCTOR_CONFIG.dummyMass);

            // Budujemy bufory dla statkĂłw
            WebGPUPhysics.createBuffersForEntity(player);
            WebGPUPhysics.createBuffersForEntity(dummy);

            entities.push(player, dummy);
            const debrisImg = new Image();
            debrisImg.src = createDebrisObstacle().toDataURL();
            debrisImg.onload = () => {
                for (let i = 0; i < 5; i++) {
                    const d = {
                        x: -400 + i * 150,
                        y: 0,
                        vx: 0, vy: 0, angle: Math.random(), angVel: 0, radius: 40
                    };
                    initHexBody(d, debrisImg, null, false, DESTRUCTOR_CONFIG.debrisMass);
                    WebGPUPhysics.createBuffersForEntity(d); // dla maĹ‚ych przeszkĂłd teĹĽ
                    entities.push(d);
                }
            };
            loop();
        }

        function useFallback() {
            statusEl.textContent = "BĹ‚Ä…d sieci/CORS. Uruchamianie generatora awaryjnego...";
            const procImg = createProceduralShipImage('#445566');
            const procDmg = createProceduralShipImage('#222222');
            const img = new Image();
            img.onload = () => {
                const imgD = new Image();
                imgD.onload = () => setupScene(img, imgD);
                imgD.src = procDmg.toDataURL();
            };
            img.src = procImg.toDataURL();
        }

        function resetSim() {
            entities = [];
            player.x = -1200; player.y = 0; player.vx = 0; player.vy = 0; player.angle = 0;
            dummy.x = 1200; dummy.y = 0; dummy.vx = 0; dummy.vy = 0; dummy.angle = Math.PI;
            init();
            DestructorSystem.debris = [];
        }

        function fireAsteroid(startPos, endPos) {
            const dx = endPos.x - startPos.x;
            const dy = endPos.y - startPos.y;
            const len = Math.hypot(dx, dy);
            // ZWIÄKSZONO PRÄDKOĹšÄ† 2X
            const speed = Math.min(len * DESTRUCTOR_CONFIG.asteroidSpeedMult, DESTRUCTOR_CONFIG.asteroidMaxSpeed);
            const dirX = len > 0 ? dx / len : 0;
            const dirY = len > 0 ? dy / len : 1;
            const radius = 60;
            const asteroidImg = new Image();
            asteroidImg.src = createAsteroidImage(radius).toDataURL();
            const ast = {
                x: startPos.x,
                y: startPos.y,
                vx: dirX * speed,
                vy: dirY * speed,
                angle: Math.random() * Math.PI * 2,
                angVel: (Math.random() - 0.5) * 5,
                radius: radius
            };
            asteroidImg.onload = () => {
                // ZWIÄKSZONO MASÄ (1 000 000)
                initHexBody(ast, asteroidImg, null, false, DESTRUCTOR_CONFIG.asteroidMass);

                // ZWIÄKSZONO Ĺ»YCIE (x10)
                if (ast.hexGrid) {
                    for (const s of ast.hexGrid.shards) {
                        s.maxHp *= DESTRUCTOR_CONFIG.asteroidHPMult;
                        s.hp = s.maxHp;
                    }
                }
                entities.push(ast);
            };
        }

        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.code === 'Space') resetSim();
            if (e.code === 'KeyR') DestructorSystem.repair(entities, 0.1);
            if (e.code === 'KeyP') Perf.toggle();
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            if (mouse.down) {
                mouse.dragCurrent = { x: mouse.x, y: mouse.y };
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                mouse.down = true;
                mouse.dragStart = { x: mouse.x, y: mouse.y };
                mouse.dragCurrent = { x: mouse.x, y: mouse.y };
            }
            if (e.button === 2) mouse.right = true;
        });
        window.addEventListener('mouseup', (e) => {
            if (e.button === 0 && mouse.dragStart) {
                const worldStart = screenToWorld(mouse.dragStart.x, mouse.dragStart.y, camera);
                const worldEnd = screenToWorld(mouse.dragCurrent.x, mouse.dragCurrent.y, camera);
                if (Math.hypot(mouse.dragStart.x - mouse.dragCurrent.x, mouse.dragStart.y - mouse.dragCurrent.y) > 10) {
                    fireAsteroid(worldStart, worldEnd);
                }
                mouse.down = false;
                mouse.dragStart = null;
                mouse.dragCurrent = null;
            }
            if (e.button === 2) mouse.right = false;
        });
        window.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSpeed = DESTRUCTOR_CONFIG.zoomSpeed;
            camera.zoom -= e.deltaY * zoomSpeed * camera.zoom;
            camera.zoom = Math.max(0.2, Math.min(camera.zoom, 3.0));
        }, { passive: false });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            HexRenderer.resize();
        });

        async function updatePhysics(dt) {
            const t0 = performance.now();

            const speed = DESTRUCTOR_CONFIG.playerSpeed;
            if (keys['w']) {
                player.vx += Math.cos(player.angle) * speed * dt;
                player.vy += Math.sin(player.angle) * speed * dt;
            }
            if (keys['s']) {
                player.vx -= Math.cos(player.angle) * (speed * 0.5) * dt;
                player.vy -= Math.sin(player.angle) * (speed * 0.5) * dt;
            }
            const turnAcceleration = DESTRUCTOR_CONFIG.playerTurnAccel;
            const maxTurnSpeed = DESTRUCTOR_CONFIG.playerMaxTurn;

            if (keys['a']) {
                player.angVel -= turnAcceleration * dt;
            } else if (keys['d']) {
                player.angVel += turnAcceleration * dt;
            }

            player.vx *= 0.99;
            player.vy *= 0.99;
            player.angVel *= 0.92;

            if (Math.abs(player.angVel) > maxTurnSpeed) {
                player.angVel = Math.sign(player.angVel) * maxTurnSpeed;
            }

            dummy.vx *= 0.99;
            dummy.vy *= 0.99;
            dummy.angVel *= 0.95;

            const tDeform0 = performance.now();
            DestructorSystem.updateVisualDeformation(entities, dt);
            Perf.deformTime += performance.now() - tDeform0;

            const aliveEntities = [];
            for (const e of entities) {
                e.x += e.vx * dt;
                e.y += e.vy * dt;
                if (e.angVel) e.angle += e.angVel * dt;

                if (e.isProjectile && (e.dead || Math.hypot(e.x - player.x, e.y - player.y) > 5000)) {
                    continue;
                }
                aliveEntities.push(e);
            }
            if (aliveEntities.length !== entities.length) {
                entities.length = 0;
                entities.push(...aliveEntities);
            }

            if (mouse.right) {
                const mWorld = screenToWorld(mouse.x, mouse.y, camera);
                const dx = mWorld.x - player.x;
                const dy = mWorld.y - player.y;
                const len = Math.hypot(dx, dy);
                const ndx = dx / len;
                const ndy = dy / len;
                const beamLen = 3000;
                const p1 = { x: player.x, y: player.y };
                const p2 = { x: player.x + ndx * beamLen, y: player.y + ndy * beamLen };
                for (const target of entities) {
                    if (!target.hexGrid) continue;
                    DestructorSystem.cutByBeam(target, p1, p2, DESTRUCTOR_CONFIG.beamWidth);
                }
            }

            await DestructorSystem.update(dt, entities);

            Perf.physicsTime += performance.now() - t0;
        }

        function draw() {
            const tDraw0 = performance.now();

            // --- Camera tracking ---
            const midX = (player.x + dummy.x) / 2;
            const midY = (player.y + dummy.y) / 2;
            camera.x += (midX - camera.x) * 0.1;
            camera.y += (midY - camera.y) * 0.1;

            // --- Canvas 2D: clear (transparent â€” background is CSS/WebGL) ---
            ctx.clearRect(0, 0, width, height);

            const gw = 100 * camera.zoom;
            const offX = (width / 2 - camera.x * camera.zoom) % gw;
            const offY = (height / 2 - camera.y * camera.zoom) % gw;
            ctx.strokeStyle = 'rgba(30, 30, 30, 0.6)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = offX; x < width; x += gw) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
            for (let y = offY; y < height; y += gw) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
            ctx.stroke();

            // --- Canvas 2D: debris (still on Canvas for now) ---
            DestructorSystem.draw(ctx, camera);

            // --- THREE.JS: update + render all hex entities ---
            HexRenderer.update(entities);
            HexRenderer.render();

            // --- Canvas 2D overlays: laser beam ---
            if (mouse.right) {
                const mWorld = screenToWorld(mouse.x, mouse.y, camera);
                const dx = mWorld.x - player.x;
                const dy = mWorld.y - player.y;
                const len = Math.hypot(dx, dy);
                if (len > 0.01) {
                    const ndx = dx / len;
                    const ndy = dy / len;
                    const beamLen = 3000;
                    const p1 = { x: player.x, y: player.y };
                    const p2 = { x: player.x + ndx * beamLen, y: player.y + ndy * beamLen };
                    const s1 = worldToScreen(p1.x, p1.y, camera);
                    const s2 = worldToScreen(p2.x, p2.y, camera);
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(s1.x, s1.y);
                    ctx.lineTo(s2.x, s2.y);
                    ctx.lineWidth = 5 * camera.zoom;
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // --- Canvas 2D overlays: drag arrow ---
            if (mouse.down && mouse.dragStart && mouse.dragCurrent) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(mouse.dragStart.x, mouse.dragStart.y);
                ctx.lineTo(mouse.dragCurrent.x, mouse.dragCurrent.y);
                ctx.strokeStyle = '#ffff00';
                ctx.fillStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                const angle = Math.atan2(mouse.dragCurrent.y - mouse.dragStart.y, mouse.dragCurrent.x - mouse.dragStart.x);
                ctx.translate(mouse.dragCurrent.x, mouse.dragCurrent.y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, -5);
                ctx.lineTo(-10, 5);
                ctx.fill();
                ctx.restore();
            }

            Perf.drawTime += performance.now() - tDraw0;
        }

        let lastTime = 0;
        let isLooping = false;
        async function loop(timestamp) {
            if (isLooping) return;
            isLooping = true;
            requestAnimationFrame(loop); // schedule next frame before await

            const dt = Math.min((timestamp - lastTime) / 1000, 0.1) || 0.016;
            lastTime = timestamp;

            const frameStart = performance.now();
            Perf.startFrame();

            await updatePhysics(dt);
            draw();

            const frameEnd = performance.now();
            Perf.recordFrameTime(frameEnd - frameStart);
            Perf.flush(frameEnd);

            isLooping = false;
        }

        Perf.init();
        HexRenderer.init();
        init();
        document.getElementById('shipPicker').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                const img = new Image();
                img.onload = function () {
                    player.hexGrid = null;
                    const damagedImg = new Image();
                    damagedImg.src = DAMAGED_URL;
                    damagedImg.onload = () => {
                        initHexBody(player, img, damagedImg, false, DESTRUCTOR_CONFIG.playerStartingMass);
                        player.vx = 0;
                        player.vy = 0;
                        statusEl.textContent = "Wczytano nowy sprite: " + file.name;
                    };
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
    </script>
</body>

</html>