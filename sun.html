<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Realistyczne Słońce — Three.js</title>
    <style>
      html, body { height: 100%; }
      body { margin: 0; background: radial-gradient(ellipse at center, #0a0a0f 0%, #050509 60%, #000 100%); overflow: hidden; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
      #app { position: fixed; inset: 0; }
      .hint { position: fixed; left: 12px; bottom: 12px; color: #b7c0ff; opacity: .7; font-size: 12px; user-select: none; }
      .hint kbd { background: #1c1f3a; border: 1px solid #2a2e5a; padding: 2px 6px; border-radius: 6px; font-size: 11px; }
      .credit { position: fixed; right: 12px; bottom: 12px; color: #7c86b7; opacity:.7; font-size: 12px; }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <div class="hint">Przeciągnij myszką, <kbd>scroll</kbd> – zoom.</div>
    <div class="credit">Three.js + Bloom + szadery proceduralne</div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
      import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
      import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
      import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

      // --- Scena / kamera / renderer ---
      const app = document.getElementById('app');
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
      camera.position.set(0, 0.6, 6.5);

      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.1;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      app.appendChild(renderer.domElement);

      // --- Tło: gwiazdy ---
      function makeStars(count = 5000, radius = 120) {
        const g = new THREE.BufferGeometry();
        const pos = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
          // rozkład na sferze
          const u = Math.random();
          const v = Math.random();
          const theta = 2 * Math.PI * u;
          const phi = Math.acos(2 * v - 1);
          const r = radius * (0.75 + 0.25 * Math.random());
          pos[i*3+0] = r * Math.sin(phi) * Math.cos(theta);
          pos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
          pos[i*3+2] = r * Math.cos(phi);
        }
        g.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const m = new THREE.PointsMaterial({ size: 0.6, sizeAttenuation: true, transparent: true, opacity: 0.9 });
        const points = new THREE.Points(g, m);
        points.renderOrder = -1;
        return points;
      }
      scene.add(makeStars());

      // --- Parametry sterujące ---
      const params = {
        rotationSpeed: 0.004,
        granulationScale: 4.02,
        granulationSpeed: 0.99,
        spotStrength: 0.67,
        spotThreshold: 0.485,
        coronaIntensity: 1.83,
        coronaPower: 2.19,
        bloomStrength: 1.14,
        bloomRadius: 1.04,
        bloomThreshold: 0.0,
        prominences: true,
      };

      // --- Shadery: fotosfera (proceduralne ziarno, plamy + ściemnienie brzegowe) ---
      const photosphereVertex = /* glsl */`
        varying vec3 vNormalW;
        varying vec3 vWorldPos;
        varying vec3 vNormalO;
        void main() {
          vNormalO = normal;
          vec4 wp = modelMatrix * vec4(position, 1.0);
          vWorldPos = wp.xyz;
          vNormalW = normalize(mat3(modelMatrix) * normal);
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `;

      // Simplex noise 3D (Ashima)
      const simplexNoise3D = /* glsl */`
        vec3 mod289(vec3 x){ return x - floor(x * (1.0/289.0)) * 289.0; }
        vec4 mod289(vec4 x){ return x - floor(x * (1.0/289.0)) * 289.0; }
        vec4 permute(vec4 x){ return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r){ return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v){
          const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
          const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
          // First corner
          vec3 i  = floor(v + dot(v, C.yyy));
          vec3 x0 =   v - i + dot(i, C.xxx) ;
          // Other corners
          vec3 g = step(x0.yzx, x0.xyz);
          vec3 l = 1.0 - g;
          vec3 i1 = min( g.xyz, l.zxy );
          vec3 i2 = max( g.xyz, l.zxy );
          //  x0 = x0 - 0.0 + 0.0 * C
          vec3 x1 = x0 - i1 + 1.0 * C.xxx;
          vec3 x2 = x0 - i2 + 2.0 * C.xxx;
          vec3 x3 = x0 - 1.0 + 3.0 * C.xxx;
          // Permutations
          i = mod289(i);
          vec4 p = permute( permute( permute(
                     i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                   + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
          // Gradients: 7x7 points over a square, mapped onto an octahedron.
          float n_ = 0.142857142857; // 1.0/7.0
          vec3  ns = n_ * D.wyz - D.xzx;
          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  // mod(p,7*7)
          vec4 x_ = floor(j * ns.z);
          vec4 y_ = floor(j - 7.0 * x_ );
          vec4 x = x_ * ns.x + ns.yyyy;
          vec4 y = y_ * ns.x + ns.yyyy;
          vec4 h = 1.0 - abs(x) - abs(y);
          vec4 b0 = vec4( x.xy, y.xy );
          vec4 b1 = vec4( x.zw, y.zw );
          vec4 s0 = floor(b0)*2.0 + 1.0;
          vec4 s1 = floor(b1)*2.0 + 1.0;
          vec4 sh = -step(h, vec4(0.0));
          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
          vec3 p0 = vec3(a0.xy,h.x);
          vec3 p1 = vec3(a0.zw,h.y);
          vec3 p2 = vec3(a1.xy,h.z);
          vec3 p3 = vec3(a1.zw,h.w);
          //Normalise gradients
          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
          p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
          // Mix final noise value
          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
          m = m * m;
          return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }
        float fbm(vec3 p){
          float f=0.0; float a=0.5; for(int i=0;i<6;i++){ f += a * snoise(p); p *= 2.04; a *= 0.5; } return f;
        }
      `;

      const photosphereFragment = /* glsl */`
        uniform float uTime;
        uniform float uGranulationScale;   // skala ziarna
        uniform float uGranulationSpeed;   // prędkość konwekcji
        uniform float uSpotStrength;       // siła plam
        uniform float uSpotThreshold;      // próg plam
        uniform vec3  uColorA;             // głęboki oranż
        uniform vec3  uColorB;             // jasny żółty
        varying vec3 vNormalW;             // normal w przestrzeni świata
        varying vec3 vWorldPos;
        varying vec3 vNormalO;
        ${simplexNoise3D}
        void main(){
          // pozycja proceduralna (lokalna), delikatnie falująca w czasie
          // użyjemy normalizowanej pozycji na kuli, by zachować ciągłość
          vec3 p = normalize(vNormalO) * uGranulationScale;
          float t = uTime * uGranulationSpeed;
          // złożone ziarno: dwa fbm-y o różnych charakterach
          float g1 = fbm(p + vec3(0.0, 0.0, t*0.75));
          float g2 = fbm(p*1.8 + vec3(t*0.25, -t*0.2, t*0.15));
          float gran = 0.6*g1 + 0.4*g2; // 0..1 ziarno
          gran = clamp(gran*0.5 + 0.5, 0.0, 1.0);

          // plamy słoneczne: niskoczęstotliwościowy wzór
          float spotsBase = fbm(p*0.55 + vec3(-t*0.08, t*0.05, 0.0));
          float spotsMask = smoothstep(uSpotThreshold+0.05, uSpotThreshold-0.12, spotsBase);

          // odwzorowanie kolorów
          vec3 color = mix(uColorA, uColorB, smoothstep(0.25, 0.85, gran));

          // ciemne plamy (multiplikatywnie), z lekką otoczką
          float spotDarken = mix(1.0, 0.25, spotsMask * uSpotStrength);
          color *= spotDarken;

          // drobne jasne włókna (pojaśnienia)
          float filaments = fbm(p*3.5 + vec3(t*0.6, t*0.4, -t*0.3));
          color += 0.07 * smoothstep(0.6, 1.0, filaments);

          // ściemnienie brzegowe (limb darkening): silniejsze przy małym kącie widzenia
          vec3 viewDir = normalize(cameraPosition - vWorldPos);
          float ndv = clamp(dot(normalize(vNormalW), viewDir), 0.0, 1.0);
          float limb = pow(ndv, 0.55); // im mniejsze ndv, tym ciemniej przy krawędzi
          color *= mix(0.78, 1.0, limb);

          // emisja – bez klasycznego oświetlenia
          gl_FragColor = vec4(color, 1.0);
        }
      `;

      const sunUniforms = {
        uTime: { value: 0 },
        uGranulationScale: { value: params.granulationScale },
        uGranulationSpeed: { value: params.granulationSpeed },
        uSpotStrength: { value: params.spotStrength },
        uSpotThreshold: { value: params.spotThreshold },
        uColorA: { value: new THREE.Color('#ff6a00') }, // głęboki oranż
        uColorB: { value: new THREE.Color('#fff6c4') }, // jasna żółć
      };

      const sunMaterial = new THREE.ShaderMaterial({
        uniforms: sunUniforms,
        vertexShader: photosphereVertex,
        fragmentShader: photosphereFragment,
        transparent: false,
        depthWrite: true,
        blending: THREE.NormalBlending,
      });

      const sun = new THREE.Mesh(new THREE.SphereGeometry(1.0, 192, 128), sunMaterial);
      scene.add(sun);

      // --- Korona / poświata (Fresnel, addytywnie) ---
      const coronaVertex = /* glsl */`
        varying vec3 vNormalW;
        varying vec3 vWorldPos;
        void main(){
          vec4 wp = modelMatrix * vec4(position, 1.0);
          vWorldPos = wp.xyz;
          vNormalW = normalize(mat3(modelMatrix) * normal);
          gl_Position = projectionMatrix * viewMatrix * wp;
        }
      `;

      const coronaFragment = /* glsl */`
        uniform float uIntensity;
        uniform float uPower;
        uniform vec3  uColorInner;
        uniform vec3  uColorOuter;
        varying vec3 vNormalW;
        varying vec3 vWorldPos;
        void main(){
          vec3 V = normalize(cameraPosition - vWorldPos);
          float fres = pow(1.0 - clamp(dot(normalize(vNormalW), V), 0.0, 1.0), uPower);
          // łagodna mieszanka koloru: cieplej przy kuli, bielej na skraju
          vec3 col = mix(uColorInner, uColorOuter, smoothstep(0.0, 1.0, fres));
          float alpha = clamp(fres * uIntensity, 0.0, 1.0);
          gl_FragColor = vec4(col, alpha);
        }
      `;
      const coronaUniforms = {
        uIntensity: { value: params.coronaIntensity },
        uPower: { value: params.coronaPower },
        uColorInner: { value: new THREE.Color('#ffae34') },
        uColorOuter: { value: new THREE.Color('#fffbe6') },
      };
      const coronaMat = new THREE.ShaderMaterial({
        uniforms: coronaUniforms,
        vertexShader: coronaVertex,
        fragmentShader: coronaFragment,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false,
        side: THREE.FrontSide,
      });
      const corona = new THREE.Mesh(new THREE.SphereGeometry(1.18, 128, 96), coronaMat);
      scene.add(corona);

      // --- Protuberancje (delikatne pętle na brzegu) ---
      const protubGroup = new THREE.Group();
      function makeProtuberance(angle, lat, scale){
        const tor = new THREE.TorusGeometry(0.18*scale, 0.035*scale, 16, 64);
        const mat = new THREE.MeshBasicMaterial({ color: 0xff6f2e, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false });
        const m = new THREE.Mesh(tor, mat);
        const r = 1.02; // tuż nad powierzchnią
        const x = r * Math.cos(lat) * Math.cos(angle);
        const y = r * Math.sin(lat);
        const z = r * Math.cos(lat) * Math.sin(angle);
        m.position.set(x, y, z);
        m.lookAt(new THREE.Vector3(x, y, z).multiplyScalar(1.35)); // odchyl na zewnątrz
        protubGroup.add(m);
      }
      for (let i=0;i<10;i++) {
        makeProtuberance(Math.random()*Math.PI*2, (Math.random()*0.9-0.45)*Math.PI, 0.8 + Math.random()*0.6);
      }
      scene.add(protubGroup);

      // --- OrbitControls ---
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 2.2;
      controls.maxDistance = 15;

      // --- Postprocessing (Bloom) ---
      const composer = new EffectComposer(renderer);
      const renderPass = new RenderPass(scene, camera);
      composer.addPass(renderPass);
      const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), params.bloomStrength, params.bloomRadius, params.bloomThreshold);
      composer.addPass(bloom);

      // --- GUI ---
      const gui = new GUI({ title: 'Słońce — ustawienia' });
      const g1 = gui.addFolder('Fotosfera');
      g1.add(params, 'rotationSpeed', 0.0, 0.1, 0.001).name('Obrót');
      g1.add(params, 'granulationScale', 0.8, 5.0, 0.01).name('Skala ziarna').onChange(v => sunUniforms.uGranulationScale.value = v);
      g1.add(params, 'granulationSpeed', 0.0, 1.2, 0.01).name('Prędkość konwekcji').onChange(v => sunUniforms.uGranulationSpeed.value = v);
      g1.add(params, 'spotStrength', 0.0, 1.0, 0.01).name('Siła plam').onChange(v => sunUniforms.uSpotStrength.value = v);
      g1.add(params, 'spotThreshold', 0.2, 0.8, 0.005).name('Próg plam').onChange(v => sunUniforms.uSpotThreshold.value = v);
      g1.open();
      const g2 = gui.addFolder('Korona & Bloom');
      g2.add(params, 'coronaIntensity', 0.0, 2.0, 0.01).name('Intensywność korony').onChange(v => coronaUniforms.uIntensity.value = v);
      g2.add(params, 'coronaPower', 0.5, 4.0, 0.01).name('Siła Fresnela').onChange(v => coronaUniforms.uPower.value = v);
      g2.add(params, 'bloomStrength', 0.0, 2.0, 0.01).name('Bloom siła').onChange(v => bloom.strength = v);
      g2.add(params, 'bloomRadius', 0.0, 2.0, 0.01).name('Bloom promień').onChange(v => bloom.radius = v);
      g2.add(params, 'bloomThreshold', 0.0, 1.0, 0.001).name('Bloom próg').onChange(v => bloom.threshold = v);
      g2.open();
      gui.add(params, 'prominences').name('Protuberancje').onChange(v => protubGroup.visible = v);

      // --- Pętla animacji ---
      const clock = new THREE.Clock();
      function animate(){
        const t = clock.getElapsedTime();
        sunUniforms.uTime.value = t;
        // obrót widoczny, ale subtelny
        sun.rotation.y += params.rotationSpeed * 0.5;
        corona.rotation.y = sun.rotation.y;
        protubGroup.rotation.y = sun.rotation.y * 0.9;
        controls.update();
        composer.render();
        requestAnimationFrame(animate);
      }
      animate();

      // --- Resize ---
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
