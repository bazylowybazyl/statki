<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Space Survivors — gwiazdy na całej mapie + duży silnik plazmowy</title>
<style>
  html,body{height:100%;margin:0;background:#030417;color:#dfe7ff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  #ui{position:absolute;left:12px;top:12px;z-index:20;background:rgba(8,10,20,0.6);padding:10px;border-radius:8px;backdrop-filter:blur(6px)}
  canvas{display:block;width:100vw;height:100vh}
  .stat{font-family:monospace;font-size:13px}
  small{color:#a8b4d9}
  #loading{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#030417;z-index:50;color:#dfe7ff;font-size:32px;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
</style>
</head>
<body>
  <div id="ui">
    <div><strong>Space Survivors — gwiazdy na całej mapie + duży silnik plazmowy</strong></div>
    <div class="stat">Czas gry: <span id="game-time">00:00</span></div>
    <div class="stat">W — ciąg (duży silnik plazmowy) · Q/E — strafe · A/D — obrót</div>
    <div class="stat">LPM — rail (A→B, A→B) · PPM — boczne rakiety · F — superbroń · SHIFT — warp · SPACJA — dopalacz</div>
    <div style="margin-top:6px"><small>Gwiazdy są proceduralne w całej galaktyce. Silnik: niebieski exhaust + krótki ślad przy ruchu.</small></div>
  </div>
<canvas id="c"></canvas>
<div id="loading">Ładowanie...</div>
<script type="importmap">
{
  "imports": {
    "three": "./node_modules/three/build/three.module.js",
    "three/addons/": "./node_modules/three/examples/jsm/"
  }
}
</script>
<script type="module">
  import * as THREE from "three";
  import { EffectComposer }  from "three/addons/postprocessing/EffectComposer.js";
  import { RenderPass }      from "three/addons/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
  import { createShortNeedleExhaust, createWarpExhaustBlue } from "./Engineeffects.js";
  window.THREE = THREE;
  window.EffectComposer  = EffectComposer;
  window.RenderPass      = RenderPass;
  window.UnrealBloomPass = UnrealBloomPass;
  window.createShortNeedleExhaust = createShortNeedleExhaust;
  window.createWarpExhaustBlue = createWarpExhaustBlue;

</script>
<script src="planet3d.proc.js"></script>

<script>
// =============== Canvas & utils ===============
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth, H = canvas.height = innerHeight;
window.addEventListener('resize', ()=>{ W = canvas.width = innerWidth; H = canvas.height = innerHeight; initStars(true); });

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const add = (a,b)=>({x:a.x+b.x,y:a.y+b.y});
const mul = (v,s)=>({x:v.x*s,y:v.y*s});
const len = v=>Math.hypot(v.x,v.y);
const norm = v=>{ const L=len(v); return L?{x:v.x/L,y:v.y/L}:{x:0,y:0}; };
function rotate(local,a){ const c=Math.cos(a), s=Math.sin(a); return {x: local.x*c - local.y*s, y: local.x*s + local.y*c}; }
function rotateInv(world,a){ return rotate(world, -a); }

// =============== Game time (1 min real = 1 h game) ===============
const TIME_SCALE = 60; // game seconds per real second
let gameTime = 0; // seconds
const gameTimeEl = document.getElementById('game-time');
function formatGameTime(sec){
  const t = Math.floor(sec);
  const h = Math.floor(t / 3600) % 24;
  const m = Math.floor((t % 3600) / 60);
  return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
}
function wrapAngle(a){ while(a>Math.PI) a-=2*Math.PI; while(a<-Math.PI) a+=2*Math.PI; return a; }
function interpAngleShort(prev,curr,t){ const d = wrapAngle(curr - prev); return wrapAngle(prev + d * t); }
function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function leadTarget(shooter, shooterVel, target, speed){
  const tx = target.x, ty = target.y;
  const tvx = target.vx || 0, tvy = target.vy || 0;
  const rx = tx - shooter.x, ry = ty - shooter.y;
  const rvx = tvx - shooterVel.x, rvy = tvy - shooterVel.y;
  const a = rvx*rvx + rvy*rvy - speed*speed;
  const b = 2*(rx*rvx + ry*rvy);
  const c = rx*rx + ry*ry;
  let t = 0;
  if(Math.abs(a) < 1e-6){
    if(Math.abs(b) > 1e-6) t = -c / b;
  } else {
    const disc = b*b - 4*a*c;
    if(disc >= 0){
      const sqrtDisc = Math.sqrt(disc);
      const t1 = (-b - sqrtDisc)/(2*a);
      const t2 = (-b + sqrtDisc)/(2*a);
      t = Math.min(t1, t2);
      if(t < 0) t = Math.max(t1, t2);
    }
  }
  if(!isFinite(t) || t < 0) t = 0;
  return { x: tx + tvx*t, y: ty + tvy*t };
}

// =============== World / camera ===============
const WORLD = { w: 120000, h: 80000 };
const camera = {
  zoom: 1.0,
  defaultZoom: 1.0,
  altZoom: 0.7,
  minZoom: 0.35,
  maxZoom: 3.2,
  wheelSpeed: 0.002,
  shakeMag: 0,
  shakeTime: 0,
  shakeDur: 0,
  addShake(mag, dur){ this.shakeMag = mag; this.shakeTime = dur; this.shakeDur = dur; }
};

// =============== Ship ===============
const ship = {
  w:100, h:300, mass:140,
  pos:{x:WORLD.w/2, y:WORLD.h/2}, vel:{x:0,y:0},
  angle:0, angVel:0, inertia:null,
  linearDamping:0.9, angularDamping:1.6,
  engines:{},
  turret:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
           recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  turret2:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
            recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  turret3:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
            recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  turret4:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
            recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  shield:{ max:120, val:120, regenRate:6, regenDelay:2, regenTimer:0 },
  hull:{ max:1000, val:1000 },
  special:{ cooldown:10, cooldownTimer:0 }
};
ship.inertia = (1/12) * ship.mass * ((ship.w*ship.w)+(ship.h*ship.h));
(function configureShip(){
  const hw = ship.w/2, hh = ship.h/2;
  // Jeden DUŻY engine na środku rufy (moc ≈ suma poprzednich)
  ship.engines.main = { offset:{x:0, y: Math.round(hh-8)}, maxThrust: 12800 };

  ship.engines.sideLeft  =  { offset:{x:-Math.round(hw-8), y: 0}, maxThrust:3000 };
  ship.engines.sideRight =  { offset:{x: Math.round(hw-8), y: 0}, maxThrust:3000 };
  ship.engines.torqueLeft  =  { offset:{x:0,y:-Math.round(hh-8)}, maxThrust:3000 };
  ship.engines.torqueRight =  { offset:{x:0,y: Math.round(hh-8)}, maxThrust:3000 };

  ship.sideGunsLeft = []; ship.sideGunsRight = [];
  const gunsPer = 8, inset=6, margin=12;
  for(let i=0;i<gunsPer;i++){
    const t = gunsPer===1?0.5:(i/(gunsPer-1));
    const yLocal = -hh + margin + t * ((hh - margin) - (-hh + margin));
    ship.sideGunsLeft.push({ x: -Math.round(hw - inset), y: Math.round(yLocal) });
    ship.sideGunsRight.push({ x:  Math.round(hw - inset), y: Math.round(yLocal) });
  }
  const podW = 30, podH = 60;
  const podX = Math.round(hw + podW/2 - 6);
  const podY = Math.round(hh - podH/2 - 20);
  ship.pods = [
    { offset:{ x: -podX, y:  podY }, w: podW, h: podH },
    { offset:{ x:  podX, y:  podY }, w: podW, h: podH },
    { offset:{ x: -podX, y: -podY }, w: podW, h: podH },
    { offset:{ x:  podX, y: -podY }, w: podW, h: podH }
  ];
  ship.turret.offset  = { x: -podX, y:  podY };
  ship.turret2.offset = { x:  podX, y:  podY };
  ship.turret3.offset = { x: -podX, y: -podY };
  ship.turret4.offset = { x:  podX, y: -podY };

  const ciwsOff = 20;
  ship.ciws = [
    { offset:{ x:-ciwsOff, y:-ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x: ciwsOff, y:-ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x:-ciwsOff, y: ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x: ciwsOff, y: ciwsOff }, angle:0, angVel:0, cd:0 }
  ];
})();

// =============== Proceduralne gwiazdy na CAŁEJ MAPIE ===============
// Generujemy je "na żądanie" w kafelkach 1024×1024 z deterministycznym seedem.
// Dzięki temu gwiazdy są wszędzie, ale pamięć i CPU trzymamy w ryzach.
const STAR_CELL = 1024;
const starCells = new Map(); // key "ix,iy" -> {stars:[...] , lastSeen: frameId}
let frameId = 0;

function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
function key(ix,iy){ return ix+','+iy; }

function generateCell(ix,iy){
  const seed = ((ix*73856093) ^ (iy*19349663) ^ 0x9e3779b9) >>> 0;
  const rnd = mulberry32(seed);
  const count = 14 + Math.floor(rnd()*10); // 14–23 gwiazdy na komórkę
  const stars = [];
  for(let i=0;i<count;i++){
    const x = ix*STAR_CELL + rnd()*STAR_CELL;
    const y = iy*STAR_CELL + rnd()*STAR_CELL;
    const size = 0.7 + rnd()*2.1;
    const bright = 0.35 + rnd()*0.65;
    stars.push({x,y,size,bright});
  }
  const obj = { stars, lastSeen: frameId };
  starCells.set(key(ix,iy), obj);
  return obj;
}
function getCell(ix,iy){
  const k = key(ix,iy);
  let c = starCells.get(k);
  if(!c) c = generateCell(ix,iy);
  c.lastSeen = frameId;
  return c;
}
function pruneStarCells(){
  // Trzymajmy ~ 600 ostatnio widzianych komórek (wystarczy z zapasem)
  if(starCells.size <= 600) return;
  // Proste LRU: wyrzucamy najstarsze
  const arr = [...starCells.entries()];
  arr.sort((a,b)=>a[1].lastSeen - b[1].lastSeen);
  const toDrop = arr.slice(0, Math.max(0, arr.length - 600));
  for(const [k] of toDrop) starCells.delete(k);
}
function initStars(reset=false){
  if(reset){ starCells.clear(); }
}

// =============== Słońce, planety i stacje ===============
const SUN = { x: WORLD.w/2, y: WORLD.h/2, r: 200 };

const PLANET_TYPES = {
  TERRAN: 'terran',
  VOLCANIC: 'volcanic',
  FROZEN: 'frozen',
  GAS: 'gas',
  BARREN: 'barren'
};

const PLANET_DATA = (() => {
  const NUM_PLANETS = 7;
  const TYPES = [
    PLANET_TYPES.VOLCANIC,
    PLANET_TYPES.VOLCANIC,
    PLANET_TYPES.TERRAN,
    PLANET_TYPES.TERRAN,
    PLANET_TYPES.BARREN,
    PLANET_TYPES.GAS,
    PLANET_TYPES.FROZEN
  ];
  const BASE_ORBIT = 7000; // stała odległość między orbitami
  const list = [];
  for (let i = 0; i < NUM_PLANETS; i++) {
    const orbitRadius = BASE_ORBIT * (i + 1);
    const angle = Math.random() * Math.PI * 2;
    const au = i + 1; // jednostka do skalowania prędkości orbitalnej
    // Orbital period scaled so that a planet at 1 AU orbits in 365 days
    const periodHours = 24 * 365 * Math.pow(au, 1.5); // Kepler scaling
    const speed = (2 * Math.PI) / (periodHours * 3600); // rad per game second
    const r = (48 + Math.floor(Math.random() * 36)) * 3; // powiększone ~3×
    list.push({ id: i, orbitRadius, angle, speed, r, type: TYPES[i], x: 0, y: 0 });
  }
  return list;
})();

let planets = PLANET_DATA.map(p => {
  p.x = SUN.x + Math.cos(p.angle) * p.orbitRadius;
  p.y = SUN.y + Math.sin(p.angle) * p.orbitRadius;
  return p;
});

let stations = planets.map(pl => {
  const orbitRadius = pl.r + 300;
  const angle = Math.random() * Math.PI * 2;
  const periodHours = 12; // stacja okrąża planetę w 12h
  const speed = (2 * Math.PI) / (periodHours * 3600);
  const x = pl.x + Math.cos(angle) * orbitRadius;
  const y = pl.y + Math.sin(angle) * orbitRadius;
  return { id: pl.id, planet: pl, orbitRadius, angle, speed, r: 40, x, y };
});

// oznacz stacje wewnątrz pasa asteroid
(() => {
  if (planets[3] && planets[4]) {
    const beltRadius = (planets[3].orbitRadius + planets[4].orbitRadius) / 2;
    for (const st of stations) st.inner = st.orbitRadius < beltRadius;
  } else {
    for (const st of stations) st.inner = true;
  }
})();

// Warp routes between stations
let warpRoutes = {};
function initWarpRoutes(){
  warpRoutes = {};
  for(const from of stations){
    if(!from.inner) continue;
    for(const to of stations){
      if(!to.inner || from.id === to.id) continue;
      const sx = from.x + (to.x - from.x) * 0.2;
      const sy = from.y + (to.y - from.y) * 0.2;
      const ex = from.x + (to.x - from.x) * 0.8;
      const ey = from.y + (to.y - from.y) * 0.8;
      const dx = ex - sx;
      const dy = ey - sy;
      const dist = Math.hypot(dx, dy) || 1;
      warpRoutes[from.id + '-' + to.id] = {
        from: from.id,
        to: to.id,
        start: { x: sx, y: sy, queues: [[], []] },
        end: { x: ex, y: ey },
        dir: { x: dx / dist, y: dy / dist },
        length: dist
      };
    }
  }
}
function getWarpRoute(fromId, toId){ return warpRoutes[fromId + '-' + toId]; }
initWarpRoutes();

let npcs = [];
function pickNextStation(npcId, lastStationId){
  const inner = stations.filter(s=>s.inner);
  let idx = Math.floor(Math.random()*inner.length);
  if(inner.length>1 && inner[idx].id === lastStationId) idx = (idx+1)%inner.length;
  return inner[idx].id;
}
const NPC_TYPES = {
  'freighter-small':  { radius:10, speed:60, hp:100, color:'#8ab4d6', weapon:null },
  'freighter-medium': { radius:15, speed:55, hp:150, color:'#769cb8', weapon:null },
  'freighter-large':  { radius:25, speed:50, hp:200, color:'#5d829c', weapon:null },
  'freighter-capital':{ radius:48, speed:45, hp:400, color:'#45667d', weapon:null },
  'police':           { radius:24, speed:100, hp:200, color:'#44aaff', weapon:'railgun' },
  'civilian-small':   { radius:6, speed:100, hp:10, color:'#cccccc', weapon:null },
  'civilian-large':   { radius:12, speed:80, hp:50, color:'#bbbbbb', weapon:null },
  'guard':            { radius:20, speed:95, hp:100, color:'#ff9933', weapon:'gun' },
  'mercenary':        { radius:25, speed:95, hp:100, color:'#ff6633', weapon:'gun' }
};
function initNPCs(){
  npcs = [];
  let npcId = 0, groupCounter = 0;
  const desiredCount = 1000;
  const ESCORT_RADIUS = 80;
  function spawnNPC(type, start, targetId, group){
    if(npcs.length >= desiredCount) return null;
    const cfg = NPC_TYPES[type];
    const x = start.x + (Math.random()-0.5)*40;
    const y = start.y + (Math.random()-0.5)*40;
    const route = getWarpRoute(start.id, targetId);
    const npc = { id:npcId++, type, group,
      x, y,
      vx:0, vy:0, angle:Math.random()*Math.PI*2,
      target: targetId, speed:cfg.speed, radius:cfg.radius,
      hp:cfg.hp, maxHp:cfg.hp, color:cfg.color, weapon:cfg.weapon,
      dead:false, respawnTimer:0, fade:1, docking:false, lastStation:start.id,
      leader:null, orbitAngle:0, orbitRadius:0,
      warpRoute: route, phase: 'toGate', lane: Math.floor(Math.random()*2) };
    npcs.push(npc);
    return npc;
  }
  function spawnFreighterEscortGroup(fType, escortMin, escortMax){
    const inner = stations.filter(s=>s.inner);
    const start = inner[Math.floor(Math.random()*inner.length)];
    const targetId = pickNextStation(npcId, start.id);
    const group = groupCounter++;
    const leader = spawnNPC(fType, start, targetId, group);
    if(!leader) return;
    const escortCount = escortMin + Math.floor(Math.random()*(escortMax-escortMin+1));
    for(let i=0;i<escortCount;i++){
      const eType = Math.random()<0.5?'guard':'mercenary';
      const angle = (i / escortCount) * Math.PI * 2;
      const escort = spawnNPC(eType, start, targetId, group);
      if(!escort) continue;
      escort.leader = leader.id;
      escort.orbitAngle = angle;
      escort.orbitRadius = leader.radius + ESCORT_RADIUS;
      escort.x = leader.x + Math.cos(angle) * escort.orbitRadius;
      escort.y = leader.y + Math.sin(angle) * escort.orbitRadius;
    }
  }
  function spawnCivilianGroup(min, max){
    const inner = stations.filter(s=>s.inner);
    const start = inner[Math.floor(Math.random()*inner.length)];
    const targetId = pickNextStation(npcId, start.id);
    const group = groupCounter++;
    spawnNPC('freighter-small', start, targetId, group);
    const count = min + Math.floor(Math.random()*(max-min+1));
    for(let i=0;i<count;i++){
      const type = Math.random()<0.5?'civilian-small':'civilian-large';
      spawnNPC(type, start, targetId, group);
    }
  }
  function spawnPolicePatrol(min, max){
    const inner = stations.filter(s=>s.inner);
    const start = inner[Math.floor(Math.random()*inner.length)];
    const targetId = pickNextStation(npcId, start.id);
    const group = groupCounter++;
    const count = min + Math.floor(Math.random()*(max-min+1));
    for(let i=0;i<count;i++) spawnNPC('police', start, targetId, group);
  }
  while(npcs.length < desiredCount){
    spawnFreighterEscortGroup('freighter-small',0,0);
    spawnFreighterEscortGroup('freighter-medium',0,0);
    spawnFreighterEscortGroup('freighter-large',0,0);
    spawnFreighterEscortGroup('freighter-capital',0,0);
    spawnCivilianGroup(1,2);
    spawnCivilianGroup(1,2);
    spawnPolicePatrol(1,2);
  }
}
// Ensure Three.js modules are loaded before initializing 3D objects
window.addEventListener('DOMContentLoaded', () => {
  initPlanets3D(planets, SUN);
});

// =============== Bullets & effects ===============
const bullets = [];
const particles = [];
const shockwaves = [];
const MAX_PARTICLES = 8000;          // twardy sufit (dobry balans)
const MAX_PARTICLES_DRAW = 4500;     // ile maks. rysujemy na ekranie

function pushParticleSafe(p){
  if (particles.length < MAX_PARTICLES) particles.push(p);
}

function spawnParticle(pos, vel, life, color, size, flash){
  pushParticleSafe({
    pos:{...pos}, vel:{...vel}, life, age:0,
    color: color||'#ffb677', size: size||2, flash: !!flash
  });
}
function spawnExplosionPlasma(x,y,scale=1){
  const count = Math.round(22 * scale);
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 120 + Math.random()*260 * scale;
    spawnParticle({x,y}, {x:Math.cos(a)*s, y:Math.sin(a)*s}, 0.45 + Math.random()*0.5, '#7CFF7C', 2 + Math.random()*3, true);
  }
}
function spawnRailHitEffect(x,y,scale=1){
  for(let i=0;i<12 * scale;i++){
    const a = Math.random()*Math.PI*2;
    const s = 80 + Math.random()*220 * scale;
    spawnParticle({x,y}, {x:Math.cos(a)*s, y:Math.sin(a)*s}, 0.25 + Math.random()*0.35, '#bfe7ff', 1 + Math.random()*2, true);
  }
  spawnParticle({x,y}, {x:0,y:0}, 0.12, '#ffffff', 6 * scale, true);
}
function spawnDefaultHit(x,y,scale=1){
  for(let i=0;i<14*scale;i++){
    const a = Math.random()*Math.PI*2;
    const s = 80 + Math.random()*160 * scale;
    spawnParticle({x,y}, {x:Math.cos(a)*s, y:Math.sin(a)*s}, 0.24 + Math.random()*0.36, '#ffb36b', 1 + Math.random()*2, true);
  }
  spawnParticle({x,y}, {x:0,y:0}, 0.08, '#ffffff', 4 * scale, true);
}

function spawnShockwave(x, y, opts = {}){
  shockwaves.push({
    x, y,
    r: opts.r || 20,
    maxR: opts.maxR || 800,
    w: opts.w || 8,
    life: 0,
    maxLife: opts.maxLife || 0.6,
    color: opts.color || 'rgba(180,200,255,'
  });
}

// =============== Station UI ===============
const STATIONS = stations; // istniejące lub generowane
let stationUI = { open:false, tab:'upgrades', station:null, cursorOver:false, hoverId:null };

const OPTIONS = {
  vfx: { colorTempK: 8000, bloomGain: 1.1 },
  audio: { master: 0.8, sfx: 1.0, music: 0.7 },
  controls: { mouseSensitivity: 1.0 } // bez odwracania osi
};

function stationUnderCursor(){
  const world = screenToWorld(mouse.x, mouse.y);
  for(const s of STATIONS){
    const d = Math.hypot(world.x - s.x, world.y - s.y);
    if(d < (s.r||120)) return s;
  }
  return null;
}

window.addEventListener('keydown', (e)=>{
  if(e.code==='Enter' && !stationUI.open){
    const s = stationUnderCursor();
    if(s){ stationUI.open = true; stationUI.station = s; stationUI.tab='upgrades'; e.preventDefault(); }
  }
  if(stationUI.open){
    if(e.code==='Escape'){ stationUI.open=false; stationUI.station=null; }
    if(e.code==='Digit1') stationUI.tab='upgrades';
    if(e.code==='Digit2') stationUI.tab='trade';
    if(e.code==='Digit3') stationUI.tab='cantina';
    if(e.code==='Digit4') stationUI.tab='hangar';
  }
});

function renderStationUI(){
  if(!stationUI.open) return;
  hudBeginPanel();
  hudTabs(['upgrades','trade','cantina','hangar'], stationUI.tab);
  if(stationUI.tab==='upgrades') renderUpgradesTab();
  if(stationUI.tab==='trade')    renderTradeTab();
  if(stationUI.tab==='cantina')  renderCantinaTab();
  if(stationUI.tab==='hangar')   renderHangarTab();
  hudEndPanel();
}

// --- Zakładki ---
const PLAYER = { credits: 1200, cargo: {}, shipId: 'starter', hull: 0.86 };
const BLUEPRINTS = {
  upgrades: [
    { id:'rail_cooler', name:'Chłodzenie raila', cost:600, apply(){ rail.heatCap *= 1.25; rail.coolRate *= 1.15; } },
    { id:'boost_core',  name:'Wzmocniony boost', cost:700, apply(){ boost.speed *= 1.15; boost.duration *= 1.1; } },
    { id:'agility',     name:'Zwrotność +',      cost:500, apply(){ ship.turnRate = (ship.turnRate||1)*1.12; } },
  ],
  ships: [
    { id:'scout', name:'Scout', cost:2500, stats:{ hp:0.8, speed:1.3, cargo:0.6 } },
    { id:'frigate', name:'Fregata', cost:4200, stats:{ hp:1.6, speed:0.85, cargo:1.4 } },
  ],
};

function renderUpgradesTab(){
  uiTitle('Ulepszenia statku');
  for(const u of BLUEPRINTS.upgrades){
    if(uiRowButton(`${u.name} — ${u.cost} cr`, 'Kup')){
      if(PLAYER.credits>=u.cost){ PLAYER.credits-=u.cost; u.apply(); toast('Zainstalowano: '+u.name); }
      else toast('Za mało kredytów');
    }
  }
}
const MARKET = { // ceny przykładowe
  buy:{ ruda: 22, paliwo: 15, żywność: 8 },
  sell:{ ruda: 18, paliwo: 12, żywność: 6 }
};
function renderTradeTab(){
  uiTitle('Handel towarami');
  for(const [k,price] of Object.entries(MARKET.buy)){
    if(uiRowButton(`${k} — kup: ${price} cr`, 'Kup')){
      if(PLAYER.credits>=price){ PLAYER.credits-=price; PLAYER.cargo[k]=(PLAYER.cargo[k]||0)+1; }
    }
  }
  for(const [k,price] of Object.entries(MARKET.sell)){
    if(uiRowButton(`${k} — sprzedaj: ${price} cr`, 'Sprzedaj')){
      if((PLAYER.cargo[k]||0)>0){ PLAYER.cargo[k]-=1; PLAYER.credits+=price; }
    }
  }
}
function renderCantinaTab(){
  uiTitle('Kantyna');
  section('Misje najemnik');
  if(uiRowButton('Zlikwiduj cel (BOSS Interceptor)', 'Przyjmij')){
    startAssassinationMission();
  }
  section('Misje żołnierz');
  if(uiRowButton('Wojna o terytorium (punkt kontrolny)', 'Dołącz')){
    startTerritoryWarMission();
  }
}
function renderHangarTab(){
  uiTitle('Hangar');
  if(uiRowButton(`Napraw kadłub (${Math.ceil((1-PLAYER.hull)*100)}% uszk.)`, 'Napraw')){
    const cost = Math.ceil((1-PLAYER.hull)*600);
    if(PLAYER.credits>=cost){ PLAYER.credits-=cost; PLAYER.hull=1.0; toast('Naprawiono kadłub.'); } else toast('Za mało kredytów');
  }
  section('Nowe statki');
  for(const s of BLUEPRINTS.ships){
    if(uiRowButton(`${s.name} — ${s.cost} cr`, 'Kup')){
      if(PLAYER.credits>=s.cost){ PLAYER.credits-=s.cost; PLAYER.shipId=s.id; applyShipStats(s.stats); toast('Zakupiono: '+s.name); }
      else toast('Za mało kredytów');
    }
  }
}
function startAssassinationMission(){ toast('Misja najemnik rozpoczęta'); }
function startTerritoryWarMission(){ toast('Dołączono do wojny terytorialnej'); }

function spawnLaserBeam(start, end, width){
  pushParticleSafe({ beam:true, start:{...start}, end:{...end}, width, age:0, life:0.12 });
}

// =============== Input ===============
const input = { main:0, leftSide:0, rightSide:0, torque:0 };
const keys = {};
let showMap = false;
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  const k = e.key.toLowerCase();
  keys[k] = true;
  if(k === 'm') showMap = !showMap;
  if(e.key === ' '){
    if(boost.state==='idle' && boost.fuel>=boost.cost){ boost.state='charging'; boost.charge=0; }
  }
  if(k === 'x') triggerScanWave();
  if(k === 'r'){
    if(highlightedEnemies.length){
      lockedTargets = highlightedEnemies.filter(n=>!n.dead)
        .sort((a,b)=>Math.hypot(a.x-ship.pos.x,a.y-ship.pos.y) - Math.hypot(b.x-ship.pos.x,b.y-ship.pos.y));
      highlightTimer = 0;
      highlightedEnemies = [];
    } else {
      lockedTarget = scan.scanned || null;
    }
  }
  updateInput();
});
window.addEventListener('keyup', e=>{
  const k = e.key.toLowerCase();
  keys[k] = false;
  if(e.key === ' ' && boost.state==='charging'){ boost.state='idle'; boost.charge=0; }
  updateInput();
});
function updateInput(){
  input.main = keys['w']?1:0;
  input.leftSide  = keys['q']?1:0;
  input.rightSide = keys['e']?1:0;
  let torque = 0; if(keys['a']) torque -= 1; if(keys['d']) torque += 1; input.torque = torque;
  if(keys['f']) tryFireSpecial();
}

// targeting / scanning
const SCAN_TIME = 1.0;
const SCAN_RANGE = 10000;
const SCAN_VFX_SPEED = 4000;
const SCAN_ARROW_LIFE = 1.5;
const scan = { target:null, progress:0, scanned:null };
let lockedTarget = null;
let lockedTargets = [];
let highlightedEnemies = [];
let highlightTimer = 0;
const HIGHLIGHT_TIME = 3;
const HIGHLIGHT_RANGE = 2000;
const radarPings = [];
const scanWaves = [];
const scanArrows = [];
function spawnRadarPing(x,y){ radarPings.push({x,y,age:0,life:1}); }
function triggerScanWave(){
  const wave = {x:ship.pos.x,y:ship.pos.y,r:0,speed:SCAN_VFX_SPEED,max:SCAN_RANGE,hit:new Set()};
  scanWaves.push(wave);
  scanArrows.length = 0;
 // Merge of branches:
  // 1) codex/add-various-npc-types-and-groups → prefer enemies that have weapons
  // 2) main → only highlight those within HIGHLIGHT_RANGE
  const inRange = (n) => Math.hypot(n.x - ship.pos.x, n.y - ship.pos.y) <= HIGHLIGHT_RANGE;
  const armed = npcs.filter(n => !n.dead && n.weapon && inRange(n));
  highlightedEnemies = armed.length ? armed : npcs.filter(n => !n.dead && inRange(n));
  highlightTimer = HIGHLIGHT_TIME;
  for(const st of stations){
    const dist = Math.hypot(st.x - ship.pos.x, st.y - ship.pos.y);
    spawnRadarPing(st.x, st.y);
    if(dist <= SCAN_RANGE){
      scanArrows.push({target:st,age:0,life:SCAN_ARROW_LIFE});
      wave.hit.add(st);
    }
  }
}

const mouse = { x: W/2, y: H/2, left:false, right:false, click:false };
canvas.addEventListener('mousemove', e=>{ mouse.x = e.clientX; mouse.y = e.clientY; });
canvas.addEventListener('mousedown', e=>{
  if(e.button===0){
    mouse.left=true; mouse.click=true;
    if(!stationUI.open && !warp.isBusy()) triggerRailVolley();
  }
  if(e.button===2){ e.preventDefault(); mouse.right=true;
    if(!stationUI.open && !warp.isBusy()){
      const mouseWorld = { x: ship.pos.x + (mouse.x - W/2)/camera.zoom, y: ship.pos.y + (mouse.y - H/2)/camera.zoom };
      const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
      const side = (local.x >= 0) ? 'right' : 'left';
      fireRocket(side);
      rocketCooldown = ROCKET_FIRE_INTERVAL;
    }
  }
  if(e.button===1){ e.preventDefault(); camera.zoom = Math.abs(camera.zoom - camera.defaultZoom) < 0.03 ? camera.altZoom : camera.defaultZoom; }
});
canvas.addEventListener('mouseup', e=>{ if(e.button===0) mouse.left=false; if(e.button===2) mouse.right=false; });
canvas.addEventListener('contextmenu', e=>e.preventDefault());
canvas.addEventListener('wheel', e=>{ e.preventDefault(); const f = 1 - e.deltaY * camera.wheelSpeed; camera.zoom *= f; camera.zoom = clamp(camera.zoom, camera.minZoom, camera.maxZoom); }, {passive:false});

// =============== Side rockets ===============
const ROCKET_FIRE_INTERVAL = 0.11;
const ROCKET_AMMO_MAX = 100;
let rocketAmmo = ROCKET_AMMO_MAX;
let rocketCooldown = 0;
let nextRocketIndexLeft = 0, nextRocketIndexRight = 0;
const SIDE_BULLET_SPEED = 760, SIDE_BULLET_DAMAGE = 20;
const SIDE_PLASMA_EXPLODE_RADIUS = 48;
const SIDE_ROCKET_TURN_RATE = 6;
const SIDE_ROCKET_HOMING_DELAY = 0.25;
const SPECIAL_COOLDOWN = 10; ship.special.cooldownTimer = 0;

function fireRocket(side){
  if(rocketAmmo <= 0) return;
  const guns = side === 'left' ? ship.sideGunsLeft : ship.sideGunsRight;
  const idx = side === 'left' ? nextRocketIndexLeft : nextRocketIndexRight;
  const gunOff = guns[idx % guns.length];
  const target = (lockedTarget && !lockedTarget.dead) ? lockedTarget : null;
  fireSideGunAtOffset(gunOff, side, target);
  if(side === 'left') nextRocketIndexLeft = (idx + 1) % guns.length;
  else nextRocketIndexRight = (idx + 1) % guns.length;
  rocketAmmo--;
}

function fireSideGunAtOffset(gunOff, side, target=null){
  const gunWorld = add(ship.pos, rotate(gunOff, ship.angle));
  const dl = side === 'left' ? -1 : 1;
  const dir = rotate({x:dl, y:0}, ship.angle);
  bullets.push({ x: gunWorld.x, y: gunWorld.y, px: gunWorld.x, py: gunWorld.y,
    vx: dir.x*SIDE_BULLET_SPEED + ship.vel.x, vy: dir.y*SIDE_BULLET_SPEED + ship.vel.y,
    life:2.4, r:5, owner:'player', damage:SIDE_BULLET_DAMAGE, penetration:0, type:'rocket',
    explodeRadius: SIDE_PLASMA_EXPLODE_RADIUS, homingDelay: SIDE_ROCKET_HOMING_DELAY, target });
  spawnParticle({x:gunWorld.x, y:gunWorld.y}, {x:dir.x*120 + ship.vel.x*0.1, y:dir.y*120 + ship.vel.y*0.1}, 0.14, '#b4ffb4', 3.2, true);
  for(let k=0;k<6;k++){
    const aa = Math.atan2(dir.y, dir.x) + (Math.random()-0.5)*0.9;
    spawnParticle({x:gunWorld.x + Math.cos(aa)*6, y:gunWorld.y + Math.sin(aa)*6}, {x:Math.cos(aa)*160, y:Math.sin(aa)*160}, 0.14 + Math.random()*0.06, '#a8ff9a', 1.1, true);
  }
}

// =============== Rail (2 lufy: serie A→B, A→B) ===============
const rail = { cd:[0,0], cdMax:0.38, shotGap:0.07, burstGap:0.18, burstsPerClick:2, queue:[], nextStart:0 };
let railTimer = 0;
const RAIL_SPEED = 2600, RAIL_PEN = 3, RAIL_DAMAGE = 60;

function triggerRailVolley(){
  if(rail.queue.length) return;
  const start = rail.nextStart; rail.nextStart ^= 1;
  const orderPair = [start, 1-start];
  for(let b=0;b<rail.burstsPerClick;b++){
    const base = b*(rail.shotGap*2 + rail.burstGap);
    rail.queue.push({ timer: base + 0*rail.shotGap, barrel: orderPair[0] });
    rail.queue.push({ timer: base + 1*rail.shotGap, barrel: orderPair[1] });
  }
}
function fireRailBarrel(barIndex){
  const forwardLen = Math.min(ship.h*0.36, 46);
  const gap = 10;
  const sign = (barIndex===0) ? -1 : +1;
  const turrets = [ship.turret, ship.turret2, ship.turret3, ship.turret4];
  for(const t of turrets){
    const a = t.angle;
    const f = {x:Math.cos(a), y:Math.sin(a)};
    const p = {x:-Math.sin(a), y:Math.cos(a)};
    const off = rotate(t.offset, ship.angle);
    const px = ship.pos.x + off.x + f.x * forwardLen + p.x * (sign * gap/2);
    const py = ship.pos.y + off.y + f.y * forwardLen + p.y * (sign * gap/2);
    bullets.push({ x:px, y:py, vx: f.x*RAIL_SPEED + ship.vel.x, vy: f.y*RAIL_SPEED + ship.vel.y, life: 2.0, r:4, owner:'player', damage:RAIL_DAMAGE, penetration:RAIL_PEN, type:'rail' });
    t.recoil = Math.min(t.recoil + t.recoilKick, t.recoilMax);
    spawnParticle({x:px, y:py}, {x:0,y:0}, 0.10, '#bfe7ff', 6, true);
    for(let i=0;i<5;i++){
      const aa = a + (Math.random()-0.5)*0.14;
      spawnParticle({x:px + Math.cos(aa)*6, y:py + Math.sin(aa)*6},{x:Math.cos(aa)*220 + ship.vel.x*0.2, y:Math.sin(aa)*220 + ship.vel.y*0.2},0.12,'#bfe7ff',1.6,true);
    }
}
  rail.cd[barIndex] = rail.cdMax;
}

// =============== CIWS (point-defence) ===============
const CIWS_FIRE_INTERVAL = 0.06;
const CIWS_BULLET_SPEED = 900;
const CIWS_DAMAGE = 8;
const CIWS_RANGE = 600;

function ciwsStep(dt){
  for(const gun of ship.ciws){
    gun.cd = Math.max(0, gun.cd - dt);
    const off = rotate(gun.offset, ship.angle);
    const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
    const baseVel = { x: ship.vel.x - ship.angVel * off.y, y: ship.vel.y + ship.angVel * off.x };
    let target = null; let dist = CIWS_RANGE;
    for(const npc of npcs){
      if(npc.dead) continue;
      const d = Math.hypot(npc.x - base.x, npc.y - base.y);
      if(d < dist){ dist = d; target = npc; }
    }
    if(target){
      const aim = leadTarget(base, baseVel, target, CIWS_BULLET_SPEED);
      const desired = Math.atan2(aim.y - base.y, aim.x - base.x);
      let diff = wrapAngle(desired - gun.angle);
      let desiredVel = clamp(diff * 8, -6, 6);
      const velDelta = desiredVel - gun.angVel;
      const maxDelta = 40 * dt;
      gun.angVel += clamp(velDelta, -maxDelta, maxDelta);
      gun.angVel *= Math.exp(-8 * dt);
      gun.angVel = clamp(gun.angVel, -6, 6);
      gun.angle = wrapAngle(gun.angle + gun.angVel * dt);
      if(Math.abs(diff) < 0.15 && gun.cd === 0){
        const dir = { x: Math.cos(gun.angle), y: Math.sin(gun.angle) };
        const px = base.x + dir.x * 6;
        const py = base.y + dir.y * 6;
        bullets.push({ x:px, y:py, vx: dir.x*CIWS_BULLET_SPEED + baseVel.x, vy: dir.y*CIWS_BULLET_SPEED + baseVel.y, life:1.2, r:2, owner:'player', damage:CIWS_DAMAGE, type:'ciws' });
        spawnParticle({x:px, y:py}, {x:dir.x*120 + baseVel.x*0.1, y:dir.y*120 + baseVel.y*0.1}, 0.06, '#ffdf9e', 2.0, true);
        gun.cd = CIWS_FIRE_INTERVAL;
      }
    }
  }
}

// =============== Specjal & dmg ===============
function tryFireSpecial(){
  if(ship.special.cooldownTimer>0) return;
  ship.special.cooldownTimer = SPECIAL_COOLDOWN;
  const dir = rotate({x:0,y:-1}, ship.angle);
  const start = add(ship.pos, rotate({x:0, y:-ship.h/2}, ship.angle));
  const length = 2000;
  const end = { x: start.x + dir.x*length, y: start.y + dir.y*length };
  const width = ship.w;
  const npcsInRange = npcs.filter(npc => !npc.dead && Math.hypot(npc.x - start.x, npc.y - start.y) < length + npc.radius);
  let hits = 0;
  const HIT_CAP = 80; // wystarczająco dużo, by czuć „miotłę”, ale bez zgonu CPU
  for (const npc of npcsInRange){
    if (hits >= HIT_CAP) break;
    const vx = npc.x - start.x, vy = npc.y - start.y;
    const proj = vx*dir.x + vy*dir.y;
    if (proj < 0 || proj > length) continue;
    const perp = Math.abs(vx*dir.y - vy*dir.x);
    if (perp <= npc.radius + width*0.5){
      applyDamageToNPC(npc, 80, 'none');
      if ((hits & 1) === 0) spawnParticle({x:npc.x, y:npc.y}, {x:0,y:0}, 0.10, '#9ccfff', 5, true);
      hits++;
    }
  }
  spawnLaserBeam(start, end, width);
  for(let i=0;i<8;i++){
    const t = i/7;
    const px = start.x + dir.x*length*t + (Math.random()-0.5)*width*0.3;
    const py = start.y + dir.y*length*t + (Math.random()-0.5)*width*0.3;
    spawnParticle({x:px, y:py}, {x:(Math.random()-0.5)*120, y:(Math.random()-0.5)*120}, 0.2, '#9ccfff', 2.5, true);
  }
}
function applyDamageToPlayer(amount){
  if(ship.shield.val>0){ const s = Math.min(ship.shield.val, amount); ship.shield.val -= s; amount -= s; ship.shield.regenTimer = ship.shield.regenDelay; }
  if(amount>0) ship.hull.val = Math.max(0, ship.hull.val - amount);
}
function applyDamageToNPC(npc, dmg, cause='default'){
  if(npc.dead) return;
  npc.hp -= dmg;
  if(npc.hp<=0){
    npc.dead = true; npc.respawnTimer = 3 + Math.random()*6;
    if(cause === 'plasma'){ spawnExplosionPlasma(npc.x, npc.y, 1.2); }
    else if(cause === 'default'){ spawnDefaultHit(npc.x, npc.y, 1.2); }
  }
}

// =============== Collisions & particles ===============
function bulletsAndCollisionsStep(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.px = b.x; b.py = b.y;
    b.x += b.vx * dt; b.y += b.vy * dt;
    b.life -= dt;

    if(b.type === 'plasma' || b.type === 'rocket'){
      const trailVel = { x: -b.vx*0.02 + (Math.random()-0.5)*10, y: -b.vy*0.02 + (Math.random()-0.5)*10 };
      spawnParticle({x:b.x + (Math.random()-0.5)*3, y:b.y + (Math.random()-0.5)*3}, trailVel, 0.28, '#8cff8c', 1.0, false);
      if(b.type === 'rocket'){
        if(b.homingDelay > 0){
          b.homingDelay -= dt;
        } else {
          let target = null;
          if(b.target && !b.target.dead){
            target = {x:b.target.x, y:b.target.y};
          } else if(lockedTargets.length){
            let dist = Infinity; let chosen = null;
            for(const t of lockedTargets){
              if(t.dead) continue;
              const d = Math.hypot(t.x - b.x, t.y - b.y);
              if(d < dist){ dist = d; chosen = t; }
            }
            if(chosen) target = {x:chosen.x, y:chosen.y};
          } else if(lockedTarget && !lockedTarget.dead){
            target = {x:lockedTarget.x, y:lockedTarget.y};
          } else {
            let dist = Infinity;
            for(const npc of npcs){
              if(npc.dead) continue;
              const d = Math.hypot(npc.x - b.x, npc.y - b.y);
              if(d < dist){ dist = d; target = {x:npc.x, y:npc.y}; }
            }
            if(!target){
              target = { x: ship.pos.x + (mouse.x - W/2)/camera.zoom,
                         y: ship.pos.y + (mouse.y - H/2)/camera.zoom };
            }
          }
          const speed = Math.hypot(b.vx, b.vy);
          const dir = norm({x:target.x - b.x, y:target.y - b.y});
          const current = Math.atan2(b.vy, b.vx);
          const desired = Math.atan2(dir.y, dir.x);
          const diff = wrapAngle(desired - current);
          const maxTurn = SIDE_ROCKET_TURN_RATE * dt;
          const turn = Math.abs(diff) < maxTurn ? diff : Math.sign(diff) * maxTurn;
          const newAng = current + turn;
          b.vx = Math.cos(newAng) * speed;
          b.vy = Math.sin(newAng) * speed;
        }
      }
    }

    if(b.life <= 0){ bullets.splice(i,1); continue; }

    // hit NPC
    let hitNPC = null;
    for(const npc of npcs){
      if(npc.dead) continue;
      const d = Math.hypot(npc.x - b.x, npc.y - b.y);
      if(d < npc.radius + b.r){ hitNPC = npc; break; }
    }

    if(hitNPC){
      if(b.type === 'plasma' || b.type === 'rocket'){
        const ex = b.x, ey = b.y;
        spawnExplosionPlasma(ex, ey, 1.0);
        for(const npc of npcs){
          if(npc.dead) continue;
          const d2 = Math.hypot(npc.x - ex, npc.y - ey);
          if(d2 <= b.explodeRadius + npc.radius){
            const falloff = 1 - (d2 / (b.explodeRadius + npc.radius));
            applyDamageToNPC(npc, Math.round(b.damage * (0.9 * falloff + 0.1)), 'plasma');
          }
        }
        bullets.splice(i,1);
        continue;
      } else if(b.type === 'rail'){
        applyDamageToNPC(hitNPC, b.damage, 'rail');
        spawnRailHitEffect(b.x, b.y, 1.0);
        b.penetration = (b.penetration !== undefined) ? b.penetration - 1 : (RAIL_PEN - 1);
        if(b.penetration <= 0){ bullets.splice(i,1); }
        continue;
      } else {
        applyDamageToNPC(hitNPC, b.damage, 'default');
        spawnDefaultHit(b.x, b.y, 1.0);
        bullets.splice(i,1);
        continue;
      }
    }

    // hit player
    if(b.owner !== 'player'){
      const hitR = Math.max(ship.w, ship.h) * 0.45;
      const d = Math.hypot(ship.pos.x - b.x, ship.pos.y - b.y);
      if(d < hitR + b.r){
        applyDamageToPlayer(b.damage);
        spawnDefaultHit(b.x, b.y, 1.0);
        bullets.splice(i,1);
        continue;
      }
    }
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.age += dt; if(p.age >= p.life){ particles.splice(i,1); continue; }
    if(p.beam) continue;
    p.vel.x *= 0.98; p.vel.y *= 0.98; p.vel.y += 8*dt;
    p.pos.x += p.vel.x*dt; p.pos.y += p.vel.y*dt;
  }
}

// =============== NPC movement/shooting ===============
let npcFireTimer = 0;
function npcShootingStep(dt){
  npcFireTimer -= dt;
  if(npcFireTimer <= 0){
    npcFireTimer = 0.45 + Math.random()*0.8;
    const candidates = npcs.filter(n=>!n.dead && n.weapon && Math.hypot(n.x-ship.pos.x, n.y-ship.pos.y) < 900);
    if(candidates.length){
      const shooter = candidates[Math.floor(Math.random()*candidates.length)];
      const dir = norm({x: ship.pos.x - shooter.x, y: ship.pos.y - shooter.y});
      const bx = shooter.x + dir.x*(shooter.radius+6), by = shooter.y + dir.y*(shooter.radius+6);
      if(shooter.weapon === 'railgun'){
        bullets.push({ x:bx, y:by, vx: dir.x*600 + shooter.vx, vy: dir.y*600 + shooter.vy, life: 2.0, r:4, owner:'npc', damage:40, type:'rail', penetration:1 });
      } else {
        bullets.push({ x:bx, y:by, vx: dir.x*220 + shooter.vx, vy: dir.y*220 + shooter.vy, life: 4, r:3, owner:'npc', damage:12 });
      }
    }
  }
}
function npcStep(dt){
  for(const npc of npcs){
    if(npc.dead){
      npc.respawnTimer -= dt;
      if(npc.respawnTimer<=0){
        const inner = stations.filter(s=>s.inner);
        const start = inner[Math.floor(Math.random()*inner.length)];
        const targetId = pickNextStation(npc.id, start.id);
        npc.x = start.x + (Math.random()-0.5)*40;
        npc.y = start.y + (Math.random()-0.5)*40;
        npc.vx = 0; npc.vy = 0;
        npc.hp = npc.maxHp; npc.dead=false; npc.target = targetId; npc.fade = 1; npc.docking=false; npc.lastStation=start.id;
        npc.warpRoute = getWarpRoute(start.id, targetId); npc.phase = 'toGate'; npc.lane = Math.floor(Math.random()*2);
      }
      continue;
    }
    if(npc.docking){
      const st = stations.find(s=>s.id===npc.lastStation);
      if(st){ npc.x = st.x; npc.y = st.y; }
      npc.fade -= dt / 0.6;
      if(npc.fade <= 0 && st){
        const targetId = pickNextStation(npc.id, npc.lastStation);
        npc.x = st.x + (Math.random()-0.5)*40;
        npc.y = st.y + (Math.random()-0.5)*40;
        npc.vx = 0; npc.vy = 0;
        npc.target = targetId; npc.fade = 1; npc.docking=false; npc.lastStation=st.id;
        npc.warpRoute = getWarpRoute(st.id, targetId); npc.phase = 'toGate'; npc.lane = Math.floor(Math.random()*2);
      }
      continue;
    }
    if(npc.phase === 'warping'){
      npc.x += npc.vx*dt; npc.y += npc.vy*dt;
      npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
      const route = npc.warpRoute;
      const traveled = (npc.x - route.start.x) * route.dir.x + (npc.y - route.start.y) * route.dir.y;
      if(traveled >= route.length){
        npc.phase = 'toStation';
        npc.x = route.end.x; npc.y = route.end.y;
      }
      continue;
    }
    if(npc.phase === 'toGate'){
      const gate = npc.warpRoute.start;
      const start = stations.find(s=>s.id===npc.lastStation);
      const gv = { x: gate.x - start.x, y: gate.y - start.y };
      const gd = Math.hypot(gv.x, gv.y) || 1;
      const dirToGate = { x: gv.x/gd, y: gv.y/gd };
      const perp = { x: -dirToGate.y, y: dirToGate.x };
      const laneOffset = npc.lane ? 20 : -20;
      const gatePos = { x: gate.x + perp.x*laneOffset, y: gate.y + perp.y*laneOffset };
      const queue = gate.queues[npc.lane];
      let idx = queue.indexOf(npc);
      if(idx === -1){ queue.push(npc); idx = queue.length-1; }
      const spacing = 30;
      const targetPos = {
        x: gatePos.x - dirToGate.x * idx * spacing,
        y: gatePos.y - dirToGate.y * idx * spacing
      };
      const distGate = Math.hypot(npc.x - gatePos.x, npc.y - gatePos.y);
      if(idx === 0 && distGate < 5){
        queue.shift();
        npc.phase = 'warping';
        npc.vx = npc.warpRoute.dir.x * 4000;
        npc.vy = npc.warpRoute.dir.y * 4000;
        npc.x = gatePos.x;
        npc.y = gatePos.y;
        continue;
      }
      const to = { x: targetPos.x - npc.x, y: targetPos.y - npc.y };
      const d = Math.hypot(to.x, to.y);
      if(d < 1){
        npc.vx = 0; npc.vy = 0;
        continue;
      }
      const dir = { x: to.x/d, y: to.y/d };
      const desiredV = { x: dir.x*npc.speed, y: dir.y*npc.speed };
      npc.vx += (desiredV.x - (npc.vx||0)) * clamp(1.5*dt,0,1);
      npc.vy += (desiredV.y - (npc.vy||0)) * clamp(1.5*dt,0,1);
      npc.x += npc.vx*dt; npc.y += npc.vy*dt; npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
      continue;
    }
    let targetPos, st = null;
    if(npc.leader != null){
      const leader = npcs.find(n=>n.id===npc.leader && !n.dead);
      if(leader){
        targetPos = {
          x: leader.x + Math.cos(npc.orbitAngle) * npc.orbitRadius,
          y: leader.y + Math.sin(npc.orbitAngle) * npc.orbitRadius
        };
      } else {
        npc.leader = null;
      }
    }
    if(!targetPos){
      st = stations.find(s=>s.id===npc.target);
      if(!st){ npc.target = pickNextStation(npc.id, -1); npc.warpRoute = getWarpRoute(npc.lastStation, npc.target); npc.phase='toGate'; continue; }
      if(npc.phase === 'toStation'){
        const gate = npc.warpRoute.end;
        const gv = { x: st.x - gate.x, y: st.y - gate.y };
        const gd = Math.hypot(gv.x, gv.y) || 1;
        const perp = { x: -gv.y/gd, y: gv.x/gd };
        const offset = npc.lane ? 20 : -20;
        targetPos = { x: st.x + perp.x*offset, y: st.y + perp.y*offset };
      } else {
        targetPos = { x: st.x, y: st.y };
      }
    }
    const to = { x: targetPos.x - npc.x, y: targetPos.y - npc.y };
    const d = Math.hypot(to.x,to.y);
    const dir = d?{x:to.x/d,y:to.y/d}:{x:0,y:0};
    const desiredSpeed = npc.leader != null ? npc.speed : npc.speed * (d < 120 ? (d/120) : 1);
    const desiredV = { x: dir.x*desiredSpeed, y: dir.y*desiredSpeed };
    npc.vx += (desiredV.x - (npc.vx||0)) * clamp(1.5*dt,0,1);
    npc.vy += (desiredV.y - (npc.vy||0)) * clamp(1.5*dt,0,1);
    const toP = { x: ship.pos.x - npc.x, y: ship.pos.y - npc.y }; const dp = Math.hypot(toP.x,toP.y);
    if(dp < 120){ npc.vx -= (toP.x/dp) * 40*dt; npc.vy -= (toP.y/dp) * 40*dt; }
    npc.x += npc.vx*dt; npc.y += npc.vy*dt; npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
    const distToStation = st ? Math.hypot(st.x - npc.x, st.y - npc.y) : Infinity;
    if(npc.leader == null && st && distToStation < 20){
      npc.docking = true;
      npc.x = st.x; npc.y = st.y;
      npc.vx = 0; npc.vy = 0;
      npc.lastStation = st.id;
    }
  }
}

// =============== Warp (jak wcześniej) ===============
const warp = {
  state:'idle', // idle | charging | active
  charge:0, chargeTime:0.8,
  orientTolerance: Math.PI/30,
  speed:3800,
  fuelMax:6, fuel:6, consumeRate:1.0, regenRate:0.5,
  dir:{x:0,y:0},
  isBusy(){ return this.state!=='idle'; }
};

function exitWarp(){
  spawnShockwave(ship.pos.x, ship.pos.y, { maxR: 1200, maxLife: 0.7 });
  camera.addShake(18, 0.22);
}

const boost = {
  state:'idle',
  charge:0, chargeTime:0.6,
  speed:1600,
  fuelMax:3, fuel:3, cost:1, regenRate:0.5,
  effectTime:0, effectDuration:0.4, effectDir:{x:0,y:0}
};
function engageBoost(){
  const dir = rotate({x:0,y:-1}, ship.angle);
  ship.vel.x += dir.x * boost.speed;
  ship.vel.y += dir.y * boost.speed;
  boost.fuel = clamp(boost.fuel - boost.cost, 0, boost.fuelMax);
  boost.state = 'idle';
  boost.charge = 0;
  boost.effectTime = boost.effectDuration;
  boost.effectDir = {x: dir.x, y: dir.y};
}
window.addEventListener('keydown', (e)=>{
  if(e.key.toLowerCase() === 'shift'){
    if(warp.state==='idle' && warp.fuel>0){ warp.state='charging'; warp.charge=0; }
  }
});
window.addEventListener('keyup', (e)=>{
  if(e.key.toLowerCase() === 'shift'){
    if(warp.state==='charging'){ warp.state='idle'; warp.charge=0; }
    else if(warp.state==='active'){ warp.state='idle'; exitWarp(); }
  }
});
function engageWarp(dir){
  warp.dir = dir;
  ship.angle = Math.atan2(dir.y, dir.x) + Math.PI/2;
  ship.angVel = 0;
  warp.state='active';
  spawnParticle({x:ship.pos.x, y:ship.pos.y}, {x:0,y:0}, 0.14, '#bfe7ff', 8, true);
  for(let i=0;i<18;i++){
    const a = Math.random()*Math.PI*2;
    spawnParticle({x:ship.pos.x, y:ship.pos.y}, {x:Math.cos(a)*320, y:Math.sin(a)*320}, 0.18+Math.random()*0.18, '#cce6ff', 1.4, false);
  }
}

// =============== Fizyk ===============
function physicsStep(dt){
  // czas gry
  gameTime = (gameTime + dt * TIME_SCALE) % (24*3600);
  // aktualizacja orbit planet i stacji
  for(const pl of planets){
    pl.angle += pl.speed * dt * TIME_SCALE;
    pl.x = SUN.x + Math.cos(pl.angle) * pl.orbitRadius;
    pl.y = SUN.y + Math.sin(pl.angle) * pl.orbitRadius;
  }
  for(const st of stations){
    st.angle += st.speed * dt * TIME_SCALE;
    st.x = st.planet.x + Math.cos(st.angle) * st.orbitRadius;
    st.y = st.planet.y + Math.sin(st.angle) * st.orbitRadius;
  }
  // regen paliwa gdy nie warpuje
  if(warp.state!=='active') warp.fuel = clamp(warp.fuel + warp.regenRate*dt, 0, warp.fuelMax);
  if(boost.state==='idle' && boost.effectTime<=0) boost.fuel = clamp(boost.fuel + boost.regenRate*dt, 0, boost.fuelMax);
  if(boost.state==='charging'){
    boost.charge += dt;
    if(boost.charge >= boost.chargeTime && boost.fuel>=boost.cost){ engageBoost(); }
  }
  if(boost.effectTime>0) boost.effectTime = Math.max(0, boost.effectTime - dt);

  // rail queue/cd
  rail.cd[0] = Math.max(0, rail.cd[0]-dt);
  rail.cd[1] = Math.max(0, rail.cd[1]-dt);
  if(mouse.left && rail.queue.length===0 && rail.cd[0]<=0 && rail.cd[1]<=0 && !warp.isBusy()){
    triggerRailVolley();
  }
  for(const q of rail.queue) q.timer -= dt;
  let firedSomething = true;
  while(firedSomething){
    firedSomething = false;
    for(let i=0;i<rail.queue.length;i++){
      const q = rail.queue[i];
      if(q.timer <= 0 && rail.cd[q.barrel] <= 0 && !warp.isBusy()){
        fireRailBarrel(q.barrel);
        rail.queue.splice(i,1);
        firedSomething = true;
        break;
      }
    }
  }
  railTimer = Math.min(rail.cd[0], rail.cd[1]);

  ship.special.cooldownTimer = Math.max(0, ship.special.cooldownTimer - dt);
  if(ship.shield.regenTimer > 0) ship.shield.regenTimer -= dt;
  else ship.shield.val = clamp(ship.shield.val + ship.shield.regenRate * dt, 0, ship.shield.max);
  rocketCooldown = Math.max(0, rocketCooldown - dt);
  // mouse world position
  const mouseWorld = { x: ship.pos.x + (mouse.x - W/2)/camera.zoom, y: ship.pos.y + (mouse.y - H/2)/camera.zoom };
  if(mouse.right && !warp.isBusy() && rocketAmmo > 0 && rocketCooldown <= 0){
    const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
    const side = (local.x >= 0) ? 'right' : 'left';
    fireRocket(side);
    rocketCooldown = ROCKET_FIRE_INTERVAL;
  }

  // hover scanning
  let hover = null;
  for(const npc of npcs){
    if(npc.dead) continue;
    if(Math.hypot(npc.x - mouseWorld.x, npc.y - mouseWorld.y) < npc.radius + 20){ hover = npc; break; }
  }
  if(!hover){
    for(const st of stations){
      if(Math.hypot(st.x - mouseWorld.x, st.y - mouseWorld.y) < st.r + 20){ hover = st; break; }
    }
  }
  if(hover !== scan.target){ scan.target = hover; scan.progress = 0; }
  if(scan.target){
    if(scan.progress < SCAN_TIME){
      scan.progress += dt;
      if(scan.progress >= SCAN_TIME){
        scan.progress = SCAN_TIME;
        scan.scanned = scan.target;
        spawnRadarPing(scan.target.x, scan.target.y);
        lockedTarget = scan.scanned;
      }
    }
  } else {
    scan.scanned = null;
    scan.progress = 0;
  }
  if(lockedTarget && lockedTarget.dead) lockedTarget = null;
  lockedTargets = lockedTargets.filter(t=>!t.dead);
  if(highlightTimer > 0){
    highlightTimer -= dt;
    if(highlightTimer <= 0){ highlightTimer = 0; highlightedEnemies = []; }
  }

  // update radar pings
  for(let i=radarPings.length-1;i>=0;i--){
    const p = radarPings[i];
    p.age += dt; if(p.age>p.life) radarPings.splice(i,1);
  }
  // update scan waves
  for(let i=scanWaves.length-1;i>=0;i--){
    const w = scanWaves[i];
    w.r += w.speed*dt;
    for(const npc of npcs){
      if(npc.dead) continue;
      if(!w.hit.has(npc) && Math.hypot(npc.x-w.x, npc.y-w.y) <= w.r){ w.hit.add(npc); spawnRadarPing(npc.x,npc.y); }
    }
    for(const st of stations){
      if(!w.hit.has(st) && Math.hypot(st.x-w.x, st.y-w.y) <= w.r){ w.hit.add(st); spawnRadarPing(st.x,st.y); }
    }
    if(w.r > w.max) scanWaves.splice(i,1);
  }

  // update scan arrows
  for(let i=scanArrows.length-1;i>=0;i--){
    const a = scanArrows[i];
    if(warp.state !== 'active') a.age += dt;
    if(a.age > a.life) scanArrows.splice(i,1);
  }

  // turret aim (poza warp active)
  if(warp.state!=='active'){
    for(const t of [ship.turret, ship.turret2, ship.turret3, ship.turret4]){
      const off = rotate(t.offset, ship.angle);
      const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
      const aimPos = (lockedTarget && !lockedTarget.dead)
        ? leadTarget(base, ship.vel, lockedTarget, RAIL_SPEED)
        : mouseWorld;
      let diffT = wrapAngle(Math.atan2(aimPos.y - base.y, aimPos.x - base.x) - t.angle);
      let desiredVel = clamp(diffT * 6.5, -t.maxSpeed, t.maxSpeed);
      const velDelta = desiredVel - t.angVel;
      const maxDelta = t.maxAccel * dt;
      t.angVel += clamp(velDelta, -maxDelta, maxDelta);
      t.angVel *= Math.exp(-t.damping * dt);
      t.angVel = clamp(t.angVel, -t.maxSpeed, t.maxSpeed);
      t.angle = wrapAngle(t.angle + t.angVel * dt);
    }
  }
  for(const t of [ship.turret, ship.turret2, ship.turret3, ship.turret4]){
    t.recoil = Math.max(0, t.recoil - t.recoilRecover * dt);
  }

  // siły
  let totalF = {x:0,y:0}, totalTorque = 0;
  const forwardLocal = {x:0, y:-1};

  if(warp.state==='active'){
    const dirToMouse = norm({x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y});
    const targetV = { x: warp.dir.x*warp.speed, y: warp.dir.y*warp.speed };
    ship.vel.x += (targetV.x - ship.vel.x) * clamp(6*dt,0,1);
    ship.vel.y += (targetV.y - ship.vel.y) * clamp(6*dt,0,1);
    ship.angVel *= Math.exp(-8*dt);
    warp.fuel = clamp(warp.fuel - warp.consumeRate*dt, 0, warp.fuelMax);
    if(warp.fuel<=0){ warp.state='idle'; exitWarp(); }
  }
  else if(warp.state==='charging'){
    const dirToMouse = norm({x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y});
    const desiredBodyAngle = Math.atan2(dirToMouse.y, dirToMouse.x) + Math.PI/2;
    const kp = 5.5, maxSpin=2.5, accel=8.0;
    const diffB = wrapAngle(desiredBodyAngle - ship.angle);
    const desiredSpin = clamp(diffB * kp, -maxSpin, maxSpin);
    const delta = clamp(desiredSpin - ship.angVel, -accel*dt, accel*dt);
    ship.angVel += delta;
    if(warp.charge < warp.chargeTime) warp.charge += dt;
    if(warp.charge >= warp.chargeTime && Math.abs(diffB) <= warp.orientTolerance && warp.fuel>0){
      engageWarp(dirToMouse);
    }
  }
  else {
    // GŁÓWNY DUŻY SILNIK — ciąg do przodu
    if(input.main>0){
      const e = ship.engines.main;
      const thrust = e.maxThrust * input.main;
      const wo = rotate(e.offset, ship.angle);
      const wf = rotate(forwardLocal, ship.angle);
      totalF.x += wf.x * thrust; totalF.y += wf.y * thrust;
      totalTorque += (wo.x * (wf.y * thrust) - wo.y * (wf.x * thrust));
    }
    // mały krótki ślad przy poruszaniu (bez gazu)
    const spd = len(ship.vel);
    if(spd > 60){
      const e = ship.engines.main;
      const wo = rotate(e.offset, ship.angle);
      const backDir = norm({x:-ship.vel.x, y:-ship.vel.y});
      spawnParticle({x: ship.pos.x + wo.x, y: ship.pos.y + wo.y},
                    {x: backDir.x*50 + (Math.random()-0.5)*20, y: backDir.y*50 + (Math.random()-0.5)*20},
                    0.18, '#bfe7ff', 1.2, false);
    }

    // boczne i moment
    if(input.leftSide>0){
      const e = ship.engines.sideLeft;
      const thrust = e.maxThrust * input.leftSide;
      const wo = rotate(e.offset, ship.angle);
      const lateral = rotate({x:1,y:0}, ship.angle);
      const worldForce = {x: lateral.x * thrust, y: lateral.y * thrust};
      totalF.x += worldForce.x; totalF.y += worldForce.y;
      totalTorque += (wo.x * worldForce.y - wo.y * worldForce.x);
      spawnParticle(add(ship.pos, wo), add(ship.vel, mul(worldForce,-0.002)), 0.30, '#cfe7ff', 1.0);
    }
    if(input.rightSide>0){
      const e = ship.engines.sideRight;
      const thrust = e.maxThrust * input.rightSide;
      const wo = rotate(e.offset, ship.angle);
      const lateral = rotate({x:-1,y:0}, ship.angle);
      const worldForce = {x: lateral.x * thrust, y: lateral.y * thrust};
      totalF.x += worldForce.x; totalF.y += worldForce.y;
      totalTorque += (wo.x * worldForce.y - wo.y * worldForce.x);
      spawnParticle(add(ship.pos, wo), add(ship.vel, mul(worldForce,-0.002)), 0.30, '#cfe7ff', 1.0);
    }
    if(input.torque !== 0){
      const sign = Math.sign(input.torque);
      const left = ship.engines.torqueLeft; const right = ship.engines.torqueRight;
      const thrust = left.maxThrust * Math.abs(input.torque);
      const o1 = rotate(left.offset, ship.angle), o2 = rotate(right.offset, ship.angle);
      const lateral1 = rotate({x:1,y:0}, ship.angle), lateral2 = rotate({x:-1,y:0}, ship.angle);
      const f1 = mul(lateral1, thrust * sign), f2 = mul(lateral2, thrust * sign);
      totalF.x += f1.x + f2.x; totalF.y += f1.y + f2.y;
      totalTorque += (o1.x * f1.y - o1.y * f1.x) + (o2.x * f2.y - o2.y * f2.x);
      spawnParticle(add(ship.pos, o1), add(ship.vel, mul(f1,-0.002)), 0.22, '#cfe7ff',1.0);
      spawnParticle(add(ship.pos, o2), add(ship.vel, mul(f2,-0.002)), 0.22, '#cfe7ff',1.0);
    }
  }

  // integracja ruchu
  const ax = totalF.x / ship.mass, ay = totalF.y / ship.mass;
  ship.vel.x += ax*dt; ship.vel.y += ay*dt;
  const linDamp = Math.exp(-ship.linearDamping*dt);
  if(warp.state!=='active'){ ship.vel.x *= linDamp; ship.vel.y *= linDamp; }
  ship.pos.x += ship.vel.x*dt; ship.pos.y += ship.vel.y*dt;

  // granice
  const margin = 50;
  ship.pos.x = clamp(ship.pos.x, margin, WORLD.w - margin);
  ship.pos.y = clamp(ship.pos.y, margin, WORLD.h - margin);

  // obrót
  const angAcc = totalTorque / ship.inertia;
  ship.angVel += angAcc*dt;
  ship.angVel *= Math.exp(-ship.angularDamping*dt);
  ship.angle += ship.angVel*dt;

  npcStep(dt);
  ciwsStep(dt);
  bulletsAndCollisionsStep(dt);
  npcShootingStep(dt);
}

// ======= Efekty VFX =======
let _engineVFX = null;
let _engineVFXLoading = false;

function getEngineVFX() {
  if (_engineVFX) return _engineVFX;

  if (typeof THREE === "undefined") return null;

  // 1) Upewnij się, że mamy konstruktory efektów
  if (typeof window.createShortNeedleExhaust !== "function") {
    if (!_engineVFXLoading) {
      _engineVFXLoading = true;
      import("./Engineeffects.js").then(mod => {
        window.createShortNeedleExhaust = mod.createShortNeedleExhaust;
        window.createWarpExhaustBlue   = mod.createWarpExhaustBlue;
      }).catch(err => console.warn("Engineeffects.js failed to load", err))
        .finally(() => { _engineVFXLoading = false; });
    }
    return null;
  }

  // 2) Offscreen canvas i scena
  const canvas = document.createElement("canvas");
  // więcej miejsca, żeby ogon nie był ścinany
  canvas.width = 128;
  canvas.height = 256;
  const ctx2d = canvas.getContext("2d");

  const scene = new THREE.Scene();
  scene.background = null;

  const camera = new THREE.OrthographicCamera(-64, 64, 64, -192, -1000, 1000);
  camera.position.z = 10;
  camera.lookAt(0, 0, 0);

  const exhaust = window.createShortNeedleExhaust();
  exhaust.group.position.y = 0; // zero — unikamy clipu przy obrocie
  scene.add(exhaust.group);

  // 3) Renderer: użyj współdzielonego jeśli jest, w przeciwnym razie lokalnego
  let localRenderer = null;
  function pickRenderer(w, h) {
    if (typeof window.getSharedRenderer === "function") {
      const r = window.getSharedRenderer(w, h);
      return r || null;
    }
    if (!localRenderer) {
      localRenderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
        premultipliedAlpha: true,
        preserveDrawingBuffer: true
      });
      localRenderer.setPixelRatio(1);
    }
    // dopasuj rozmiar jeśli się zmienił
    const d = localRenderer.getSize(new THREE.Vector2());
    if (d.x !== w || d.y !== h) localRenderer.setSize(w, h, false);
    return localRenderer;
  }

  _engineVFX = {
    canvas, ctx2d, camera, scene, exhaust,
    render(time) {
      const r = pickRenderer(canvas.width, canvas.height);
      if (!r) return;
      // pełny reset i przezroczyste czyszczenie
      r.setRenderTarget(null);
      r.setViewport(0, 0, canvas.width, canvas.height);
      if (r.state && r.state.reset) r.state.reset();
      r.setScissorTest(false);
      r.setClearColor(0x000000, 0); // przeźroczyste tło
      r.clear(true, true, false);

      // dynamiczny throttle
      const spd = Math.hypot(ship.vel.x, ship.vel.y);
      const moveGlow = Math.min(spd / 900, 0.6);
      const thrust = input.main > 0 ? input.main : 0;
      const boostAmp = (boost.effectTime > 0) ? 1.0 : 0.0;
      const warpAmp  = (warp.state === 'active') ? 1.0 : 0.0;
      const throttle = Math.max(thrust, moveGlow * 0.8);

      exhaust.setThrottle(throttle);
      exhaust.setWarpBoost(Math.max(boostAmp, warpAmp));

      exhaust.update(time);
      r.render(scene, camera);

      // skopiuj do 2D
      ctx2d.clearRect(0, 0, canvas.width, canvas.height);
      ctx2d.drawImage(r.domElement, 0, 0, canvas.width, canvas.height);
    }
  };

  return _engineVFX;
}

// Prosty fallback 2D — żeby ZAWSZE coś było widać, gdy evfx==null
function drawEngineFallback2D() {
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  const g = ctx.createLinearGradient(0, 0, 0, 90);
  g.addColorStop(0, 'rgba(170,210,255,0.55)');
  g.addColorStop(1, 'rgba(170,210,255,0)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(-14, 0);
  ctx.quadraticCurveTo(0, 70, 14, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawPhotonBeamLocal(alpha){
  const L = 200;
  ctx.save();
  ctx.lineCap = 'round';
  ctx.shadowBlur = 28;
  ctx.shadowColor = `rgba(230,250,255,${0.95 * alpha})`;
  ctx.strokeStyle = `rgba(255,255,255,${0.95 * alpha})`;
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, -L * 0.96);
  ctx.stroke();
  ctx.restore();

  const g = ctx.createLinearGradient(0, 0, 0, -L);
  g.addColorStop(0, `rgba(160,210,255,${0.25 * alpha})`);
  g.addColorStop(1, `rgba(160,210,255,0)`);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(-50, 0);
  ctx.quadraticCurveTo(0, -L * 0.5, 0, -L);
  ctx.quadraticCurveTo(0, -L * 0.5, 50, 0);
  ctx.closePath();
  ctx.fill();

  for (let i = 0; i < 4; i++) {
    const phase = ((vfxTime * 0.8) + i * 0.25) % 1;
    const y = -phase * L;
    const r = 20 + 40 * (1 - phase);
    ctx.strokeStyle = `rgba(200,240,255,${(1 - phase) * alpha})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, y, r, 0, Math.PI * 2);
    ctx.stroke();
  }

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.shadowBlur = 19.2;
  ctx.shadowColor = '#fff';
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(0, 0, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawMainEngineVfxLocal(localPos, forward, widen = 1.5, yNudge = -68) {
  ctx.save();
  // przechodzimy w lokal statku
  ctx.translate(localPos.x, localPos.y);
  // dopasowanie szerokości do kadłuba
  ctx.scale(widen, 1);
  // igła w dół statku (dysza na dole) — oś Y płomienia w dół
  ctx.rotate(Math.atan2(forward.y, forward.x) + Math.PI/2);
  ctx.globalCompositeOperation = 'lighter';

  const evfx = getEngineVFX();
  if (evfx) {
    evfx.render(vfxTime);
    const w = evfx.canvas.width, h = evfx.canvas.height;
    ctx.drawImage(evfx.canvas, -w / 2, yNudge, w, h);
  }
  ctx.restore();
}

function drawBoostBeam(pos, dir, cam, alpha){ const s=worldToScreen(pos.x,pos.y,cam); ctx.save(); ctx.translate(s.x,s.y); ctx.scale(camera.zoom,camera.zoom); ctx.rotate(Math.atan2(-dir.x, dir.y)); ctx.globalCompositeOperation='lighter'; drawPhotonBeamLocal(alpha); ctx.restore(); }

// =============== Main loop ===============
let lastTime = performance.now();
const PHYS_DT = 1/120;
let acc = 0;
let vfxTime = 0;
let prevState = null;
function saveState(){ prevState = { pos:{...ship.pos}, angle: ship.angle, turretAngle: ship.turret.angle, turretAngle2: ship.turret2.angle, turretAngle3: ship.turret3.angle, turretAngle4: ship.turret4.angle, ciwsAngles: ship.ciws.map(c=>c.angle) }; }
saveState();
function loop(now){
  const frame = Math.min(0.033, (now - lastTime)/1000);
  lastTime = now;
  acc += frame;
  vfxTime += frame;
  saveState();
  let steps = 0;
  while(acc >= PHYS_DT && steps < 10){
    physicsStep(PHYS_DT);
    acc -= PHYS_DT; steps++;
  }
  const alpha = acc / PHYS_DT;
  frameId++;
  updatePlanets3D(frame);
  // Shockwaves
  for(let i=shockwaves.length-1;i>=0;i--){
    const s = shockwaves[i];
    s.life += frame;
    const k = Math.min(1, s.life/s.maxLife);
    s.r = s.maxR * k;
    s.w = Math.max(1, (1-k) * (s.maxR*0.06));
    if(s.life >= s.maxLife) shockwaves.splice(i,1);
  }
  if(camera.shakeTime > 0){
    camera.shakeTime -= frame;
    if(camera.shakeTime <= 0) camera.shakeMag = 0;
  }
  render(alpha);
  requestAnimationFrame(loop);
}

// =============== Render ===============
function worldToScreen(wx,wy,cam){ return { x: (wx - cam.x)*camera.zoom + W/2, y: (wy - cam.y)*camera.zoom + H/2 }; }

function drawStars(cam){
  // jak daleko poza ekran ładować komórki
  const marginW = (W/2)/camera.zoom + 2000;
  const marginH = (H/2)/camera.zoom + 2000;
  const minX = Math.floor((cam.x - marginW)/STAR_CELL);
  const maxX = Math.floor((cam.x + marginW)/STAR_CELL);
  const minY = Math.floor((cam.y - marginH)/STAR_CELL);
  const maxY = Math.floor((cam.y + marginH)/STAR_CELL);

  for(let iy=minY; iy<=maxY; iy++){
    for(let ix=minX; ix<=maxX; ix++){
      const cell = getCell(ix,iy);
      for(const s of cell.stars){
        const sx = (s.x - cam.x) * camera.zoom + W/2;
        const sy = (s.y - cam.y) * camera.zoom + H/2;
        if(sx < -50 || sx > W+50 || sy < -50 || sy > H+50) continue;

        if(warp.state==='active'){
          // Smugi przy warp
          const L = 24 * (1 + 1.2*(warp.fuel/warp.fuelMax));
          const dx = -warp.dir.x * L, dy = -warp.dir.y * L;
          ctx.strokeStyle = 'rgba(200,220,255,0.35)';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(sx+dx, sy+dy); ctx.lineTo(sx, sy); ctx.stroke();
        } else {
          ctx.globalAlpha = s.bright;
          ctx.fillStyle = '#ffffff';
          const sz = Math.max(0.6, s.size * (0.8 + 0.2*Math.random()));
          ctx.fillRect(Math.round(sx), Math.round(sy), Math.ceil(sz), Math.ceil(sz));
          ctx.globalAlpha = 1;
        }
      }
    }
  }
  pruneStarCells();
}

function render(alpha){
  // Interpolacja stanu
  const interpPos = {
    x: prevState.pos.x*(1-alpha) + ship.pos.x*alpha,
    y: prevState.pos.y*(1-alpha) + ship.pos.y*alpha
  };
  const interpAngle = prevState.angle*(1-alpha) + ship.angle*alpha;
  const interpTurretAngle = interpAngleShort(prevState.turretAngle, ship.turret.angle, alpha);
  const interpTurretAngle2 = interpAngleShort(prevState.turretAngle2, ship.turret2.angle, alpha);
  const interpTurretAngle3 = interpAngleShort(prevState.turretAngle3, ship.turret3.angle, alpha);
  const interpTurretAngle4 = interpAngleShort(prevState.turretAngle4, ship.turret4.angle, alpha);
  const interpCIWSAngles = ship.ciws.map((c,i)=>interpAngleShort(prevState.ciwsAngles[i], c.angle, alpha));

  // Kamera
  const cam = { x: interpPos.x, y: interpPos.y };
  if(camera.shakeMag > 0){
    const t = camera.shakeTime / camera.shakeDur;
    const mag = camera.shakeMag * Math.max(0, t);
    cam.x += (Math.random()*2 - 1) * mag;
    cam.y += (Math.random()*2 - 1) * mag;
  }

  // aktualizuj wyświetlanie czasu
  gameTimeEl.textContent = formatGameTime(gameTime);

  // Czyścimy ekran
  ctx.clearRect(0,0,W,H);


  // Gwiazdy (proceduralne kafelki na całej mapie)
  drawStars(cam);

  // scan waves
  for(const w of scanWaves){
    const s = worldToScreen(w.x, w.y, cam);
    ctx.strokeStyle = 'rgba(120,200,255,0.18)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, w.r * camera.zoom, 0, Math.PI*2); ctx.stroke();
  }

  drawPlanets3D(ctx, cam);

  // drogi między stacjami
  const drawn = new Set();
  for(const npc of npcs){
    if(npc.dead) continue;
    const start = stations.find(s=>s.id===npc.lastStation);
    const target = stations.find(s=>s.id===npc.target);
    if(!start || !target) continue;
    const key = start.id < target.id ? start.id+'-'+target.id : target.id+'-'+start.id;
    if(drawn.has(key)) continue;
    drawn.add(key);
    const s1 = worldToScreen(start.x, start.y, cam);
    const s2 = worldToScreen(target.x, target.y, cam);
    ctx.strokeStyle = 'rgba(120,180,255,0.15)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
  }

  // Warp gates
  for(const key in warpRoutes){
    const route = warpRoutes[key];
    const perp = { x: -route.dir.y, y: route.dir.x };
    const w = 6*camera.zoom;
    const s1 = worldToScreen(route.start.x, route.start.y, cam);
    const s2 = worldToScreen(route.end.x, route.end.y, cam);
    ctx.strokeStyle = '#88aaff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(s1.x - perp.x*w, s1.y - perp.y*w);
    ctx.lineTo(s1.x + perp.x*w, s1.y + perp.y*w);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(s2.x - perp.x*w, s2.y - perp.y*w);
    ctx.lineTo(s2.x + perp.x*w, s2.y + perp.y*w);
    ctx.stroke();
  }

  // Shockwaves (na warstwie świata, pod HUD)
  for(const s of shockwaves){
    const sw = worldToScreen(s.x, s.y, cam);
    ctx.beginPath();
    ctx.lineWidth = s.w * camera.zoom;
    ctx.strokeStyle = s.color + (1 - s.life/s.maxLife) + ')';
    ctx.arc(sw.x, sw.y, s.r * camera.zoom, 0, Math.PI*2);
    ctx.stroke();
  }

  // Stacje
  for(const st of stations){
    const s = worldToScreen(st.x, st.y, cam);
    const rr = st.r * camera.zoom;
    ctx.fillStyle = '#273447';
    roundRectScreen(s.x - rr, s.y - rr*0.6, rr*2, rr*1.2, 6*camera.zoom); ctx.fill();
    ctx.strokeStyle = 'rgba(175,210,255,0.12)'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, rr*1.05, 0, Math.PI*2); ctx.stroke();
    ctx.fillStyle = '#dfe7ff'; ctx.font = `${12*camera.zoom}px monospace`;
    ctx.fillText('ST'+st.id, s.x - rr*0.35, s.y + 4*camera.zoom);
  }

  // Laser beams
  for(const p of particles){
    if(!p.beam) continue;
    const s1 = worldToScreen(p.start.x, p.start.y, cam);
    const s2 = worldToScreen(p.end.x, p.end.y, cam);
    const t = clamp(1 - p.age/p.life, 0, 1);
    ctx.save();
    ctx.globalAlpha = t;
    ctx.lineCap = 'round';
    ctx.shadowBlur = 30 * camera.zoom;
    ctx.shadowColor = 'rgba(120,180,255,0.9)';
    ctx.strokeStyle = 'rgba(160,210,255,0.7)';
    ctx.lineWidth = p.width * camera.zoom * 1.4;
    ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    ctx.restore();
    ctx.lineCap = 'butt';
    ctx.strokeStyle = 'rgba(220,240,255,1.0)';
    ctx.lineWidth = p.width * camera.zoom * 0.6;
    ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
  }

  // Pociski
  for(const b of bullets){
    const s = worldToScreen(b.x, b.y, cam);
    if(b.type === 'rail'){
      const a = Math.atan2(b.vy, b.vx);
      const lenPx = 28;
      const dx = Math.cos(a) * (lenPx*0.5);
      const dy = Math.sin(a) * (lenPx*0.5);

      // glow
      ctx.save();
      ctx.lineCap = 'round';
      ctx.shadowBlur = 20 * camera.zoom;
      ctx.shadowColor = 'rgba(140,200,255,0.9)';
      ctx.strokeStyle = 'rgba(160,210,255,0.6)';
      ctx.lineWidth = 12 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx, s.y - dy); ctx.lineTo(s.x + dx, s.y + dy); ctx.stroke();
      ctx.restore();

      // rdzeń
      ctx.lineCap = 'round';
      ctx.strokeStyle = 'rgba(240,255,255,1.0)';
      ctx.lineWidth = 4 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx*0.4, s.y - dy*0.4); ctx.lineTo(s.x + dx*0.9, s.y + dy*0.9); ctx.stroke();
      ctx.lineCap = 'butt';
    } else if(b.type === 'plasma'){
      const sp = worldToScreen(b.px, b.py, cam);
      ctx.save();
      ctx.lineCap = 'round';
      ctx.shadowBlur = 20 * camera.zoom;
      ctx.shadowColor = 'rgba(100,255,120,0.85)';
      ctx.strokeStyle = 'rgba(80,240,120,0.55)';
      ctx.lineWidth = 8 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(sp.x, sp.y); ctx.lineTo(s.x, s.y); ctx.stroke();
      ctx.restore();
      ctx.beginPath(); ctx.fillStyle = '#9eff9a';
      ctx.arc(s.x, s.y, Math.max(2, b.r*camera.zoom*0.8), 0, Math.PI*2); ctx.fill();
    } else {
      ctx.beginPath(); ctx.fillStyle = '#ffd86b';
      ctx.arc(s.x, s.y, Math.max(1.5, b.r*camera.zoom), 0, Math.PI*2); ctx.fill();
    }
  }

  // NPC
  for(const npc of npcs){
    if(npc.dead) continue;
    const s = worldToScreen(npc.x, npc.y, cam);
    ctx.save();
    ctx.globalAlpha = npc.fade;
    ctx.translate(s.x,s.y); ctx.rotate(npc.angle);
    ctx.fillStyle = npc.color;
    roundRectScreen(-npc.radius*camera.zoom, -npc.radius*camera.zoom,
                    npc.radius*2*camera.zoom, npc.radius*1.2*camera.zoom, 4*camera.zoom);
    ctx.fill();
    const hpw = (npc.hp / npc.maxHp) * (npc.radius*2*camera.zoom);
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(-npc.radius*camera.zoom, -npc.radius*camera.zoom - 8*camera.zoom, hpw, 4*camera.zoom);
    ctx.restore();
  }

  // radar pings
  for(const ping of radarPings){
    const s = worldToScreen(ping.x, ping.y, cam);
    const t = ping.age/ping.life;
    ctx.strokeStyle = `rgba(120,200,255,${1-t})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, 40 * t * camera.zoom, 0, Math.PI*2); ctx.stroke();
  }

  // scan indicator and lock
  if(scan.target){
    const obj = scan.target;
    const s = worldToScreen(obj.x, obj.y, cam);
    const rad = ((obj.radius||obj.r) + 10) * camera.zoom;
    const t = scan.progress/SCAN_TIME;
    ctx.strokeStyle = 'rgba(120,200,255,0.7)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, rad, -Math.PI/2, -Math.PI/2 + Math.PI*2*t); ctx.stroke();
  }
  if(highlightedEnemies.length){
    for(const obj of highlightedEnemies){
      if(obj.dead) continue;
      const s = worldToScreen(obj.x, obj.y, cam);
      const rad = ((obj.radius||obj.r) + 12) * camera.zoom;
      ctx.strokeStyle = 'rgba(255,255,0,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
    }
  }
  if(lockedTargets.length){
    for(const obj of lockedTargets){
      if(obj.dead) continue;
      const s = worldToScreen(obj.x, obj.y, cam);
      const rad = ((obj.radius||obj.r) + 14) * camera.zoom;
      ctx.strokeStyle = 'rgba(255,80,80,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
    }
  } else if(lockedTarget){
    const obj = lockedTarget;
    const s = worldToScreen(obj.x, obj.y, cam);
    const rad = ((obj.radius||obj.r) + 14) * camera.zoom;
    ctx.strokeStyle = 'rgba(255,80,80,0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
  }

  // Particles (za statkiem) — zwykłe
  {
    let drawn = 0;
    for (let i = particles.length - 1; i >= 0 && drawn < MAX_PARTICLES_DRAW; i--){
      const p = particles[i];
      if (p.flash || p.beam) continue;
      drawn++;
      const s = worldToScreen(p.pos.x, p.pos.y, cam);
      const t = clamp(1 - p.age/p.life, 0, 1);
      ctx.globalAlpha = t;
      ctx.beginPath(); ctx.fillStyle = p.color;
      ctx.arc(s.x, s.y, p.size * camera.zoom, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Efekt dopalacza
  if(boost.effectTime>0){
    const e = ship.engines.main;
    const origin = add(interpPos, rotate(e.offset, interpAngle));
    drawBoostBeam(origin, boost.effectDir, cam, boost.effectTime/boost.effectDuration);
  }

  // ======= STATEK =======
  const shipS = worldToScreen(interpPos.x, interpPos.y, cam);
  ctx.save(); ctx.translate(shipS.x, shipS.y); ctx.scale(camera.zoom, camera.zoom); ctx.rotate(interpAngle);

  // cień + kadłub
  ctx.fillStyle = 'rgba(3,8,18,0.8)';
  ctx.fillRect(-ship.w/2 + 6, -ship.h/2 + 8, ship.w, ship.h);
  const g = ctx.createLinearGradient(-ship.w/2, -ship.h/2, ship.w/2, ship.h/2);
  g.addColorStop(0, '#1d2740'); g.addColorStop(1, '#2d3b55');
  ctx.fillStyle = g; roundRect(ctx, -ship.w/2, -ship.h/2, ship.w, ship.h, 10); ctx.fill();
  ctx.fillStyle = '#a8d1ff'; ctx.beginPath();
  ctx.ellipse(0, -6, ship.w*0.22, ship.h*0.22, 0, 0, Math.PI*2); ctx.fill();

  // boczne dobudówki
  for(const pod of ship.pods){
    ctx.save();
    ctx.translate(pod.offset.x, pod.offset.y);
    const pg = ctx.createLinearGradient(-pod.w/2, -pod.h/2, pod.w/2, pod.h/2);
    pg.addColorStop(0, '#1d2740'); pg.addColorStop(1, '#2d3b55');
    ctx.fillStyle = pg; roundRect(ctx, -pod.w/2, -pod.h/2, pod.w, pod.h, 6); ctx.fill();
    ctx.restore();
  }

  // główny niebieski nozzle
  const mainE = ship.engines.main;
  ctx.save(); ctx.translate(mainE.offset.x, mainE.offset.y);
  ctx.fillStyle = '#2a3a56'; roundRect(ctx, -14, -9, 28, 18, 6); ctx.fill();
  ctx.save(); ctx.globalAlpha = 0.8; ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(150,200,255,0.9)';
  ctx.fillStyle = 'rgba(160,210,255,0.75)'; roundRect(ctx, -8, -6, 16, 12, 4); ctx.fill();
  ctx.restore(); ctx.restore();

  // boczne/torque nozzles
  for(const k of ['sideLeft','sideRight','torqueLeft','torqueRight']){
    const e = ship.engines[k];
    ctx.save(); ctx.translate(e.offset.x, e.offset.y);
    ctx.fillStyle = '#2f3b57'; roundRect(ctx, -6,-6,12,12,3); ctx.fill(); ctx.restore();
  }

  // krótkie lufy boczne
  ctx.fillStyle = '#cbd6ff';
  for(const off of ship.sideGunsLeft){ ctx.save(); ctx.translate(off.x, off.y); roundRect(ctx, -12,-3,8,6,3); ctx.fill(); ctx.restore(); }
  for(const off of ship.sideGunsRight){ ctx.save(); ctx.translate(off.x, off.y); roundRect(ctx, 4,-3,8,6,3); ctx.fill(); ctx.restore(); }

  // VFX głównego silnika – pod tarczą, wyrasta z dyszy
  {
    const e = ship.engines.main;
    const forward = { x: 0, y: -1 }; // lokalny "w dół statku"
    // szerokość zależna od gazu/ruchu
    const spd = Math.hypot(ship.vel.x, ship.vel.y);
    const moveGlow = Math.min(spd / 900, 0.6) * 0.8;
    const throttle = Math.max(input.main || 0, moveGlow);
    const widen = 2.4 + 0.6 * throttle; // 1.2..1.8
    drawMainEngineVfxLocal(e.offset, forward, widen);
  }

  // status circle (hull/shield/speed/rockets) behind shield
  {
    const hullFrac = ship.hull.val / ship.hull.max;
    const shieldFrac = ship.shield.val / ship.shield.max;
    const r = Math.max(ship.w, ship.h) * 0.6;
    ctx.save();
    ctx.rotate(-interpAngle);
    ctx.lineWidth = 4;
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 - Math.PI,true); ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 + Math.PI,false); ctx.stroke();
    ctx.strokeStyle = '#ef4444';
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 - Math.PI*hullFrac,true); ctx.stroke();
    ctx.strokeStyle = '#3b82f6';
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 + Math.PI*shieldFrac,false); ctx.stroke();
    ctx.fillStyle = '#dfe7ff';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const speed = Math.round(Math.hypot(ship.vel.x, ship.vel.y));
    ctx.fillText(`${speed}`, 0, -r - 8);
    if(rocketAmmo < ROCKET_AMMO_MAX) ctx.fillText(`${rocketAmmo}`, 0, r + 8);
    ctx.restore();
  }

  // tarcza
  const sp = ship.shield.val / ship.shield.max;
  if(sp > 0.005){
    ctx.beginPath(); ctx.strokeStyle = `rgba(120,200,255,${0.18 + 0.4*sp})`;
    ctx.lineWidth = 3; ctx.arc(0,0, Math.max(ship.w,ship.h)*0.6, 0, Math.PI*2); ctx.stroke();
  }

  // CIWS turrets
  const ciwsBase = 8, ciwsBarrelLen = 12, ciwsBarrelH = 4;
  ship.ciws.forEach((c,i)=>{
    const ang = interpCIWSAngles[i];
    ctx.save();
    ctx.translate(c.offset.x, c.offset.y);
    ctx.rotate(ang - interpAngle);
    ctx.fillStyle = '#b8bcc6';
    roundRect(ctx, -ciwsBase/2, -ciwsBase/2, ciwsBase, ciwsBase, 2); ctx.fill();
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(30,50,90,0.45)'; ctx.stroke();
    ctx.fillStyle = '#d0d0d0';
    roundRect(ctx, ciwsBase/2, -ciwsBarrelH/2, ciwsBarrelLen, ciwsBarrelH, 2); ctx.fill(); ctx.stroke();
    ctx.restore();
  });

  // wieżyczki podwójne z recoilem
  const baseW = 16, baseH = 24, barrelLen = Math.max(11, Math.round(ship.h * 0.12)) / 2, barrelH = 6, gap = 10;
  const turrets = [
    { t: ship.turret,  ang: interpTurretAngle },
    { t: ship.turret2, ang: interpTurretAngle2 },
    { t: ship.turret3, ang: interpTurretAngle3 },
    { t: ship.turret4, ang: interpTurretAngle4 }
  ];
  for(const {t, ang} of turrets){
    ctx.save();
    ctx.translate(t.offset.x, t.offset.y);
    ctx.rotate(ang - interpAngle);
    const recoil = t.recoil;
    ctx.fillStyle = '#9ab7ff'; roundRect(ctx, -baseW/2, -baseH/2, baseW, baseH, 5); ctx.fill();
    ctx.lineWidth = 1.2; ctx.strokeStyle = 'rgba(30,50,90,0.45)'; ctx.stroke();
    ctx.fillStyle = '#c0c0c0';
    roundRect(ctx, 6 - recoil, -gap/2 - barrelH/2, barrelLen, barrelH, 3); ctx.fill(); ctx.stroke();
    roundRect(ctx, 6 - recoil,  gap/2 - barrelH/2, barrelLen, barrelH, 3); ctx.fill(); ctx.stroke();
    ctx.restore();
  }
  ctx.restore(); // ship

  // scan arrows pointing to stations
  if(warp.state !== 'active'){
    const shieldR = Math.max(ship.w, ship.h) * 0.6;
    for(const a of scanArrows){
      const st = a.target;
      const dx = st.x - ship.pos.x;
      const dy = st.y - ship.pos.y;
      const ang = Math.atan2(dy, dx);
      const baseR = shieldR + 10;
      const ax = ship.pos.x + Math.cos(ang) * baseR;
      const ay = ship.pos.y + Math.sin(ang) * baseR;
      const s = worldToScreen(ax, ay, cam);
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(ang);
      const size = 18 * camera.zoom;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(120,200,255,0.9)';
      ctx.moveTo(0, -size*0.5);
      ctx.lineTo(size, 0);
      ctx.lineTo(0, size*0.5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      const tx = ship.pos.x + Math.cos(ang) * (baseR + 14);
      const ty = ship.pos.y + Math.sin(ang) * (baseR + 14);
      const ts = worldToScreen(tx, ty, cam);
      ctx.save();
      ctx.fillStyle = '#dfe7ff';
      ctx.font = `${12*camera.zoom}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${Math.round(Math.hypot(dx,dy))}u`, ts.x, ts.y);
      ctx.restore();
    }
  }

  // Particles typu "flash" na samym wierzchu
  {
    let drawn = 0;
    for (let i = particles.length - 1; i >= 0 && drawn < MAX_PARTICLES_DRAW; i--){
      const p = particles[i];
      if (!p.flash) continue;
      drawn++;
      const s = worldToScreen(p.pos.x, p.pos.y, cam);
      const t = clamp(1 - p.age/p.life, 0, 1);
      ctx.globalAlpha = t;
      ctx.save();
      ctx.shadowBlur = 20 * camera.zoom * (p.size/2);
      let shadowColor = p.color;
      if(p.color === '#bfe7ff') shadowColor = 'rgba(120,200,255,0.9)';
      if(p.color === '#ffd8c4') shadowColor = 'rgba(255,180,120,0.9)';
      if(p.color === '#7CFF7C' || p.color === '#a8ff9a') shadowColor = 'rgba(120,255,140,0.95)';
      if(p.color === '#ffffff') shadowColor = 'rgba(255,255,255,0.95)';
      ctx.shadowColor = shadowColor;
      ctx.beginPath(); ctx.fillStyle = p.color;
      ctx.arc(s.x, s.y, (p.size * 3) * camera.zoom, 0, Math.PI*2); ctx.fill();
      ctx.restore();
      ctx.beginPath(); ctx.fillStyle = p.color;
      ctx.arc(s.x, s.y, p.size * camera.zoom, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // HUD
  ctx.fillStyle = '#dfe7ff'; ctx.font = '12px monospace';
  ctx.fillText(`HP: ${Math.round(ship.hull.val)}/${ship.hull.max}`, 12, H-100);
  ctx.fillText(`Shield: ${Math.round(ship.shield.val)}/${ship.shield.max}`, 12, H-84);
  const warpText = warp.state==='active' ? `ACTIVE`
                  : warp.state==='charging' ? `CHARGING ${(Math.min(1,warp.charge/warp.chargeTime)*100).toFixed(0)}%`
                  : 'READY';
  ctx.fillText(`Warp: ${warpText}`, 12, H-68);
  const fw = 200, fh = 10, ffrac = warp.fuel/warp.fuelMax;
  ctx.strokeStyle = 'rgba(255,255,255,0.14)'; ctx.strokeRect(12-1, H-52-fh, fw+2, fh+2);
  ctx.fillStyle = '#60a5fa'; ctx.fillRect(12, H-52-fh, fw*ffrac, fh);
  ctx.fillStyle = '#dfe7ff'; ctx.fillText(`${warp.fuel.toFixed(1)}s / ${warp.fuelMax}s`, 12 + fw + 8, H-42-fh);
  const boostText = boost.state==='charging' ? `CHARGING ${(Math.min(1,boost.charge/boost.chargeTime)*100).toFixed(0)}%` : 'READY';
  ctx.fillText(`Boost: ${boostText} (${boost.fuel.toFixed(1)}/${boost.fuelMax})`, 12, H-44);
  const railTimerHUD = Math.min(rail.cd[0], rail.cd[1]);
  ctx.fillText(`Rail: ${railTimerHUD>0?railTimerHUD.toFixed(2)+'s':'READY'}  Special: ${ship.special.cooldownTimer>0?ship.special.cooldownTimer.toFixed(1)+'s':'READY'}`, 12, H-28);

  // rocket ammo
  const bw = 160, bh = 10;
  const ammoFrac = rocketAmmo / ROCKET_AMMO_MAX;
  ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.strokeRect(12-1, H-12-bh-12, bw+2, bh+2);
  ctx.fillStyle = '#3b82f6'; ctx.fillRect(12, H-12-bh-12, bw*ammoFrac, bh);
  ctx.fillStyle = '#dfe7ff'; ctx.fillText(`Rockets: ${rocketAmmo}`, 12 + bw + 8, H-12-bh-6-12);

  if(showMap) drawSectorMap();
  renderStationUI();
  mouse.click=false;
}

function drawSectorMap(){
  const mapW = 600;
  const mapH = Math.round(mapW * WORLD.h / WORLD.w);
  const x0 = (W - mapW) / 2;
  const y0 = (H - mapH) / 2;
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = 'rgba(26,26,26,0.8)';
  ctx.fillRect(x0, y0, mapW, mapH);
  ctx.strokeStyle = '#dfe7ff';
  ctx.lineWidth = 2;
  ctx.strokeRect(x0, y0, mapW, mapH);
  const sx = mapW / WORLD.w;
  const sy = mapH / WORLD.h;

  ctx.fillStyle = '#ffd966';
  ctx.beginPath();
  ctx.arc(x0 + SUN.x * sx, y0 + SUN.y * sy, 6, 0, Math.PI*2);
  ctx.fill();

  ctx.fillStyle = '#60a5fa';
  for(const st of stations){
    ctx.beginPath();
    ctx.arc(x0 + st.x * sx, y0 + st.y * sy, 4, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.arc(x0 + ship.pos.x * sx, y0 + ship.pos.y * sy, 4, 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

// =============== Helpers ===============
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
function roundRectScreen(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

function screenToWorld(sx, sy){
  return { x: ship.pos.x + (sx - W/2)/camera.zoom, y: ship.pos.y + (sy - H/2)/camera.zoom };
}

// --- Minimal UI helpers ---
let uiLayout = {x:0,y:0,w:0,line:0};
function hudBeginPanel(){
  const w = 360, h = 300;
  uiLayout = { x:(W-w)/2, y:(H-h)/2, w, line:32 };
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.6)';
  ctx.fillRect(uiLayout.x, uiLayout.y, w, h);
  ctx.translate(uiLayout.x, uiLayout.y);
}
function hudEndPanel(){ ctx.restore(); }
function hudTabs(tabs, active){
  const tabW = uiLayout.w / tabs.length;
  ctx.fillStyle='rgba(22,22,40,0.8)';
  ctx.fillRect(0,0,uiLayout.w,24);
  ctx.textBaseline='top';
  tabs.forEach((t,i)=>{
    ctx.fillStyle = t===active?'#dfe7ff':'#777';
    ctx.fillText(t, i*tabW+6, 6);
  });
  uiLayout.line = 40;
}
function uiTitle(text){
  ctx.fillStyle='#dfe7ff';
  ctx.fillText(text,8,uiLayout.line);
  uiLayout.line += 24;
}
function section(text){ uiTitle(text); }
function uiRowButton(label, btn){
  const y = uiLayout.line;
  ctx.fillStyle='#dfe7ff';
  ctx.fillText(label,8,y+4);
  const bw=80,bh=20,bx=uiLayout.w-bw-8,by=y;
  const over = mouse.x>=uiLayout.x+bx && mouse.x<=uiLayout.x+bx+bw && mouse.y>=uiLayout.y+by && mouse.y<=uiLayout.y+by+bh;
  ctx.fillStyle=over?'#3b82f6':'#1e3a8a';
  ctx.fillRect(bx,by,bw,bh);
  ctx.fillStyle='#fff';
  ctx.fillText(btn,bx+8,by+4);
  uiLayout.line += bh+8;
  return over && mouse.click;
}
function toast(msg){ console.log(msg); }
function applyShipStats(stats){
  if(stats.hp && ship.hull){ ship.hull.max*=stats.hp; ship.hull.val=ship.hull.max; }
  if(stats.speed){ ship.speedMod = (ship.speedMod||1) * stats.speed; }
  if(stats.cargo){ ship.cargoCapacity = (ship.cargoCapacity||1) * stats.cargo; }
}

// init
const loadingEl = document.getElementById('loading');
function startGame(){
  initStars(true);
  initNPCs();
  for(let i=0;i<120;i++) npcStep(PHYS_DT);
  loadingEl.style.display = 'none';
  lastTime = performance.now();
  requestAnimationFrame(loop);
  console.log('Gwiazdy: proceduralne kafelki 1024px na całej mapie. Silnik: warkocz jonowy, dopalacz: wiązka fotonów.');
}
setTimeout(startGame, 500);
</script>
</body>
</html>
