<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Space Survivors — gwiazdy na całej mapie + duży silnik plazmowy</title>
<style>
  html,body{height:100%;margin:0;background:#030417;color:#dfe7ff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  #ui{position:absolute;left:12px;top:12px;z-index:20;background:rgba(8,10,20,0.6);padding:10px;border-radius:8px;backdrop-filter:blur(6px)}
  canvas{display:block;width:100vw;height:100vh}
  .stat{font-family:monospace;font-size:13px}
  small{color:#a8b4d9}
  #loading{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#030417;z-index:50;color:#dfe7ff;font-size:32px;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
</style>
</head>
<body>
  <div id="ui">
    <div><strong>Space Survivors — gwiazdy na całej mapie + duży silnik plazmowy</strong></div>
    <div class="stat">Czas gry: <span id="game-time">00:00</span></div>
    <div class="stat">W — ciąg (duży silnik plazmowy) · Q/E — strafe · A/D — obrót</div>
    <div class="stat">LPM — rail (A→B, A→B) · PPM — boczne rakiety · F — superbroń · SHIFT — warp · SPACJA — dopalacz</div>
    <div style="margin-top:6px"><small>Gwiazdy są proceduralne w całej galaktyce. Silnik: niebieski exhaust + krótki ślad przy ruchu.</small></div>
  </div>
<canvas id="c"></canvas>
<div id="loading">Ładowanie...</div>

<script type="importmap">
{
  "imports": {
    "three": "./node_modules/three/build/three.module.js",
    "three/addons/": "./node_modules/three/examples/jsm/"
  }
}
</script>

<script type="module">
  import * as THREE from "three";
  import { EffectComposer }  from "three/addons/postprocessing/EffectComposer.js";
  import { RenderPass }      from "three/addons/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
  import { createShortNeedleExhaust, createWarpExhaustBlue } from "./Engineeffects.js";
  window.THREE = THREE;
  window.EffectComposer  = EffectComposer;
  window.RenderPass      = RenderPass;
  window.UnrealBloomPass = UnrealBloomPass;
  window.createShortNeedleExhaust = createShortNeedleExhaust;
  window.createWarpExhaustBlue = createWarpExhaustBlue;
</script>

<script src="planet3d.proc.js"></script>

<script>
// =============== Canvas & utils ===============
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth, H = canvas.height = innerHeight;
window.addEventListener('resize', ()=>{
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  initStars(true);
  // opcjonalny resize dla modułu 3D, jeśli go wystawiasz
  if (typeof resizePlanets3D === 'function') resizePlanets3D();
});

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const add = (a,b)=>({x:a.x+b.x,y:a.y+b.y});
const mul = (v,s)=>({x:v.x*s,y:v.y*s});
const len = v=>Math.hypot(v.x,v.y);
const norm = v=>{ const L=len(v); return L?{x:v.x/L,y:v.y/L}:{x:0,y:0}; };
function rotate(local,a){ const c=Math.cos(a), s=Math.sin(a); return {x: local.x*c - local.y*s, y: local.x*s + local.y*c}; }
function rotateInv(world,a){ return rotate(world, -a); }

// =============== Game time (1 min real = 1 h game) ===============
const TIME_SCALE = 60; // game seconds per real second
let gameTime = 0; // seconds
const gameTimeEl = document.getElementById('game-time');
function formatGameTime(sec){
  const t = Math.floor(sec);
  const h = Math.floor(t / 3600) % 24;
  const m = Math.floor((t % 3600) / 60);
  return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
}
function wrapAngle(a){ while(a>Math.PI) a-=2*Math.PI; while(a<-Math.PI) a+=2*Math.PI; return a; }
function interpAngleShort(prev,curr,t){ const d = wrapAngle(curr - prev); return wrapAngle(prev + d * t); }
function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function leadTarget(shooter, shooterVel, target, speed){
  const tx = target.x, ty = target.y;
  const tvx = target.vx || 0, tvy = target.vy || 0;
  const rx = tx - shooter.x, ry = ty - shooter.y;
  const rvx = tvx - shooterVel.x, rvy = tvy - shooterVel.y;
  const a = rvx*rvx + rvy*rvy - speed*speed;
  const b = 2*(rx*rvx + ry*rvy);
  const c = rx*rx + ry*ry;
  let t = 0;
  if(Math.abs(a) < 1e-6){
    if(Math.abs(b) > 1e-6) t = -c / b;
  } else {
    const disc = b*b - 4*a*c;
    if(disc >= 0){
      const sqrtDisc = Math.sqrt(disc);
      const t1 = (-b - sqrtDisc)/(2*a);
      const t2 = (-b + sqrtDisc)/(2*a);
      t = Math.min(t1, t2);
      if(t < 0) t = Math.max(t1, t2);
    }
  }
  if(!isFinite(t) || t < 0) t = 0;
  return { x: tx + tvx*t, y: ty + tvy*t };
}

// =============== World / camera ===============
const WORLD = { w: 120000, h: 80000 };
const camera = {
  zoom: 1.0,
  defaultZoom: 1.0,
  altZoom: 0.7,
  minZoom: 0.35,
  maxZoom: 3.2,
  wheelSpeed: 0.002,
  shakeMag: 0,
  shakeTime: 0,
  shakeDur: 0,
  addShake(mag, dur){ this.shakeMag = mag; this.shakeTime = dur; this.shakeDur = dur; }
};

// =============== Ship ===============
const ship = {
  w:100, h:300, mass:140,
  pos:{x:WORLD.w/2, y:WORLD.h/2}, vel:{x:0,y:0},
  angle:0, angVel:0, inertia:null,
  linearDamping:0.9, angularDamping:1.6,
  engines:{},
  turret:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
           recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  turret2:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
            recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  turret3:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
            recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  turret4:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
            recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  shield:{ max:120, val:120, regenRate:6, regenDelay:2, regenTimer:0 },
  hull:{ max:1000, val:1000 },
  special:{ cooldown:10, cooldownTimer:0 },
  input:{ thrustX:0, thrustY:0, aimX:0, aimY:0 }
};
ship.inertia = (1/12) * ship.mass * ((ship.w*ship.w)+(ship.h*ship.h));
const BASE_SHIP = {
  hullMax: ship.hull.max,
  cargoCap: 20,
  maxSpeed: 0
};
(function configureShip(){
  const hw = ship.w/2, hh = ship.h/2;
  // Jeden DUŻY engine na środku rufy (moc ≈ suma poprzednich)
  ship.engines.main = { offset:{x:0, y: Math.round(hh-8)}, maxThrust: 12800 };

  ship.engines.sideLeft  =  { offset:{x:-Math.round(hw-8), y: 0}, maxThrust:3000 };
  ship.engines.sideRight =  { offset:{x: Math.round(hw-8), y: 0}, maxThrust:3000 };
  ship.engines.torqueLeft  =  { offset:{x:0,y:-Math.round(hh-8)}, maxThrust:3000 };
  ship.engines.torqueRight =  { offset:{x:0,y: Math.round(hh-8)}, maxThrust:3000 };

  ship.sideGunsLeft = []; ship.sideGunsRight = [];
  const gunsPer = 8, inset=6, margin=12;
  for(let i=0;i<gunsPer;i++){
    const t = gunsPer===1?0.5:(i/(gunsPer-1));
    const yLocal = -hh + margin + t * ((hh - margin) - (-hh + margin));
    ship.sideGunsLeft.push({ x: -Math.round(hw - inset), y: Math.round(yLocal) });
    ship.sideGunsRight.push({ x:  Math.round(hw - inset), y: Math.round(yLocal) });
  }
  const podW = 30, podH = 60;
  const podX = Math.round(hw + podW/2 - 6);
  const podY = Math.round(hh - podH/2 - 20);
  ship.pods = [
    { offset:{ x: -podX, y:  podY }, w: podW, h: podH },
    { offset:{ x:  podX, y:  podY }, w: podW, h: podH },
    { offset:{ x: -podX, y: -podY }, w: podW, h: podH },
    { offset:{ x:  podX, y: -podY }, w: podW, h: podH }
  ];
  ship.turret.offset  = { x: -podX, y:  podY };
  ship.turret2.offset = { x:  podX, y:  podY };
  ship.turret3.offset = { x: -podX, y: -podY };
  ship.turret4.offset = { x:  podX, y: -podY };

  const ciwsOff = 20;
  ship.ciws = [
    { offset:{ x:-ciwsOff, y:-ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x: ciwsOff, y:-ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x:-ciwsOff, y: ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x: ciwsOff, y: ciwsOff }, angle:0, angVel:0, cd:0 }
  ];
})();

// =============== Proceduralne gwiazdy na CAŁEJ MAPIE ===============
const STAR_CELL = 1024;
const starCells = new Map(); // key "ix,iy" -> {stars:[...] , lastSeen: frameId}
let frameId = 0;

function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
function key(ix,iy){ return ix+','+iy; }

function generateCell(ix,iy){
  const seed = ((ix*73856093) ^ (iy*19349663) ^ 0x9e3779b9) >>> 0;
  const rnd = mulberry32(seed);
  const count = 14 + Math.floor(rnd()*10); // 14–23 gwiazdy na komórkę
  const stars = [];
  for(let i=0;i<count;i++){
    const x = ix*STAR_CELL + rnd()*STAR_CELL;
    const y = iy*STAR_CELL + rnd()*STAR_CELL;
    const size = 0.7 + rnd()*2.1;
    const bright = 0.35 + rnd()*0.65;
    stars.push({x,y,size,bright});
  }
  const obj = { stars, lastSeen: frameId };
  starCells.set(key(ix,iy), obj);
  return obj;
}
function getCell(ix,iy){
  const k = key(ix,iy);
  let c = starCells.get(k);
  if(!c) c = generateCell(ix,iy);
  c.lastSeen = frameId;
  return c;
}
function pruneStarCells(){
  if(starCells.size <= 600) return;
  const arr = [...starCells.entries()];
  arr.sort((a,b)=>a[1].lastSeen - b[1].lastSeen);
  const toDrop = arr.slice(0, Math.max(0, arr.length - 600));
  for(const [k] of toDrop) starCells.delete(k);
}
function initStars(reset=false){
  if(reset){ starCells.clear(); }
}

// =============== Słońce, planety i stacje ===============
const SUN = { x: WORLD.w/2, y: WORLD.h/2, r: 200 };

const PLANET_TYPES = {
  TERRAN: 'terran',
  VOLCANIC: 'volcanic',
  FROZEN: 'frozen',
  GAS: 'gas',
  BARREN: 'barren'
};

const PLANET_DATA = (() => {
  const NUM_PLANETS = 7;
  const TYPES = [
    PLANET_TYPES.VOLCANIC,
    PLANET_TYPES.VOLCANIC,
    PLANET_TYPES.TERRAN,
    PLANET_TYPES.TERRAN,
    PLANET_TYPES.BARREN,
    PLANET_TYPES.GAS,
    PLANET_TYPES.FROZEN
  ];
  const BASE_ORBIT = 7000;
  const list = [];
  for (let i = 0; i < NUM_PLANETS; i++) {
    const orbitRadius = BASE_ORBIT * (i + 1);
    const angle = Math.random() * Math.PI * 2;
    const au = i + 1;
    const periodHours = 24 * 365 * Math.pow(au, 1.5); // Kepler scaling
    const speed = (2 * Math.PI) / (periodHours * 3600); // rad per game second
    const r = (48 + Math.floor(Math.random() * 36)) * 3; // powiększone ~3×
    list.push({ id: i, orbitRadius, angle, speed, r, type: TYPES[i], x: 0, y: 0 });
  }
  return list;
})();

let planets = PLANET_DATA.map(p => {
  p.x = SUN.x + Math.cos(p.angle) * p.orbitRadius;
  p.y = SUN.y + Math.sin(p.angle) * p.orbitRadius;
  return p;
});

let stations = planets.map(pl => {
  const orbitRadius = pl.r + 300;
  const angle = Math.random() * Math.PI * 2;
  const periodHours = 12; // stacja okrąża planetę w 12h
  const speed = (2 * Math.PI) / (periodHours * 3600);
  const x = pl.x + Math.cos(angle) * orbitRadius;
  const y = pl.y + Math.sin(angle) * orbitRadius;
  return { id: pl.id, planet: pl, orbitRadius, angle, speed, r: 40, x, y };
});

// oznacz stacje wewnątrz pasa asteroid
(() => {
  if (planets[3] && planets[4]) {
    const beltRadius = (planets[3].orbitRadius + planets[4].orbitRadius) / 2;
    for (const st of stations) st.inner = st.orbitRadius < beltRadius;
  } else {
    for (const st of stations) st.inner = true;
  }
})();

// Warp routes between stations
let warpRoutes = {};
function initWarpRoutes(){
  warpRoutes = {};
  for (const from of stations){
    for (const to of stations){
      if (from.id === to.id) continue;
      if (from.inner !== to.inner) continue;
      const sx = from.x + (to.x - from.x) * 0.2;
      const sy = from.y + (to.y - from.y) * 0.2;
      const ex = from.x + (to.x - from.x) * 0.8;
      const ey = from.y + (to.y - from.y) * 0.8;
      const dx = ex - sx, dy = ey - sy;
      const dist = Math.hypot(dx, dy) || 1;
      warpRoutes[from.id + '-' + to.id] = {
        from: from.id, to: to.id,
        start: { x: sx, y: sy, queues: [[], []] },
        end:   { x: ex, y: ey },
        dir:   { x: dx / dist, y: dy / dist },
        length: dist
      };
    }
  }
}
function getWarpRoute(fromId, toId){ return warpRoutes[fromId + '-' + toId]; }
initWarpRoutes();

let npcs = [];
const MISSION_NPCS = [];
let mercMission = null;

function spawnMissionFighter(pos){
  const n = makeNPCBase(pos, { hp: 120, accel: 90, maxSpeed: 540, turn: 4.0, radius: 22 });
  n.type = 'pirate';
  n.color = '#ff5533';
  n.ai = function(dt){
    chaseEvadeAI(n, ship, { strafe:true });
  };
  n.mission = true;
  npcs.push(n);
}

function makeNPCBase(pos, stats){
  return {
    x: pos.x, y: pos.y,
    vx: 0, vy: 0,
    angle: 0,
    hp: stats.hp || 100,
    maxHp: stats.hp || 100,
    accel: stats.accel || 0,
    maxSpeed: stats.maxSpeed || 0,
    turn: stats.turn || 0,
    radius: stats.radius || 20,
    dead: false,
    ai: null,
    weapons: {}
  };
}

function makeRailgun(cfg){ return { ...cfg }; }
function makeRocketPod(cfg){ return { ...cfg }; }
function makeGatling(cfg){ return { ...cfg }; }

// ——— NO-OPY, aby uniknąć ReferenceError przy ewentualnym użyciu tych spawnerów
function useRailPair(){ /* no-op */ }
function useRocketsPair(){ /* no-op */ }
function useCIWSPair(){ /* no-op */ }
function maybeFireRockets(){ /* no-op */ }

function spawnInterceptor(pos){
  const n = makeNPCBase(pos, { hp: 160, accel: 90, maxSpeed: 540, turn: 4.0, radius: 22 });
  n.type = 'interceptor';
  n.ai = function(dt){
    chaseEvadeAI(n, ship, { strafe:true, dodgeRails:true, rocketBurst:false });
  };
  MISSION_NPCS.push(n);
}

function spawnDestroyer(pos){
  const n = makeNPCBase(pos, { hp: 1200, accel: 40, maxSpeed: 260, turn: 1.2, radius: 60 });
  n.type = 'destroyer';
  n.weapons = {
    railL: makeRailgun({ dmg: 85, cooldown: 0.85, spread: 0.004 }),
    railR: makeRailgun({ dmg: 85, cooldown: 0.85, spread: 0.004 }),
    rocketL: makeRocketPod({ salvo: 3, cooldown: 2.8 }),
    rocketR: makeRocketPod({ salvo: 3, cooldown: 2.8 })
  };
  n.ai = function(dt){
    battleshipAI(n, ship);
    useRailPair(n, ship);
    useRocketsPair(n, ship);
  };
  MISSION_NPCS.push(n);
}

function spawnGunship(pos){
  const n = makeNPCBase(pos, { hp: 520, accel: 60, maxSpeed: 360, turn: 2.4, radius: 40 });
  n.type = 'gunship';
  n.weapons = {
    ciwsL: makeGatling({ dps: 65, heat: 0.3 }),
    ciwsR: makeGatling({ dps: 65, heat: 0.3 }),
    rockets: makeRocketPod({ salvo: 2, cooldown: 3.2 })
  };
  n.ai = function(dt){
    dogfightAI(n, ship);
    useCIWSPair(n, ship);
    maybeFireRockets(n, ship);
  };
  MISSION_NPCS.push(n);
}
function getStationById(id){ return stations.find(s=>s.id===id); }
function pickNextStation(npcId, lastStationId){
  const last = getStationById(lastStationId) || stations[0];
  const sameSphere = stations.filter(s => s.inner === last.inner);
  let idx = Math.floor(Math.random()*sameSphere.length);
  if(sameSphere.length>1 && sameSphere[idx].id === lastStationId) idx = (idx+1)%sameSphere.length;
  return sameSphere[idx].id;
}
const NPC_TYPES = {
  'freighter-small':  { radius:10, speed:60, hp:100, color:'#8ab4d6', weapon:null },
  'freighter-medium': { radius:15, speed:55, hp:150, color:'#769cb8', weapon:null },
  'freighter-large':  { radius:25, speed:50, hp:200, color:'#5d829c', weapon:null },
  'freighter-capital':{ radius:48, speed:45, hp:400, color:'#45667d', weapon:null },
  'police':           { radius:24, speed:100, hp:200, color:'#44aaff', weapon:'railgun' },
  'civilian-small':   { radius:6, speed:100, hp:10, color:'#cccccc', weapon:null },
  'civilian-large':   { radius:12, speed:80, hp:50, color:'#bbbbbb', weapon:null },
  'guard':            { radius:20, speed:95, hp:100, color:'#ff9933', weapon:'gun' },
  'mercenary':        { radius:25, speed:95, hp:100, color:'#ff6633', weapon:'gun' }
};

// ——— GLOBALNY spawner do użycia poza initNPCs (np. w physicsStep)
let NPC_SEQ = 1_000_000;
function spawnNPCDirect(type, start, targetId){
  const cfg = NPC_TYPES[type]; if(!cfg) return null;
  const npc = {
    id: NPC_SEQ++,
    type, group: null,
    x: start.x + (Math.random()-0.5)*40,
    y: start.y + (Math.random()-0.5)*40,
    vx:0, vy:0,
    angle: Math.random()*Math.PI*2,
    target: targetId,
    speed: cfg.speed, radius: cfg.radius,
    hp: cfg.hp, maxHp: cfg.hp, color: cfg.color, weapon: cfg.weapon,
    dead:false, respawnTimer:0, fade:1, docking:false, lastStation:start.id,
    leader:null, orbitAngle:0, orbitRadius:0,
    warpRoute: null,
    phase: 'direct',
    lane: Math.floor(Math.random()*2)
  };
  npcs.push(npc);
  return npc;
}

function initNPCs(){
  npcs = [];
  let npcId = 0, groupCounter = 0;
  const desiredCount = 1000;
  const ESCORT_RADIUS = 80;

  function spawnNPC(type, start, targetId, group, opts = {}){
    if(npcs.length >= desiredCount) return null;
    const cfg = NPC_TYPES[type];
    const x = start.x + (Math.random()-0.5)*40;
    const y = start.y + (Math.random()-0.5)*40;
    const route = (opts.direct ? null : getWarpRoute(start.id, targetId));
    const npc = {
      id:npcId++, type, group,
      x, y,
      vx:0, vy:0, angle:Math.random()*Math.PI*2,
      target: targetId, speed:cfg.speed, radius:cfg.radius,
      hp:cfg.hp, maxHp:cfg.hp, color:cfg.color, weapon:cfg.weapon,
      dead:false, respawnTimer:0, fade:1, docking:false, lastStation:start.id,
      leader:null, orbitAngle:0, orbitRadius:0,
      warpRoute: route,
      phase: route ? 'toGate' : 'direct',
      lane: Math.floor(Math.random()*2)
    };
    npcs.push(npc);
    return npc;
  }

  // --- spawny „inner” ---
  function spawnFreighterEscortGroup(fType, escortMin, escortMax){
    const inner = stations.filter(s=>s.inner);
    if(!inner.length) return;
    const start = inner[Math.floor(Math.random()*inner.length)];
    const targetId = pickNextStation(npcId, start.id);
    const group = groupCounter++;
    const leader = spawnNPC(fType, start, targetId, group);
    if(!leader) return;
    const escortCount = escortMin + Math.floor(Math.random()*(escortMax-escortMin+1));
    for(let i=0;i<escortCount;i++){
      const eType = Math.random()<0.5 ? 'guard':'mercenary';
      const angle = (i / Math.max(1,escortCount)) * Math.PI * 2;
      const escort = spawnNPC(eType, start, targetId, group);
      if(!escort) continue;
      escort.leader = leader.id;
      escort.orbitAngle = angle;
      escort.orbitRadius = leader.radius + ESCORT_RADIUS;
      escort.x = leader.x + Math.cos(angle) * escort.orbitRadius;
      escort.y = leader.y + Math.sin(angle) * escort.orbitRadius;
    }
  }
  function spawnCivilianGroup(min, max){
    const inner = stations.filter(s=>s.inner);
    if(!inner.length) return;
    const start = inner[Math.floor(Math.random()*inner.length)];
    const targetId = pickNextStation(npcId, start.id);
    const group = groupCounter++;
    spawnNPC('freighter-small', start, targetId, group);
    const count = min + Math.floor(Math.random()*(max-min+1));
    for(let i=0;i<count;i++){
      const type = Math.random()<0.5 ? 'civilian-small':'civilian-large';
      spawnNPC(type, start, targetId, group);
    }
  }
  function spawnPolicePatrol(min, max){
    const inner = stations.filter(s=>s.inner);
    if(!inner.length) return;
    const start = inner[Math.floor(Math.random()*inner.length)];
    const targetId = pickNextStation(npcId, start.id);
    const group = groupCounter++;
    const count = min + Math.floor(Math.random()*(max-min+1));
    for(let i=0;i<count;i++) spawnNPC('police', start, targetId, group);
  }

  // --- helpery sfer ---
  const innerStations = stations.filter(s=>s.inner);
  const outerStations = stations.filter(s=>!s.inner);
  const pickFrom = arr => arr[Math.floor(Math.random()*arr.length)];

  // --- INNER: limit do 50% puli ---
  while(innerStations.length && npcs.length < desiredCount * 0.5){
    spawnFreighterEscortGroup('freighter-small',0,0);
    spawnFreighterEscortGroup('freighter-medium',0,0);
    spawnCivilianGroup(1,2);
    spawnPolicePatrol(1,2);
  }

  // --- OUTER spawny ---
  function spawnOuterFreighterEscortGroup(fType, escortMin, escortMax){
    if(!outerStations.length) return;
    const start = pickFrom(outerStations);
    const same = outerStations.filter(s=>s.id!==start.id);
    const targetId = (same.length ? pickFrom(same) : start).id;
    const group = groupCounter++;
    const leader = spawnNPC(fType, start, targetId, group);
    if(!leader) return;
    const escortCount = escortMin + Math.floor(Math.random()*(escortMax-escortMin+1));
    for(let i=0;i<escortCount;i++){
      const eType = Math.random()<0.5 ? 'guard':'mercenary';
      const angle = (i / Math.max(1,escortCount)) * Math.PI * 2;
      const escort = spawnNPC(eType, start, targetId, group);
      if(!escort) continue;
      escort.leader = leader.id;
      escort.orbitAngle = angle;
      escort.orbitRadius = leader.radius + ESCORT_RADIUS;
      escort.x = leader.x + Math.cos(angle) * escort.orbitRadius;
      escort.y = leader.y + Math.sin(angle) * escort.orbitRadius;
    }
  }
  function spawnOuterCivilianGroup(min, max){
    if(!outerStations.length) return;
    const start = pickFrom(outerStations);
    const others = outerStations.filter(s=>s.id!==start.id);
    const targetId = (others.length?pickFrom(others):start).id;
    const group = groupCounter++;
    spawnNPC('freighter-small', start, targetId, group);
    const count = min + Math.floor(Math.random()*(max-min+1));
    for(let i=0;i<count;i++){
      const type = Math.random()<0.5 ? 'civilian-small':'civilian-large';
      spawnNPC(type, start, targetId, group);
    }
  }
  function spawnOuterPolicePatrol(min, max){
    if(!outerStations.length) return;
    const start = pickFrom(outerStations);
    const others = outerStations.filter(s=>s.id!==start.id);
    const targetId = (others.length?pickFrom(others):start).id;
    const group = groupCounter++;
    const count = min + Math.floor(Math.random()*(max-min+1));
    for(let i=0;i<count;i++) spawnNPC('police', start, targetId, group);
  }

  if(outerStations.length){
    while(npcs.length < desiredCount){
      spawnOuterFreighterEscortGroup('freighter-medium',0,0);
      spawnOuterFreighterEscortGroup('freighter-large',0,0);
      spawnOuterCivilianGroup(1,2);
      spawnOuterPolicePatrol(1,2);
    }
  } else {
    while(npcs.length < desiredCount){
      spawnFreighterEscortGroup('freighter-small',0,0);
      spawnFreighterEscortGroup('freighter-medium',0,0);
      spawnCivilianGroup(1,2);
      spawnPolicePatrol(1,2);
    }
  }

  window._crossSphereTimer = 0;
}

// Ensure Three.js modules are loaded before initializing 3D objects
window.addEventListener('DOMContentLoaded', () => {
  initPlanets3D(planets, SUN);
});

// =============== Bullets & effects ===============
const bullets = [];
const particles = [];
const shockwaves = [];
const MAX_PARTICLES = 8000;
const MAX_PARTICLES_DRAW = 4500;

function pushParticleSafe(p){
  if (particles.length < MAX_PARTICLES) particles.push(p);
}

function spawnParticle(pos, vel, life, color, size, flash){
  pushParticleSafe({
    pos:{...pos}, vel:{...vel}, life, age:0,
    color: color||'#ffb677', size: size||2, flash: !!flash
  });
}
function spawnExplosionPlasma(x,y,scale=1){
  const count = Math.round(22 * scale);
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 120 + Math.random()*260 * scale;
    spawnParticle({x,y}, {x:Math.cos(a)*s, y:Math.sin(a)*s}, 0.45 + Math.random()*0.5, '#7CFF7C', 2 + Math.random()*3, true);
  }
}
function spawnRailHitEffect(x,y,scale=1){
  for(let i=0;i<12 * scale;i++){
    const a = Math.random()*Math.PI*2;
    const s = 80 + Math.random()*220 * scale;
    spawnParticle({x,y}, {x:Math.cos(a)*s, y:Math.sin(a)*s}, 0.25 + Math.random()*0.35, '#bfe7ff', 1 + Math.random()*2, true);
  }
  spawnParticle({x,y}, {x:0,y:0}, 0.12, '#ffffff', 6 * scale, true);
}
function spawnDefaultHit(x,y,scale=1){
  for(let i=0;i<14*scale;i++){
    const a = Math.random()*Math.PI*2;
    const s = 80 + Math.random()*160 * scale;
    spawnParticle({x,y}, {x:Math.cos(a)*s, y:Math.sin(a)*s}, 0.24 + Math.random()*0.36, '#ffb36b', 1 + Math.random()*2, true);
  }
  spawnParticle({x,y}, {x:0,y:0}, 0.08, '#ffffff', 4 * scale, true);
}

function spawnShockwave(x, y, opts = {}){
  shockwaves.push({
    x, y,
    r: opts.r || 20,
    maxR: opts.maxR || 800,
    w: opts.w || 8,
    life: 0,
    maxLife: opts.maxLife || 0.6,
    color: opts.color || 'rgba(180,200,255,'
  });
}

// =============== Station UI ===============
const STATIONS = stations;
let stationUI = {
  open:false,
  tab:'upgrades',
  station:null,
  cursorOver:false,
  hoverId:null,
  x:(W-450)/2,
  y:(H-520)/2,
  w:450,
  h:520,
  dragging:false,
  dragDX:0,
  dragDY:0
};

const OPTIONS = {
  vfx: { colorTempK: 8000, bloomGain: 1.1 },
  audio: { master: 0.8, sfx: 1.0, music: 0.7 },
  controls: { mouseSensitivity: 1.0 }
};
let OPTIONS_OPEN = false;

function stationUnderCursor(){
  const world = screenToWorld(mouse.x, mouse.y);
  for(const s of STATIONS){
    const d = Math.hypot(world.x - s.x, world.y - s.y);
    if(d < (s.r||120)) return s;
  }
  return null;
}

window.addEventListener('keydown', (e)=>{
  if(e.code==='Enter' && !stationUI.open){
    const s = stationUnderCursor();
    if(s){
      stationUI.open = true;
      stationUI.station = s;
      stationUI.tab='upgrades';
      stationUI.x = (W - stationUI.w) / 2;
      stationUI.y = (H - stationUI.h) / 2;
      stationUI.dragging = false;
      e.preventDefault();
    }
  }
  if(stationUI.open){
    if(e.code==='Escape'){ stationUI.open=false; stationUI.station=null; stationUI.dragging=false; }
    if(e.code==='Digit1') stationUI.tab='upgrades';
    if(e.code==='Digit2') stationUI.tab='trade';
    if(e.code==='Digit3') stationUI.tab='cantina';
    if(e.code==='Digit4') stationUI.tab='hangar';
  }
});

window.addEventListener('keydown', (e)=>{
  if(e.code==='KeyO' && !stationUI.open){ OPTIONS_OPEN = !OPTIONS_OPEN; }
});

function renderStationUI(){
  if(!stationUI.open) return;
  hudBeginPanel(stationUI.x, stationUI.y, stationUI.w, stationUI.h);
  hudTabs(['upgrades','trade','cantina','hangar'], stationUI.tab);
  if(stationUI.tab==='upgrades') renderUpgradesTab();
  if(stationUI.tab==='trade')    renderTradeTab();
  if(stationUI.tab==='cantina')  renderCantinaTab();
  if(stationUI.tab==='hangar')   renderHangarTab();
  hudEndPanel();
}

// --- Zakładki ---
const PLAYER = { credits: 1200, cargo: {}, shipId: 'starter', hull: 0.86 };
const BLUEPRINTS = {
  upgrades: [
    { id:'rail_cooler', name:'Chłodzenie raila', cost:600, apply(){ rail.heatCap *= 1.25; rail.coolRate *= 1.15; } },
    { id:'boost_core',  name:'Wzmocniony boost', cost:700, apply(){ boost.speed *= 1.15; boost.duration *= 1.1; } },
    { id:'agility',     name:'Zwrotność +',      cost:500, apply(){ ship.turnRate = (ship.turnRate||1)*1.12; } },
  ],
  ships: [
    { id:'scout', name:'Scout', cost:2500, stats:{ hp:0.8, speed:1.3, cargo:0.6 } },
    { id:'frigate', name:'Fregata', cost:4200, stats:{ hp:1.6, speed:0.85, cargo:1.4 } },
  ],
};

function renderUpgradesTab(){
  uiTitle('Ulepszenia statku');
  for(const u of BLUEPRINTS.upgrades){
    if(uiRowButton(`${u.name} — ${u.cost} cr`, 'Kup')){
      if(PLAYER.credits>=u.cost){ PLAYER.credits-=u.cost; u.apply(); toast('Zainstalowano: '+u.name); }
      else toast('Za mało kredytów');
    }
  }
}
const MARKET = {
  buy:{ ruda: 22, paliwo: 15, żywność: 8 },
  sell:{ ruda: 18, paliwo: 12, żywność: 6 }
};
function renderTradeTab(){
  uiTitle('Handel towarami');
  for(const [k,price] of Object.entries(MARKET.buy)){
    if(uiRowButton(`${k} — kup: ${price} cr`, 'Kup')){
      if(PLAYER.credits>=price){ PLAYER.credits-=price; PLAYER.cargo[k]=(PLAYER.cargo[k]||0)+1; }
    }
  }
  for(const [k,price] of Object.entries(MARKET.sell)){
    if(uiRowButton(`${k} — sprzedaj: ${price} cr`, 'Sprzedaj')){
      if((PLAYER.cargo[k]||0)>0){ PLAYER.cargo[k]-=1; PLAYER.credits+=price; }
    }
  }
}
function renderCantinaTab(){
  uiTitle('Kantyna');
  section('Misje najemnik');
  if(uiRowButton('Najemnik: piracka stacja', 'Przyjmij')){
    startMercenaryMission();
  }
  section('Misje żołnierz');
  if(uiRowButton('Wojna o terytorium (punkt kontrolny)', 'Dołącz')){
    startTerritoryWarMission();
  }
}
function renderHangarTab(){
  uiTitle('Hangar');
  if(uiRowButton(`Napraw kadłub (${Math.ceil((1-PLAYER.hull)*100)}% uszk.)`, 'Napraw')){
    const cost = Math.ceil((1-PLAYER.hull)*600);
    if(PLAYER.credits>=cost){ PLAYER.credits-=cost; PLAYER.hull=1.0; toast('Naprawiono kadłub.'); } else toast('Za mało kredytów');
  }
  section('Nowe statki');
  for(const s of BLUEPRINTS.ships){
    if(uiRowButton(`${s.name} — ${s.cost} cr`, 'Kup')){
      if(PLAYER.credits>=s.cost){ PLAYER.credits-=s.cost; PLAYER.shipId=s.id; applyShipStats(s.stats); toast('Zakupiono: '+s.name); }
      else toast('Za mało kredytów');
    }
  }
}
function startMercenaryMission(){
  if(mercMission) return;
  const beltRadius = (planets[3].orbitRadius + planets[4].orbitRadius) / 2;
  const angle = Math.random() * Math.PI * 2;
  const x = SUN.x + Math.cos(angle) * beltRadius;
  const y = SUN.y + Math.sin(angle) * beltRadius;
  const station = { id:'PIR', x, y, r:80, hp:10000, maxHp:10000, static:true, mission:true };
    stations.push(station);
  mercMission = { station, npcsSpawned:false };
  toast('Misja najemnik rozpoczęta');
}
function startTerritoryWarMission(){ toast('Dołączono do wojny terytorialnej'); }

function renderOptions(){
  if(!OPTIONS_OPEN) return;
  hudBeginPanel();
  uiTitle('Opcje');
  slider('VFX: temperatura (K)', 1000, 20000, 500, OPTIONS.vfx, 'colorTempK');
  slider('VFX: bloom', 0.2, 2.5, 0.05, OPTIONS.vfx, 'bloomGain');
  slider('Audio: master', 0, 1, 0.05, OPTIONS.audio, 'master');
  slider('Audio: SFX', 0, 1, 0.05, OPTIONS.audio, 'sfx');
  slider('Audio: muzyka', 0, 1, 0.05, OPTIONS.audio, 'music');
  slider('Mysz: czułość', 0.3, 2.0, 0.05, OPTIONS.controls, 'mouseSensitivity');
  hudEndPanel();
}

function spawnLaserBeam(start, end, width){
  pushParticleSafe({ beam:true, start:{...start}, end:{...end}, width, age:0, life:0.12 });
}

// =============== Input ===============
const input = { main:0, leftSide:0, rightSide:0, torque:0 };
const keys = {};
let showMap = false;
let PAUSED = false;
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  const k = e.key.toLowerCase();
  keys[k] = true;
  if(k === 'm') showMap = !showMap;
  if(e.key === ' '){
    if(boost.state==='idle' && boost.fuel>=boost.cost){ boost.state='charging'; boost.charge=0; }
  }
  if(k === 'x') triggerScanWave();
  if(k === 'r'){
    if(highlightedEnemies.length){
      lockedTargets = highlightedEnemies.filter(n=>!n.dead)
        .sort((a,b)=>Math.hypot(a.x-ship.pos.x,a.y-ship.pos.y) - Math.hypot(b.x-ship.pos.x,b.y-ship.pos.y));
      highlightTimer = 0;
      highlightedEnemies = [];
    } else {
      lockedTarget = scan.scanned || null;
    }
  }
  updateInput();
});
window.addEventListener('keyup', e=>{
  const k = e.key.toLowerCase();
  keys[k] = false;
  if(e.key === ' ' && boost.state==='charging'){ boost.state='idle'; boost.charge=0; }
  updateInput();
});
function updateInput(){
  input.main = keys['w']?1:0;
  input.leftSide  = keys['q']?1:0;
  input.rightSide = keys['e']?1:0;
  let torque = 0; if(keys['a']) torque -= 1; if(keys['d']) torque += 1; input.torque = torque;
  if(keys['f']) tryFireSpecial();
}

// targeting / scanning
const SCAN_TIME = 1.0;
const SCAN_RANGE = 10000;
const SCAN_VFX_SPEED = 4000;
const SCAN_ARROW_LIFE = 1.5;
const scan = { target:null, progress:0, scanned:null };
let lockedTarget = null;
let lockedTargets = [];
let highlightedEnemies = [];
let highlightTimer = 0;
const HIGHLIGHT_TIME = 3;
const HIGHLIGHT_RANGE = 2000;
const radarPings = [];
const scanWaves = [];
const scanArrows = [];
function spawnRadarPing(x,y){ radarPings.push({x,y,age:0,life:1}); }
function triggerScanWave(){
  const wave = {x:ship.pos.x,y:ship.pos.y,r:0,speed:SCAN_VFX_SPEED,max:SCAN_RANGE,hit:new Set()};
  scanWaves.push(wave);
  scanArrows.length = 0;
  const inRange = (n) => Math.hypot(n.x - ship.pos.x, n.y - ship.pos.y) <= HIGHLIGHT_RANGE;
  const armed = npcs.filter(n => !n.dead && n.weapon && inRange(n));
  highlightedEnemies = armed.length ? armed : npcs.filter(n => !n.dead && inRange(n));
  highlightTimer = HIGHLIGHT_TIME;
  for(const st of stations){
    const dist = Math.hypot(st.x - ship.pos.x, st.y - ship.pos.y);
    spawnRadarPing(st.x, st.y);
    if(dist <= SCAN_RANGE){
      scanArrows.push({target:st,age:0,life:SCAN_ARROW_LIFE});
      wave.hit.add(st);
    }
  }
}

const mouse = { x: W/2, y: H/2, left:false, right:false, click:false };
canvas.addEventListener('mousemove', e=>{
  mouse.x = e.clientX; mouse.y = e.clientY;
  if(stationUI.open && stationUI.dragging){
    stationUI.x = mouse.x - stationUI.dragDX;
    stationUI.y = mouse.y - stationUI.dragDY;
  }
});
canvas.addEventListener('mousedown', e=>{
  if(e.button===0){
    mouse.left=true;
    if(stationUI.open){
      const inX = mouse.x >= stationUI.x && mouse.x <= stationUI.x + stationUI.w;
      const inY = mouse.y >= stationUI.y && mouse.y <= stationUI.y + stationUI.h;
      if(inX && inY && mouse.y <= stationUI.y + 24){
        stationUI.dragging = true;
        stationUI.dragDX = mouse.x - stationUI.x;
        stationUI.dragDY = mouse.y - stationUI.y;
      }
    }
    if(!stationUI.open && !warp.isBusy()) triggerRailVolley();
  }
  if(e.button===2){ e.preventDefault(); mouse.right=true;
    if(!stationUI.open && !warp.isBusy()){
      const mouseWorld = { x: ship.pos.x + (mouse.x - W/2)/camera.zoom, y: ship.pos.y + (mouse.y - H/2)/camera.zoom };
      const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
      const side = (local.x >= 0) ? 'right' : 'left';
      fireRocket(side);
      rocketCooldown = ROCKET_FIRE_INTERVAL;
    }
  }
  if(e.button===1){ e.preventDefault(); camera.zoom = Math.abs(camera.zoom - camera.defaultZoom) < 0.03 ? camera.altZoom : camera.defaultZoom; }
});
canvas.addEventListener('mouseup', e=>{
  if(e.button===0){
    mouse.left=false;
    if(stationUI.dragging){
      stationUI.dragging=false;
    } else {
      mouse.click=true;
    }
  }
  if(e.button===2) mouse.right=false;
});
canvas.addEventListener('contextmenu', e=>e.preventDefault());
canvas.addEventListener('wheel', e=>{ e.preventDefault(); const f = 1 - e.deltaY * camera.wheelSpeed; camera.zoom *= f; camera.zoom = clamp(camera.zoom, camera.minZoom, camera.maxZoom); }, {passive:false});

const GAMEPAD = { enabled:true, dead:0.15, last:{} };
function applyGamepad(){
  const pads = navigator.getGamepads?.() || [];
  const p = pads[0];
  if(!p) return;
  const ax = (v)=> (Math.abs(v)<GAMEPAD.dead?0:v);
  const lx = ax(p.axes[0]||0), ly = ax(p.axes[1]||0);
  const rx = ax(p.axes[2]||0), ry = ax(p.axes[3]||0);
  ship.input.thrustX = lx;
  ship.input.thrustY = ly*-1;
  ship.input.aimX = rx;
  ship.input.aimY = ry*-1;
  input.main = Math.max(0, ship.input.thrustY);
  input.torque = ship.input.thrustX;
  input.leftSide = 0;
  input.rightSide = 0;
  const btn = (i)=>!!(p.buttons[i]&&p.buttons[i].pressed);
  if(btn(0)) triggerRailVolley();
  if(btn(1)) fireRocket();
  if(btn(2)) engageBoost();
  if(btn(3)) attemptWarp();
  if(btn(9)) PAUSED = !PAUSED;
}

// =============== Side rockets, rail, CIWS, special, dmg ===============
const ROCKET_FIRE_INTERVAL = 0.11;
const ROCKET_AMMO_MAX = 100;
let rocketAmmo = ROCKET_AMMO_MAX;
let rocketCooldown = 0;
let nextRocketIndexLeft = 0, nextRocketIndexRight = 0;
const SIDE_BULLET_SPEED = 760, SIDE_BULLET_DAMAGE = 20;
const SIDE_PLASMA_EXPLODE_RADIUS = 48;
const SIDE_ROCKET_TURN_RATE = 6;
const SIDE_ROCKET_HOMING_DELAY = 0.25;
const SPECIAL_COOLDOWN = 10; ship.special.cooldownTimer = 0;

function fireRocket(side){
  if(rocketAmmo <= 0) return;
  const guns = side === 'left' ? ship.sideGunsLeft : ship.sideGunsRight;
  const idx = side === 'left' ? nextRocketIndexLeft : nextRocketIndexRight;
  const gunOff = guns[idx % guns.length];
  const target = (lockedTarget && !lockedTarget.dead) ? lockedTarget : null;
  fireSideGunAtOffset(gunOff, side, target);
  if(side === 'left') nextRocketIndexLeft = (idx + 1) % guns.length;
  else nextRocketIndexRight = (idx + 1) % guns.length;
  rocketAmmo--;
}
function fireSideGunAtOffset(gunOff, side, target=null){
  const gunWorld = add(ship.pos, rotate(gunOff, ship.angle));
  const dl = side === 'left' ? -1 : 1;
  const dir = rotate({x:dl, y:0}, ship.angle);
  bullets.push({ x: gunWorld.x, y: gunWorld.y, px: gunWorld.x, py: gunWorld.y,
    vx: dir.x*SIDE_BULLET_SPEED + ship.vel.x, vy: dir.y*SIDE_BULLET_SPEED + ship.vel.y,
    life:2.4, r:5, owner:'player', damage:SIDE_BULLET_DAMAGE, penetration:0, type:'rocket',
    explodeRadius: SIDE_PLASMA_EXPLODE_RADIUS, homingDelay: SIDE_ROCKET_HOMING_DELAY, target });
  spawnParticle({x:gunWorld.x, y:gunWorld.y}, {x:dir.x*120 + ship.vel.x*0.1, y:dir.y*120 + ship.vel.y*0.1}, 0.14, '#b4ffb4', 3.2, true);
  for(let k=0;k<6;k++){
    const aa = Math.atan2(dir.y, dir.x) + (Math.random()-0.5)*0.9;
    spawnParticle({x:gunWorld.x + Math.cos(aa)*6, y:gunWorld.y + Math.sin(aa)*6}, {x:Math.cos(aa)*160, y:Math.sin(aa)*160}, 0.14 + Math.random()*0.06, '#a8ff9a', 1.1, true);
  }
}

const rail = { cd:[0,0], cdMax:0.38, shotGap:0.07, burstGap:0.18, burstsPerClick:2, queue:[], nextStart:0 };
let railTimer = 0;
const RAIL_SPEED = 2600, RAIL_PEN = 3, RAIL_DAMAGE = 60;
function triggerRailVolley(){
  if(rail.queue.length) return;
  const start = rail.nextStart; rail.nextStart ^= 1;
  const orderPair = [start, 1-start];
  for(let b=0;b<rail.burstsPerClick;b++){
    const base = b*(rail.shotGap*2 + rail.burstGap);
    rail.queue.push({ timer: base + 0*rail.shotGap, barrel: orderPair[0] });
    rail.queue.push({ timer: base + 1*rail.shotGap, barrel: orderPair[1] });
  }
}
function fireRailBarrel(barIndex){
  const forwardLen = Math.min(ship.h*0.36, 46);
  const gap = 10;
  const sign = (barIndex===0) ? -1 : +1;
  const turrets = [ship.turret, ship.turret2, ship.turret3, ship.turret4];
  for(const t of turrets){
    const a = t.angle;
    const f = {x:Math.cos(a), y:Math.sin(a)};
    const p = {x:-Math.sin(a), y:Math.cos(a)};
    const off = rotate(t.offset, ship.angle);
    const px = ship.pos.x + off.x + f.x * forwardLen + p.x * (sign * gap/2);
    const py = ship.pos.y + off.y + f.y * forwardLen + p.y * (sign * gap/2);
    bullets.push({ x:px, y:py, vx: f.x*RAIL_SPEED + ship.vel.x, vy: f.y*RAIL_SPEED + ship.vel.y, life: 2.0, r:4, owner:'player', damage:RAIL_DAMAGE, penetration:RAIL_PEN, type:'rail' });
    t.recoil = Math.min(t.recoil + t.recoilKick, t.recoilMax);
    spawnParticle({x:px, y:py}, {x:0,y:0}, 0.10, '#bfe7ff', 6, true);
    for(let i=0;i<5;i++){
      const aa = a + (Math.random()-0.5)*0.14;
      spawnParticle({x:px + Math.cos(aa)*6, y:py + Math.sin(aa)*6},{x:Math.cos(aa)*220 + ship.vel.x*0.2, y:Math.sin(aa)*220 + ship.vel.y*0.2},0.12,'#bfe7ff',1.6,true);
    }
  }
  rail.cd[barIndex] = rail.cdMax;
}

const CIWS_FIRE_INTERVAL = 0.06;
const CIWS_BULLET_SPEED = 900;
const CIWS_DAMAGE = 8;
const CIWS_RANGE = 600;
function ciwsStep(dt){
  for(const gun of ship.ciws){
    gun.cd = Math.max(0, gun.cd - dt);
    const off = rotate(gun.offset, ship.angle);
    const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
    const baseVel = { x: ship.vel.x - ship.angVel * off.y, y: ship.vel.y + ship.angVel * off.x };
    let target = null; let dist = CIWS_RANGE;
    for(const npc of npcs){
      if(npc.dead) continue;
      const d = Math.hypot(npc.x - base.x, npc.y - base.y);
      if(d < dist){ dist = d; target = npc; }
    }
    if(target){
      const aim = leadTarget(base, baseVel, target, CIWS_BULLET_SPEED);
      const desired = Math.atan2(aim.y - base.y, aim.x - base.x);
      let diff = wrapAngle(desired - gun.angle);
      let desiredVel = clamp(diff * 8, -6, 6);
      const velDelta = desiredVel - gun.angVel;
      const maxDelta = 40 * dt;
      gun.angVel += clamp(velDelta, -maxDelta, maxDelta);
      gun.angVel *= Math.exp(-8 * dt);
      gun.angVel = clamp(gun.angVel, -6, 6);
      gun.angle = wrapAngle(gun.angle + gun.angVel * dt);
      if(Math.abs(diff) < 0.15 && gun.cd === 0){
        const dir = { x: Math.cos(gun.angle), y: Math.sin(gun.angle) };
        const px = base.x + dir.x * 6;
        const py = base.y + dir.y * 6;
        bullets.push({ x:px, y:py, vx: dir.x*CIWS_BULLET_SPEED + baseVel.x, vy: dir.y*CIWS_BULLET_SPEED + baseVel.y, life:1.2, r:2, owner:'player', damage:CIWS_DAMAGE, type:'ciws' });
        spawnParticle({x:px, y:py}, {x:dir.x*120 + baseVel.x*0.1, y:dir.y*120 + baseVel.y*0.1}, 0.06, '#ffdf9e', 2.0, true);
        gun.cd = CIWS_FIRE_INTERVAL;
      }
    }
  }
}

function tryFireSpecial(){
  if(ship.special.cooldownTimer>0) return;
  ship.special.cooldownTimer = SPECIAL_COOLDOWN;
  const dir = rotate({x:0,y:-1}, ship.angle);
  const start = add(ship.pos, rotate({x:0, y:-ship.h/2}, ship.angle));
  const length = 2000;
  const end = { x: start.x + dir.x*length, y: start.y + dir.y*length };
  const width = ship.w;
  const npcsInRange = npcs.filter(npc => !npc.dead && Math.hypot(npc.x - start.x, npc.y - start.y) < length + npc.radius);
  let hits = 0;
  const HIT_CAP = 80;
  for (const npc of npcsInRange){
    if (hits >= HIT_CAP) break;
    const vx = npc.x - start.x, vy = npc.y - start.y;
    const proj = vx*dir.x + vy*dir.y;
    if (proj < 0 || proj > length) continue;
    const perp = Math.abs(vx*dir.y - vy*dir.x);
    if (perp <= npc.radius + width*0.5){
      applyDamageToNPC(npc, 80, 'none');
      if ((hits & 1) === 0) spawnParticle({x:npc.x, y:npc.y}, {x:0,y:0}, 0.10, '#9ccfff', 5, true);
      hits++;
    }
  }
  spawnLaserBeam(start, end, width);
  for(let i=0;i<8;i++){
    const t = i/7;
    const px = start.x + dir.x*length*t + (Math.random()-0.5)*width*0.3;
    const py = start.y + dir.y*length*t + (Math.random()-0.5)*width*0.3;
    spawnParticle({x:px, y:py}, {x:(Math.random()-0.5)*120, y:(Math.random()-0.5)*120}, 0.2, '#9ccfff', 2.5, true);
  }
}
function applyDamageToPlayer(amount){
  if(ship.shield.val>0){ const s = Math.min(ship.shield.val, amount); ship.shield.val -= s; amount -= s; ship.shield.regenTimer = ship.shield.regenDelay; }
  if(amount>0) ship.hull.val = Math.max(0, ship.hull.val - amount);
}
function applyDamageToNPC(npc, dmg, cause='default'){
  if(npc.dead) return;
  npc.hp -= dmg;
  if(npc.hp<=0){
    npc.dead = true; npc.respawnTimer = 3 + Math.random()*6;
    if(cause === 'plasma'){ spawnExplosionPlasma(npc.x, npc.y, 1.2); }
    else if(cause === 'default'){ spawnDefaultHit(npc.x, npc.y, 1.2); }
  }
}

// =============== Collisions & particles, NPC AI, warp, physics ===============

// --- Pomocnicze (kamera/world/screen) ---
function cameraShakeOffsets(){
  if(camera.shakeTime>0){
    const t = camera.shakeTime / Math.max(0.001,camera.shakeDur);
    const a = (Math.random()*Math.PI*2);
    const m = camera.shakeMag * t*t;
    const ox = Math.cos(a)*m, oy = Math.sin(a)*m;
    camera.shakeTime -= dtGlobal;
    if(camera.shakeTime<0){ camera.shakeTime=0; camera.shakeMag=0; }
    return {ox,oy};
  }
  return {ox:0,oy:0};
}
function applyCameraTransform(){
  const {ox,oy} = cameraShakeOffsets();
  const tx = W/2 - ship.pos.x*camera.zoom + ox;
  const ty = H/2 - ship.pos.y*camera.zoom + oy;
  ctx.setTransform(camera.zoom,0,0,camera.zoom,tx,ty);
}
function resetTransform(){ ctx.setTransform(1,0,0,1,0,0); }
function worldToScreen(x,y){
  const {ox,oy} = cameraShakeOffsets();
  const sx = (x - ship.pos.x)*camera.zoom + W/2 + ox;
  const sy = (y - ship.pos.y)*camera.zoom + H/2 + oy;
  return {x:sx,y:sy};
}
function screenToWorld(x,y){
  const wx = (x - W/2)/camera.zoom + ship.pos.x;
  const wy = (y - H/2)/camera.zoom + ship.pos.y;
  return {x:wx,y:wy};
}

// --- Boost / Warp ---
const boost = { state:'idle', fuel:100, cost:20, charge:0, duration:1.25, t:0, speed:1200 };
function engageBoost(){
  if(boost.state==='active') return;
  if(boost.fuel < boost.cost) return;
  boost.fuel -= boost.cost;
  boost.state='active';
  boost.t = boost.duration;
  camera.addShake(10, 0.25);
}
function updateBoost(dt){
  if(boost.state==='charging'){ /* tu można dodać efekt ładowania */ }
  if(boost.state==='active'){
    const fwd = rotate({x:0,y:-1}, ship.angle);
    ship.vel.x += fwd.x * boost.speed * dt;
    ship.vel.y += fwd.y * boost.speed * dt;
    boost.t -= dt;
    if(boost.t<=0) boost.state='idle';
  }
}

const warp = {
  state:'idle', route:null, s:0, v:0, lane:0, cooldown:0,
  isBusy(){ return this.state!=='idle' && this.state!=='cooldown'; }
};
function attemptWarp(){
  if(warp.state!=='idle') return;
  // Znajdź najbliższy start warp w zasięgu
  let best=null, bd=260;
  for(const k in warpRoutes){
    const r = warpRoutes[k];
    const d = Math.hypot(ship.pos.x - r.start.x, ship.pos.y - r.start.y);
    if(d<bd){ bd=d; best=r; }
  }
  if(!best) { toast('Brak bramy warp w pobliżu'); return; }
  warp.state='charging';
  warp.route=best; warp.s=0; warp.v=0; warp.lane = 0;
  camera.addShake(6, 0.3);
}
function updateWarp(dt){
  if(!warp.route) return;
  if(warp.state==='charging'){
    // krótkie przyciąganie do startu
    const dx = warp.route.start.x - ship.pos.x;
    const dy = warp.route.start.y - ship.pos.y;
    ship.pos.x += dx * Math.min(1, dt*3);
    ship.pos.y += dy * Math.min(1, dt*3);
    if(Math.hypot(dx,dy) < 6){
      warp.state='in';
      warp.v = 1200;
      // zresetuj prędkość własną
      ship.vel.x = ship.vel.y = 0;
    }
  } else if(warp.state==='in'){
    warp.s += warp.v * dt;
    const p = Math.min(1, warp.s / warp.route.length);
    ship.pos.x = warp.route.start.x + warp.route.dir.x * warp.s;
    ship.pos.y = warp.route.start.y + warp.route.dir.y * warp.s;
    warp.v = Math.min(2600, warp.v + 1800*dt);
    if(p>=1){
      warp.state='out';
      warp.v = 0;
      camera.addShake(8, 0.3);
    }
  } else if(warp.state==='out'){
    // wyplucie przy końcu
    const ex = warp.route.end.x + warp.route.dir.x * 140;
    const ey = warp.route.end.y + warp.route.dir.y * 140;
    const dx = ex - ship.pos.x, dy = ey - ship.pos.y;
    ship.pos.x += dx * Math.min(1, dt*4);
    ship.pos.y += dy * Math.min(1, dt*4);
    if(Math.hypot(dx,dy) < 8){
      warp.state='cooldown';
      warp.cooldown = 1.0;
      warp.route=null;
    }
  } else if(warp.state==='cooldown'){
    warp.cooldown -= dt; if(warp.cooldown<=0) warp.state='idle';
  }
}

// --- Turrety (prowadzenie) ---
function updateTurrets(dt){
  const target = screenToWorld(mouse.x, mouse.y);
  const turrets = [ship.turret, ship.turret2, ship.turret3, ship.turret4];
  for(const t of turrets){
    const off = rotate(t.offset, ship.angle);
    const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
    const desired = Math.atan2(target.y - base.y, target.x - base.x);
    const diff = wrapAngle(desired - t.angle);
    const maxVel = t.maxSpeed, maxAcc = t.maxAccel;
    const velDelta = clamp(diff* t.damping - t.angVel, -maxAcc*dt, maxAcc*dt);
    t.angVel = clamp(t.angVel + velDelta, -maxVel, maxVel);
    t.angle = wrapAngle(t.angle + t.angVel * dt);
    // recoil recovery
    t.recoil = Math.max(0, t.recoil - t.recoilRecover * dt);
  }
}

// --- AI prosty dla misji ---
function chaseEvadeAI(n, target, opts={}){
  const dx = target.pos.x - n.x, dy = target.pos.y - n.y;
  const angleTo = Math.atan2(dy,dx);
  const diff = wrapAngle(angleTo - n.angle);
  const turn = clamp(diff, -n.turn, n.turn);
  n.angle = wrapAngle(n.angle + turn * dtGlobal);
  const spd = n.maxSpeed * 0.9;
  n.vx += Math.cos(n.angle) * n.accel * dtGlobal;
  n.vy += Math.sin(n.angle) * n.accel * dtGlobal;
  const v = Math.hypot(n.vx,n.vy);
  if(v>spd){ const s=spd/v; n.vx*=s; n.vy*=s; }
}
function dogfightAI(n, target){ chaseEvadeAI(n,target); }
function battleshipAI(n, target){ chaseEvadeAI(n,target); }

// --- Strzelanie NPC (prosto) ---
let npcRailCD = 0;
function npcShootingStep(dt){
  npcRailCD = Math.max(0, npcRailCD - dt);
  for(const n of npcs){
    if(n.dead) continue;
    if(n.weapon==='railgun' && npcRailCD===0){
      const d = Math.hypot(n.x - ship.pos.x, n.y - ship.pos.y);
      if(d < 1600){
        const a = Math.atan2(ship.pos.y - n.y, ship.pos.x - n.x);
        bullets.push({ x:n.x, y:n.y, vx:Math.cos(a)*RAIL_SPEED, vy:Math.sin(a)*RAIL_SPEED, life:1.6, r:3, owner:'npc', damage:28, penetration:1, type:'rail' });
        npcRailCD = 0.45 + Math.random()*0.45;
      }
    }
  }
}

// --- Kolizje / pociski ---
function explodePlasma(b){
  spawnExplosionPlasma(b.x,b.y,1.0);
  // AoE
  for(const n of npcs){
    if(n.dead) continue;
    const d = Math.hypot(n.x-b.x, n.y-b.y);
    if(d <= (b.explodeRadius||40)) applyDamageToNPC(n, 30, 'plasma');
  }
}
function bulletsAndCollisionsStep(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    if(b.beam) continue; // wiązki rysowane osobno
    // homing rakiet
    if(b.type==='rocket'){
      b.homingDelay = Math.max(0, (b.homingDelay||0) - dt);
      if(b.homingDelay===0 && b.target && !b.target.dead){
        const aim = Math.atan2(b.target.y - b.y, b.target.x - b.x);
        const va = Math.atan2(b.vy, b.vx);
        const diff = wrapAngle(aim - va);
        const na = va + clamp(diff, -SIDE_ROCKET_TURN_RATE*dt, SIDE_ROCKET_TURN_RATE*dt);
        const sp = Math.hypot(b.vx,b.vy);
        b.vx = Math.cos(na) * sp;
        b.vy = Math.sin(na) * sp;
      }
    }

    b.px = b.x; b.py = b.y;
    b.x += b.vx * dt; b.y += b.vy * dt;
    b.life -= dt;

    // trafienia w NPC
    if(b.owner==='player'){
      for(const n of npcs){
        if(n.dead) continue;
        const d = Math.hypot(n.x - b.x, n.y - b.y);
        if(d < (n.radius + (b.r||2))){
          applyDamageToNPC(n, b.damage||10, b.type==='rocket'?'plasma':'default');
          if(b.type==='rail'){
            spawnRailHitEffect(b.x, b.y, 1);
            b.penetration = (b.penetration||0) - 1;
            if(b.penetration<=0){ bullets.splice(i,1); break; }
          } else if(b.type==='rocket'){
            explodePlasma(b); bullets.splice(i,1); break;
          } else {
            spawnDefaultHit(b.x,b.y,1);
            bullets.splice(i,1); break;
          }
        }
      }
    } else if(b.owner==='npc'){
      // prosty dmg na gracza
      const d = Math.hypot(ship.pos.x - b.x, ship.pos.y - b.y);
      if(d < (ship.w*0.35)){
        applyDamageToPlayer(b.damage||10);
        spawnDefaultHit(b.x,b.y,1);
        bullets.splice(i,1); continue;
      }
    }

    // żywotność / eksplozja rakiety na końcu
    if(b.life<=0){
      if(b.type==='rocket'){ explodePlasma(b); }
      bullets.splice(i,1);
    }
  }

  // wiązki (specjal)
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.age += dt;
    if(p.beam){ if(p.age > p.life){ particles.splice(i,1); } continue; }
    p.pos.x += p.vel.x * dt;
    p.pos.y += p.vel.y * dt;
    if((p.age >= p.life)) particles.splice(i,1);
  }
}

// --- Prosty ruch NPC + dokowanie/respawn ---
function npcStep(dt){
  for(const n of npcs){
    if(n.dead){
      n.respawnTimer -= dt;
      if(n.respawnTimer<=0 && !n.mission){
        // respawn w pobliżu stacji
        const s = getStationById(n.lastStation) || stations[0];
        n.x = s.x + (Math.random()-0.5)*200;
        n.y = s.y + (Math.random()-0.5)*200;
        n.vx=n.vy=0; n.hp=n.maxHp; n.dead=false;
      }
      continue;
    }

    // eskorta utrzymuje offset względem lidera
    if(n.leader!=null){
      const lead = npcs.find(m=>m && m.id===n.leader && !m.dead);
      if(lead){
        n.orbitAngle += 0.4*dt;
        const tx = lead.x + Math.cos(n.orbitAngle)*n.orbitRadius;
        const ty = lead.y + Math.sin(n.orbitAngle)*n.orbitRadius;
        const a = Math.atan2(ty-n.y, tx-n.x);
        n.vx += Math.cos(a)*n.accel*dt;
        n.vy += Math.sin(a)*n.accel*dt;
      }
    }else{
      // prosty kierunek w stronę aktualnego celu (stacja)
      const target = getStationById(n.target);
      if(target){
        const a = Math.atan2(target.y - n.y, target.x - n.x);
        n.vx += Math.cos(a) * n.accel * dt;
        n.vy += Math.sin(a) * n.accel * dt;

        // dokowanie
        const d = Math.hypot(target.x - n.x, target.y - n.y);
        if(d < (target.r + 28)){
          n.docking = true; n.lastStation = target.id;
          // wybór nowej destynacji
          n.target = pickNextStation(n.id, target.id);
        }
      }
    }

    // ogranicz prędkość
    const v = Math.hypot(n.vx,n.vy);
    const ms = n.maxSpeed;
    if(v>ms){ const s = ms/v; n.vx*=s; n.vy*=s; }

    // tłumienie
    n.vx *= (1 - Math.min(0.6*dt, 0.6));
    n.vy *= (1 - Math.min(0.6*dt, 0.6));

    // update pozycji
    n.x += n.vx * dt;
    n.y += n.vy * dt;
  }
}

// --- Fizyka statku, ciągi i VFX silnika ---
function physicsStep(dt){
  // główny silnik
  if(input.main>0){
    const fwd = rotate({x:0,y:-1}, ship.angle);
    const thrust = ship.engines.main.maxThrust * input.main;
    ship.vel.x += (thrust / ship.mass) * fwd.x * dt;
    ship.vel.y += (thrust / ship.mass) * fwd.y * dt;

    // VFX
    const tail = add(ship.pos, rotate({x:0,y:ship.h/2}, ship.angle));
    for(let i=0;i<2;i++){
      spawnParticle(tail, {x:(Math.random()-0.5)*90, y:(Math.random()*-120 - 260)}, 0.18+Math.random()*0.12, '#7fc7ff', 2.2+Math.random()*1.5, true);
    }
  }
  // strafe
  if(input.leftSide>0 || input.rightSide>0){
    const side = input.rightSide - input.leftSide;
    const dir = rotate({x:1,y:0}, ship.angle);
    const thrust = 4000 * side;
    ship.vel.x += (thrust / ship.mass) * dir.x * dt;
    ship.vel.y += (thrust / ship.mass) * dir.y * dt;
  }
  // moment/obrót
  const torque = input.torque * 4200;
  ship.angVel += (torque / ship.inertia) * dt;

  // tłumienia
  ship.vel.x *= (1 - Math.min(ship.linearDamping*dt, ship.linearDamping));
  ship.vel.y *= (1 - Math.min(ship.linearDamping*dt, ship.linearDamping));
  ship.angVel *= (1 - Math.min(ship.angularDamping*dt, ship.angularDamping));

  // integracja
  ship.pos.x += ship.vel.x * dt;
  ship.pos.y += ship.vel.y * dt;
  ship.angle = wrapAngle(ship.angle + ship.angVel * dt);

  // regen tarczy
  if(ship.shield.regenTimer>0) ship.shield.regenTimer -= dt;
  else ship.shield.val = Math.min(ship.shield.max, ship.shield.val + ship.shield.regenRate * dt);
}

// =============== Render ===============
function renderStars(){
  // zakres widoczny
  const w = W / camera.zoom, h = H / camera.zoom;
  const x0 = ship.pos.x - w/2, y0 = ship.pos.y - h/2;
  const x1 = ship.pos.x + w/2, y1 = ship.pos.y + h/2;
  const ix0 = Math.floor((x0-50)/STAR_CELL), iy0 = Math.floor((y0-50)/STAR_CELL);
  const ix1 = Math.floor((x1+50)/STAR_CELL), iy1 = Math.floor((y1+50)/STAR_CELL);

  ctx.fillStyle = '#000';
  for(let iy=iy0; iy<=iy1; iy++){
    for(let ix=ix0; ix<=ix1; ix++){
      const cell = getCell(ix,iy);
      for(const s of cell.stars){
        ctx.globalAlpha = s.bright;
        ctx.fillStyle = '#dfe7ff';
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }
  ctx.globalAlpha = 1;
}

function drawSun(){
  const g = ctx.createRadialGradient(SUN.x,SUN.y, 0, SUN.x,SUN.y, SUN.r*2.2);
  g.addColorStop(0, 'rgba(255,230,140,0.9)');
  g.addColorStop(1, 'rgba(255,230,140,0.0)');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(SUN.x,SUN.y,SUN.r*2.2,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#ffdd88';
  ctx.beginPath(); ctx.arc(SUN.x,SUN.y,SUN.r,0,Math.PI*2); ctx.fill();
}

function drawStations(){
  for(const s of stations){
    ctx.lineWidth = 2/camera.zoom;
    ctx.strokeStyle = s.inner? '#4ab3ff' : '#bbb';
    ctx.fillStyle = 'rgba(10,20,40,0.8)';
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill(); ctx.stroke();
    if(s.mission){
      ctx.strokeStyle='#ff5533';
      ctx.setLineDash([8/camera.zoom,6/camera.zoom]);
      ctx.beginPath(); ctx.arc(s.x,s.y,s.r+10,0,Math.PI*2); ctx.stroke();
      ctx.setLineDash([]);
    }
  }
}

function drawNPCs(){
  for(const n of npcs){
    if(n.dead) continue;
    ctx.fillStyle = n.color || '#9ccfff';
    ctx.beginPath(); ctx.arc(n.x,n.y,n.radius,0,Math.PI*2); ctx.fill();
  }
}

function drawBullets(){
  for(const b of bullets){
    if(b.beam) continue;
    if(b.type==='rail'){
      ctx.strokeStyle = '#bfe7ff';
      ctx.lineWidth = 2/camera.zoom;
      ctx.beginPath(); ctx.moveTo(b.px||b.x, b.py||b.y); ctx.lineTo(b.x, b.y); ctx.stroke();
    } else if(b.type==='rocket'){
      ctx.fillStyle = '#a8ff9a';
      ctx.beginPath(); ctx.arc(b.x,b.y,3,0,Math.PI*2); ctx.fill();
    } else {
      ctx.fillStyle = '#ffdf9e';
      ctx.beginPath(); ctx.arc(b.x,b.y,2,0,Math.PI*2); ctx.fill();
    }
  }
  // wiązki
  for(const p of particles){
    if(!p.beam) continue;
    ctx.strokeStyle = 'rgba(156,207,255,0.9)';
    ctx.lineWidth = (p.width||ship.w)/camera.zoom;
    ctx.beginPath(); ctx.moveTo(p.start.x, p.start.y); ctx.lineTo(p.end.x, p.end.y); ctx.stroke();
  }
}

function drawParticles(){
  const count = Math.min(MAX_PARTICLES_DRAW, particles.length);
  for(let i=0;i<count;i++){
    const p = particles[i];
    if(p.beam) continue;
    const t = 1 - (p.age / p.life);
    ctx.globalAlpha = Math.max(0, Math.min(1, t * (p.flash?1.1:0.8)));
    ctx.fillStyle = p.color || '#fff';
    ctx.beginPath();
    ctx.arc(p.pos.x, p.pos.y, p.size||2, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawShip(){
  ctx.save();
  ctx.translate(ship.pos.x, ship.pos.y);
  ctx.rotate(ship.angle);

  // kadłub
  ctx.fillStyle = '#0c172a';
  ctx.strokeStyle = '#5fa9ff';
  ctx.lineWidth = 2/camera.zoom;
  ctx.beginPath();
  ctx.roundRect(-ship.w/2, -ship.h/2, ship.w, ship.h, 12);
  ctx.fill(); ctx.stroke();

  // pylon/pods
  ctx.fillStyle = '#11233d';
  for(const p of ship.pods){
    ctx.fillRect(p.offset.x - p.w/2, p.offset.y - p.h/2, p.w, p.h);
  }

  // turrety (z recoil)
  function drawTurret(t){
    const f = {x:Math.cos(t.angle), y:Math.sin(t.angle)};
    ctx.save();
    ctx.translate(t.offset.x, t.offset.y);
    ctx.rotate(t.angle);
    const r = (t.recoil||0);
    ctx.fillStyle = '#203a69';
    ctx.fillRect(-6, -18 - r, 12, 36);
    ctx.restore();
  }
  drawTurret(ship.turret); drawTurret(ship.turret2); drawTurret(ship.turret3); drawTurret(ship.turret4);

  ctx.restore();
}

// --- HUD/UI helpers ---
const UI = { x:0,y:0,w:0,h:0, line:0, clicked:false };
function hudBeginPanel(x, y, w, h){
  w = w??420; h = h??360; x = x??(W-w)/2; y = y??(H-h)/2;
  UI.x=x; UI.y=y; UI.w=w; UI.h=h; UI.line=0;
  resetTransform();
  ctx.fillStyle = 'rgba(8,10,20,0.85)';
  ctx.strokeStyle = 'rgba(120,150,210,0.6)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.roundRect(x,y,w,h,10); ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#dfe7ff';
  UI.clicked = mouse.click; // pojedynczy klik w tej klatce
}
function hudEndPanel(){ /* nic, ale zostawione dla porządku */ }
function hudTabs(tabs, current){
  const th = 28, tw = Math.floor(UI.w / tabs.length);
  ctx.font = 'bold 13px Inter,system-ui,Segoe UI';
  for(let i=0;i<tabs.length;i++){
    const tx = UI.x + i*tw, ty = UI.y;
    const over = mouse.x>=tx && mouse.x<=tx+tw && mouse.y>=ty && mouse.y<=ty+th;
    ctx.fillStyle = (tabs[i]===current)?'#1a2544': (over?'#121a31':'#0c1426');
    ctx.fillRect(tx,ty,tw,th);
    ctx.strokeStyle = '#2a3a65'; ctx.strokeRect(tx+0.5,ty+0.5,tw-1,th-1);
    ctx.fillStyle = '#cfe1ff';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(tabs[i], tx+tw/2, ty+th/2);
    if(over && UI.clicked){
      stationUI.tab = tabs[i];
    }
  }
  UI.line = th + 8;
}
function uiTitle(txt){
  ctx.font = 'bold 16px Inter,system-ui,Segoe UI';
  ctx.textAlign='left'; ctx.textBaseline='top';
  ctx.fillStyle='#dfe7ff';
  ctx.fillText(txt, UI.x+14, UI.y+UI.line+6);
  UI.line += 30;
}
function section(txt){
  ctx.font = 'bold 13px Inter,system-ui,Segoe UI';
  ctx.fillStyle='#9bb4ff';
  ctx.fillText(txt, UI.x+14, UI.y+UI.line+4);
  UI.line += 22;
}
function uiRowButton(label, btn){
  const lh = 28, pad=14;
  const y = UI.y + UI.line;
  ctx.font = '13px Inter,system-ui,Segoe UI';
  ctx.fillStyle='#cfe1ff'; ctx.textAlign='left'; ctx.textBaseline='middle';
  ctx.fillText(label, UI.x+pad, y+lh/2);
  const bw=90;
  const bx = UI.x + UI.w - bw - pad, by=y+4, bh=lh-8;
  const over = mouse.x>=bx && mouse.x<=bx+bw && mouse.y>=by && mouse.y<=by+bh;
  ctx.fillStyle = over? '#1d2b54' : '#142245';
  ctx.fillRect(bx,by,bw,bh);
  ctx.strokeStyle = '#3556a3'; ctx.strokeRect(bx+0.5,by+0.5,bw-1,bh-1);
  ctx.fillStyle = '#e6f0ff'; ctx.textAlign='center';
  ctx.fillText(btn, bx+bw/2, y+lh/2);
  UI.line += lh + 6;
  return over && UI.clicked;
}
function slider(label, min, max, step, obj, key){
  const lh=36, pad=14; const y=UI.y+UI.line;
  ctx.font = '13px Inter,system-ui,Segoe UI';
  ctx.fillStyle='#cfe1ff'; ctx.textAlign='left'; ctx.textBaseline='top';
  ctx.fillText(`${label}: ${Math.round(obj[key])}`, UI.x+pad, y+6);

  const w = UI.w - pad*2, x = UI.x+pad, by = y+22, h=8;
  ctx.fillStyle='#0c1426'; ctx.fillRect(x,by,w,h);
  const t = (obj[key]-min)/(max-min);
  ctx.fillStyle='#3056a8'; ctx.fillRect(x,by,w*t,h);
  const over = mouse.x>=x && mouse.x<=x+w && mouse.y>=by && mouse.y<=by+h;
  if(over && mouse.left){
    const nt = clamp((mouse.x-x)/w,0,1);
    const raw = min + nt*(max-min);
    const stepped = Math.round(raw/step)*step;
    obj[key]=clamp(stepped,min,max);
  }
  UI.line += lh;
}

// --- Toasty ---
const TOASTS = [];
function toast(msg, sec=2.2){ TOASTS.push({msg,time:sec}); }
function renderToasts(dt){
  resetTransform();
  let y = H - 24;
  for(let i=TOASTS.length-1;i>=0;i--){
    const t = TOASTS[i];
    t.time -= dt;
    ctx.globalAlpha = Math.min(1, Math.max(0, t.time/0.4));
    ctx.fillStyle = 'rgba(12,20,38,0.85)';
    ctx.strokeStyle='rgba(70,110,180,0.6)';
    ctx.lineWidth=1;
    const text = t.msg;
    ctx.font='13px Inter,system-ui,Segoe UI';
    const w = ctx.measureText(text).width + 20;
    const x = W - w - 16;
    ctx.beginPath(); ctx.roundRect(x,y-18,w,22,8); ctx.fill(); ctx.stroke();
    ctx.fillStyle='#dfe7ff'; ctx.textAlign='left'; ctx.textBaseline='middle';
    ctx.fillText(text, x+10, y-7);
    y -= 26;
    ctx.globalAlpha=1;
    if(t.time<=0) TOASTS.splice(i,1);
  }
}

// --- Mapa (prosta) ---
function renderMiniMap(){
  if(!showMap) return;
  const mw=280,mh=180,x=20,y=H-mh-20;
  resetTransform();
  ctx.fillStyle='rgba(8,10,20,0.85)'; ctx.strokeStyle='rgba(120,150,210,0.6)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.roundRect(x,y,mw,mh,10); ctx.fill(); ctx.stroke();

  // Proj. układu na minimapę
  ctx.save();
  ctx.beginPath(); ctx.rect(x+8,y+8,mw-16,mh-16); ctx.clip();
  const cx = x+mw/2, cy = y+mh/2;
  const scale = 0.0025; // mała galaktyka

  // słońce
  ctx.fillStyle='#ffd480'; ctx.beginPath(); ctx.arc(cx,cy,6,0,Math.PI*2); ctx.fill();
  // planety & stacje
  ctx.fillStyle='#88aaff';
  for(const p of planets){
    const px = cx + (p.x - SUN.x)*scale, py = cy + (p.y - SUN.y)*scale;
    ctx.fillRect(px-2,py-2,4,4);
  }
  for(const s of stations){
    const sx = cx + (s.x - SUN.x)*scale, sy = cy + (s.y - SUN.y)*scale;
    ctx.fillStyle = s.mission? '#ff5533' : (s.inner?'#4ab3ff':'#9bb7ff');
    ctx.fillRect(sx-2,sy-2,4,4);
  }
  // gracz
  ctx.fillStyle='#7cff9c';
  ctx.beginPath(); ctx.arc(cx + (ship.pos.x - SUN.x)*scale, cy + (ship.pos.y - SUN.y)*scale, 3, 0, Math.PI*2); ctx.fill();

  ctx.restore();
}

// --- UI EKRAN STACJI / OPCJE ---
function renderHUD(){
  resetTransform();
  // Pasek tarczy/kadłuba
  const bar = (x,y,w,h, val,max, c)=>{ ctx.fillStyle='#0e162a'; ctx.fillRect(x,y,w,h); const t=val/max; ctx.fillStyle=c; ctx.fillRect(x,y,w*t,h); ctx.strokeStyle='#2a3a65'; ctx.strokeRect(x+0.5,y+0.5,w-1,h-1); };
  bar(20,20,220,12, ship.shield.val, ship.shield.max, '#63b3ff');
  bar(20,36,220,12, ship.hull.val, ship.hull.max, '#ff7b63');
  // Boost / warp
  bar(20,56,220,8, boost.fuel, 100, '#7cffb3');

  if(OPTIONS_OPEN) renderOptions();
  if(stationUI.open) renderStationUI();
  renderMiniMap();
}

// =============== Pętla gry ===============
let lastT = performance.now();
let dtGlobal = 0;

function applyShipBoundaries(){
  // opcjonalne ograniczenia w WORLD
  ship.pos.x = clamp(ship.pos.x, -1000000, 1000000);
  ship.pos.y = clamp(ship.pos.y, -1000000, 1000000);
}

function updateGameTime(dt){
  gameTime += dt * TIME_SCALE;
  gameTimeEl.textContent = formatGameTime(gameTime);
}

function spawnMercenaryWaveIfNeeded(){
  if(!mercMission || mercMission.npcsSpawned) return;
  const s = mercMission.station;
  // Eskadra przy stacji
  for(let i=0;i<8;i++) spawnMissionFighter({x:s.x + Math.cos(i)*260, y:s.y + Math.sin(i)*260});
  spawnGunship({x:s.x+320,y:s.y});
  spawnGunship({x:s.x-320,y:s.y});
  spawnDestroyer({x:s.x,y:s.y+380});
  mercMission.npcsSpawned = true;
}

function frame(t){
  const now = t||performance.now();
  dtGlobal = Math.min(0.05, (now - lastT)/1000); // cap 50 ms
  lastT = now;

  // LOGIKA
  applyGamepad();
  updateBoost(dtGlobal);
  updateWarp(dtGlobal);
  physicsStep(dtGlobal);
  npcStep(dtGlobal);
  npcShootingStep(dtGlobal);
  ciwsStep(dtGlobal);
  bulletsAndCollisionsStep(dtGlobal);
  updateTurrets(dtGlobal);
  updateGameTime(dtGlobal);

  // RENDER
  ctx.clearRect(0,0,W,H);
  applyCameraTransform();
  // tło gwiezdne
  renderStars();
  // słońce i stacje/npc/ship/bullets/vfx
  drawSun();
  drawStations();
  drawNPCs();
  drawBullets();
  drawParticles();
  drawShip();

  // overlay/HUD
  renderHUD();
  renderToasts(dtGlobal);

  // update 3D modułu jeśli jest
  if(typeof updatePlanets3D==='function') updatePlanets3D(gameTime);

  // po pierwszej klatce schowaj "Ładowanie"
  const loading = document.getElementById('loading'); if(loading) loading.style.display='none';

  // housekeeping
  pruneStarCells();
  mouse.click = false;

  requestAnimationFrame(frame);
}

// --- Obsługa klawiatury: warp pod SHIFT ---
window.addEventListener('keydown', (e)=>{
  if(e.code==='ShiftLeft' || e.code==='ShiftRight'){
    attemptWarp();
  }
});

// --- Helpery gracza/statku ---
function applyShipStats(stats){
  // proste mnożniki
  ship.hull.max = Math.round(BASE_SHIP.hullMax * (stats.hp||1));
  ship.hull.val = ship.hull.max;
  ship.linearDamping = 0.9 / (stats.speed||1);
  // cargo itp. pomijamy w tym demie
}

// Start gry
function startGame(){
  initStars(true);
  initNPCs();
  spawnMercenaryWaveIfNeeded();
  requestAnimationFrame(frame);
}
startGame();

</script>

</body>
</html>

