<!doctype html>
<html lang="pl">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Super Capital: Battle for Solar System ‚Äî Aero HUD</title>
  <link rel="stylesheet" href="assets/css/main.css">


</head>

<body>
  <!-- --- HUD TOP CONTAINER --- -->
  <div id="hud-top-container">
    <div class="hud-dock" id="hud-top-dock">
      <div class="location-display">
        <span class="loc-label">CURRENT SECTOR</span>
        <span class="loc-name" id="loc-text">INTERPLANETARY SPACE</span>
      </div>
      <div class="hud-drawer" id="top-drawer">
        <div class="station-header">
          <div class="station-title">
            <h2 id="station-title">Orbital Station</h2>
            <span id="station-subtitle">Sector 7</span>
          </div>
          <div class="station-credits" id="station-credits">0 CR</div>
        </div>
        <div class="station-nav" id="station-tabs">
          <!-- Zak≈Çadki generowane przez JS -->
        </div>
        <div class="station-content" id="station-content-area">
          <div id="tab-upgrades" class="station-tab"></div>
          <div id="tab-trade" class="station-tab hidden"></div>
          <div id="tab-cantina" class="station-tab hidden"></div>
          <div id="tab-hangar" class="station-tab hidden"></div>
          <div id="tab-mechanic-html" class="station-tab hidden"></div>
          <div id="tab-infrastructure-html" class="station-tab hidden"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- --- LEFT PANELS (Support) --- -->
  <div id="side-panels-container">
    <div class="side-panel-transparent" id="panel-support">
      <div class="panel-header" onclick="togglePanel('panel-support')"><span class="panel-title">Wsparcie</span><span
          class="panel-chevron">‚ñº</span></div>
      <div class="panel-body">
        <div class="support-card" data-support-spawn="carrier_capital">
          <div class="ship-icon-wrap">
            <div class="icon-capital">
              <div class="icon-cap-side"></div>
              <div class="icon-cap-center"></div>
              <div class="icon-cap-side"></div>
            </div>
          </div>
          <div class="support-details"><span class="ship-name">Capital</span><span class="ship-role">Flagship</span></div>
          <div class="support-count">x1</div>
        </div>
        <div class="support-card" data-support-spawn="battleship">
          <div class="ship-icon-wrap">
            <div class="icon-battleship">
              <div class="icon-bs-rect"></div>
              <div class="icon-bs-chevron"></div>
            </div>
          </div>
          <div class="support-details"><span class="ship-name">Battleship</span><span class="ship-role">Heavy
              Capital</span></div>
          <div class="support-count">x5</div>
        </div>
        <div class="support-card" data-support-spawn="destroyer">
          <div class="ship-icon-wrap">
            <div class="icon-destroyer"></div>
          </div>
          <div class="support-details"><span class="ship-name">Destroyer</span><span class="ship-role">Escort
              Class</span></div>
          <div class="support-count">x5</div>
        </div>
        <div class="support-card" data-support-spawn="frigate_pd">
          <div class="ship-icon-wrap">
            <div class="icon-frigate"></div>
          </div>
          <div class="support-details"><span class="ship-name">Frigate</span><span class="ship-role">Patrol Unit</span>
          </div>
          <div class="support-count">x50</div>
        </div>
        <div class="support-card" data-support-spawn="fighter">
          <div class="ship-icon-wrap">
            <div class="icon-fighter"></div>
          </div>
          <div class="support-details"><span class="ship-name">Fighter</span><span class="ship-role">Interceptor</span>
          </div>
          <div class="support-count">x200</div>
        </div>
        <div class="orders-row">
          <div class="glass-btn active" id="support-guard">Guard</div>
          <div class="glass-btn" id="support-engage">Engage</div>
        </div>
      </div>
    </div>

    <div class="side-panel-transparent" id="panel-shield">
      <div class="panel-header" onclick="togglePanel('panel-shield')"><span class="panel-title">Tarcza</span><span
          class="panel-chevron">‚ñº</span></div>
      <div class="panel-body">
        <div class="orders-row">
          <div class="glass-btn" id="btn-energy-shot">Energy Shot (+50%)</div>
        </div>
      </div>
    </div>
  </div>

  <!-- --- RIGHT PANELS (Fleet) --- -->
  <div id="right-panels-container">
    <div class="side-panel-transparent" id="panel-fleet">
      <div class="panel-header" onclick="togglePanel('panel-fleet')"><span class="panel-title">Flota</span><span
          class="panel-chevron">‚ñº</span></div>
      <div class="panel-body">
        <div class="fleet-list" id="fleet-list"></div>
      </div>
    </div>
  </div>

  <!-- --- HUD BOTTOM CONTAINER --- -->
  <div id="hud-bottom-container">
    <div class="hud-wing left" id="left-wing">
      <div class="stat-unit" id="shield-unit">
        <div class="stat-value-text" id="val-shield">2800</div>
        <div class="stat-bar-aero">
          <div class="stat-ghost" id="ghost-shield"></div>
          <div class="stat-fill shield" id="fill-shield"></div>
        </div>
        <div class="stat-label">Deflector Shield</div>
      </div>
      <div class="stat-unit" id="hp-unit">
        <div class="stat-value-text" id="val-hp">4200</div>
        <div class="stat-bar-aero">
          <div class="stat-ghost" id="ghost-hp"></div>
          <div class="stat-fill hp" id="fill-hp"></div>
        </div>
        <div class="stat-label">Hull Integrity</div>
      </div>
    </div>

    <div class="hud-dock" id="hud-center-dock">
      <div class="hud-drawer" id="bottom-drawer">
        <div class="drawer-content-wrapper" id="drawer-content-wrapper"></div>
      </div>
      <div class="warp-separator-container" id="warp-container"><span class="warp-label-center"
          id="warp-text">WARP DRIVE CHARGING</span>
        <div class="warp-separator-fill" id="fill-warp"></div>
      </div>
      <div class="dock-dashboard">
        <div class="dash-group left"><span class="dash-label">Engine</span>
          <div class="dash-gauge">
            <div class="dash-fill power" id="fill-power"></div>
          </div>
        </div>
        <div class="dash-group center">
          <div class="speed-display"><span class="speed-value" id="val-speed">0</span><span class="speed-unit">M/S</span>
          </div>
          <div class="dash-gauge">
            <div class="dash-fill core" id="fill-core"></div>
          </div>
          <span class="dash-label">CORE INTEGRITY</span>
        </div>
        <div class="dash-group right"><span class="dash-label">Boost</span>
          <div class="dash-gauge">
            <div class="dash-fill boost" id="fill-boost"></div>
          </div>
        </div>
      </div>
      <div class="skill-row" id="skill-row">
        <!-- Generowane przez HUDSystem -->
      </div>
    </div>

    <div class="hud-wing right" id="hex-armor-container" style="display: none;"></div>
  </div>

  <div id="ui" class="hidden">
    <div><strong>Super Capital: Battle for Solar System ‚Äî gwiazdy na ca≈Çej mapie + du≈ºy silnik plazmowy</strong></div>
    <div class="stat">Czas gry: <span id="game-time">00:00</span></div>
    <div class="stat">W ‚Äî ciƒÖg (du≈ºy silnik plazmowy) ¬∑ Q/E ‚Äî strafe ¬∑ A/D ‚Äî obr√≥t</div>
    <div class="stat">LPM ‚Äî rail (A‚ÜíB, A‚ÜíB) ¬∑ PPM ‚Äî bro≈Ñ specjalna (priorytet) / boczne rakiety ¬∑ F ‚Äî superbro≈Ñ ¬∑ SHIFT ‚Äî warp / dopalacz na orbitach
    </div>
    <div style="margin-top:6px"><small>Gwiazdy sƒÖ proceduralne w ca≈Çej galaktyce. Silnik: niebieski exhaust + kr√≥tki
        ≈õlad przy ruchu.</small></div>

    <div id="bg-gen-status" style="margin-top: 8px; font-size: 11px; color: #7dd3fc; display: none;">
      Generowanie galaktyki: <span id="bg-gen-percent">0%</span>
    </div>
  </div>
  <div id="hud-topbar" class="hud-topbar hidden">
    <div id="skill-slots" class="skill-slot-row" aria-label="Umiejƒôtno≈õci i skille"></div>
  </div>
  <div id="main-menu">
    <div class="menu-perspective-wrapper">
      <div class="sc-logo-container">
        <h1 class="sc-main-title">SUPER CAPITAL</h1>
        <div class="sc-subtitle">Battle for Solar System</div>
      </div>

      <div class="menu-glass-panel">
        <div id="menu-home-view" class="menu-sub-view active">
          <button id="btn-continue" class="menu-btn-styled hidden">
            <span>Kontynuuj</span> <span>‚ñ∂</span>
          </button>
          <button id="btn-new-game" class="menu-btn-styled primary">
            <span>Nowa Gra</span> <span>‚öî</span>
          </button>
          <button id="btn-load-game" class="menu-btn-styled" disabled>
            <span>Wczytaj</span> <span>üìÇ</span>
          </button>
          <button id="btn-options" class="menu-btn-styled">
            <span>Opcje</span> <span>‚öô</span>
          </button>
          <button id="btn-credits" class="menu-btn-styled">
            <span>Credits</span> <span>i</span>
          </button>
        </div>

        <div id="menu-options-view" class="menu-sub-view">
          <h2 style="text-align:center; color:#fff; text-transform:uppercase; letter-spacing:4px; margin-bottom:10px;">
            Konfiguracja
          </h2>

          <div class="menu-options-grid">
            <div class="menu-section">
              <div class="menu-section-title">Grafika</div>
              <div style="margin-bottom:8px; font-size:12px; color:#a2d9ff;">Jako≈õƒá rendera (Nebula)</div>
              <div class="menu-chip-group" role="group" aria-label="Jako≈õƒá rendera">
                <button class="menu-chip" data-quality="2k">2K</button>
                <button class="menu-chip" data-quality="4k">4K</button>
                <button class="menu-chip" data-quality="8k">8K</button>
              </div>
              <div style="margin-top:12px; margin-bottom:8px; font-size:12px; color:#a2d9ff;">Jako≈õƒá Planet (3D)</div>
              <div class="menu-chip-group" id="planet-quality-group">
                <button class="menu-chip" data-planet-q="low">Low</button>
                <button class="menu-chip" data-planet-q="medium">Med</button>
                <button class="menu-chip" data-planet-q="high">High</button>
                <button class="menu-chip" data-planet-q="ultra">Ultra</button>
              </div>
            </div>

            <div class="menu-section">
              <div class="menu-section-title">D≈∫wiƒôk</div>
              <div class="option-slider-row">
                <div class="option-slider-label"><span>G≈Ç√≥wna g≈Ço≈õno≈õƒá</span> <span>80%</span></div>
                <input type="range" class="option-slider" min="0" max="100" value="80">
              </div>
              <div class="option-slider-row">
                <div class="option-slider-label"><span>Efekty SFX</span> <span>100%</span></div>
                <input type="range" class="option-slider" min="0" max="100" value="100">
              </div>
            </div>

            <div class="menu-section">
              <div class="menu-section-title">Sterowanie</div>
              <div class="menu-empty-placeholder">Brak dostƒôpnych ustawie≈Ñ</div>
            </div>
          </div>

          <button id="btn-options-back" class="menu-btn-styled" style="justify-content:center; margin-top:10px;">
            Powr√≥t
          </button>
        </div>

        <div id="menu-credits-view" class="menu-sub-view">
          <div class="credits-text">
            <h3 style="color:#fff; letter-spacing:2px; margin-bottom:15px;">Dane projektu</h3>
            <p><strong>Dow√≥dca:</strong><br>Ty</p>
            <p><strong>Systemy SI:</strong><br>Gemini 2.0 Flash</p>
            <p style="font-size:12px; opacity:0.7; margin-top:15px;">
              Silnik renderujƒÖcy: Three.js + Canvas 2D<br>
              Wersja: 0.9.9 Alpha
            </p>
          </div>
          <button id="btn-credits-back" class="menu-btn-styled" style="justify-content:center;">
            Zamknij
          </button>
        </div>
      </div>

      <div class="menu-footer">System online // oczekiwanie na rozkazy</div>
    </div>
  </div>
  <div id="game-root" style="position: relative; width: 100vw; height: 100vh; overflow: hidden; background: #050505;">
    <canvas id="webgl-layer" style="position: absolute; top: 0; left: 0; z-index: 0; width: 100%; height: 100%;"></canvas>
    
    <canvas id="c" style="position: absolute; top: 0; left: 0; z-index: 1; pointer-events: auto;"></canvas>
  </div>
  <div id="loading" class="hidden">
    <div class="loading-box">
      <div class="loading-title">≈Åadowanie</div>
      <div class="loading-bar"><span id="loading-fill"></span></div>
      <div id="loading-progress" class="loading-progress">0%</div>
    </div>
  </div>
  <div id="infrastructure-overlay" class="station-overlay hidden">
    <h3>Station Infrastructure</h3>
    <ul>
      <li data-tab="infrastructure">Infrastructure</li>
    </ul>
    <div class="infrastructure-body">
      <div class="infra-building-list" id="infra-building-list"></div>
      <div class="infra-info" id="infra-info">
        <h4>Budowa stacji</h4>
        <p>PrzeciƒÖgnij budynki z listy na siatkƒô wok√≥≈Ç stacji, aby rozpoczƒÖƒá ich konstrukcjƒô.</p>
      </div>
    </div>
  </div>
  <div id="zoom-indicator">ZOOM X1.00</div>
  <div id="planet-radar" class="planet-radar"></div>
  <div id="hover-info" class="hover-info hidden">
    <div class="hover-title"></div>
    <span class="hover-subtitle"></span>
    <div class="hover-content"></div>
  </div>
  <script type="importmap">
{
  "imports": {
    "three": "./node_modules/three/build/three.module.js",
    "three/addons/": "./node_modules/three/examples/jsm/"
  }
}
</script>
  <script type="module" src="./src/config/constants.js"></script>
  <script type="module" src="./src/ai/aiUtils.js"></script>
  <script type="module" src="./src/ai/capitalAI.js"></script>
  <script type="module" src="./src/ai/fighterAI.js"></script>
  <script src="https://unpkg.com/regl/dist/regl.min.js"></script>
  <script type="module">
    import * as THREE from "three";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
    import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
    import { CopyShader } from "three/addons/shaders/CopyShader.js";
    import { createShortNeedleExhaust, createWarpExhaustBlue } from "./Engineeffects.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { initWorld3D, attachPirateStation3D, dettachPirateStation3D, updateWorld3D, drawWorld3D } from "./src/3d/world3d.js";
    import { initStations3D, updateStations3D, detachPlanetStations3D, drawStations3D } from "./src/3d/stations3D.js";
    import { initOverlay } from "./src/effects3d/overlay.js";
    import { createRailgunExplosionFactory } from "./src/effects3d/railgunExplosion.js";
    import { createArmataImpactFactory } from "./src/effects3d/armataImpact.js";
    import { createAutocannonImpactFactory } from "./src/effects3d/autocannonImpact.js";
    import { createReactorBlowFactory } from "./src/effects3d/reactorblow.js";
    import * as Space2DBackground from "./src/lib/space2d/tyroBackground.js";
    import { WarpBlackHole } from "./src/vfx/warpBlackHole.js";
    import { drawInfrastructureIcon, updateInfrastructureAnimations } from './src/buildings/infrastructureView.js';
    import { createShipEntity, applyPlayerInput, runShipAI } from "./src/game/shipEntity.js";
    import { DestructorSystem, initHexBody, drawHexBody, drawHexBodyLocal } from "./src/game/destructor.js";
    window.THREE = THREE;
    window.EffectComposer = EffectComposer;
    window.RenderPass = RenderPass;
    window.UnrealBloomPass = UnrealBloomPass;
    window.ShaderPass = ShaderPass;
    window.OutputPass = OutputPass;
    window.createShortNeedleExhaust = createShortNeedleExhaust;
    window.createWarpExhaustBlue = createWarpExhaustBlue;
    window.GLTFLoader = GLTFLoader;
    window.initWorld3D = initWorld3D;
    window.attachPirateStation3D = attachPirateStation3D;
    window.dettachPirateStation3D = dettachPirateStation3D;
    window.updateWorld3D = updateWorld3D;
    window.drawWorld3D = drawWorld3D;
    window.initStations3D = initStations3D;
    window.updateStations3D = updateStations3D;
    window.drawStations3D = drawStations3D;
    window.detachPlanetStations3D = detachPlanetStations3D;
    window.initOverlay3D = initOverlay;
    window.createRailgunExplosionFactory = createRailgunExplosionFactory;
    window.createArmataImpactFactory = createArmataImpactFactory;
    window.createAutocannonImpactFactory = createAutocannonImpactFactory;
    window.createReactorBlowFactory = createReactorBlowFactory;
    window.createShipEntity = createShipEntity;
    window.applyPlayerInput = applyPlayerInput;
    window.runShipAI = runShipAI;
    window.drawInfrastructureIcon = drawInfrastructureIcon;
    window.updateInfrastructureAnimations = updateInfrastructureAnimations;
    window.DestructorSystem = DestructorSystem;
    window.initHexBody = initHexBody;
    window.drawHexBody = drawHexBody;
    window.drawHexBodyLocal = drawHexBodyLocal;
    // Nie modyfikujemy namespace'u modu≈Çu THREE (jest niemodyfikowalny).
    // Je≈õli co≈õ potrzebuje CopyShader globalnie, wystawiamy go przez window:
    window.CopyShader = CopyShader;
    window.Space2DBackground = Space2DBackground;

    const warpFX = new WarpBlackHole({ zIndex: 45, mode: 'offscreen' });
    warpFX.setEnabled(false);
    window.warpBlackHoleFX = warpFX;

  </script>
  <!-- prze≈ÇƒÖcznik: aktywuj assetowy renderer planet (klasyczny skrypt, aby globalne API by≈Ço gotowe zanim ruszy pƒôtla gry) -->
  <script type="module" src="planet3d.assets.js"></script>

  <script type="module">
    import { DEFAULT_PLANET_SCALE, TIME_SCALE } from './src/config/constants.js';
    import { WORLD, setWorldSize } from './src/world/world.js';
    import { initShieldSystem, updateShieldFx, drawShield, registerShieldImpact, resizeShieldSystem, triggerEnergyShot as applyEnergyShot } from './shieldSystem.js';
    // DODANO IMPORT SHIP_PHYSICS
    import { createShipEntity, applyPlayerInput, runShipAI, SHIP_PHYSICS } from "./src/game/shipEntity.js";
    import { DestructorSystem, initHexBody, drawHexBody, drawHexBodyLocal } from "./src/game/destructor.js";
    // IMPORTUJEMY NOWY MODU≈Å SUPERBRONI
    import * as Superweapon from "./src/game/superweapon.js";
    import { HUDSystem } from "./src/ui/hudSystem.js";
    import { WEAPONS, WEAPON_ICON_PATHS, AISPACE_GUNS, AISPACE_PD, AISPACE_MISSILES, AISPACE_GUNS_M } from "./src/data/weapons.js";
    import { SHIPS as SHIP_FRAMES, SUPPORT_SHIP_TEMPLATES as SUPPORT_SHIP_TEMPLATES_DATA, CAPITAL_SHIP_TEMPLATES as CAPITAL_SHIP_TEMPLATES_DATA } from "./src/data/ships.js";
    // Statki Terran (Wsparcie)
    import terranFrigateImg from "./src/assets/ships/terranfrigate.png";
    import terranDestroyerImg from "./src/assets/ships/terrandestroyer.png";
    import terranBattleshipImg from "./src/assets/ships/terranbattleship.png";

    // Statki Pirat√≥w
    import pirateFrigateImg from "./src/assets/ships/piratefrigate.png";
    import pirateDestroyerImg from "./src/assets/ships/piratedestroyer.png";
    import pirateBattleshipImg from "./src/assets/ships/piratebattleship.png";

    // Jednostki mniejsze
    import fighterImg from "./assets/fighter.png";
    import npcFriImg from "./assets/npc_friendly.png";
    import npcHosImg from "./assets/npc_hostile.png";
    window.bullets = [];
    // Aby stary kod dzia≈Ça≈Ç, zrobimy alias:
    const bullets = window.bullets;
    window.registerShieldImpact = registerShieldImpact;
    window.DEFAULT_PLANET_SCALE ??= DEFAULT_PLANET_SCALE;
    window.TIME_SCALE ??= TIME_SCALE;
    window.WORLD ??= WORLD;

    const hud = new HUDSystem();
    hud.init();
    window.hudSystem = hud;

    // LOKALNY alias na potrzeby tego modu≈Çu (ESM nie widzi 'go≈Çych' globali z window):
    const PLANET_SCALE =
      (typeof window !== 'undefined' && typeof window.DEFAULT_PLANET_SCALE !== 'undefined')
        ? window.DEFAULT_PLANET_SCALE : (DEFAULT_PLANET_SCALE ?? 3);

    let warpBrakeTimer = 0;
    const GRAVITY_WELL_IDS = ['planet_gravity', 'pirate_gravity', 'sun'];

    function isGravityWellZoneId(id) {
      return GRAVITY_WELL_IDS.includes(id);
    }

    function resolveGravityWellSource(zoneId) {
      if (zoneId === 'sun') return { x: SUN.x, y: SUN.y };
      if (zoneId === 'pirate_gravity' && mercMission?.station) {
        return { x: mercMission.station.x, y: mercMission.station.y };
      }
      if (zoneId === 'planet_gravity' && Array.isArray(planets)) {
        const playerPos = ship?.pos || null;
        let closest = null;
        for (const planet of planets) {
          if (!planet) continue;
          const dist = playerPos
            ? Math.hypot(planet.x - playerPos.x, planet.y - playerPos.y)
            : Math.hypot(planet.x, planet.y);
          if (!closest || dist < closest.dist) {
            closest = { x: planet.x, y: planet.y, dist };
          }
        }
        if (closest) return { x: closest.x, y: closest.y };
      }
      return null;
    }

    function gravityBrakeCameraOffset() {
      const brake = warp?.gravityBrake;
      if (!brake || !brake.active || brake.duration <= 0) return null;
      const t = clamp(brake.timer / brake.duration, 0, 1);
      const ease = Math.pow(t, 0.8);
      const baseMag = 120 + Math.min(480, brake.startSpeed * 0.06);
      const mag = baseMag * ease;
      return { x: brake.dir.x * mag, y: brake.dir.y * mag };
    }

    // =============== Canvas & utils ===============
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    let W = canvas.width = innerWidth, H = canvas.height = innerHeight;

    const fleetUIRoot = document.getElementById('panel-fleet');
    const fleetListEl = document.getElementById('fleet-list');
    const supportUIRoot = document.getElementById('panel-support');
    const supportGuardBtn = document.getElementById('support-guard');
    const supportEngageBtn = document.getElementById('support-engage');
    const supportSpawnButtons = document.querySelectorAll('[data-support-spawn]');
    const carrierSpawnBtn = document.querySelector('[data-support-spawn="carrier_capital"]');
    const shieldControlsRoot = document.getElementById('panel-shield');
    const energyShotBtn = document.getElementById('btn-energy-shot');
    const supportDragState = {
      active: false,
      key: null,
      sourceBtn: null
    };
    const SUPPORT_DRAG_TYPES = new Set([
      'carrier_capital',
      'frigate_pd',
      'frigate_laser',
      'destroyer',
      'battleship'
    ]);
    const SUPPORT_CLICK_TYPES = new Set([
      'fighter',
      'carrier_fighter'
    ]);

    function isSupportDragKey(key) {
      return SUPPORT_DRAG_TYPES.has(key);
    }

    function beginSupportDrag(key, btn) {
      supportDragState.active = true;
      supportDragState.key = key;
      supportDragState.sourceBtn = btn || null;
    }

    function endSupportDrag(event) {
      if (!supportDragState.active) return false;
      const key = supportDragState.key;
      supportDragState.active = false;
      supportDragState.key = null;
      supportDragState.sourceBtn = null;

      const rect = canvas.getBoundingClientRect();
      const x = event.clientX;
      const y = event.clientY;
      const overCanvas = x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
      if (overCanvas) {
        const world = screenToWorld(x - rect.left, y - rect.top);
        if (key === 'carrier_capital') {
          spawnFriendlyCarrier({ pos: world });
        } else {
          spawnSupportShip(key, { spawnPos: world });
        }
        setSupportOrder('guard', { force: true });
      }
      mouse.left = false;
      mouse.click = false;
      return true;
    }

    function setupSidePanel(panelEl) {
      if (!panelEl) return null;
      const toggleBtn = panelEl.querySelector('.panel-toggle');
      const bodyEl = panelEl.querySelector('.side-panel-body');
      let collapsed = false;

      function applyState() {
        panelEl.classList.toggle('collapsed', collapsed);
        if (bodyEl) bodyEl.setAttribute('aria-hidden', collapsed ? 'true' : 'false');
        panelEl.setAttribute('data-collapsed', collapsed ? 'true' : 'false');
      }

      applyState();

      if (toggleBtn) {
        toggleBtn.addEventListener('click', () => {
          collapsed = !collapsed;
          applyState();
        });
      }

      return {
        collapse() { if (!collapsed) { collapsed = true; applyState(); } },
        expand() { if (collapsed) { collapsed = false; applyState(); } },
        isCollapsed: () => collapsed
      };
    }

    const fleetPanel = setupSidePanel(fleetUIRoot);
    const supportPanel = setupSidePanel(supportUIRoot);
    const shieldPanel = setupSidePanel(shieldControlsRoot);
    const Fleet = window.Fleet || (window.Fleet = {
      ships: [],
      dirty: true,
      ui: {
        root: fleetUIRoot || null,
        list: fleetListEl || null,
        lastUpdate: 0
      }
    });
    if (!Fleet.ui.root && fleetUIRoot) Fleet.ui.root = fleetUIRoot;
    if (!Fleet.ui.list && fleetListEl) Fleet.ui.list = fleetListEl;
    function markFleetDirty() { Fleet.dirty = true; }

    const SupportWing = window.SupportWing || (window.SupportWing = {
      units: [],
      order: 'guard',
      ui: {
        root: supportUIRoot || null,
        guardBtn: supportGuardBtn || null,
        engageBtn: supportEngageBtn || null
      }
    });
    if (!SupportWing.ui.root && supportUIRoot) SupportWing.ui.root = supportUIRoot;
    if (!SupportWing.ui.guardBtn && supportGuardBtn) SupportWing.ui.guardBtn = supportGuardBtn;
    if (!SupportWing.ui.engageBtn && supportEngageBtn) SupportWing.ui.engageBtn = supportEngageBtn;

    const OPTIONS = {
      vfx: { colorTempK: 8000, bloomGain: 1.1, engineGain: 1.0 },
      audio: { master: 0.8, sfx: 1.0, music: 0.7 },
      controls: { mouseSensitivity: 1.0 }, // bez odwracania osi
      planetQuality: 'medium'
    };
    window.OPTIONS = OPTIONS;
    let OPTIONS_OPEN = false;

    // --- SYSTEM AUDIO (AudioSys) ---
    const AudioSys = {
      ctx: null,
      masterGain: null,
      sounds: {},
      isInit: false,

      // Inicjalizacja kontekstu (musi byƒá po klikniƒôciu u≈ºytkownika)
      init: function () {
        if (this.isInit) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();

        // G≈Ç√≥wna szyna g≈Ço≈õno≈õci (Master)
        this.masterGain = this.ctx.createGain();
        // Pobieramy g≈Ço≈õno≈õƒá z Twoich OPTIONS (je≈õli sƒÖ dostƒôpne)
        const vol = (typeof OPTIONS !== 'undefined') ? OPTIONS.audio.master : 0.5;
        this.masterGain.gain.value = vol;
        this.masterGain.connect(this.ctx.destination);

        this.isInit = true;
        console.log("üîä AudioSys: Zainicjowano.");
      },

      // ≈Åadowanie pojedynczego d≈∫wiƒôku do pamiƒôci
      loadSound: async function (name, url) {
        if (!this.ctx) this.init();
        try {
          const response = await fetch(url);
          const arrayBuffer = await response.arrayBuffer();
          const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
          this.sounds[name] = audioBuffer;
          console.log(`üîä AudioSys: Za≈Çadowano '${name}'`);
        } catch (e) {
          console.error(`üîä AudioSys: B≈ÇƒÖd ≈Çadowania '${name}' z ${url}:`, e);
        }
      },

      // Tworzenie zapƒôtlonego silnika (z kontrolƒÖ Pitch i Volume)
      createEngineLoop: function (soundName) {
        if (!this.sounds[soundName]) return null;

        const source = this.ctx.createBufferSource();
        source.buffer = this.sounds[soundName];
        source.loop = true;

        const gainNode = this.ctx.createGain();
        gainNode.gain.value = 0; // Na start cisza

        // ≈Åa≈Ñcuch: ≈πr√≥d≈Ço -> Gain -> Master -> Wyj≈õcie
        source.connect(gainNode);
        gainNode.connect(this.masterGain);

        source.start(0);

        return {
          source: source,
          gain: gainNode,

          // Funkcja aktualizujƒÖca brzmienie w czasie rzeczywistym
          update: (throttle) => {
            const now = AudioSys.ctx.currentTime;
            const targetPitch = 0.5 + (throttle * 0.6);
            source.playbackRate.setTargetAtTime(targetPitch, now, 0.2);
            let baseVol = 0.05 + (throttle * 0.25);

            // Pobranie ustawie≈Ñ SFX gracza
            const sfxVol = (typeof OPTIONS !== 'undefined') ? OPTIONS.audio.sfx : 1.0;

            // Aplikowanie g≈Ço≈õno≈õci
            gainNode.gain.setTargetAtTime(baseVol * sfxVol, now, 0.1);
          },

          stop: () => {
            try { source.stop(); } catch (e) { }
          }
        };
      },
      // Prosta funkcja do strza≈Ç√≥w (na przysz≈Ço≈õƒá)
      playSound: function (name) {
        if (!this.sounds[name]) return;
        const source = this.ctx.createBufferSource();
        source.buffer = this.sounds[name];
        const sfxVol = (typeof OPTIONS !== 'undefined') ? OPTIONS.audio.sfx : 1.0;

        const gain = this.ctx.createGain();
        gain.gain.value = sfxVol;

        source.connect(gain);
        gain.connect(this.masterGain);
        source.start(0);
      }
    };
window.AudioSys = AudioSys;
    // --- CENTRALA D≈πWIƒòKOWA UZBROJENIA ---
    window.addEventListener('game_weapon_fired', (e) => {
      if (!window.AudioSys || !window.AudioSys.isInit) return;

      const { weaponId, x, y } = e.detail;

      // Tutaj decydujemy jaki d≈∫wiƒôk graƒá w zale≈ºno≈õci od ID broni
      switch (weaponId) {
        case 'hexlance':
          // Odtw√≥rz d≈∫wiƒôk superbroni (z lekkƒÖ wariacjƒÖ tonu)
          playDynamicSound('sfx_hexlance', { pitchVar: 0.1, volume: 0.6 });
          break;

        case 'railgun_mk1':
        case 'railgun_mk2':
          playDynamicSound('sfx_railgun', { pitchVar: 0.2, volume: 0.05 });
          break;

        case 'main_cannon':
          // (Przysz≈Ço≈õƒá) Tu dodasz d≈∫wiƒôk dla Main Cannon
          // playDynamicSound('sfx_maincannon', { pitchVar: 0.2, volume: 0.6 });
          break;

        case 'nuclear_missile':
          // (Przysz≈Ço≈õƒá) Inna superbro≈Ñ
          // playDynamicSound('sfx_nuke_launch', { volume: 1.0 });
          break;
      }
    });

    // Helper do ≈Çadniejszego odtwarzania d≈∫wiƒôk√≥w (z wariacjƒÖ)
    function playDynamicSound(soundKey, opts = {}) {
      const ctx = window.AudioSys.ctx;
      const buffer = window.AudioSys.sounds[soundKey];
      if (!ctx || !buffer) return;

      const source = ctx.createBufferSource();
      source.buffer = buffer;

      // Losowa wariacja tonu (≈ºeby seria nie brzmia≈Ça sztucznie)
      if (opts.pitchVar) {
        const detune = (Math.random() - 0.5) * 2 * opts.pitchVar; 
        source.playbackRate.value = 1.0 + detune;
      }

      const gainNode = ctx.createGain();
      // Ustaw g≈Ço≈õno≈õƒá (bazujƒÖc na opcjach gry + opcjach wywo≈Çania)
      const gameSfxVol = (typeof OPTIONS !== 'undefined') ? OPTIONS.audio.sfx : 1.0;
      gainNode.gain.value = (opts.volume || 1.0) * gameSfxVol;

      source.connect(gainNode);
      gainNode.connect(window.AudioSys.masterGain);
      source.start(0);
    }

    const uiRoot = document.getElementById('ui');
    const mainMenuEl = document.getElementById('main-menu');
    const newGameButton = document.getElementById('btn-new-game');
    const loadGameButton = document.getElementById('btn-load-game');
    const optionsButton = document.getElementById('btn-options');
    const creditsButton = document.getElementById('btn-credits');
    const continueButton = document.getElementById('btn-continue');
    const menuHomeView = document.getElementById('menu-home-view');
    const menuOptionsView = document.getElementById('menu-options-view');
    const menuCreditsView = document.getElementById('menu-credits-view');
    const MENU_MUSIC_SRC = '/sounds/menu/menu.mp3';
    let menuMusicEl = null;
    let menuMusicFadeId = null;
    let menuMusicUnlockAttached = false;
    const optionsBackButton = document.getElementById('btn-options-back');
    const creditsBackButton = document.getElementById('btn-credits-back');
    const qualityButtons = Array.from(document.querySelectorAll('[data-quality]'));
    const loadingEl = document.getElementById('loading');
    const loadingFillEl = document.getElementById('loading-fill');
    const loadingProgressEl = document.getElementById('loading-progress');
    const planetRadarRoot = document.getElementById('planet-radar');
    const hudTopbarRoot = document.getElementById('hud-topbar');
    const skillSlotsEl = document.getElementById('skill-slots');
    const hullFillEl = document.getElementById('player-hull-fill');
    const shieldFillEl = document.getElementById('player-shield-fill');
    const hullLabelEl = document.getElementById('player-hull-label');
    const shieldLabelEl = document.getElementById('player-shield-label');
    let gameStarted = false;
    let menuView = 'home';

    function setLoadingProgress(value, label) {
      const clamped = Math.max(0, Math.min(100, Math.round(value)));
      if (loadingFillEl) loadingFillEl.style.width = `${clamped}%`;
      if (loadingProgressEl) loadingProgressEl.textContent = label ? `${clamped}% ¬∑ ${label}` : `${clamped}%`;
    }

    function showLoadingOverlay(progress = 0, label = '') {
      if (loadingEl) loadingEl.classList.remove('hidden');
      setLoadingProgress(progress, label);
    }

    function hideLoadingOverlay() {
      if (loadingEl) loadingEl.classList.add('hidden');
    }

    function nextFrame() {
      return new Promise(resolve => requestAnimationFrame(() => resolve()));
    }

    function waitForCondition(predicate, timeoutMs = 4000) {
      return new Promise(resolve => {
        const start = performance.now();
        (function poll() {
          if (predicate()) return resolve();
          if (performance.now() - start >= timeoutMs) return resolve();
          requestAnimationFrame(poll);
        })();
      });
    }

    function setMenuView(nextView = 'home') {
      if (nextView !== 'options' && nextView !== 'credits') {
        menuView = 'home';
      } else {
        menuView = nextView;
      }
      if (menuHomeView) menuHomeView.classList.toggle('active', menuView === 'home');
      if (menuOptionsView) menuOptionsView.classList.toggle('active', menuView === 'options');
      if (menuCreditsView) menuCreditsView.classList.toggle('active', menuView === 'credits');
      if (menuView === 'options') applyQualitySelection();
    }

    function getMenuMusicVolume() {
      const master = OPTIONS?.audio?.master ?? 1;
      const music = OPTIONS?.audio?.music ?? 1;
      return Math.max(0, Math.min(1, master * music));
    }

    function getMenuMusic() {
      if (!menuMusicEl) {
        menuMusicEl = new Audio(MENU_MUSIC_SRC);
        menuMusicEl.loop = true;
        menuMusicEl.volume = getMenuMusicVolume();
      }
      return menuMusicEl;
    }

    function tryPlayMenuMusic() {
      if (gameStarted) return;
      const audio = getMenuMusic();
      audio.volume = getMenuMusicVolume();
      const unlock = () => {
        audio.play().catch(() => { });
        document.removeEventListener('pointerdown', unlock);
        document.removeEventListener('keydown', unlock);
        menuMusicUnlockAttached = false;
      };

      const playPromise = audio.play();
      if (playPromise && typeof playPromise.catch === 'function') {
        playPromise.catch(() => {
          if (menuMusicUnlockAttached) return;
          menuMusicUnlockAttached = true;
          document.addEventListener('pointerdown', unlock, { once: true });
          document.addEventListener('keydown', unlock, { once: true });
        });
      }
    }

    function fadeOutMenuMusic(duration = 1200) {
      if (menuMusicFadeId) cancelAnimationFrame(menuMusicFadeId);
      const audio = menuMusicEl;
      if (!audio || audio.paused || audio.volume <= 0.001) {
        if (audio) {
          audio.pause();
          audio.currentTime = 0;
        }
        return Promise.resolve();
      }
      const startVolume = audio.volume;
      return new Promise(resolve => {
        const start = performance.now();
        const step = (now) => {
          const t = Math.min(1, (now - start) / duration);
          const v = startVolume * (1 - t);
          audio.volume = Math.max(0, v);
          if (t < 1) {
            menuMusicFadeId = requestAnimationFrame(step);
          } else {
            audio.pause();
            audio.currentTime = 0;
            resolve();
          }
        };
        menuMusicFadeId = requestAnimationFrame(step);
      });
    }

    function isMainMenuVisible() {
      return !!mainMenuEl && !mainMenuEl.classList.contains('hidden');
    }

    // --- ZBIORCZA LISTA ELEMENT√ìW HUD (Nowych i starych) ---
    function getGameUIElements() {
      return [
        // G≈Ç√≥wne kontenery AERO HUD
        document.getElementById('hud-top-container'),
        document.getElementById('hud-bottom-container'),
        
        // Kontenery boczne
        document.getElementById('side-panels-container'),
        document.getElementById('right-panels-container'),
        
        // Bezpo≈õrednie panele (dla pewno≈õci)
        document.getElementById('panel-support'),
        document.getElementById('panel-fleet'),
        
        // Elementy Overlay
        document.getElementById('planet-radar'),
        document.getElementById('zoom-indicator'),
        document.getElementById('hint-box'),
        
        // Stare/Inne elementy
        document.getElementById('hud-topbar'),
        document.getElementById('ui'),
        
        // Canvasy hex pancerza (dla pewno≈õci, choƒá sƒÖ w bottom-container)
        document.getElementById('hex-armor-container')
      ];
    }

    function toggleGameUI(visible) {
      const elements = getGameUIElements();
      elements.forEach(el => {
        if (el) {
          if (visible) el.classList.remove('hidden');
          else el.classList.add('hidden');
        }
      });
    }

    if (isMainMenuVisible()) {
      toggleGameUI(false);
      tryPlayMenuMusic();
    }

    function showMainMenu(view = 'home') {
      setMenuView(view);
      if (mainMenuEl) mainMenuEl.classList.remove('hidden');
      
      // UKRYJ HUD GRY GDY MENU JEST OTWARTE
      toggleGameUI(false);

      if (gameStarted) setPaused(true);
      if (!gameStarted) tryPlayMenuMusic();
    }

    function hideMainMenu() {
      if (mainMenuEl) mainMenuEl.classList.add('hidden');
      
      // POKA≈ª HUD GRY TYLKO JE≈öLI GRA JEST ROZPOCZƒòTA
      if (gameStarted) {
        toggleGameUI(true);
        setPaused(false);
      }
    }

   

    function toggleMainMenu() {
      if (isMainMenuVisible()) hideMainMenu();
      else showMainMenu('home');
    }

    function getBackgroundQuality() {
      if (window.Nebula?.getConfig) return window.Nebula.getConfig().quality;
      if (window.Space2DBackground?.getConfig) return window.Space2DBackground.getConfig().quality;
      return null;
    }

    function applyQualitySelection() {
      const current = getBackgroundQuality();
      if (!qualityButtons || !qualityButtons.length) return;
      qualityButtons.forEach(btn => {
        const isActive = btn.dataset.quality === current;
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
    }

    function setBackgroundQuality(quality) {
      if (window.Nebula?.setQuality) window.Nebula.setQuality(quality);
      else if (window.Space2DBackground?.setQuality) window.Space2DBackground.setQuality(quality);
      applyQualitySelection();
    }

    if (skillSlotsEl && skillSlotsEl.childElementCount === 0) {
      const slots = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'];
      slots.forEach(label => {
        const slot = document.createElement('div');
        slot.className = 'skill-slot';
        slot.textContent = label;
        skillSlotsEl.appendChild(slot);
      });
    }

    // Model widoku overlayu (ortho nad ≈õwiatem 2D)
    const overlayView = {
      center: { x: 0, y: 0 },
      viewport: { w: innerWidth, h: innerHeight },
      zoom: 1.0
    };

    let spaceBg = null;
    let spaceBgReady = false;
    const warpBlackHoleFX = window.warpBlackHoleFX || null;
    let warpLensMode = 'background';
    let warpLensSource = null;

    const WARP_LENS_DEFAULTS = Object.freeze({
      threshold: 0,
      radiusBase: 0.6,
      radiusScale: 0.3,
      massBase: 0,
      massScale: 0.035,
      softness: 0.6,
      opacityBase: 0.55,
      opacityScale: 0.73,
      tailDepthExtra: -0.2,
      forwardStretch: 1.0
    });

    const DevVFX = window.DevVFX = window.DevVFX || {};
    DevVFX.warpLens = Object.assign({}, WARP_LENS_DEFAULTS, DevVFX.warpLens || {});
    window.__WARP_LENS_DEFAULTS = WARP_LENS_DEFAULTS;

    function warpLensParam(key) {
      const defaults = WARP_LENS_DEFAULTS;
      const bag = DevVFX?.warpLens || defaults;
      const raw = bag[key];
      return Number.isFinite(raw) ? raw : defaults[key];
    }

    function getAuToWorldUnits() {
      return (typeof BASE_ORBIT === 'number' && BASE_ORBIT > 0) ? BASE_ORBIT : 3000;
    }

    function getWarpLensThreshold() {
      const v = warpLensParam('threshold');
      if (!Number.isFinite(v)) return WARP_LENS_DEFAULTS.threshold;
      return Math.min(1, Math.max(0, v));
    }

    function configureWarpLensSource() {
      if (!warpBlackHoleFX) return;
      if (typeof warpBlackHoleFX.setSourceParallaxTransform === 'function') {
        warpBlackHoleFX.setSourceParallaxTransform(null);
      }
      if (warpLensMode === 'background') {
        if (spaceBg && typeof spaceBg.getBackgroundCanvas === 'function') {
          const descriptor = typeof spaceBg.getBackgroundSampleDescriptor === 'function'
            ? spaceBg.getBackgroundSampleDescriptor()
            : null;
          const src = descriptor?.canvas ?? spaceBg.getBackgroundCanvas();
          if (src && warpLensSource !== src) {
            warpLensSource = src;
            warpBlackHoleFX.setSourceCanvas(src);
          }
          if (descriptor && typeof warpBlackHoleFX.setSourceParallaxTransform === 'function') {
            warpBlackHoleFX.setSourceParallaxTransform(descriptor);
          }
        }
      } else if (warpLensMode === 'full') {
        if (warpLensSource !== ctx.canvas) {
          warpLensSource = ctx.canvas;
          warpBlackHoleFX.setSourceCanvas(ctx.canvas);
        }
      }
    }

    if (warpBlackHoleFX) {
      window.setWarpLensMode = function (mode) {
        const next = mode === 'full' ? 'full' : 'background';
        if (warpLensMode !== next) {
          warpLensMode = next;
          warpLensSource = null;
          configureWarpLensSource();
        }
      };
      window.addEventListener('resize', configureWarpLensSource);
    }

    if (typeof configureWarpLensSource === 'function') {
      configureWarpLensSource();
    }

    function tryInitSpaceBackground() {
      if (spaceBgReady) return true;
      const module = window.Space2DBackground;
      if (!module) return false;
      spaceBg = module;
      try {
        module.setBgOptions?.({
          renderSun: false,
          renderNebulae: true,
          renderStars: true,
          renderPointStars: false,
          shortScale: true
        });
        module.initSpaceBg?.(window.SUN?.seed ?? 12345);
        module.resizeSpaceBg?.(innerWidth, innerHeight);
        spaceBgReady = true;
        configureWarpLensSource();
        window.removeEventListener('DOMContentLoaded', tryInitSpaceBackground);
        window.removeEventListener('load', tryInitSpaceBackground);
        return true;
      } catch (err) {
        return false;
      }
    }

    if (!tryInitSpaceBackground()) {
      window.addEventListener('DOMContentLoaded', tryInitSpaceBackground);
      window.addEventListener('load', tryInitSpaceBackground);
      let spaceBgPollAttempts = 0;
      const MAX_SPACE_BG_POLL_ATTEMPTS = 240;
      (function pollSpaceBackground() {
        if (tryInitSpaceBackground() || spaceBgPollAttempts++ >= MAX_SPACE_BG_POLL_ATTEMPTS) return;
        requestAnimationFrame(pollSpaceBackground);
      })();
    }

    function waitForSpaceBackgroundReady() {
      if (spaceBgReady) return Promise.resolve();
      return waitForCondition(() => spaceBgReady, 2500);
    }

    let mainScene3D = null;
    let planetScene3D = null;
    let planetStationsReady = false;

    //const { createShipEntity, applyPlayerInput, runShipAI } = window

    function asThreeScene(candidate) {
      if (!candidate) return null;
      if (candidate.isScene) return candidate;
      if (candidate.scene && candidate.scene.isScene) return candidate.scene;
      if (candidate.scene3D && candidate.scene3D.isScene) return candidate.scene3D;
      if (candidate.planetScene && candidate.planetScene.isScene) return candidate.planetScene;
      if (candidate.sceneObject && candidate.sceneObject.isScene) return candidate.sceneObject;
      return null;
    }

    function findPlanetScene3D() {
      const directCandidates = [
        mainScene3D,
        planetScene3D,
        window.planetsScene3D,
        window.planetsScene,
        window.planetScene3D,
        window.PlanetScene3D,
        window.PlanetsScene3D,
        window.planets3DScene,
        window.planets3D
      ];
      for (const candidate of directCandidates) {
        const scene = asThreeScene(candidate);
        if (scene) return scene;
      }
      const lazyCandidates = [
        typeof window.getPlanetsScene3D === 'function' ? window.getPlanetsScene3D() : null,
        typeof window.getPlanetScene3D === 'function' ? window.getPlanetScene3D() : null
      ];
      for (const candidate of lazyCandidates) {
        const scene = asThreeScene(candidate);
        if (scene) return scene;
      }
      return null;
    }

    function ensurePlanetStationsInit(stationsList) {
      if (typeof window.initStations3D !== 'function') return false;
      if (!Array.isArray(stationsList)) return false;
      if (!planetStationsReady) {
        window.initStations3D(null, stationsList);
        planetStationsReady = true;
      }
      return planetStationsReady;
    }

    function detachPlanetStationsIfNeeded() {
      if (typeof window.detachPlanetStations3D === 'function') {
        window.detachPlanetStations3D(planetScene3D);
      }
      planetScene3D = null;
      planetStationsReady = false;
    }

    window.addEventListener('beforeunload', detachPlanetStationsIfNeeded);

    // Dev flags/tuning (persisted via  where available)
    window.DevFlags = Object.assign({
      showRuler: false,
      showPlanetOrbits: false,
      unlimitedWarp: false,
      showSunDir: false,
      use3DPirateStation: true,
      usePlanetStations3D: true,
      disableCameraShake: false
    }, window.DevFlags || {});
    const DEFAULT_PIRATE_STATION_SCALE = 6;
    const DEFAULT_STATION_3D_SCALE = 2.70;
    window.DEFAULT_STATION_SCALE = DEFAULT_PIRATE_STATION_SCALE;
    window.DEFAULT_STATION_3D_SCALE = DEFAULT_STATION_3D_SCALE;

    window.DevTuning = Object.assign({
      pirateStationScale: DEFAULT_PIRATE_STATION_SCALE
    }, window.DevTuning || {});

    const DevFlags = window.DevFlags;
    const DevTuning = window.DevTuning;
    const Dev = window.Dev = window.Dev || {};
    if (!Number.isFinite(Dev.station3DScale) || Dev.station3DScale <= 0) {
      Dev.station3DScale = DEFAULT_STATION_3D_SCALE;
    }
    if (!Number.isFinite(DevTuning.pirateStationScale)) {
      DevTuning.pirateStationScale = DEFAULT_PIRATE_STATION_SCALE;
    }

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    function clampTurnAngle(currentAng, targetAng, maxRateRad, dt) {
      let d = targetAng - currentAng;
      while (d > Math.PI) d -= 2 * Math.PI;
      while (d < -Math.PI) d += 2 * Math.PI;
      const change = Math.max(-maxRateRad * dt, Math.min(maxRateRad * dt, d));
      let out = currentAng + change;
      if (out > Math.PI) out -= 2 * Math.PI;
      if (out < -Math.PI) out += 2 * Math.PI;
      return out;
    }

    function dist2(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return dx * dx + dy * dy;
    }
    const lerp = (a, b, t) => a + (b - a) * t;
    const add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });
    const mul = (v, s) => ({ x: v.x * s, y: v.y * s });
    const len = v => Math.hypot(v.x, v.y);
    const norm = v => { const L = len(v); return L ? { x: v.x / L, y: v.y / L } : { x: 0, y: 0 }; };
    function getEllipseRadiusAtAngle(angle, rx, ry) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return (rx * ry) / Math.sqrt((ry * cos) ** 2 + (rx * sin) ** 2);
    }
    function isLineOfFireBlocked(shooter, target, weaponRange) {
      const start = { x: shooter.x, y: shooter.y };
      const targetX = target.pos ? target.pos.x : target.x;
      const targetY = target.pos ? target.pos.y : target.y;
      const distToTarget = Math.hypot(targetX - shooter.x, targetY - shooter.y);
      if (!Number.isFinite(distToTarget) || distToTarget <= 0) return false;
      const checkDist = Math.min(distToTarget, weaponRange || 1000);

      const dx = (targetX - shooter.x) / distToTarget;
      const dy = (targetY - shooter.y) / distToTarget;

      const potentialVictims = [window.ship, ...npcs];

      for (const victim of potentialVictims) {
        if (victim === shooter || victim.dead) continue;

        const isAlly = (shooter.friendly === victim.friendly) || (shooter.friendly && victim === window.ship);
        if (!isAlly) continue;

        const victimRadius = victim.radius ?? victim.r ?? 0;
        const distToVictim = Math.hypot(victim.x - start.x, victim.y - start.y);
        if (distToVictim > checkDist + victimRadius) continue;

        const dot = (victim.x - start.x) * dx + (victim.y - start.y) * dy;
        if (dot < 0) continue;

        const closestX = start.x + dx * dot;
        const closestY = start.y + dy * dot;

        const distSq = (victim.x - closestX) ** 2 + (victim.y - closestY) ** 2;

        const safeRadius = (victimRadius || 20) + 15;

        if (distSq < safeRadius * safeRadius) {
          return true;
        }
      }

      return false;
    }
    window.clampTurnAngle = clampTurnAngle;
    window.dist2 = dist2;
    window.isLineOfFireBlocked = isLineOfFireBlocked;
    const smoothstep01 = t => { const x = clamp(t, 0, 1); return x * x * (3 - 2 * x); };
    function rotate(local, a) { const c = Math.cos(a), s = Math.sin(a); return { x: local.x * c - local.y * s, y: local.x * s + local.y * c }; }
    function rotateInv(world, a) { return rotate(world, -a); }
    function muzzlePosFor(entity, dir, extra = 8) {
      const rad = (entity.radius != null) ? entity.radius : (entity.r != null ? entity.r : 12);
      return { x: entity.x + dir.x * (rad + extra), y: entity.y + dir.y * (rad + extra) };
    }

    const fleetNumberFormatter = new Intl.NumberFormat('pl-PL', { maximumFractionDigits: 0 });
    const FLEET_UI_REFRESH_MS = 1000;
    const SUPPORT_TYPE_LABELS = {
      fighter: 'Mysliwiec',
      frigate_pd: 'Fregata PD',
      frigate_laser: 'Fregata Laserowa',
      destroyer: 'Destroyer',
      battleship: 'Battleship',
      carrier: 'Capital',
      capital: 'Capital',
      supercapital: 'Supercapital'
    };
    const UNIMPLEMENTED_FLEET_TYPES = new Set(['capital', 'supercapital']);
    window.aiSpawnBullet = function (sim, from, to, weapon) {
      const ang = Math.atan2(to.y - from.y, to.x - from.x);
      const spread = (weapon.spread || 0) * (Math.PI / 180);
      const a = ang + (Math.random() * 2 - 1) * spread;
      const speed = weapon.speed || 500;

      // Mapowanie wyglƒÖdu pocisku
      let bType = 'plasma';
      if (weapon.name && weapon.name.includes('Rail')) bType = 'rail';
      if (weapon.name && weapon.name.includes('Flak')) bType = 'armata';

      window.bullets.push({
        x: from.x,
        y: from.y,
        vx: Math.cos(a) * speed + (from.vx || 0) * 0.2,
        vy: Math.sin(a) * speed + (from.vy || 0) * 0.2,
        life: (weapon.range || 1000) / speed,
        r: (bType === 'rail') ? 4 : 3,
        owner: from.friendly ? 'player' : 'npc',
        damage: weapon.dmg || 10,
        type: bType,
        color: weapon.color || '#ffd36e',
        source: from,
        explodeRadius: (bType === 'armata') ? (weapon.radius || 40) : 0
      });
    };
    function formatFleetNumber(value) {
      if (!Number.isFinite(value)) return '0';
      return fleetNumberFormatter.format(Math.max(0, Math.round(value)));
    }

    function getSupportTypeLabel(typeKey) {
      if (!typeKey) return 'Jednostka';
      return SUPPORT_TYPE_LABELS[typeKey] || typeKey;
    }

    function buildSupportEntries() {
      const entries = [];
      const units = Array.isArray(SupportWing?.units) ? SupportWing.units : [];
      const liveUnits = units.filter(u => u && u.npc && !u.npc.dead && u.npc.friendly);
      const fighterCount = liveUnits.filter(u => (u.type || u.npc?.type) === 'fighter').length;
      if (fighterCount > 0) {
        entries.push({ kind: 'fighters', label: 'Mysliwce', count: fighterCount });
      }

      for (const unit of liveUnits) {
        const npc = unit.npc;
        const typeKey = unit.type || npc.type;
        if (typeKey === 'fighter') continue;
        const shield = npc.shield || {};
        const label = getSupportTypeLabel(typeKey);

        entries.push({
          id: unit.slotIndex ?? `${typeKey || 'support'}_${entries.length}`,
          kind: UNIMPLEMENTED_FLEET_TYPES.has(typeKey) ? 'placeholder' : 'ship',
          name: label,
          typeLabel: label,
          meta: 'Wsparcie',
          hull: Math.max(0, npc.hp ?? 0),
          shield: Math.max(0, shield.val ?? 0)
        });
      }
      return entries;
    }

    function buildCapitalEntries() {
      const entries = [];
      for (const ship of Fleet.ships) {
        const npc = ship.entity;
        if (!npc || npc.dead || !npc.friendly) continue;
        const typeKey = ship.type || npc.type || 'capital';
        const label = ship.displayName || getSupportTypeLabel(typeKey);
        const shield = npc.shield || {};

        entries.push({
          id: ship.id || `${typeKey}_${entries.length}`,
          kind: UNIMPLEMENTED_FLEET_TYPES.has(typeKey) ? 'placeholder' : 'ship',
          name: label,
          typeLabel: ship.roleText || getSupportTypeLabel(typeKey),
          meta: ship.roleText || 'Capital',
          hull: Math.max(0, ship.status?.hull ?? npc.hp ?? 0),
          shield: Math.max(0, ship.status?.shield ?? shield.val ?? 0)
        });
      }
      return entries;
    }

    function renderFleetEntry(entry) {
      const item = document.createElement('div');
      item.className = 'fleet-item';

      const header = document.createElement('div');
      header.className = 'fleet-header';
      const nameEl = document.createElement('div');
      nameEl.className = 'fleet-name';
      const typeEl = document.createElement('div');
      typeEl.className = 'fleet-type';

      if (entry.kind === 'fighters') {
        nameEl.textContent = `${entry.label}`;
        typeEl.textContent = `x${formatFleetNumber(entry.count)}`;
        header.append(nameEl, typeEl);
        item.appendChild(header);
        return item;
      }

      nameEl.textContent = entry.name;
      typeEl.textContent = entry.typeLabel || entry.meta || 'Flota';
      header.append(nameEl, typeEl);
      item.appendChild(header);

      if (entry.kind === 'placeholder') {
        const note = document.createElement('div');
        note.className = 'fleet-type';
        note.textContent = 'W przygotowaniu';
        item.appendChild(note);
        return item;
      }

      const bars = document.createElement('div');
      bars.className = 'fleet-bars';
      const hpBar = document.createElement('div');
      hpBar.className = 'mini-bar';
      const hpFill = document.createElement('div');
      hpFill.className = 'mini-fill hp';
      hpFill.style.width = entry.hull > 0 ? '100%' : '0%';
      hpBar.appendChild(hpFill);

      const shieldBar = document.createElement('div');
      shieldBar.className = 'mini-bar';
      const shieldFill = document.createElement('div');
      shieldFill.className = 'mini-fill shield';
      shieldFill.style.width = entry.shield > 0 ? '100%' : '0%';
      shieldBar.appendChild(shieldFill);

      bars.append(hpBar, shieldBar);
      item.appendChild(bars);

      return item;
    }

    function updateFleetUI() {
      // --- POPRAWKA: Je≈õli menu jest otwarte, nie ruszaj UI ---
      if (isMainMenuVisible()) return;
      // --------------------------------------------------------

      const ui = Fleet.ui;
      if (!ui || !ui.root || !ui.list) return;
      const now = performance.now();
      if (!Fleet.dirty && now - (ui.lastUpdate || 0) < FLEET_UI_REFRESH_MS) return;
      ui.lastUpdate = now;

      const entries = [...buildSupportEntries(), ...buildCapitalEntries()];
      if (!entries.length) {
        ui.root.classList.add('hidden');
        ui.list.innerHTML = '';
        Fleet.dirty = false;
        return;
      }

      ui.root.classList.remove('hidden');
      ui.list.innerHTML = '';
      for (const entry of entries) {
        ui.list.appendChild(renderFleetEntry(entry));
      }
      Fleet.dirty = false;
    }

    const SUPPORT_FORMATION = {
      lineOrder: ['frigate_laser', 'frigate_pd', 'destroyer', 'battleship', 'fighter'],
      lead: 260,
      lineGap: 160,
      lateralGap: 160,
      spawn: { perRow: 4, colGap: 90, rowGap: 70, lead: 160 },
      fighterSquadSize: 9,
      fighterOffsets: [
        { x: -20, y: -15 }, { x: -20, y: 15 },
        { x: -40, y: -30 }, { x: -40, y: 30 },
        { x: -60, y: -45 }, { x: -60, y: 45 },
        { x: -80, y: -60 }, { x: -80, y: 60 }
      ],
      fighterSpacing: 90
    };
    function supportGuardSlot(slotIndex) {
      const data = SupportWing.units[slotIndex] || null;
      const leader = (data?.leader && !data.leader.dead) ? data.leader : ship;
      const leaderPos = leader?.pos || { x: leader?.x ?? ship.pos.x, y: leader?.y ?? ship.pos.y };
      const leaderAng = leader?.angle ?? ship.angle;
      const type = data?.type || 'fighter';
      const lineOrder = SUPPORT_FORMATION.lineOrder || [];
      const lineIndex = lineOrder.includes(type) ? lineOrder.indexOf(type) : lineOrder.length;

      if (type === 'fighter') {
        const squadSize = SUPPORT_FORMATION.fighterSquadSize || 9;
        const fighters = SupportWing.units.filter(u => u && !u.npc?.dead && u.type === 'fighter');
        const fighterIndex = fighters.indexOf(data);
        const squadIndex = Math.max(0, Math.floor(Math.max(0, fighterIndex) / squadSize));
        const squadMateIndex = Math.max(0, fighterIndex % squadSize);
        const squadCount = Math.max(1, Math.ceil(fighters.length / squadSize));

        const lateralSpacing = SUPPORT_FORMATION.fighterSpacing || SUPPORT_FORMATION.lateralGap || 90;
        const lateral = (squadIndex - (squadCount - 1) * 0.5) * lateralSpacing;
        const forward = (SUPPORT_FORMATION.lead + lineIndex * SUPPORT_FORMATION.lineGap);
        const leaderLocal = { x: forward, y: lateral };
        const leaderRotated = rotate(leaderLocal, leaderAng - Math.PI / 2);

        if (squadMateIndex === 0) {
          return { x: leaderPos.x + leaderRotated.x, y: leaderPos.y + leaderRotated.y };
        }

        const offsets = SUPPORT_FORMATION.fighterOffsets || [];
        const formationOffset = offsets[squadMateIndex - 1] || offsets[offsets.length - 1] || { x: -40, y: 0 };
        const rotatedOffset = rotate(formationOffset, leaderAng);
        return {
          x: leaderPos.x + leaderRotated.x + rotatedOffset.x,
          y: leaderPos.y + leaderRotated.y + rotatedOffset.y
        };
      }

      const peers = SupportWing.units.filter(u => u && !u.npc?.dead && u.type === type);
      const colCount = Math.max(1, peers.length);
      const positionInLine = Math.max(0, peers.indexOf(data));
      const lateral = (positionInLine - (colCount - 1) / 2) * SUPPORT_FORMATION.lateralGap;
      const forward = SUPPORT_FORMATION.lead + lineIndex * SUPPORT_FORMATION.lineGap;

      const local = { x: forward, y: lateral };
      const rotated = rotate(local, leaderAng - Math.PI / 2);
      return { x: leaderPos.x + rotated.x, y: leaderPos.y + rotated.y };
    }

    function setSupportOrder(order, opts = {}) {
      const normalized = order === 'engage' ? 'engage' : 'guard';
      if (SupportWing.order === normalized && !opts.force) return;
      SupportWing.order = normalized;

      if (SupportWing.ui.guardBtn) {
        SupportWing.ui.guardBtn.classList.toggle('active', normalized === 'guard');
      }
      if (SupportWing.ui.engageBtn) {
        SupportWing.ui.engageBtn.classList.toggle('active', normalized === 'engage');
      }
    }

    function cleanupSupportWing() {
      SupportWing.units = SupportWing.units.filter(data => data?.npc && !data.npc.dead);
      SupportWing.units.forEach((data, idx) => { data.slotIndex = idx; });
    }

    function getFriendlyCarrierEntity() {
      const carrierEntry = Fleet?.ships?.find(s => s?.type === 'carrier' && s.entity && !s.entity.dead);
      return carrierEntry?.entity || null;
    }

    function updateSupportWing(dt) {
      cleanupSupportWing();
      if (SupportWing.ui.root) {
        SupportWing.ui.root.classList.remove('hidden');
      }
      if (carrierSpawnBtn) {
        const hasCarrier = !!getFriendlyCarrierEntity();
        carrierSpawnBtn.classList.toggle('disabled', hasCarrier);
        carrierSpawnBtn.setAttribute('aria-disabled', hasCarrier ? 'true' : 'false');
      }
      if (SupportWing.order === 'engage') {
        const piratesAlive = npcs.some(n => n && !n.dead && n.isPirate);
        if (!piratesAlive) {
          setSupportOrder('guard', { force: true });
        }
      }
    }

    function supportGuardBehavior(npc, slotIndex, dt) {
      const slot = supportGuardSlot(slotIndex);

      // --- FIX: Detekcja kolizji z Liderem ---
      const leader = (npc.supportData?.leader) || ship;
      const distToLeader = Math.hypot(npc.x - leader.x, npc.y - leader.y);

      // Bezpieczna strefa wok√≥≈Ç lidera
      const minSafeDist = (leader.radius || 220) + (npc.radius || 30) + 60;

      if (distToLeader < minSafeDist) {
        // JESTE≈ö ZA BLISKO! Tryb ucieczki
        const pushX = npc.x - leader.x;
        const pushY = npc.y - leader.y;
        const dist = Math.hypot(pushX, pushY) || 1;
        const dir = { x: pushX / dist, y: pushY / dist };

        // Wymu≈õ odlot od lidera
        const wantSpeed = npc.maxSpeed * 0.9;
        const turned = window.clampTurnVec(npc.vx, npc.vy, dir.x * wantSpeed, dir.y * wantSpeed, dt, 360);

        npc.vx = turned.vx;
        npc.vy = turned.vy;
        npc.angle = Math.atan2(npc.vy, npc.vx);
        return; // Przerywamy, nie lecimy do slotu
      }

      // Standardowy lot do slotu (je≈õli jest bezpiecznie)
      const dx = slot.x - npc.x;
      const dy = slot.y - npc.y;
      const dist = Math.hypot(dx, dy) || 1;
      const dir = { x: dx / dist, y: dy / dist };
      const wantSpeed = Math.min(npc.maxSpeed || 240, dist * 1.4);
      const turned = window.clampTurnVec(npc.vx, npc.vy, dir.x * wantSpeed, dir.y * wantSpeed, dt, 220);
      npc.vx = turned.vx;
      npc.vy = turned.vy;
      npc.angle = Math.atan2(npc.vy || 0, npc.vx || 0);

      if (dist < 12) {
        npc.vx *= 0.92;
        npc.vy *= 0.92;
      }
      npc.forceTarget = null;
      npc.target = null;
    }

    function steerNpcTowards(npc, target, dt, opts = {}) {
      const dx = target.x - npc.x;
      const dy = target.y - npc.y;
      const dist = Math.hypot(dx, dy) || 1;
      const dir = { x: dx / dist, y: dy / dist };
      const wantSpeed = Math.min(opts.maxSpeed || npc.maxSpeed || 240, dist * (opts.speedScale || 1.2));
      const turned = window.clampTurnVec(npc.vx || 0, npc.vy || 0, dir.x * wantSpeed, dir.y * wantSpeed, dt, opts.turnLimit || 220);
      npc.vx = turned.vx;
      npc.vy = turned.vy;
      npc.angle = Math.atan2(npc.vy || 0, npc.vx || 0);
      return dist;
    }
    function applySeparationForces(npc, ax, ay) {
      const myRadius = npc.radius || 20;
      const myMass = npc.mass || 1;

      for (const other of npcs) {
        if (other === npc || other.dead) continue;
        // Du≈ºe statki ignorujƒÖ ma≈Çe my≈õliwce (niech my≈õliwce schodzƒÖ z drogi)
        if (npc.isCapitalShip && other.fighter) continue;

        const dx = npc.x - other.x;
        const dy = npc.y - other.y;
        const distSq = dx * dx + dy * dy;

        // Zasiƒôg: promienie + margines 100 jednostek
        const otherRadius = other.radius || 20;
        const safeDistance = myRadius + otherRadius + 100;

        if (distSq < safeDistance * safeDistance) {
          const dist = Math.sqrt(distSq) || 1;
          const overlap = safeDistance - dist;

          // Im bli≈ºej, tym potƒô≈ºniejsza si≈Ça odpychajƒÖca
          const force = (overlap * 20.0) / myMass;

          ax += (dx / dist) * force;
          ay += (dy / dist) * force;
        }
      }

      // --- SEPARACJA OD GRACZA (Priorytet absolutny) ---
      if (window.ship && !window.ship.destroyed && npc !== window.ship) {
        const player = window.ship;
        const dx = npc.x - player.pos.x;
        const dy = npc.y - player.pos.y;
        const distSq = dx * dx + dy * dy;

        // Gracz ma du≈ºy promie≈Ñ (Capital), dajemy du≈ºy margines bezpiecze≈Ñstwa
        // (radius Gracza ~220 + radius NPC + 180 marginesu)
        const playerRadius = player.radius || 220;
        const safeDistance = myRadius + playerRadius + 180;

        if (distSq < safeDistance * safeDistance) {
          const dist = Math.sqrt(distSq) || 1;
          const overlap = safeDistance - dist;

          // GIGANTYCZNA si≈Ça odpychania dla sojusznik√≥w, ≈ºeby nie wlatywali w gracza
          const pushStrength = npc.friendly ? 60.0 : 15.0;
          const force = (overlap * pushStrength) / myMass;

          ax += (dx / dist) * force;
          ay += (dy / dist) * force;

          // Hamulec awaryjny: Je≈õli lecisz W STRONƒò gracza, natychmiast hamuj
          const dot = npc.vx * (-dx) + npc.vy * (-dy);
          if (dot > 0) {
            npc.vx *= 0.85; // Mocne hamowanie
            npc.vy *= 0.85;
          }
        }
      }

      return { ax, ay };
    }
    window.applySeparationForces = applySeparationForces;
    function handleCommandedNpc(npc, dt) {
      const cmd = npc.command;
      if (!cmd || !cmd.target) return false;
      const attackMove = cmd.type === 'attack-move';
      if (attackMove) {
        const target = aiPickTarget(npc);
        if (target) {
          npc.forceTarget = target;
          return false;
        }
      }
      const arrival = cmd.arrival || (npc.radius || 20) + 20;
      const dist = steerNpcTowards(npc, cmd.target, dt, { turnLimit: attackMove ? 260 : 220 });
      if (dist <= arrival) {
        npc.command = null;
        npc.forceTarget = null;
      }
      return true;
    }

    // === FIX SUPPORT AI (Guard vs Engage) ===
    function runSupportAI(npc, dt) {
      const data = npc.supportData;
      if (!data) return;

      // Zaznacz, ≈ºe ten NPC nale≈ºy do skrzyd≈Ça wsparcia
      npc.isSupportWing = true;

      // Aktualny rozkaz skrzyd≈Ça (domy≈õlnie guard, jakby co≈õ by≈Ço nieustawione)
      const order = (typeof SupportWing !== 'undefined' && SupportWing && SupportWing.order)
        ? SupportWing.order
        : 'guard';

      npc.supportOrder = order; // przyda siƒô w fighter AI

      const ENGAGE_RANGE = 25000; // zasiƒôg polowania w ENGAGE
      const GUARD_ATTACK_RANGE = 6000;  // zasiƒôg odpalenia ataku w GUARD

      const searchRange = (order === 'engage') ? ENGAGE_RANGE : GUARD_ATTACK_RANGE;

      // 1. Znajd≈∫ cel
      let target = null;

      if (window.aiPickBestTarget) {
        target = window.aiPickBestTarget(npc, searchRange);
      } else if (window.aiPickTarget) {
        target = window.aiPickTarget(npc);
        // je≈ºeli aiPickTarget nie respektuje zasiƒôgu ‚Äì doci≈õnijmy rƒôcznie
        if (target) {
          const d2 = dist2(npc, target);
          if (d2 > searchRange * searchRange) {
            target = null;
          }
        }
      }

      // W trybie ENGAGE, je≈õli nie ma celu w zasiƒôgu, leƒá do najbli≈ºszego wroga na mapie
      if (order === 'engage' && !target && Array.isArray(npcs)) {
        let best = null;
        let bestD2 = Infinity;
        for (const n of npcs) {
          if (!n || n.dead || !n.isPirate) continue;
          const dx = n.x - npc.x;
          const dy = n.y - npc.y;
          const d2 = dx * dx + dy * dy;
          if (d2 < bestD2) {
            bestD2 = d2;
            best = n;
          }
        }
        target = best;
      }

      // 2. Ustaw cel na NPC
      npc.forceTarget = target || null;
      npc.target = target || null;

      // 3. Wykonanie AI
      if (target) {
        // --- TRYB BOJOWY ---
        if (data.type === 'fighter') {
          if (window.runAdvancedFighterAI) {
            window.runAdvancedFighterAI(npc, dt);
          }
        } else if (data.type === 'frigate_pd' || data.type === 'frigate_laser') {
          if (window.aiFrigate) window.aiFrigate(null, npc, dt);
        } else if (data.type === 'destroyer') {
          if (window.aiDestroyer) window.aiDestroyer(null, npc, dt);
        } else if (data.type === 'battleship') {
          if (window.aiBattleship) window.aiBattleship(null, npc, dt);
        }
      } else {
        // --- TRYB FORMACJI (Brak wrog√≥w / wr√≥g daleko w GUARD) ---
        supportGuardBehavior(npc, data.slotIndex, dt);

        if (npc.keepAngle) {
          npc.angle = Math.atan2(npc.vy, npc.vx);
        }

        // My≈õliwiec bez celu wraca logicznie do stanu "guard"
        if (data.type === 'fighter') {
          npc.state = 'guard';
        }
      }
    }

    function isPirateStation(st) {
      if (!st) return false;
      const name = typeof st.name === 'string' ? st.name.toLowerCase() : '';
      return st.isPirate || st.type === 'pirate' || st.style === 'pirate' || name.includes('pir');
    }

    function stationScaleFor(st) {
      const baseDefault = DEFAULT_STATION_3D_SCALE;
      const rawGlobal = Number.isFinite(Dev.station3DScale) ? Dev.station3DScale : NaN;
      const globalScale = (Number.isFinite(rawGlobal) && rawGlobal > 0) ? rawGlobal : baseDefault;
      const rawPirate = Number.isFinite(DevTuning.pirateStationScale) ? DevTuning.pirateStationScale : NaN;
      const pirateScale = (Number.isFinite(rawPirate) && rawPirate > 0) ? rawPirate : globalScale;
      return isPirateStation(st) ? pirateScale : globalScale;
    }

    // === HARDPOINTS: enums ===
    const HP = {
      MAIN: 'main',
      MISSILE: 'missile',
      AUX: 'aux',
      HANGAR: 'hangar',
      SPECIAL: 'special'
    };

    // === definicje broni ===

    // === definicje statk√≥w / ram ===
    const SHIPS = buildShipFrames(SHIP_FRAMES);

    function buildShipFrames(shipFrames) {
      const frames = {};
      for (const [id, frame] of Object.entries(shipFrames)) {
        frames[id] = {
          ...frame,
          genHardpoints(bounds) {
            return buildShipHardpoints(frame.hardpointLayout, bounds);
          }
        };
      }
      return frames;
    }

    function buildShipHardpoints(layout, bounds) {
      if (!layout) return [];
      const rotation = layout.rotate || null;
      const layoutBounds = rotation ? { w: bounds.h, h: bounds.w } : bounds;
      if (layout.type === 'atlas_broadside') {
        const hp = buildAtlasHardpoints(layout, layoutBounds);
        return applyHardpointRotation(hp, rotation);
      }
      if (layout.type === 'lines') {
        const hp = [];
        for (const line of layout.lines || []) {
          placeLineNormalized(hp, line.type, line.count, line.start, line.end, layoutBounds);
        }
        for (const special of layout.specials || []) {
          hp.push({
            id: uid(),
            type: special.type,
            pos: { x: (special.pos?.x || 0) * layoutBounds.w, y: (special.pos?.y || 0) * layoutBounds.h, rot: 0 },
            mount: null,
            ammo: null,
            maxAmmo: null
          });
        }
        return applyHardpointRotation(hp, rotation);
      }
      return [];
    }

    function buildAtlasHardpoints(layout, bounds) {
      const w = bounds.w, h = bounds.h;
      const hp = [];
      const leftX = w * layout.leftX;
      const rightX = w * layout.rightX;
      const spreadX = w * layout.spreadX;
      const depthY = h * layout.depthY;
      const startY = layout.startY;
      const gapY = layout.gapY;
      const rows = layout.rows || 0;

      for (let i = 0; i < rows; i++) {
        const cy = (startY * h) + (i * gapY * h);
        hp.push({ id: uid(), type: HP.MAIN, pos: { x: leftX, y: cy - depthY, rot: 0 }, mount: null, ammo: null, maxAmmo: null });
        hp.push({ id: uid(), type: HP.MAIN, pos: { x: leftX - spreadX, y: cy + depthY, rot: 0 }, mount: null, ammo: null, maxAmmo: null });
        hp.push({ id: uid(), type: HP.MAIN, pos: { x: leftX + spreadX, y: cy + depthY, rot: 0 }, mount: null, ammo: null, maxAmmo: null });

        hp.push({ id: uid(), type: HP.MAIN, pos: { x: rightX, y: cy - depthY, rot: 0 }, mount: null, ammo: null, maxAmmo: null });
        hp.push({ id: uid(), type: HP.MAIN, pos: { x: rightX - spreadX, y: cy + depthY, rot: 0 }, mount: null, ammo: null, maxAmmo: null });
        hp.push({ id: uid(), type: HP.MAIN, pos: { x: rightX + spreadX, y: cy + depthY, rot: 0 }, mount: null, ammo: null, maxAmmo: null });
      }
      return hp;
    }

    function applyHardpointRotation(hardpoints, rotation) {
      if (!rotation) return hardpoints;
      for (const hp of hardpoints) {
        const { x, y } = hp.pos || { x: 0, y: 0 };
        if (rotation === 'cw') {
          hp.pos.x = y;
          hp.pos.y = -x;
        } else if (rotation === 'ccw') {
          hp.pos.x = -y;
          hp.pos.y = x;
        }
      }
      return hardpoints;
    }

    function placeLineNormalized(out, type, count, a, b, bounds) {
      placeLine(out, type, count, { x: a.x * bounds.w, y: a.y * bounds.h }, { x: b.x * bounds.w, y: b.y * bounds.h });
    }

    function placeLine(out, type, count, a, b) {
      for (let i = 0; i < count; i++) {
        const t = count === 1 ? 0.5 : (i / (count - 1));
        out.push({ id: uid(), type, pos: { x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t, rot: 0 }, mount: null, ammo: null, maxAmmo: null });
      }
    }
    function uid() { return 'hp_' + Math.random().toString(36).slice(2, 9); }

    const Game = window.Game || (window.Game = {});
    Game.infrastructure = Game.infrastructure || new Map();
    Game.stationEconomy = Game.stationEconomy || new Map();
    const previousPlayer = Game.player || {};
    const defaultInventory = ['railgun_mk1', 'railgun_mk2', 'armata_mk1', 'heavy_autocannon', 'missile_rack', 'ciws_mk1', 'laser_pd_mk1', 'fighter_bay', 'super_f'];
    const existingInventory = previousPlayer.inventory ? Array.from(previousPlayer.inventory) : [];
    const mergedInventory = new Set([...existingInventory, ...defaultInventory]);
    const hasSavedShipPosition = !!previousPlayer.pos;

    // =============== Ship ===============
    const shipOverrides = {};
    if (previousPlayer.pos) shipOverrides.pos = previousPlayer.pos;
    if (previousPlayer.vel) shipOverrides.vel = previousPlayer.vel;
    if (typeof previousPlayer.angle === 'number') shipOverrides.angle = previousPlayer.angle;
    if (typeof previousPlayer.angVel === 'number') shipOverrides.angVel = previousPlayer.angVel;
    if (typeof previousPlayer.mass === 'number') shipOverrides.mass = previousPlayer.mass;
    if (typeof previousPlayer.linearDamping === 'number') shipOverrides.linearDamping = previousPlayer.linearDamping;
    if (typeof previousPlayer.angularDamping === 'number') shipOverrides.angularDamping = previousPlayer.angularDamping;
    if (typeof previousPlayer.w === 'number') shipOverrides.w = previousPlayer.w;
    if (typeof previousPlayer.h === 'number') shipOverrides.h = previousPlayer.h;
    if (previousPlayer.controller) shipOverrides.controller = previousPlayer.controller;
    if (previousPlayer.aiController) shipOverrides.aiController = previousPlayer.aiController;

    Game.player = createShipEntity({ world: WORLD, overlayView, overrides: shipOverrides });
    const ship = Game.player;
    window.ship = ship;

    ship.inventory = mergedInventory;
    ship.shipFrame = previousPlayer.shipFrame || 'atlas';
    ship.hardpoints = previousPlayer.hardpoints || [];
    ship.weapons = previousPlayer.weapons || {};
    ship.spriteW = previousPlayer.spriteW || ship.spriteW || 260;
    ship.spriteH = previousPlayer.spriteH || ship.spriteH || 520;
    ship.destroyed = ship.hull?.val <= 0;

    if (previousPlayer && typeof previousPlayer === 'object') {
      for (const [key, value] of Object.entries(previousPlayer)) {
        if (ship[key] === undefined) {
          ship[key] = value;
        }
      }
    }

    overlayView.center.x = ship.pos.x;
    overlayView.center.y = ship.pos.y;

    let rocketAmmo = 0;
    let rocketAmmoMax = 0;

    function triggerEnergyShot() {
      if (!ship?.shield) return;
      applyEnergyShot(ship);
    }
    window.triggerEnergyShot = triggerEnergyShot;

    function setHardpointMount(hp, weaponId, opts = {}) {
      if (!hp) return;
      const weapon = weaponId ? WEAPONS[weaponId] : null;
      const inventory = Game.player?.inventory;
      if (!weapon || (inventory && weaponId && !inventory.has(weaponId)) || weapon.type !== hp.type) {
        hp.mount = null;
        hp.ammo = null;
        hp.maxAmmo = null;
        return;
      }
      hp.mount = weaponId;
      const baseMax = weapon.ammo != null ? weapon.ammo : null;
      hp.maxAmmo = opts.hasOwnProperty('maxAmmo') ? opts.maxAmmo : baseMax;
      if (weapon.ammo != null) {
        const desiredAmmo = opts.hasOwnProperty('ammo') ? opts.ammo : weapon.ammo;
        hp.ammo = Math.max(0, desiredAmmo);
      } else {
        hp.ammo = null;
      }
    }

    function rebuildHardpointsForFrame() {
      const frame = SHIPS[Game.player.shipFrame];
      if (!frame) return;
      const spriteSize = { w: Game.player.spriteW || 260, h: Game.player.spriteH || 520 };
      Game.player.hardpoints = frame.genHardpoints(spriteSize);
      autoMountDefaults();
      syncWeaponSystems();
    }

    function autoMountDefaults() {
      mountFirstFree(HP.MAIN, 'railgun_mk2', 24);
      mountFirstFree(HP.MISSILE, 'missile_rack', 8);
      mountFirstFree(HP.AUX, 'ciws_mk1', 8);
      mountFirstFree(HP.HANGAR, 'fighter_bay', 4);
      mountFirstFree(HP.SPECIAL, 'super_f', 1);
    }

    function mountFirstFree(type, weaponId, howMany) {
      if (!Game.player.inventory.has(weaponId)) return;
      for (const hp of Game.player.hardpoints) {
        if (howMany <= 0) break;
        if (hp.type === type && !hp.mount) {
          setHardpointMount(hp, weaponId);
          howMany--;
        }
      }
    }

    function syncWeaponSystems() {
      const byType = {};
      for (const type of Object.values(HP)) byType[type] = [];
      for (const hp of Game.player.hardpoints) {
        if (!hp.mount) continue;
        const weapon = WEAPONS[hp.mount];
        if (weapon) byType[hp.type].push({ hp, weapon });
      }
      Game.player.weapons = byType;
      rocketAmmoMax = missileAmmoCapacity();
      rocketAmmo = missileAmmoTotal();
      updateMainWeaponBehavior();
    }

    function getMainWeaponBehaviorForWeaponId(id) {
      if (!id) return MAIN_WEAPON_BEHAVIOR.default;
      return MAIN_WEAPON_BEHAVIOR[id] || MAIN_WEAPON_BEHAVIOR.default;
    }

    function updateMainWeaponBehavior() {
      const mainWeapons = Game.player.weapons?.[HP.MAIN] || [];
      let behavior = MAIN_WEAPON_BEHAVIOR.default;
      if (mainWeapons.length) {
        for (const loadout of mainWeapons) {
          const id = loadout?.weapon?.id;
          const candidate = getMainWeaponBehaviorForWeaponId(id);
          if (!candidate) continue;
          const candidatePriority = candidate.priority ?? 0;
          const currentPriority = behavior.priority ?? 0;
          const candidateCooldown = candidate.cooldown ?? MAIN_WEAPON_BEHAVIOR.default.cooldown;
          const currentCooldown = behavior.cooldown ?? MAIN_WEAPON_BEHAVIOR.default.cooldown;
          const preferCandidate = (candidatePriority > currentPriority)
            || (candidatePriority === currentPriority && candidateCooldown > currentCooldown);
          if (preferCandidate) {
            behavior = candidate;
          }
        }
      }
      rail.behaviorId = behavior.id || 'default';
      rail.cdMax = behavior.cooldown ?? MAIN_WEAPON_BEHAVIOR.default.cooldown;
      rail.shotGap = behavior.shotGap ?? MAIN_WEAPON_BEHAVIOR.default.shotGap;
      rail.burstGap = behavior.burstGap ?? MAIN_WEAPON_BEHAVIOR.default.burstGap;
      rail.burstsPerClick = behavior.burstsPerClick ?? MAIN_WEAPON_BEHAVIOR.default.burstsPerClick;
      rail.barrelsPerShot = behavior.barrelsPerShot ?? MAIN_WEAPON_BEHAVIOR.default.barrelsPerShot;
    }

    function missileAmmoTotal() {
      let total = 0;
      for (const hp of Game.player.hardpoints) {
        if (hp.type === HP.MISSILE && hp.mount) {
          if (typeof hp.ammo === 'number') total += hp.ammo;
        }
      }
      return total;
    }

    function missileAmmoCapacity() {
      let total = 0;
      for (const hp of Game.player.hardpoints) {
        if (hp.type === HP.MISSILE && hp.mount) {
          if (typeof hp.maxAmmo === 'number') total += hp.maxAmmo;
        }
      }
      return total;
    }

    function tryPreserveMounts(previous) {
      if (!previous) return;
      const byType = new Map();
      for (const hp of previous) {
        if (!hp.mount) continue;
        const entry = { weaponId: hp.mount, ammo: hp.ammo, maxAmmo: hp.maxAmmo };
        if (!byType.has(hp.type)) byType.set(hp.type, []);
        byType.get(hp.type).push(entry);
      }
      for (const hp of Game.player.hardpoints) {
        const arr = byType.get(hp.type);
        if (arr && arr.length) {
          const entry = arr.shift();
          setHardpointMount(hp, entry.weaponId, { ammo: entry.ammo, maxAmmo: entry.maxAmmo });
        }
      }
    }

    function saveLoadout() {
      try {
        localStorage.setItem('loadout', JSON.stringify({
          shipFrame: Game.player.shipFrame,
          hardpoints: Game.player.hardpoints.map(h => ({ id: h.id, type: h.type, mount: h.mount, ammo: h.ammo, maxAmmo: h.maxAmmo }))
        }));
      } catch (e) { console.warn('Loadout save error', e); }
    }

    function loadLoadout() {
      const raw = localStorage.getItem('loadout');
      if (!raw) { syncWeaponSystems(); return; }
      try {
        const data = JSON.parse(raw);
        if (data.shipFrame && SHIPS[data.shipFrame]) {
          Game.player.shipFrame = data.shipFrame;
        }
        const frame = SHIPS[Game.player.shipFrame];
        if (frame) {
          const spriteSize = { w: Game.player.spriteW || 260, h: Game.player.spriteH || 520 };
          const fresh = frame.genHardpoints(spriteSize);
          const savedByType = new Map();
          for (const saved of (data.hardpoints || [])) {
            if (!saved.mount) continue;
            if (!savedByType.has(saved.type)) savedByType.set(saved.type, []);
            savedByType.get(saved.type).push(saved);
          }
          for (const hp of fresh) {
            const arr = savedByType.get(hp.type);
            if (arr && arr.length) {
              const saved = arr.shift();
              setHardpointMount(hp, saved.mount, { ammo: saved.ammo, maxAmmo: saved.maxAmmo });
            }
          }
          Game.player.hardpoints = fresh;
        }
      } catch (e) {
        console.warn('Loadout parse error', e);
      }
      syncWeaponSystems();
      if (typeof renderMechanic === 'function') renderMechanic();
    }

    window.addEventListener('beforeunload', saveLoadout);

    function drawHardpointGizmos(ctx, worldPos) {
      if (!window.DEBUG_DRAW_HARDPOINTS) return;
      ctx.save();
      const screenX = (worldPos.x - camera.x) * camera.zoom + W / 2;
      const screenY = (worldPos.y - camera.y) * camera.zoom + H / 2;
      ctx.translate(screenX, screenY);
      for (const h of Game.player.hardpoints) {
        ctx.beginPath();
        ctx.arc(h.pos.x * camera.zoom, h.pos.y * camera.zoom, 6, 0, Math.PI * 2);
        ctx.strokeStyle = ({ main: '#3b82f6', missile: '#10b981', aux: '#f59e0b', hangar: '#a78bfa', special: '#ef4444' })[h.type] || '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      ctx.restore();
    }

    // =============== Floating HUD state ===============
    const HUD = {
      navArrows: [], // niebieskie strza≈Çki po X: {x,y,age,life}
    };

    // =============== Planet radar UI ===============
    const planetRadarState = {
      enabled: true,
      visited: new Set(),
      elements: new Map()
    };

    function formatAuDistance(distAu) {
      if (distAu >= 10) return `${distAu.toFixed(0)} AU`;
      if (distAu >= 1) return `${distAu.toFixed(1)} AU`;
      return `${distAu.toFixed(2)} AU`;
    }

    function projectToScreenEdge(dirX, dirY, margin) {
      const halfW = Math.max(1, W / 2 - margin);
      const halfH = Math.max(1, H / 2 - margin);
      const safeX = Math.abs(dirX) < 1e-3 ? 1e-3 : dirX;
      const safeY = Math.abs(dirY) < 1e-3 ? 1e-3 : dirY;
      const scale = Math.min(halfW / Math.abs(safeX), halfH / Math.abs(safeY));
      return { x: W / 2 + safeX * scale, y: H / 2 + safeY * scale };
    }

    function ensurePlanetRadarItem(id) {
      if (!planetRadarRoot) return null;
      let el = planetRadarState.elements.get(id);
      if (el) return el;

      const item = document.createElement('div');
      item.className = 'planet-radar-item';

      const label = document.createElement('div');
      label.className = 'planet-radar-label';

      item.append(label);
      planetRadarRoot.appendChild(item);
      planetRadarState.elements.set(id, item);
      return item;
    }

    function togglePlanetRadarVisibility(force) {
      const next = typeof force === 'boolean' ? force : !planetRadarState.enabled;
      planetRadarState.enabled = next;
      if (planetRadarRoot) {
        planetRadarRoot.classList.toggle('hidden', !next);
      }
    }

    function updatePlanetRadar(ship, cam) {
      // --- POPRAWKA ---
      if (isMainMenuVisible()) {
        if (planetRadarRoot) planetRadarRoot.classList.add('hidden');
        return;
      }
      // ----------------
      if (!Array.isArray(planets)) return;
      const auUnit = getAuToWorldUnits();
      const margin = 32;
      const maxScaleAu = 40;
      const minScale = 0.58;
      const maxScale = 1.4;
      const shouldRender = !!planetRadarRoot && planetRadarState.enabled;

      if (planetRadarRoot) {
        planetRadarRoot.classList.toggle('hidden', !planetRadarState.enabled);
      }

      for (const planet of planets) {
        if (!planet) continue;
        const id = planet.id || planet.name || '';
        if (!id) continue;

        const dx = planet.x - ship.pos.x;
        const dy = planet.y - ship.pos.y;
        const distWorld = Math.hypot(dx, dy);
        const arrivalRadius = Math.max(10, (planet.r || 0) * 2);
        const distAu = Math.max(0, (distWorld - Math.max(planet.r || 0, 0)) / auUnit);

        if (planetRadarState.visited.has(id) && distAu >= 2) {
          planetRadarState.visited.delete(id);
        }

        if (distWorld <= arrivalRadius) {
          planetRadarState.visited.add(id);
          const existing = planetRadarState.elements.get(id);
          if (existing) {
            existing.remove();
            planetRadarState.elements.delete(id);
          }
          continue;
        }

        if (planetRadarState.visited.has(id)) {
          const existing = planetRadarState.elements.get(id);
          if (existing) {
            existing.remove();
            planetRadarState.elements.delete(id);
          }
          continue;
        }

        if (!shouldRender) continue;

        const screenPos = worldToScreen(planet.x, planet.y, cam);
        const dirX = screenPos.x - W / 2;
        const dirY = screenPos.y - H / 2;
        const edgePos = projectToScreenEdge(dirX, dirY, margin);

        const item = ensurePlanetRadarItem(id);
        if (!item) continue;
        const labelEl = item.querySelector('.planet-radar-label');

        if (labelEl) {
          const ratio = clamp(distAu / maxScaleAu, 0, 1);
          const scale = maxScale - (maxScale - minScale) * ratio;
          const label = planet.label || formatPlanetLabel(planet, 0);
          labelEl.textContent = `${label} ¬∑ ${formatAuDistance(distAu)}`;
          labelEl.style.fontSize = `${11 * scale}px`;
          labelEl.style.opacity = `${0.75 + 0.25 * (1 - ratio)}`;
          labelEl.style.writingMode = '';
          labelEl.style.transform = '';
          labelEl.style.margin = '';
        }

        if (item) {
          let flexDirection = 'column';
          if (labelEl) {
            if (Math.abs(dirX) > Math.abs(dirY)) {
              labelEl.style.writingMode = 'vertical-rl';
              labelEl.style.transform = dirX > 0 ? 'rotate(180deg)' : '';
              labelEl.style.margin = '4px 0 0 0';
            } else {
              labelEl.style.writingMode = 'horizontal-tb';
            }
          }

          if (edgePos.y > H - margin * 1.5) {
            flexDirection = 'column-reverse';
          }

          item.style.flexDirection = flexDirection;
          item.style.transform = 'translate(-50%, -50%)';
        }

        item.style.left = `${edgePos.x}px`;
        item.style.top = `${edgePos.y}px`;
      }

      if (mercMission?.station && shouldRender) {
        const pirate = mercMission.station;
        const id = 'pirate_station';
        const dx = pirate.x - ship.pos.x;
        const dy = pirate.y - ship.pos.y;
        const distWorld = Math.hypot(dx, dy);
        const bodyRadius = Math.max(0, pirate.r || 0);
        const distAu = Math.max(0, (distWorld - bodyRadius) / auUnit);
        const screenPos = worldToScreen(pirate.x, pirate.y, cam);
        const dirX = screenPos.x - W / 2;
        const dirY = screenPos.y - H / 2;
        const edgePos = projectToScreenEdge(dirX, dirY, margin);
        const item = ensurePlanetRadarItem(id);

        if (item) {
          item.classList.add('pirate');
          const labelEl = item.querySelector('.planet-radar-label');
          if (labelEl) {
            const ratio = clamp(distAu / maxScaleAu, 0, 1);
            const scale = maxScale - (maxScale - minScale) * ratio;
            labelEl.textContent = `PIRATE STATION ¬∑ ${formatAuDistance(distAu)}`;
            labelEl.style.fontSize = `${11 * scale}px`;
            labelEl.style.opacity = `${0.75 + 0.25 * (1 - ratio)}`;
            labelEl.classList.add('pirate');
            labelEl.style.writingMode = '';
            labelEl.style.transform = '';
            labelEl.style.margin = '';

            if (Math.abs(dirX) > Math.abs(dirY)) {
              labelEl.style.writingMode = 'vertical-rl';
              labelEl.style.transform = dirX > 0 ? 'rotate(180deg)' : '';
              labelEl.style.margin = '4px 0 0 0';
            } else {
              labelEl.style.writingMode = 'horizontal-tb';
            }
          }

          let flexDirection = 'column';
          if (edgePos.y > H - margin * 1.5) {
            flexDirection = 'column-reverse';
          }

          item.style.flexDirection = flexDirection;
          item.style.transform = 'translate(-50%, -50%)';
          item.style.left = `${edgePos.x}px`;
          item.style.top = `${edgePos.y}px`;
        }
      }

      if (!shouldRender) return;

      for (const [id, node] of planetRadarState.elements.entries()) {
        const isPirateMarker = id === 'pirate_station';
        const pirateActive = !!mercMission?.station;
        const stillExists = planets.some(pl => (pl?.id || pl?.name) === id) || (isPirateMarker && pirateActive);
        if (!stillExists || (planetRadarState.visited.has(id) && !isPirateMarker)) {
          node.remove();
          planetRadarState.elements.delete(id);
        }
      }
    }

    function hudPingNpcStations() {
      // Niebieskie strza≈Çki do stacji nie-misyjnych; gasnƒÖ po 4s
      const targets = stations.filter(s => !s.mission).slice(0, 8);
      HUD.navArrows = targets.map(s => ({ x: s.x, y: s.y, age: 0, life: 4.0 }));
    }
    function hudUpdateNav(dt) {
      for (const p of HUD.navArrows) p.age += dt;
      HUD.navArrows = HUD.navArrows.filter(p => p.age < p.life);
    }

    function drawArrowOnRing(cx, cy, R, ang, size, color) {
      const x = cx + Math.cos(ang) * R, y = cy + Math.sin(ang) * R;
      ctx.save(); ctx.translate(x, y); ctx.rotate(ang);
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(size, 0);
      ctx.lineTo(-size * 0.6, size * 0.6);
      ctx.lineTo(-size * 0.2, 0);
      ctx.lineTo(-size * 0.6, -size * 0.6);
      ctx.closePath(); ctx.fill();
      ctx.restore();
    }
    function hudRenderNav(ship, cam) {
      if (!HUD.navArrows.length) return;
      const s = worldToScreen(ship.pos.x, ship.pos.y, cam);
      const R = Math.max(ship.w, ship.h) * camera.zoom * 0.6 + 30;
      for (const p of HUD.navArrows) {
        const ang = Math.atan2(p.y - ship.pos.y, p.x - ship.pos.x);
        const a = Math.max(0, 1 - p.age / p.life);
        ctx.save(); ctx.globalAlpha = 0.3 + 0.7 * a;
        drawArrowOnRing(s.x, s.y, R, ang, 12, '#60a5fa');
        ctx.restore();
      }
    }

    // =============== Zoom indicator ===============
    const zoomIndicatorEl = document.getElementById('zoom-indicator');
    const zoomIndicator = {
      el: zoomIndicatorEl,
      timer: 0,
      hold: 1.2,
      visible: false,
      update(dt) {
        if (!this.el) return;
        if (this.timer > 0) {
          this.timer -= dt;
          if (this.timer <= 0 && this.visible) {
            this.visible = false;
            this.el.classList.remove('visible');
          }
        }
      },
      show(zoomValue) {
        if (!this.el) return;
        const normalized = clamp(zoomValue / Math.max(0.0001, camera.maxZoom || 1), 0, 1);
        const display = normalized >= 0.995 ? 1 : Math.max(0.01, normalized);
        this.el.textContent = `ZOOM X${display.toFixed(display >= 1 ? 0 : 2)}`;
        this.timer = this.hold;
        this.visible = true;
        this.el.classList.add('visible');
      }
    };

    // =============== Game time (1 min real = 1 h game) ===============
    let gameTime = 0; // seconds
    const gameTimeEl = document.getElementById('game-time');
    function formatGameTime(sec) {
      const t = Math.floor(sec);
      const h = Math.floor(t / 3600) % 24;
      const m = Math.floor((t % 3600) / 60);
      return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;
    }

    function updatePlayerStatusUI() {
      // --- POPRAWKA: Je≈õli menu jest otwarte, przerywamy ---
      if (isMainMenuVisible()) return;
      // -----------------------------------------------------

      if (!window.hudSystem) return;
      const boostFuelMax = boost?.fuelMax || 1;
      const sysData = {
        power: (enginePower?.current ?? 0) * 100,
        boost: (boost?.fuel ?? 0) / boostFuelMax * 100,
        core: 100,
        warpState: warp?.state,
        warpCharge: warp?.charge ?? 0,
        warpMax: warp?.chargeTime ?? 1,
        warpSpeed: warp?.speed ?? 0
      };
      const envData = {
        locationName: zoneState.current?.label || 'UNKNOWN SECTOR'
      };
      window.hudSystem.update(ship, sysData, envData);
    }
    function wrapAngle(a) { while (a > Math.PI) a -= 2 * Math.PI; while (a < -Math.PI) a += 2 * Math.PI; return a; }
    window.wrapAngle = wrapAngle;
    function interpAngleShort(prev, curr, t) { const d = wrapAngle(curr - prev); return wrapAngle(prev + d * t); }
    function shuffleArray(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } }
    function leadTarget(shooter, shooterVel, target, speed) {
      const tx = target.x, ty = target.y;
      const tvx = target.vx || 0, tvy = target.vy || 0;
      const rx = tx - shooter.x, ry = ty - shooter.y;
      const rvx = tvx - shooterVel.x, rvy = tvy - shooterVel.y;
      const a = rvx * rvx + rvy * rvy - speed * speed;
      const b = 2 * (rx * rvx + ry * rvy);
      const c = rx * rx + ry * ry;
      let t = 0;
      if (Math.abs(a) < 1e-6) {
        if (Math.abs(b) > 1e-6) t = -c / b;
      } else {
        const disc = b * b - 4 * a * c;
        if (disc >= 0) {
          const sqrtDisc = Math.sqrt(disc);
          const t1 = (-b - sqrtDisc) / (2 * a);
          const t2 = (-b + sqrtDisc) / (2 * a);
          t = Math.min(t1, t2);
          if (t < 0) t = Math.max(t1, t2);
        }
      }
      if (!isFinite(t) || t < 0) t = 0;
      return { x: tx + tvx * t, y: ty + tvy * t };
    }

    // =============== World / camera ===============
    const camera = {
      x: WORLD.w / 2,
      y: WORLD.h / 2,
      zoom: 1.0,
      defaultZoom: 1.0,
      altZoom: 0.7,
      minZoom: 0.06,
      maxZoom: 3.2,
      wheelSpeed: 0.002,
      manualZoom: false,
      shakeMag: 0,
      shakeTime: 0,
      shakeDur: 0,
      mode: 'ship',
      focusStation: null,
      freePanSpeed: 1,
      lastPointerX: null,
      lastPointerY: null,
      freeKeyPanSpeed: 1400,
      targetX: WORLD.w / 2,
      targetY: WORLD.h / 2,
      targetZoom: 1.0,
      focusScreenXRatio: 0.3,
      focusScreenYRatio: 0.5,
      focusZoom: 1.0,
      focusArrived: false,
      transition: null,
      addShake(mag, dur) {
        if (DevFlags && DevFlags.disableCameraShake) {
          this.shakeMag = 0;
          this.shakeTime = 0;
          this.shakeDur = 0;
          return;
        }
        this.shakeMag = mag;
        this.shakeTime = dur;
        this.shakeDur = dur;
      },
      enterFreeMode() {
        this.mode = 'free';
        this.focusStation = null;
        this.targetX = this.x;
        this.targetY = this.y;
        this.targetZoom = this.zoom;
        this.transition = null;
        this.focusArrived = false;
        this.lastPointerX = null;
        this.lastPointerY = null;
      },
      exitFreeMode() {
        this.mode = 'ship';
        this.focusStation = null;
        this.focusArrived = false;
        this.lastPointerX = null;
        this.lastPointerY = null;
        const tx = ship.pos.x;
        const ty = ship.pos.y;
        const tz = clamp(this.zoom, this.minZoom, this.maxZoom);
        this.beginTransition(tx, ty, tz, 0.75, () => {
          this.targetX = tx;
          this.targetY = ty;
          this.targetZoom = tz;
        });
        this.manualZoom = true;
      },
      toggleFreeMode() {
        if (this.mode === 'free') this.exitFreeMode();
        else this.enterFreeMode();
      },
      beginTransition(x, y, zoom, duration = 0.8, onComplete) {
        const targetZoom = clamp(zoom, this.minZoom, this.maxZoom);
        this.manualZoom = false;
        this.transition = {
          kind: this.mode,
          startX: this.x,
          startY: this.y,
          startZoom: this.zoom,
          targetX: x,
          targetY: y,
          targetZoom,
          elapsed: 0,
          duration: Math.max(0.0001, duration),
          onComplete
        };
      },
      focusOnStation(station) {
        if (!station) return;
        this.focusStation = station;
        this.mode = 'focus';
        this.focusArrived = false;
        this.focusScreenXRatio = 0.3;
        this.focusScreenYRatio = 0.5;
        this.lastPointerX = null;
        this.lastPointerY = null;
        const target = computeStationFocusTarget(station);
        this.focusZoom = target.zoom;
        this.targetX = target.x;
        this.targetY = target.y;
        this.targetZoom = target.zoom;
        this.beginTransition(target.x, target.y, target.zoom, 0.85, () => {
          this.focusArrived = true;
        });
      },
      focusOnInfrastructure(station, layout) {
        if (!station) return;
        this.focusStation = station;
        this.mode = 'infrastructure';
        this.focusArrived = false;
        this.focusScreenXRatio = 0.42;
        this.focusScreenYRatio = 0.52;
        this.lastPointerX = null;
        this.lastPointerY = null;
        const target = computeInfrastructureFocusTarget(station, layout);
        this.focusZoom = target.zoom;
        this.targetX = target.x;
        this.targetY = target.y;
        this.targetZoom = target.zoom;
        this.beginTransition(target.x, target.y, target.zoom, 0.9, () => {
          this.focusArrived = true;
        });
      },
      clearFocus() {
        if (this.mode === 'focus' || this.mode === 'infrastructure') {
          this.focusStation = null;
          this.mode = 'ship';
          this.focusArrived = false;
          this.manualZoom = false;
          this.targetZoom = this.defaultZoom;
          this.targetX = ship.pos.x;
          this.targetY = ship.pos.y;
          this.beginTransition(this.targetX, this.targetY, this.targetZoom, 0.6);
          this.lastPointerX = null;
          this.lastPointerY = null;
        }
      }
    };

    function computeStationFocusTarget(station) {
      if (!station) return { x: camera.x, y: camera.y, zoom: camera.zoom };
      const ratioX = camera.focusScreenXRatio ?? 0.32;
      const ratioY = camera.focusScreenYRatio ?? 0.52;
      const baseRadius = ((station.r ?? station.baseR) || 120);
      const desiredRadiusPx = clamp(Math.min(W, H) * 0.24, 180, 320);
      const zoom = clamp(desiredRadiusPx / Math.max(60, baseRadius), camera.minZoom, camera.maxZoom);
      const screenX = ratioX * W;
      const screenY = ratioY * H;
      const x = station.x - (screenX - W / 2) / zoom;
      const y = station.y - (screenY - H / 2) / zoom;
      return { x, y, zoom, screenX, screenY };
    }

    function computeInfrastructureFocusTarget(station, layout) {
      if (!station) return computeStationFocusTarget(station);
      const activeLayout = layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      const padding = (activeLayout?.cellSize || 200) * 0.9;
      const worldWidth = (activeLayout?.width || 600) + padding;
      const worldHeight = (activeLayout?.height || 400) + padding;
      const zoomX = W / Math.max(worldWidth, 1);
      const zoomY = H / Math.max(worldHeight, 1);
      const baseZoom = Math.min(zoomX, zoomY) * 0.92;
      const zoom = clamp(baseZoom, camera.minZoom, camera.maxZoom);
      const ratioX = 0.42;
      const ratioY = 0.52;
      const screenX = ratioX * W;
      const screenY = ratioY * H;
      const x = station.x - (screenX - W / 2) / zoom;
      const y = station.y - (screenY - H / 2) / zoom;
      return { x, y, zoom, screenX, screenY };
    }

    // Model widoku overlayu ju≈º istnieje ‚Äì dopasuj poczƒÖtkowy zoom do kamery
    overlayView.zoom = camera.zoom;

    function updateCameraTarget(dt) {
      if (camera.mode === 'ship') {
        // --- ZMIANA: POZYCJA PRZENIESIONA DO RENDER() ---
        // W trybie 'ship' nie obliczamy tu targetX/Y, ≈ºeby uniknƒÖƒá konfliktu 
        // z interpolacjƒÖ w funkcji render() (co powodowa≈Ço drgania).
        
        // Reset zoomu je≈õli nie ma animacji i gracz nie przybli≈ºa rƒôcznie
        if (!camera.transition && !camera.manualZoom) camera.targetZoom = camera.defaultZoom;
      
      } else if (camera.mode === 'free') {
        const moveX = (keys['arrowright'] ? 1 : 0) - (keys['arrowleft'] ? 1 : 0);
        const moveY = (keys['arrowdown'] ? 1 : 0) - (keys['arrowup'] ? 1 : 0);
        if (moveX || moveY) {
          const len = Math.hypot(moveX, moveY) || 1;
          const panSpeed = camera.freeKeyPanSpeed / Math.max(0.0001, camera.zoom);
          camera.x += (moveX / len) * panSpeed * dt;
          camera.y += (moveY / len) * panSpeed * dt;
        }
        if (mouse.overCanvas && !stationUI.open && !showMap) {
          const panSpeed = (camera.freePanSpeed || 1) / Math.max(0.0001, camera.zoom);
          if (mouse.dx || mouse.dy) {
            camera.x += mouse.dx * panSpeed;
            camera.y += mouse.dy * panSpeed;
          }
        }
        camera.targetX = camera.x;
        camera.targetY = camera.y;
      } else if (camera.mode === 'focus') {
        const st = camera.focusStation;
        if (st) {
          const target = computeStationFocusTarget(st);
          camera.focusZoom = target.zoom;
          camera.targetX = target.x;
          camera.targetY = target.y;
          camera.targetZoom = target.zoom;
          if (camera.transition && camera.transition.kind === 'focus') {
            camera.transition.targetX = target.x;
            camera.transition.targetY = target.y;
            camera.transition.targetZoom = target.zoom;
          }
        } else {
          camera.clearFocus();
          // Wracamy do statku - render() przejmie pozycjƒô
          camera.targetZoom = camera.defaultZoom;
        }
      } else if (camera.mode === 'infrastructure') {
        const st = camera.focusStation;
        if (st) {
          const layout = infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
          const target = computeInfrastructureFocusTarget(st, layout);
          camera.focusZoom = target.zoom;
          camera.targetX = target.x;
          camera.targetY = target.y;
          camera.targetZoom = target.zoom;
          if (camera.transition && camera.transition.kind === 'infrastructure') {
            camera.transition.targetX = target.x;
            camera.transition.targetY = target.y;
            camera.transition.targetZoom = target.zoom;
          }
        } else {
          camera.clearFocus();
          camera.targetZoom = camera.defaultZoom;
        }
      }

      if (camera.transition) {
        const tr = camera.transition;
        tr.elapsed = Math.min(tr.elapsed + dt, tr.duration);
        const t = tr.duration <= 0 ? 1 : tr.elapsed / tr.duration;
        const eased = smoothstep01(t);
        camera.x = lerp(tr.startX, tr.targetX, eased);
        camera.y = lerp(tr.startY, tr.targetY, eased);
        camera.zoom = lerp(tr.startZoom, tr.targetZoom, eased);
        if (tr.elapsed >= tr.duration - 1e-6) {
          camera.x = tr.targetX;
          camera.y = tr.targetY;
          camera.zoom = tr.targetZoom;
          const onComplete = tr.onComplete;
          camera.transition = null;
          if (typeof onComplete === 'function') onComplete();
        }
      } else {
        // --- WYG≈ÅADZANIE RUCHU KAMERY ---
        // ZMIANA: Ruszamy kamerƒÖ tutaj TYLKO je≈õli NIE jeste≈õmy w trybie statku.
        // PozycjƒÖ statku steruje teraz render(), co eliminuje drgania przy interpolacji.
        
        if (camera.mode !== 'ship') {
          const posLerp = Math.min(1, dt * 6);
          camera.x += (camera.targetX - camera.x) * posLerp;
          camera.y += (camera.targetY - camera.y) * posLerp;
        }
        
        const zoomLerp = Math.min(1, dt * 4);
        camera.zoom += (camera.targetZoom - camera.zoom) * zoomLerp;
      }

      camera.zoom = clamp(camera.zoom, camera.minZoom, camera.maxZoom);
      mouse.dx = 0;
      mouse.dy = 0;
    }
    // Bezpieczna, odroczona inicjalizacja overlayu 3D
    let overlay3D = null;

    window.addEventListener('resize', () => {
      W = canvas.width = innerWidth;
      H = canvas.height = innerHeight;
      resizeShieldSystem(innerWidth, innerHeight);
      spaceBg?.resizeSpaceBg?.(innerWidth, innerHeight);
      configureWarpLensSource?.();
      if (camera.mode === 'focus' && camera.focusStation) {
        const target = computeStationFocusTarget(camera.focusStation);
        camera.focusZoom = target.zoom;
        camera.targetX = target.x;
        camera.targetY = target.y;
        camera.targetZoom = target.zoom;
        if (camera.transition && camera.transition.kind === 'focus') {
          camera.transition.targetX = target.x;
          camera.transition.targetY = target.y;
          camera.transition.targetZoom = target.zoom;
        }
      }
      if (camera.mode === 'infrastructure' && camera.focusStation) {
        const layout = infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
        const target = computeInfrastructureFocusTarget(camera.focusStation, layout);
        camera.focusZoom = target.zoom;
        camera.targetX = target.x;
        camera.targetY = target.y;
        camera.targetZoom = target.zoom;
        if (camera.transition && camera.transition.kind === 'infrastructure') {
          camera.transition.targetX = target.x;
          camera.transition.targetY = target.y;
          camera.transition.targetZoom = target.zoom;
        }
      }
      resizeOverlay3D();
      initStars(true);
    });

    function startOverlay3D() {
      const init = window.initOverlay3D;
      const railFactory = window.createRailgunExplosionFactory;
      const armataFactory = window.createArmataImpactFactory;
      const autocannonFactory = window.createAutocannonImpactFactory;
      const reactorFactory = window.createReactorBlowFactory;
      const host = document.getElementById('game-root');

      // Musimy mieƒá: API z modu≈Çu + host z DOM + overlayView z tego skryptu
      if (!init || !railFactory || !host || typeof overlayView === 'undefined') return false;

      const ov = init({ host, getView: () => overlayView });
      overlay3D = ov;
      window.overlay3D = ov;
      window.makeRailgunExplosion = railFactory(ov.scene);
      if (armataFactory) {
        window.makeArmataImpact = armataFactory(ov.scene);
      }
      if (autocannonFactory) {
        window.makeAutocannonImpact = autocannonFactory(ov.scene);
      }
      if (reactorFactory) {
        window.makeReactorBlow = reactorFactory(ov.scene);
      }
      resizeOverlay3D();
      return true;
    }

    // Modu≈Çy <script type="module"> wykonujƒÖ siƒô po parsowaniu DOM, wiƒôc
    // DOMContentLoaded zwykle wystarczy. Dla pewno≈õci dodajemy kr√≥tki polling.
    window.addEventListener('DOMContentLoaded', () => {
      if (startOverlay3D()) return;
      let tries = 0;
      const maxTries = 120; // ~2 sekundy przy 60 FPS
      (function poll() {
        if (startOverlay3D() || tries++ > maxTries) return;
        requestAnimationFrame(poll);
      })();
    });

    // Helper do spawnu eksplozji 3D
    function triggerRailgunExplosion3D(x, y, size = ship.h * 0.22) {
      if (overlay3D && window.makeRailgunExplosion) {
        const fx = window.makeRailgunExplosion({ x, y, size });
        overlay3D.spawn(fx);
      }
    }

    function triggerArmataImpact3D(x, y, size = ship.h * 0.3) {
      if (overlay3D && window.makeArmataImpact) {
        const fx = window.makeArmataImpact({ x, y, size });
        overlay3D.spawn(fx);
      }
    }

    function triggerAutocannonImpact3D(x, y, size = ship.h * 0.2) {
      if (overlay3D && window.makeAutocannonImpact) {
        const fx = window.makeAutocannonImpact({ x, y, size });
        overlay3D.spawn(fx);
      }
    }

    function triggerReactorBlow3D(x, y, size = ship.h * 0.35) {
      if (overlay3D && window.makeReactorBlow) {
        const fx = window.makeReactorBlow({ x, y, size });
        overlay3D.spawn(fx);
      }
    }

    // Resize: utrzymuj rozmiar overlayu = okna
    function resizeOverlay3D() {
      overlayView.viewport.w = innerWidth;
      overlayView.viewport.h = innerHeight;
      if (overlay3D) overlay3D.resize();
    }

    resizeOverlay3D();

    // === Ship sprite ===
    const USE_SHIP_SPRITE = true;
    const shipSprite = new Image();
    const capitalShipSpriteCache = {};
    const fighterSprite = new Image();
    const fighterSpriteState = { ready: false, error: false, width: 0, height: 0 };
    const hullSpriteCache = new Map();

    function loadHullSprite(src) {
      if (!src) return null;
      if (!hullSpriteCache.has(src)) {
        const img = new Image();
        const entry = { image: img, ready: false, error: false, width: 1, height: 1 };
        img.onload = () => {
          entry.ready = true;
          entry.width = img.naturalWidth || 1;
          entry.height = img.naturalHeight || 1;
        };
        img.onerror = () => { entry.error = true; };
        img.src = src;
        hullSpriteCache.set(src, entry);
      }
      return hullSpriteCache.get(src) || null;
    }

    const HULL_SPRITE_PATHS = {
      terran: {
        frigate: terranFrigateImg,
        destroyer: terranDestroyerImg,
        battleship: terranBattleshipImg
      },
      pirate: {
        frigate: pirateFrigateImg,
        destroyer: pirateDestroyerImg,
        battleship: pirateBattleshipImg
      }
    };

    function getNpcHullClass(npc) {
      const type = String(npc?.type || '');
      if (type === 'destroyer') return 'destroyer';
      if (type === 'battleship') return 'battleship';
      if (type.includes('frigate')) return 'frigate';
      return null;
    }

    function getHullSpriteForNpc(npc) {
      const faction = (npc?.isPirate) ? 'pirate' : (npc?.supportData && npc?.friendly ? 'terran' : null);
      if (!faction) return null;
      const hullClass = getNpcHullClass(npc);
      const src = hullClass ? HULL_SPRITE_PATHS[faction]?.[hullClass] : null;
      if (!src) return null;
      const sprite = loadHullSprite(src);
      if (!sprite || !sprite.ready || sprite.error) return null;
      return sprite;
    }

    function getCapitalShipSprite(src) {
      if (!src) return null;
      if (!capitalShipSpriteCache[src]) {
        const img = new Image();
        const entry = capitalShipSpriteCache[src] = {
          image: img,
          ready: false,
          error: false,
          width: 0,
          height: 0
        };
        img.onload = () => {
          entry.ready = true;
          entry.width = img.naturalWidth;
          entry.height = img.naturalHeight;
        };
        img.onerror = () => {
          entry.error = true;
        };
        img.src = src;
      }
      return capitalShipSpriteCache[src];
    }
    ship.spriteReady = false;
    shipSprite.onload = () => {
      ship.spriteReady = true;
      ship.spriteW = shipSprite.naturalWidth;
      ship.spriteH = shipSprite.naturalHeight;
      Game.player.spriteW = ship.spriteW;
      Game.player.spriteH = ship.spriteH;
      const prev = Game.player.hardpoints.map(h => ({ type: h.type, mount: h.mount, ammo: h.ammo, maxAmmo: h.maxAmmo }));
      rebuildHardpointsForFrame();
      tryPreserveMounts(prev);
      syncWeaponSystems();
      initHexBody(ship, shipSprite);
      if (typeof renderMechanic === 'function') renderMechanic();
      saveLoadout();
    };
    shipSprite.src = "assets/capital_ship_rect_v1.png"; // <- ≈õcie≈ºka do pliku

    fighterSprite.onload = () => {
      fighterSpriteState.ready = true;
      fighterSpriteState.width = fighterSprite.naturalWidth || 1;
      fighterSpriteState.height = fighterSprite.naturalHeight || 1;
    };
    fighterSprite.onerror = () => {
      fighterSpriteState.error = true;
    };
    fighterSprite.src = fighterImg;

    const npcSpriteFriendly = new Image();
    const npcSpriteHostile = new Image();
    let npcSpritesReady = 0;

    npcSpriteFriendly.onload = () => { npcSpritesReady++; };
    npcSpriteHostile.onload = () => { npcSpritesReady++; };

    npcSpriteFriendly.src = npcFriImg;
    npcSpriteHostile.src = npcHosImg;

    const heavyAutocannonSprite = new Image();
    let heavyAutocannonSpriteReady = false;
    heavyAutocannonSprite.onload = () => {
      heavyAutocannonSpriteReady = true;
    };
    heavyAutocannonSprite.src = "assets/weapons/heavy_autocannon.svg";

    // USUNIƒòTO STARY KOD SUPERBRONI (definicje superweapon, executeSuperweaponFire itp.)
    // Teraz korzystamy z src/game/superweapon.js


    // =============== Proceduralne gwiazdy na CA≈ÅEJ MAPIE ===============
    // Generujemy je "na ≈ºƒÖdanie" w kafelkach 1024√ó1024 z deterministycznym seedem.
    // Dziƒôki temu gwiazdy sƒÖ wszƒôdzie, ale pamiƒôƒá i CPU trzymamy w ryzach.
    const STAR_CELL = 1024;
    const starCells = new Map(); // key "ix,iy" -> {stars:[...] , lastSeen: frameId}
    let frameId = 0;

    function mulberry32(a) { return function () { var t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
    function key(ix, iy) { return ix + ',' + iy; }

    function generateCell(ix, iy) {
      const seed = ((ix * 73856093) ^ (iy * 19349663) ^ 0x9e3779b9) >>> 0;
      const rnd = mulberry32(seed);
      const count = 5 + Math.floor(rnd() * 5); // ilo≈õc gwiazd na komorke
      const stars = [];
      for (let i = 0; i < count; i++) {
        const x = ix * STAR_CELL + rnd() * STAR_CELL;
        const y = iy * STAR_CELL + rnd() * STAR_CELL;
        const size = 0.7 + rnd() * 2.1;
        const bright = 0.35 + rnd() * 0.65;
        stars.push({ x, y, size, bright });
      }
      const obj = { stars, lastSeen: frameId };
      starCells.set(key(ix, iy), obj);
      return obj;
    }
    function getCell(ix, iy) {
      const k = key(ix, iy);
      let c = starCells.get(k);
      if (!c) c = generateCell(ix, iy);
      c.lastSeen = frameId;
      return c;
    }
    function pruneStarCells() {
      // Trzymajmy ~ 600 ostatnio widzianych kom√≥rek (wystarczy z zapasem)
      if (starCells.size <= 600) return;
      // Proste LRU: wyrzucamy najstarsze
      const arr = Array.from(starCells.entries());
      arr.sort((a, b) => a[1].lastSeen - b[1].lastSeen);
      const toDrop = arr.slice(0, Math.max(0, arr.length - 600));
      for (const [k] of toDrop) starCells.delete(k);
    }
    function initStars(reset = false) {
      if (reset) { starCells.clear(); }
    }

    // =============== S≈Ço≈Ñce, planety i stacje ===============
    const SUN = {
      x: WORLD.w / 2, y: WORLD.h / 2, r: 823, r3D: 399,
      color: {
        core: '#ffe88a',   // jasno-≈º√≥≈Çty rdze≈Ñ
        mid: '#ffbe3b',   // pomara≈Ñcz-≈º√≥≈Çƒá
        rim: '#ff8c1a'    // ciep≈Ça krawƒôd≈∫ tarczy
      },
      corona: {
        rays: 72,           // ile ‚Äûigie≈Ç‚Äù
        jitter: 0.35,       // nieregularno≈õƒá
        length: 0.85,       // d≈Çugo≈õƒá korony w promieniach R
        pulse: 0.22,        // amplituda pulsu
        haze: 2.8          // rozmiar miƒôkkiej po≈õwiaty (√óR)
      },
      seed: 93731
    };
    window.SUN = SUN;

    // --- tryb: REALNY UK≈ÅAD S≈ÅONECZNY (domy≈õlnie w≈ÇƒÖczony) ---
    const solarParams = new URLSearchParams(location.search);
    const USE_SOLAR = solarParams.has('solar') ? solarParams.get('solar') !== '0' : true; // mo≈ºna te≈º sterowaƒá paramem URL ?solar=1

    function makeSolarPlanets() {
      // Skala: 1 AU ‚âà 3000 jednostek ≈õwiata (Neptun ~ 90k)
      // Uwaga: powiƒôkszamy AU tak, aby rozmiary planet w 3D (√ó4.5) nie powodowa≈Çy
      // nachodzenia Ziemi i Marsa przy zbie≈ºnych kƒÖtach orbitalnych.
      const BASE_AU = 3000;
      const PLANET_3D_SIZE_MULTIPLIER = 4.5;
      const EARTH_BASE_R = 2800;
      const MARS_BASE_R = 3000;
      const EARTH_ORBIT_AU = 25.0;
      const MARS_ORBIT_AU = 33.0;
      const earthMarsMinGap = (EARTH_BASE_R + MARS_BASE_R) * PLANET_SCALE * PLANET_3D_SIZE_MULTIPLIER;
      const earthMarsOrbitGapAu = MARS_ORBIT_AU - EARTH_ORBIT_AU;
      const minAuForNoOverlap = earthMarsMinGap / earthMarsOrbitGapAu;
      const AU = Math.max(BASE_AU, Math.ceil(minAuForNoOverlap));
      window.BASE_ORBIT = AU;
      const MIN_SUN_GAP = 600;
      const MIN_PLANET_GAP = 800;
      const INNER_PLANET_COUNT = 4;
      const INNER_EXTRA_ORBIT = 600;
      const INNER_EXTRA_SUN_GAP = 600;
      const INNER_EXTRA_PLANET_GAP = 600;
      const rand = () => Math.random() * Math.PI * 2;
      const defs = [
        { id: 'mercury', name: 'mercury', baseR: 2000, orbitAU: 8.0, type: 'rocky' },
        { id: 'venus', name: 'venus', baseR: 2800, orbitAU: 15.0, type: 'rocky' },
        {
          id: 'earth',
          name: 'earth',
          baseR: 2800,
          orbitAU: 25.0,
          type: 'terran',
          orbitZone: {
            inner: 8500,
            outer: 12000,
            gravity: 15000
          }
        },
        { id: 'mars', name: 'mars', baseR: 3000, orbitAU: 33.0, type: 'rocky' },
        { id: 'jupiter', name: 'jupiter', baseR: 3800, orbitAU: 50.20, type: 'gas' },
        { id: 'saturn', name: 'saturn', baseR: 3700, orbitAU: 80.58, type: 'gas' },
        { id: 'uranus', name: 'uranus', baseR: 2000, orbitAU: 100.20, type: 'gas' },
        { id: 'neptune', name: 'neptune', baseR: 2000, orbitAU: 120.00, type: 'gas' },
        // { id:'pluto',   name:'pluto',   baseR:  30, orbitAU:39.50 },
      ];

      let minOrbitEdge = SUN.r;
      return defs.map((def, index) => {
        const effectiveR = def.baseR * PLANET_SCALE;
        const baseOrbit = def.orbitAU * AU;
        const isInner = index < INNER_PLANET_COUNT;
        const extraOrbit = isInner ? INNER_EXTRA_ORBIT : 0;
        const sunGap = SUN.r + effectiveR + MIN_SUN_GAP + (isInner ? INNER_EXTRA_SUN_GAP : 0);
        const neighborGap = minOrbitEdge + effectiveR + MIN_PLANET_GAP + (isInner ? INNER_EXTRA_PLANET_GAP : 0);
        const orbitRadius = Math.max(
          baseOrbit + extraOrbit,
          sunGap,
          neighborGap
        );

        minOrbitEdge = orbitRadius + effectiveR;

        return {
          id: def.id,
          name: def.name,
          type: def.type,
          baseR: def.baseR,
          r: effectiveR,
          orbitAU: def.orbitAU,
          orbitZone: def.orbitZone,
          orbitRadius,
          angle: rand(),
          speed: 0
        };
      });
    }

    const WORLD_BELT_WIDTH_AU = 2;
    const WORLD_SAFETY_MARGIN_AU = 2;
    const WORLD_EDGE_MARGIN_AU = WORLD_SAFETY_MARGIN_AU;

    function computeWorldDiameter(planets) {
      const auToWorld = getAuToWorldUnits();
      const beltWidthAU = WORLD_BELT_WIDTH_AU;
      const beltHalfWidthAU = beltWidthAU / 2;
      const safetyMarginAU = WORLD_SAFETY_MARGIN_AU;
      const beltCenterAU = (() => {
        const neptune = planets.find(p => p.id === 'neptune' || p.name === 'neptune');
        if (neptune && Number.isFinite(neptune.orbitAU)) return neptune.orbitAU + 3;

        const maxOrbitAU = planets
          .map(p => p.orbitAU)
          .filter(Number.isFinite)
          .reduce((max, v) => Math.max(max, v), -Infinity);
        if (Number.isFinite(maxOrbitAU)) return maxOrbitAU + 3;

        const maxOrbitRadius = planets
          .map(p => p.orbitRadius)
          .filter(Number.isFinite)
          .reduce((max, v) => Math.max(max, v), -Infinity);
        if (Number.isFinite(maxOrbitRadius)) return (maxOrbitRadius / auToWorld) + 3;

        return 60;
      })();

      const outerRadiusWorld = (beltCenterAU + beltHalfWidthAU + safetyMarginAU) * auToWorld;
      return outerRadiusWorld * 2;
    }

    function alignWorldToCenter(centerX, centerY) {
      SUN.x = centerX;
      SUN.y = centerY;

      if (camera) {
        camera.x = centerX;
        camera.y = centerY;
        camera.targetX = centerX;
        camera.targetY = centerY;
      }

      if (!hasSavedShipPosition && ship) {
        ship.pos.x = centerX;
        ship.pos.y = centerY;
        overlayView.center.x = centerX;
        overlayView.center.y = centerY;
      }
    }

    // je≈õli kiedy≈õ bƒôdziemy chcieli wr√≥ciƒá do starych zasad, zostawiamy helper:
    function makeProceduralPlanets() {
      // stary kod mo≈ºe zostaƒá, ale domy≈õlnie nieu≈ºywany
      const PLANET_TYPES = {
        TERRAN: 'terran',
        VOLCANIC: 'volcanic',
        FROZEN: 'frozen',
        GAS: 'gas',
        BARREN: 'barren'
      };
      const NUM_PLANETS = 7;
      const TYPES = [
        PLANET_TYPES.VOLCANIC,
        PLANET_TYPES.VOLCANIC,
        PLANET_TYPES.TERRAN,
        PLANET_TYPES.TERRAN,
        PLANET_TYPES.BARREN,
        PLANET_TYPES.GAS,
        PLANET_TYPES.FROZEN
      ];
      const BASE_ORBIT = 7000;
      window.BASE_ORBIT = BASE_ORBIT;
      const list = [];
      for (let i = 0; i < NUM_PLANETS; i++) {
        const orbitRadius = BASE_ORBIT * (i + 1);
        const angle = Math.random() * Math.PI * 2;
        const au = i + 1;
        const periodHours = 24 * 365 * Math.pow(au, 1.5);
        const speed = (2 * Math.PI) / (periodHours * 3600);
        const r = (48 + Math.floor(Math.random() * 36)) * 3;
        list.push({ id: i, orbitRadius, angle, speed, r, type: TYPES[i], x: 0, y: 0 });
      }
      return list;
    }

    const PLANET_DATA = USE_SOLAR ? makeSolarPlanets() : makeProceduralPlanets();

    const WORLD_DIAMETER = computeWorldDiameter(PLANET_DATA);
    setWorldSize(WORLD, { width: WORLD_DIAMETER, height: WORLD_DIAMETER });
    alignWorldToCenter(WORLD.w / 2, WORLD.h / 2);

    function formatPlanetLabel(planet, index) {
      if (typeof planet.label === 'string' && planet.label.trim().length) {
        return planet.label.trim();
      }
      const candidates = [];
      if (typeof planet.name === 'string') candidates.push(planet.name);
      if (typeof planet.id === 'string') candidates.push(planet.id);
      if (typeof planet.type === 'string') candidates.push(planet.type);

      for (const raw of candidates) {
        if (!raw) continue;
        const pretty = raw
          .replace(/[_-]+/g, ' ')
          .trim()
          .replace(/\b\w/g, ch => ch.toUpperCase());
        if (pretty) return pretty;
      }

      // Tego brakowa≈Ço:
      return `Planet ${index + 1}`;
    }
    // wylicz pozycje
    let planets = PLANET_DATA.map((p, index) => {
      if (p.baseR == null) p.baseR = p.r;
      if (p.r == null && p.baseR != null) {
        p.r = p.baseR * PLANET_SCALE;
      }
      p.x = SUN.x + Math.cos(p.angle) * p.orbitRadius;
      p.y = SUN.y + Math.sin(p.angle) * p.orbitRadius;
      p.label = formatPlanetLabel(p, index);
      return p;
    });
    window.planets = planets;

    // =============== Strefy (planety/s≈Ço≈Ñce/pas asteroid) ===============
    const AU_IN_WORLD_UNITS = getAuToWorldUnits();
    const ZONE_APPROACH_DISTANCE = AU_IN_WORLD_UNITS; // 1 AU przed granicƒÖ
    window.ZONE_APPROACH_DISTANCE = ZONE_APPROACH_DISTANCE;

    const PIRATE_ORBIT = Object.freeze({
      innerAu: 4,
      outerAu: 6
    });

    function pirateOrbitRadii() {
      const au = AU_IN_WORLD_UNITS || getAuToWorldUnits();
      return {
        inner: PIRATE_ORBIT.innerAu * au,
        outer: PIRATE_ORBIT.outerAu * au,
        gravityWell: (PIRATE_ORBIT.outerAu + 1) * au
      };
    }

    const zoneState = {
      current: null,
      approaching: null,
      lastZoneKey: null,
      lastZoneId: null,
      lastApproachKey: null,
      initialized: false,
      messages: []
    };

    function makeInterplanetaryZone() {
      return {
        key: 'interplanetary',
        id: 'interplanetary',
        label: 'Interplanetary Zone',
        enteringLabel: 'Interplanetary Zone',
        warpMultiplier: 2,
        wormholeVfx: true
      };
    }

    const zonePriority = {
      planet_inner: 4,
      planet_outer: 3,
      planet_gravity: 2.5,
      pirate_inner: 4,
      pirate_outer: 3,
      pirate_gravity: 2.5,
      sun: 2,
      asteroid_belt: 1
    };

    function zonePropsForId(id) {
      if (
        id === 'planet_inner' ||
        id === 'planet_outer' ||
        id === 'planet_gravity' ||
        id === 'pirate_inner' ||
        id === 'pirate_outer' ||
        id === 'pirate_gravity' ||
        id === 'sun' ||
        id === 'asteroid_belt'
      ) {
        return { warpMultiplier: 0.3, wormholeVfx: false };
      }
      if (id === 'interplanetary') {
        return { warpMultiplier: 2, wormholeVfx: true };
      }
      return { warpMultiplier: 1, wormholeVfx: false };
    }

    function isPlanetOrbitZoneId(id) {
      return (
        id === 'planet_inner' ||
        id === 'planet_outer' ||
        id === 'planet_gravity' ||
        id === 'pirate_inner' ||
        id === 'pirate_outer' ||
        id === 'pirate_gravity'
      );
    }

    function planetOrbitRadii(planet) {
      // 1. Bezpiecznie pobierz fizyczny promie≈Ñ (hitbox)
      const r = (planet.r && Number.isFinite(planet.r)) ? planet.r : 100;

      // 2. PRIORYTET: Je≈õli zdefiniowano rƒôczne strefy w konfiguracji planety - u≈ºyj ich!
      // To pozwala ustawiƒá np. Outer na 12000 pod Ring, niezale≈ºnie od wielko≈õci planety.
      if (planet.orbitZone) {
        return {
          inner: planet.orbitZone.inner || (r * 2.5),
          outer: planet.orbitZone.outer || (r * 4.0),
          gravityWell: planet.orbitZone.gravity || (r * 8.0)
        };
      }

      // 3. FALLBACK: Nowa, bezpieczniejsza matematyka dla planet bez konfigu.
      // Zwiƒôkszamy mno≈ºnik Inner z 2.0 na 2.2, ≈ºeby linia na pewno by≈Ça nad du≈ºƒÖ grafikƒÖ.
      const innerRadius = Math.max(r * 2.2, r + 1500);

      // Outer to strefa operacyjna (tam gdzie ringi)
      const outerRadius = innerRadius + 4000;

      // Gravity Well to granica przyciƒÖgania
      const gravityWellRadius = outerRadius + 6000;

      return { inner: innerRadius, outer: outerRadius, gravityWell: gravityWellRadius };
    }

    function enhanceZoneDescriptor(zone) {
      if (!zone) return null;
      const props = zonePropsForId(zone.id);
      zone.warpMultiplier = props.warpMultiplier;
      zone.wormholeVfx = props.wormholeVfx;
      return zone;
    }

    function formatPlanetOrbitLabel(planet) {
      const name = typeof planet.label === 'string' && planet.label.trim().length
        ? planet.label.trim()
        : formatPlanetLabel(planet, 0);
      return name;
    }

    function formatPirateOrbitLabel(station) {
      if (!station) return 'Pirate Station';
      const raw = (station.label || station.name || station.id || '').toString();
      const trimmed = raw.trim();
      return trimmed.length ? trimmed : 'Pirate Station';
    }

    function detectZones(pos) {
      const zones = [];

      for (const [index, planet] of planets.entries()) {
        if (!planet) continue;
        const orbitRadii = planetOrbitRadii(planet);
        const dx = pos.x - planet.x;
        const dy = pos.y - planet.y;
        const dist = Math.hypot(dx, dy);
        const labelName = formatPlanetOrbitLabel(planet) || `Planet ${index + 1}`;
        zones.push({
          key: `planet-${planet.id || planet.name || index}-inner`,
          id: 'planet_inner',
          label: `${labelName} - Inner Orbit`,
          enteringLabel: `${labelName} - Inner Orbit`,
          edgeDist: dist - orbitRadii.inner,
          approachRange: ZONE_APPROACH_DISTANCE,
          priority: zonePriority.planet_inner
        });
        zones.push({
          key: `planet-${planet.id || planet.name || index}-outer`,
          id: 'planet_outer',
          label: `${labelName} - Outer Orbit`,
          enteringLabel: `${labelName} - Outer Orbit`,
          edgeDist: dist - orbitRadii.outer,
          approachRange: ZONE_APPROACH_DISTANCE,
          priority: zonePriority.planet_outer
        });
        if (Number.isFinite(orbitRadii.gravityWell)) {
          zones.push({
            key: `planet-${planet.id || planet.name || index}-gravity-well`,
            id: 'planet_gravity',
            label: `${labelName} - Gravity Well`,
            enteringLabel: `${labelName} - Gravity Well`,
            edgeDist: dist - orbitRadii.gravityWell,
            approachRange: ZONE_APPROACH_DISTANCE,
            priority: zonePriority.planet_gravity
          });
        }
      }

      const pirateStation = mercMission?.station;
      if (pirateStation) {
        const orbitRadii = pirateOrbitRadii();
        const dx = pos.x - pirateStation.x;
        const dy = pos.y - pirateStation.y;
        const dist = Math.hypot(dx, dy);
        const labelName = formatPirateOrbitLabel(pirateStation);
        if (Number.isFinite(orbitRadii.inner)) {
          zones.push({
            key: `pirate-${pirateStation.id || 'station'}-inner`,
            id: 'pirate_inner',
            label: `${labelName} - Inner Orbit`,
            enteringLabel: `${labelName} - Inner Orbit`,
            edgeDist: dist - orbitRadii.inner,
            approachRange: ZONE_APPROACH_DISTANCE,
            priority: zonePriority.pirate_inner
          });
        }
        if (Number.isFinite(orbitRadii.outer)) {
          zones.push({
            key: `pirate-${pirateStation.id || 'station'}-outer`,
            id: 'pirate_outer',
            label: `${labelName} - Outer Orbit`,
            enteringLabel: `${labelName} - Outer Orbit`,
            edgeDist: dist - orbitRadii.outer,
            approachRange: ZONE_APPROACH_DISTANCE,
            priority: zonePriority.pirate_outer
          });
        }
        if (Number.isFinite(orbitRadii.gravityWell)) {
          zones.push({
            key: `pirate-${pirateStation.id || 'station'}-gravity-well`,
            id: 'pirate_gravity',
            label: `${labelName} - Gravity Well`,
            enteringLabel: `${labelName} - Gravity Well`,
            edgeDist: dist - orbitRadii.gravityWell,
            approachRange: ZONE_APPROACH_DISTANCE,
            priority: zonePriority.pirate_gravity
          });
        }
      }

      const sunRadius = Math.max(10, (SUN.r || 0) * 2);
      const sunDist = Math.hypot(pos.x - SUN.x, pos.y - SUN.y);
      const sunEdge = sunDist - sunRadius;
      zones.push({
        key: 'sun',
        id: 'sun',
        label: 'Sun',
        enteringLabel: 'Entering Sun',
        edgeDist: sunEdge,
        approachRange: ZONE_APPROACH_DISTANCE,
        priority: zonePriority.sun
      });

      if (ASTEROID_BELT) {
        const radial = sunDist;
        const inner = ASTEROID_BELT.inner;
        const outer = ASTEROID_BELT.outer;
        const inside = radial >= inner && radial <= outer;
        const edgeDist = inside
          ? Math.min(radial - inner, outer - radial) * -1
          : Math.min(Math.abs(radial - inner), Math.abs(radial - outer));
        zones.push({
          key: 'asteroid-belt',
          id: 'asteroid_belt',
          label: 'Asteroid Belt',
          enteringLabel: 'Entering Asteroid Belt',
          edgeDist,
          approachRange: ZONE_APPROACH_DISTANCE,
          priority: zonePriority.asteroid_belt
        });
      }

      const insideZones = zones.filter(z => z.edgeDist <= 0);
      insideZones.sort((a, b) => (b.priority - a.priority) || (Math.abs(a.edgeDist) - Math.abs(b.edgeDist)));
      let current = insideZones[0] || makeInterplanetaryZone();

      const approachCandidates = zones
        .filter(z => z.edgeDist > 0 && z.edgeDist <= z.approachRange)
        .sort((a, b) => a.edgeDist - b.edgeDist);
      const approaching = approachCandidates[0] || null;

      return { current: enhanceZoneDescriptor(current), approaching: enhanceZoneDescriptor(approaching) };
    }

    function pushZoneMessage(text, duration = 3.5) {
      zoneState.messages.push({ text, life: duration, maxLife: duration });
    }

    function updateZoneMessages(dt) {
      for (const msg of zoneState.messages) {
        msg.life -= dt;
      }
      zoneState.messages = zoneState.messages.filter(msg => msg.life > 0);
    }

    function updateZoneState(dt) {
      const prevZoneKey = zoneState.current?.key || zoneState.lastZoneKey;
      const prevZoneId = zoneState.current?.id || zoneState.lastZoneId;
      const detection = detectZones(ship.pos);
      zoneState.current = detection.current;
      zoneState.approaching = detection.approaching;

      if (!zoneState.initialized) {
        zoneState.lastZoneKey = zoneState.current?.key || null;
        zoneState.lastZoneId = zoneState.current?.id || null;
        zoneState.initialized = true;
      } else if (zoneState.current && zoneState.current.key !== zoneState.lastZoneKey) {
        if (zoneState.current.label) pushZoneMessage(zoneState.current.label);
        zoneState.lastZoneKey = zoneState.current.key;
      }

      handleZoneTransition(prevZoneId, zoneState.current?.id || null);
      zoneState.lastZoneId = zoneState.current?.id || zoneState.lastZoneId;

      const approachKey = zoneState.approaching?.key || null;
      if (
        zoneState.initialized &&
        approachKey &&
        approachKey !== zoneState.lastApproachKey &&
        approachKey !== zoneState.current?.key &&
        approachKey !== prevZoneKey
      ) {
        if (zoneState.approaching?.enteringLabel) pushZoneMessage(zoneState.approaching.enteringLabel);
      }
      zoneState.lastApproachKey = approachKey;

      updateZoneMessages(dt);
    }

    function handleZoneTransition(prevZoneId, currentZoneId) {
      if (isGravityWellZoneId(currentZoneId) && currentZoneId !== prevZoneId) {
        triggerGravityWarpBrake(currentZoneId);
      }
      if (currentZoneId === 'pirate_inner' && prevZoneId !== 'pirate_inner') {
        enterPirateInnerOrbit();
      }
    }


    const ASTEROID_BELT = (() => {
      const AU_TO_WORLD = getAuToWorldUnits();
      const neptuneBelt = (() => {
        const neptune = planets.find(p => p.id === 'neptune' || p.name === 'neptune');
        if (!neptune || !Number.isFinite(neptune.orbitAU)) return null;
        const beltAU = neptune.orbitAU + 3;
        const beltWidthAU = WORLD_BELT_WIDTH_AU;
        const mid = beltAU * AU_TO_WORLD;
        const inner = Math.max(50, mid - (beltWidthAU * AU_TO_WORLD) / 2);
        const outer = mid + (beltWidthAU * AU_TO_WORLD) / 2;
        return { inner, outer, mid };
      })();
      if (neptuneBelt) return neptuneBelt;

      const innerPlanet = planets[3];
      const outerPlanet = planets[4];
      if (innerPlanet && outerPlanet && innerPlanet.orbitRadius && outerPlanet.orbitRadius) {
        const r1 = innerPlanet.orbitRadius;
        const r2 = outerPlanet.orbitRadius;
        const inner = r1 + 0.25 * (r2 - r1);
        const outer = r1 + 0.55 * (r2 - r1);
        return { inner, outer, mid: (inner + outer) / 2 };
      }
      return null;
    })();

    const STATION_STYLES = ['ringGate', 'hexHub', 'triRing', 'solarPetals', 'shipyard', 'tradeSpindle'];

    let stations = planets.map(pl => {
      const orbitRadius = 0; // stacje cywilne na ≈õrodku planety
      const angle = 0; // brak dryfu orbitalnego
      const periodHours = 12; // zachowana sp√≥jno≈õƒá parametr√≥w (nieu≈ºywane przy orbitRadius=0)
      const speed = 0;
      const x = pl.x;
      const y = pl.y;
      const r = 120;
      const portOffset = r + 40;
      const gateOffset = 220;
      const warpGate = { x: x + gateOffset, y, offset: { x: gateOffset, y: 0 } };
      const ports = [
        { x: portOffset, y: 0 },
        { x: 0, y: portOffset },
        { x: -portOffset, y: 0 },
        { x: 0, y: -portOffset }
      ];
      const style = STATION_STYLES[Math.floor(Math.random() * STATION_STYLES.length)];
      return {
        id: pl.id,
        planet: pl,
        orbitRadius,
        angle,
        speed,
        r,
        baseR: r,
        x,
        y,
        ports,
        style,
        warpGate
      };
    });
    window.stations = stations;
    window.USE_STATION_3D = true;
    if (window.__setStation3DScale) {
      window.__lastStationScale = 1;
      if (window.Dev && typeof Dev.station3DScale === 'number') {
        __setStation3DScale(Dev.station3DScale);
      }
    }

    if (!hasSavedShipPosition) {
      const earthStation = stations.find(st => st.id === 'earth');
      if (earthStation) {
        const planetRadius = earthStation.planet?.r || 0;
        const orbitPadding = 900;
        const spawnOrbitRadius = Math.max(planetRadius + orbitPadding, earthStation.r + 200);
        const spawnAngle = earthStation.planet?.angle || 0;
        const spawnPos = {
          x: earthStation.x + Math.cos(spawnAngle) * spawnOrbitRadius,
          y: earthStation.y + Math.sin(spawnAngle) * spawnOrbitRadius
        };

        ship.pos.x = spawnPos.x;
        ship.pos.y = spawnPos.y;
        ship.vel.x = 0;
        ship.vel.y = 0;

        camera.x = spawnPos.x;
        camera.y = spawnPos.y;
        camera.targetX = spawnPos.x;
        camera.targetY = spawnPos.y;

        overlayView.center.x = spawnPos.x;
        overlayView.center.y = spawnPos.y;
      }
    }

    // oznacz stacje wewnƒÖtrz pasa asteroid
    (() => {
      if (ASTEROID_BELT) {
        const beltRadius = ASTEROID_BELT.mid;
        for (const st of stations) {
          const planetOrbit = st.planet?.orbitRadius;
          const distFromSun = Number.isFinite(planetOrbit)
            ? planetOrbit
            : Math.hypot((st.planet?.x ?? st.x) - SUN.x, (st.planet?.y ?? st.y) - SUN.y);
          st.inner = distFromSun < beltRadius;
        }
      } else {
        for (const st of stations) st.inner = true;
      }
    })();

    // Warp routes between stations
    let warpRoutes = {};
    function initWarpRoutes() {
      warpRoutes = {};
      for (const from of stations) {
        for (const to of stations) {
          if (from.id === to.id) continue;
          if (from.inner !== to.inner) continue;
          const sx = from.warpGate?.x ?? from.x;
          const sy = from.warpGate?.y ?? from.y;
          const ex = to.warpGate?.x ?? to.x;
          const ey = to.warpGate?.y ?? to.y;
          const dx = ex - sx;
          const dy = ey - sy;
          const dist = Math.hypot(dx, dy) || 1;
          warpRoutes[from.id + '-' + to.id] = {
            from: from.id,
            to: to.id,
            fromRef: from,
            toRef: to,
            start: { x: sx, y: sy, queues: [[], []] },
            end: { x: ex, y: ey },
            dir: { x: dx / dist, y: dy / dist },
            length: dist
          };
        }
      }
    }
    function getWarpRoute(fromId, toId) { return warpRoutes[fromId + '-' + toId]; }
    initWarpRoutes();

    let npcs = [];
    window.npcs = npcs;
    // Lista na martwe, dryfujƒÖce kawa≈Çki
    const wrecks = [];
    window.wrecks = wrecks;
    // === SQUAD SYSTEM ===
    const SQUADS = [];
    window.SQUADS = SQUADS;
    class Squad {
      constructor(team, type) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.team = team; // 'player' lub 'pirate'
        this.type = type; // 'fighter', 'capital'
        this.units = [];
        this.leader = null;
        this.targetSquad = null;
        this.state = 'guard'; // guard, engage, return
      }

      addUnit(u) {
        this.units.push(u);
        u.squad = this;

        // FIX: Natychmiast mianuj lidera, je≈õli go nie ma
        if (!this.leader) {
          this.leader = u;
        }

        this.recalculateFormation();
      }

      update() {
        // 1. Usu≈Ñ martwe jednostki z listy
        const initialCount = this.units.length;
        this.units = this.units.filter(u => !u.dead);

        // 2. Sprawd≈∫ ciƒÖg≈Ço≈õƒá dowodzenia
        // Je≈õli liczba jednostek siƒô zmieni≈Ça (kto≈õ zginƒÖ≈Ç) LUB obecny lider nie ≈ºyje/nie istnieje
        if (this.units.length !== initialCount || !this.leader || this.leader.dead) {

          if (this.units.length > 0) {
            // --- AWANS I PRZEGRUPOWANIE ---
            // Nowym liderem zostaje pierwszy ≈ºywy na li≈õcie
            this.leader = this.units[0];

            // Przelicz sloty formacji dla wszystkich ocala≈Çych
            // To jest ten kluczowy mechanizm z AI SPACE, kt√≥rego brakowa≈Ço
            this.recalculateFormation();
          } else {
            this.leader = null;
          }
        }
      }

      recalculateFormation() {
        // Przelicza offsety dla ka≈ºdego statku w oparciu o jego aktualny indeks w eskadrze
        this.units.forEach((u, idx) => {
          if (idx === 0) {
            // Lider jest zawsze w punkcie 0,0
            u.formationOffset = { x: 0, y: 0 };
          } else {
            // Reszta ustawia siƒô w formacji "Chevron" (V)
            // idx: 1 -> row 1, side L
            // idx: 2 -> row 1, side R
            // idx: 3 -> row 2, side L ...
            const row = Math.floor((idx + 1) / 2);
            const side = (idx % 2 === 0) ? 1 : -1; // 1 = Prawa, -1 = Lewa

            // Offsety: troche szerzej ni≈º wcze≈õniej, ≈ºeby siƒô nie zderzali
            u.formationOffset = { x: -row * 60, y: side * row * 45 };
          }
          // Zabezpieczenie kompatybilno≈õci (niekt√≥re funkcje mogƒÖ szukaƒá formationSlot)
          u.formationSlot = u.formationOffset;
        });
      }
    }

    function stationLaunchPose(station, idx) {
      const dirs = [
        { x: 1, y: 0 },
        { x: -1, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: -1 }
      ];
      const dir = dirs[idx % dirs.length];
      const offset = (station.r || 40) + 50;
      const launchSpeed = 120;
      return {
        x: station.x + dir.x * offset,
        y: station.y + dir.y * offset,
        vx: dir.x * launchSpeed,
        vy: dir.y * launchSpeed
      };
    }
    const MISSION_NPCS = [];
    let mercMission = null;
    const missionCompleteBanner = {
      active: false,
      text: '',
      timer: 0,
      duration: 5,
      fadeIn: 0.75,
      fadeOut: 1.25,
      trigger(text) {
        this.text = text;
        this.timer = 0;
        this.active = true;
      },
      update(dt) {
        if (!this.active) return;
        this.timer += dt;
        if (this.timer >= this.duration) {
          this.active = false;
          this.timer = 0;
        }
      },
      alpha() {
        if (!this.active) return 0;
        const { timer, duration, fadeIn, fadeOut } = this;
        if (timer < fadeIn) {
          const t = clamp(timer / fadeIn, 0, 1);
          return 1 - Math.pow(1 - t, 3);
        }
        if (timer > duration - fadeOut) {
          const t = clamp((duration - timer) / fadeOut, 0, 1);
          return t * t * t;
        }
        return 1;
      },
      progress() {
        if (!this.active) return 0;
        return clamp(this.timer / Math.max(0.0001, this.duration), 0, 1);
      }
    };

    // === Missions / Journal ===
    const MISSIONS = {
      active: [],   // {id, title, type, stationId?, pos:{x,y}, status:'active'|'completed'}
      show: false
    };

    function createShieldState(shieldCfg) {
      if (!shieldCfg || !Number.isFinite(shieldCfg.max) || shieldCfg.max <= 0) return null;

      const regenRate = shieldCfg.regenRate ?? shieldCfg.regen ?? 0;
      const regenDelay = shieldCfg.regenDelay ?? 0;
      const val = shieldCfg.val ?? shieldCfg.max;

      return {
        max: shieldCfg.max,
        val: val,
        regenRate,
        regenDelay,
        regenTimer: shieldCfg.regenTimer ?? 0,
        impacts: Array.isArray(shieldCfg.impacts) ? [...shieldCfg.impacts] : [],
        state: shieldCfg.state || (val > 0 ? 'activating' : 'off'),
        activationProgress: shieldCfg.activationProgress ?? 0,
        currentAlpha: shieldCfg.currentAlpha ?? 0,
        energyShotTimer: shieldCfg.energyShotTimer ?? 0,
        energyShotDuration: shieldCfg.energyShotDuration ?? shieldCfg.energyShotTimer ?? 0.5
      };
    }

    function makeNPCBase(pos, stats) {
      stats = stats || {};

      const npc = {
        x: pos.x,
        y: pos.y,
        vx: 0,
        vy: 0,
        angle: 0,

        hp: stats.hp || 100,
        maxHp: stats.hp || 100,

        accel: stats.accel || 0,
        maxSpeed: stats.maxSpeed || 0,
        turn: stats.turn || 0,
        radius: stats.radius || 20,

        // je≈õli nie podasz isCollidable w statsach ‚Äì jest kolizyjny
        isCollidable: stats.isCollidable !== false,

        dead: false,
        ai: null,
        weapons: {}
      };

      // NOWE: przeniesienie fizyki ze stat√≥w na NPC
      if (typeof stats.friction === 'number') {
        npc.friction = stats.friction;
      }
      if (typeof stats.mass === 'number') {
        npc.mass = stats.mass;
      }
      if (typeof stats.separationRange === 'number') {
        npc.separationRange = stats.separationRange;
      }

      npc.shield = createShieldState(stats.shield);

      return npc;
    }

    const SUPPORT_SHIP_CONFIGURERS = {
      fighter(npc) {
        npc.fighter = true;
        npc.gun = 'laserS';
        npc.msl = 'AF';
        npc.mslAmmo = 2;
        npc.gunCD = 0;
        npc.ai = (dt) => { if (window.runAdvancedFighterAI) window.runAdvancedFighterAI(npc, dt); };
      },
      interceptor(npc) {
        npc.fighter = true;
        npc.gun = 'laserS';
        npc.msl = 'AF';
        npc.mslAmmo = 1;
        npc.ai = (dt) => { if (window.runAdvancedFighterAI) window.runAdvancedFighterAI(npc, dt); };
      },
      frigate_pd(npc) {
        npc.pd = 'pd_mk1';
        npc.mainGun = 'm_autocannon';
        npc.preferredRange = 760;
        npc.ai = (dt) => { if (window.aiFrigate) window.aiFrigate(null, npc, dt); };
        npc.keepAngle = true;
      },
      frigate_laser(npc) {
        npc.pd = 'pd_laser';
        npc.mainGun = 'h_beam';
        npc.preferredRange = 920;
        npc.ai = (dt) => {
          if (window.aiLaserFrigate) window.aiLaserFrigate(null, npc, dt);
          else if (window.aiFrigate) window.aiFrigate(null, npc, dt);
        };
        npc.keepAngle = true;
      },
      destroyer(npc) {
        npc.isCapitalShip = true;
        npc.mGun = 'm_rail';
        npc.pd = 'pd_mk1';
        npc.boostDur = 1.8;
        npc.preferredRange = 820;
        npc.ai = (dt) => window.aiDestroyer(null, npc, dt);
        npc.keepAngle = true;
        npc.capitalProfile = {
          lengthScale: 2.0,
          widthScale: 1.5
        };
      },
      battleship(npc) {
        npc.isCapitalShip = true;
        npc.pd = 'pd_laser';
        npc.mGun = 'h_rapid';
        npc.preferredRange = 780;
        npc.broadsideRange = 1200;
        npc.ai = (dt) => window.aiBattleship(null, npc, dt);
        npc.keepAngle = true;
      }
    };

    const SUPPORT_SHIP_TEMPLATES = buildSupportTemplates(SUPPORT_SHIP_TEMPLATES_DATA);

    function buildSupportTemplates(templates) {
      const result = {};
      for (const [key, template] of Object.entries(templates)) {
        const configureKey = template.configureId || key;
        result[key] = {
          ...template,
          configure: SUPPORT_SHIP_CONFIGURERS[configureKey]
        };
      }
      return result;
    }
    function spawnSupportShip(templateKey, opts = {}) {
      const template = SUPPORT_SHIP_TEMPLATES[templateKey];
      if (!template) return [];
      const anchor = (opts.anchor && !opts.anchor.dead) ? opts.anchor : ship;
      const anchorPos = anchor.pos || { x: anchor.x ?? ship.pos.x, y: anchor.y ?? ship.pos.y };
      const anchorVel = anchor.vel || { x: anchor.vx ?? 0, y: anchor.vy ?? 0 };
      const anchorAngle = anchor.angle ?? ship.angle;
      const useSpawnPos = opts.spawnPos && Number.isFinite(opts.spawnPos.x) && Number.isFinite(opts.spawnPos.y);
      const basePos = useSpawnPos ? opts.spawnPos : anchorPos;
      const baseAngle = opts.spawnAngle ?? anchorAngle;
      const baseOffset = (opts.spawnOffset ?? template.spawnOffset ?? (useSpawnPos ? { x: 0, y: 0 } : { x: -60, y: 0 }));

      const created = [];
      const count = Math.max(1, template.count || 1);
      const spawnFormation = SUPPORT_FORMATION.spawn || { perRow: 4, rowGap: 70 };
      for (let i = 0; i < count; i++) {
        const jitter = (Math.random() * 12 - 6);
        const offset = {
          x: (baseOffset.x || 0) + jitter,
          y: (baseOffset.y || 0) + ((i % spawnFormation.perRow) - (spawnFormation.perRow - 1) * 0.5) * 8
        };
        const rotated = rotate(offset, baseAngle);
        const spawnPos = { x: basePos.x + rotated.x, y: basePos.y + rotated.y };
        const npc = makeNPCBase(spawnPos, { ...template.stats, shield: template.shield });
        npc.friendly = true;
        npc.mission = true;
        npc.color = template.color || '#7cff91';
        npc.type = templateKey;
        npc.vx = anchorVel.x ?? npc.vx;
        npc.vy = anchorVel.y ?? npc.vy;
        npc.supportData = { npc, type: templateKey, slotIndex: SupportWing.units.length + created.length, leader: anchor };
        template.configure?.(npc, i);
        npc.ai = dt => runSupportAI(npc, dt);
        SupportWing.units.push(npc.supportData);
        npcs.push(npc);
        created.push(npc);
      }
      if (created.length) markFleetDirty();
      return created;
    }

    const CAPITAL_SHIP_TEMPLATES = CAPITAL_SHIP_TEMPLATES_DATA;

    Fleet.templates = Object.assign(Fleet.templates || {}, { capital: CAPITAL_SHIP_TEMPLATES });

    function addFleetShip(entry) {
      if (!entry || !entry.entity) return null;
      Fleet.ships.push(entry);
      npcs.push(entry.entity);
      markFleetDirty();
      return entry;
    }

    function createCapitalShipEntry(templateKey, overrides = {}) {
      const template = CAPITAL_SHIP_TEMPLATES[templateKey];
      if (!template) return null;
      const offset = overrides.formationOffset || template.formationOffset || { x: -820, y: 420 };
      const basePos = overrides.pos || { x: ship.pos.x + offset.x, y: ship.pos.y + offset.y };

      const npc = makeNPCBase(basePos, {
        hp: template.hull,
        accel: template.accel,
        maxSpeed: template.maxSpeed,
        turn: template.turn,
        radius: template.radius
      });

      npc.hp = template.hull;
      npc.maxHp = template.hull;
      npc.radius = template.radius;
      npc.friendly = true;
      npc.mission = true;
      npc.type = template.id;
      npc.color = template.profile?.accentColor || '#9ccfff';
      npc.isCapitalShip = true;
      npc.capitalProfile = Object.assign({
        lengthScale: 3.4,
        widthScale: 1.4
      }, template.profile || {});
      if (npc.capitalProfile.spriteSrc) {
        npc.capitalSprite = getCapitalShipSprite(npc.capitalProfile.spriteSrc);
      }
      npc.shield = {
        val: template.shield,
        max: template.shield,
        regenRate: template.shieldRegen,
        regenDelay: template.shieldDelay,
        regenTimer: 0
      };
      npc.hardpoints = { large: template.hardpoints.large, medium: template.hardpoints.medium };
      npc.fleetFormationOffset = offset;
      npc.vx = 0;
      npc.vy = 0;
      npc.angle = Math.atan2(ship.pos.y - npc.y, ship.pos.x - npc.x);
      npc.desiredAngle = npc.angle;
      npc.keepAngle = true;
      npc.drawLayer = template.profile?.spriteLayer ?? 0;
      npc.carrierWeapons = createCarrierWeaponSystems(template.weapons || {});

      const entry = {
        id: overrides.id || `fleet_${templateKey}_${Math.random().toString(36).slice(2, 8)}`,
        type: templateKey,
        displayName: overrides.displayName || template.displayName,
        roleText: overrides.roleText || template.roleText,
        entity: npc,
        hardpoints: { large: template.hardpoints.large, medium: template.hardpoints.medium },
        status: {
          hull: template.hull,
          hullMax: template.hull,
          shield: template.shield,
          shieldMax: template.shield
        },
        template
      };

      npc.fleetEntry = entry;
      npc.ai = dt => updateCapitalCarrier(entry, dt);

      return entry;
    }

    const CARRIER_DEFAULT_WEAPON_RANGE = 2200;
    function createCarrierWeaponSystems(cfg) {
      const systems = { mainCannons: [], dorsalBatteries: [] };
      if (cfg && Array.isArray(cfg.mainCannons)) {
        for (const weapon of cfg.mainCannons) {
          systems.mainCannons.push({
            id: weapon.id || `main_${systems.mainCannons.length}`,
            offset: weapon.offset || { x: 0, y: 0 },
            cooldown: Math.max(0.2, weapon.cooldown || 3.0),
            timer: 0,
            projectileSpeed: weapon.projectileSpeed || 1600,
            damage: weapon.damage || 180,
            spread: weapon.spread || 0,
            arc: weapon.arc || Math.PI / 2,
            muzzleForward: weapon.muzzleForward ?? 0.12,
            type: 'main'
          });
        }
      }
      if (cfg && Array.isArray(cfg.dorsalBatteries)) {
        for (const weapon of cfg.dorsalBatteries) {
          systems.dorsalBatteries.push({
            id: weapon.id || `aux_${systems.dorsalBatteries.length}`,
            offset: weapon.offset || { x: 0, y: 0 },
            cooldown: Math.max(0.1, weapon.cooldown || 1.4),
            timer: 0,
            projectileSpeed: weapon.projectileSpeed || 1100,
            damage: weapon.damage || 28,
            spread: weapon.spread || 0.01,
            arc: weapon.arc || Math.PI / 1.6,
            muzzleForward: weapon.muzzleForward ?? 0.06,
            type: 'aux'
          });
        }
      }
      return systems;
    }

    function selectCarrierTarget(entry) {
      if (!entry || !entry.entity) return null;
      const carrier = entry.entity;
      const range = entry.template?.weaponRange || CARRIER_DEFAULT_WEAPON_RANGE;

      const primary = entry.primaryTarget;
      if (primary && isHostileNpc(primary)) {
        const dist = Math.hypot(primary.x - carrier.x, primary.y - carrier.y);
        if (dist <= range * 1.15) {
          return primary;
        }
      }
      if (primary && !isHostileNpc(primary)) {
        entry.primaryTarget = null;
      }

      const anchorX = carrier.x;
      const anchorY = carrier.y;

      const focusCandidates = [];
      for (const target of lockedTargets) {
        if (isHostileNpc(target) && !focusCandidates.includes(target)) {
          focusCandidates.push(target);
        }
      }
      if (lockedTarget && isHostileNpc(lockedTarget) && !focusCandidates.includes(lockedTarget)) {
        focusCandidates.push(lockedTarget);
      }

      let focus = null;
      let focusDist = Infinity;
      for (const candidate of focusCandidates) {
        const dist = Math.hypot(candidate.x - anchorX, candidate.y - anchorY);
        if (dist < focusDist) {
          focus = candidate;
          focusDist = dist;
        }
      }

      if (focus && focusDist <= range * 1.2) {
        entry.primaryTarget = focus;
        return focus;
      }

      let best = null, bestDist = range;
      for (const npc of npcs) {
        if (!npc || npc.dead || npc.friendly) continue;
        const dist = Math.hypot(npc.x - anchorX, npc.y - anchorY);
        if (dist < bestDist) {
          best = npc;
          bestDist = dist;
        }
      }
      entry.primaryTarget = best;
      return best;
    }

    function getCapitalDimensions(npc) {
      const profile = npc.capitalProfile || {};
      const radius = npc.radius || 1;
      const length = Math.max(60, radius * (profile.lengthScale || 3.2));
      const width = Math.max(30, radius * (profile.widthScale || 1.2));
      return { length, width, halfL: length * 0.5, halfW: width * 0.5 };
    }

    function capitalLocalFromNormalized(offset, dims) {
      if (!offset) return { x: 0, y: 0 };
      if (offset.absolute) return { x: offset.x || 0, y: offset.y || 0 };
      const nx = Number.isFinite(offset.x) ? offset.x : 0;
      const ny = Number.isFinite(offset.y) ? offset.y : 0;
      return { x: nx * dims.halfL, y: ny * dims.halfW };
    }

    function updateCarrierWeapons(entry, dt, order, target) {
      const npc = entry.entity;
      if (!npc || !npc.carrierWeapons) return;
      const profile = npc.capitalProfile || {};
      const dims = getCapitalDimensions(npc);
      const rotation = (npc.angle || 0) + (profile.spriteRotation || 0);
      const systems = npc.carrierWeapons;
      const range = entry.template?.weaponRange || CARRIER_DEFAULT_WEAPON_RANGE;
      const shouldFire = !!target && order !== 'return';

      const fireWeapon = (weapon, type) => {
        weapon.timer = Math.max(0, (weapon.timer || 0) - dt);
        if (!shouldFire || weapon.timer > 0) return;

        const localBase = capitalLocalFromNormalized(weapon.offset, dims);
        const forwardExtra = Number.isFinite(weapon.muzzleForward) ? weapon.muzzleForward * dims.halfL : 0;
        const local = { x: localBase.x + forwardExtra, y: localBase.y };
        const worldOff = rotate(local, rotation);
        const muzzle = { x: npc.x + worldOff.x, y: npc.y + worldOff.y };
        const lead = leadTarget(muzzle, { x: npc.vx, y: npc.vy }, target, weapon.projectileSpeed);
        const aim = Math.atan2(lead.y - muzzle.y, lead.x - muzzle.x);
        const forward = rotate({ x: 1, y: 0 }, rotation);
        const dirToTarget = { x: Math.cos(aim), y: Math.sin(aim) };
        const dot = forward.x * dirToTarget.x + forward.y * dirToTarget.y;
        const angleDiff = Math.acos(clamp(dot, -1, 1));
        const dist = Math.hypot(target.x - muzzle.x, target.y - muzzle.y);
        if (angleDiff > (weapon.arc || Math.PI / 2) * 0.5 || dist > range * 1.1) {
          return;
        }

        const jitter = (Math.random() - 0.5) * (weapon.spread || 0);
        const finalAngle = aim + jitter;
        const dir = { x: Math.cos(finalAngle), y: Math.sin(finalAngle) };
        const speed = weapon.projectileSpeed || 1500;
        const life = Math.max(0.6, (range / speed) * 1.15);
        const bullet = {
          x: muzzle.x,
          y: muzzle.y,
          vx: dir.x * speed + npc.vx,
          vy: dir.y * speed + npc.vy,
          life,
          r: type === 'main' ? 6 : 3,
          owner: 'player',
          damage: weapon.damage || (type === 'main' ? 180 : 32),
          type: type === 'main' ? 'armata' : 'autocannon',
          penetration: type === 'main' ? 2 : 0,
          source: npc,
          effectScale: type === 'main' ? 1.2 : 0.9
        };
        window.bullets.push(bullet);
        if (type === 'main') {
          spawnRailMuzzle(muzzle, dir, { x: npc.vx, y: npc.vy }, 1.2);
          camera.addShake(6, 0.15);
        } else {
          spawnAutocannonMuzzle(muzzle, dir, { x: npc.vx, y: npc.vy }, 0.9);
        }
        weapon.timer = weapon.cooldown || 2.5;
      };

      if (Array.isArray(systems.mainCannons)) {
        for (const weapon of systems.mainCannons) {
          fireWeapon(weapon, 'main');
        }
      }
      if (Array.isArray(systems.dorsalBatteries)) {
        for (const weapon of systems.dorsalBatteries) {
          fireWeapon(weapon, 'aux');
        }
      }
    }

    function spawnCarrierEngineFx(entry) {
      const npc = entry.entity;
      if (!npc || !npc.capitalProfile) return;
      const profile = npc.capitalProfile;
      const offsets = Array.isArray(profile.engineOffsets) ? profile.engineOffsets : null;
      if (!offsets || !offsets.length) return;

      const dims = getCapitalDimensions(npc);
      const rotation = (npc.angle || 0) + (profile.spriteRotation || 0);
      const speed = Math.hypot(npc.vx || 0, npc.vy || 0);
      const thrust = clamp(speed / Math.max(1, npc.maxSpeed || 1), 0, 1);
      if (thrust < 0.05 && speed < 12) return;

      const dir = rotate({ x: -1, y: 0 }, rotation);
      const glowScale = Number.isFinite(profile.engineGlowSize) ? profile.engineGlowSize : 0.24;
      const baseRadius = Math.max(6, npc.radius * glowScale * 0.32);

      for (const offset of offsets) {
        const local = capitalLocalFromNormalized(offset, dims);
        const worldOff = rotate(local, rotation);
        const pos = { x: npc.x + worldOff.x, y: npc.y + worldOff.y };
        const intensity = 0.32 + thrust * 0.55;
        const particleSize = clamp(baseRadius * (0.7 + thrust * 0.9), 6, npc.radius * 0.3);
        const particleLife = 0.16 + thrust * 0.14;
        const vel = {
          x: npc.vx - dir.x * (100 + thrust * 220),
          y: npc.vy - dir.y * (100 + thrust * 220)
        };
        const color = `rgba(135,205,255,${intensity})`;
        spawnParticle(pos, vel, particleLife, color, particleSize, false);
      }
    }

    function ensureCarrierWarpDrive(entry) {
      if (!entry) return null;
      if (!entry.warpDrive) {
        const chargeTime = (warp?.chargeTime || 0.8) * 1.05;
        const entryDuration = (warp?.entryDuration || 0.9) * 1.1;
        entry.warpDrive = {
          state: 'idle',
          charge: 0,
          chargeTime,
          entryDuration,
          entryProgress: 0,
          entryBaseSpeed: 0,
          dir: { x: 1, y: 0 },
          turnRate: (warp?.turnRate || Math.PI / 5) * 0.7,
          alignRate: (warp?.alignRate || Math.PI / 2.5) * 0.8,
          exitProgress: 0,
          exitDuration: 0.8
        };
      }
      return entry.warpDrive;
    }

    function updateCapitalCarrier(entry, dt) {
      const npc = entry?.entity;
      if (!npc || npc.dead) return;

      const formation = entry.template?.formationOffset || npc.fleetFormationOffset || { x: -800, y: 360 };
      const rotated = rotate(formation, ship.angle);
      const target = { x: ship.pos.x + rotated.x, y: ship.pos.y + rotated.y };
      const toTarget = { x: target.x - npc.x, y: target.y - npc.y };
      const dist = Math.hypot(toTarget.x, toTarget.y);

      const warpDrive = ensureCarrierWarpDrive(entry);
      const playerWarpState = warp.state;
      const shouldWarp = playerWarpState === 'charging' || playerWarpState === 'active';

      if (warpDrive) {
        if (!shouldWarp) {
          if (warpDrive.state === 'active') {
            warpDrive.state = 'exiting';
            warpDrive.exitProgress = 0;
          } else if (warpDrive.state === 'charging') {
            warpDrive.state = 'idle';
            warpDrive.charge = 0;
          } else if (warpDrive.state === 'exiting') {
            warpDrive.exitProgress = Math.min(1, warpDrive.exitProgress + dt / Math.max(0.001, warpDrive.exitDuration));
            if (warpDrive.exitProgress >= 1) {
              warpDrive.state = 'idle';
              warpDrive.charge = 0;
            }
          }
        } else {
          if (warpDrive.state === 'idle') {
            warpDrive.state = 'charging';
            warpDrive.charge = 0;
          } else if (warpDrive.state === 'exiting') {
            warpDrive.state = 'charging';
            warpDrive.exitProgress = 0;
          }
          if (warpDrive.state === 'charging') {
            warpDrive.charge = Math.min(warpDrive.charge + dt, warpDrive.chargeTime);
            if (playerWarpState === 'active' && warpDrive.charge >= warpDrive.chargeTime) {
              warpDrive.state = 'active';
              warpDrive.entryProgress = 0;
              warpDrive.entryBaseSpeed = Math.hypot(npc.vx, npc.vy);
              const dir = warp?.dir || { x: Math.cos(npc.angle), y: Math.sin(npc.angle) };
              const mag = Math.hypot(dir.x, dir.y) || 1;
              warpDrive.dir.x = dir.x / mag;
              warpDrive.dir.y = dir.y / mag;
            }
          } else if (warpDrive.state === 'active') {
            if (playerWarpState !== 'active') {
              warpDrive.state = 'exiting';
              warpDrive.exitProgress = 0;
            } else {
              warpDrive.entryProgress = Math.min(1, warpDrive.entryProgress + dt / Math.max(0.001, warpDrive.entryDuration));
              const curAngle = Math.atan2(warpDrive.dir.y, warpDrive.dir.x);
              const targetAngle = Math.atan2(warp.dir.y || 0, warp.dir.x || 1);
              const delta = wrapAngle(targetAngle - curAngle);
              const maxTurn = warpDrive.turnRate * dt;
              const newAngle = curAngle + clamp(delta, -maxTurn, maxTurn);
              warpDrive.dir.x = Math.cos(newAngle);
              warpDrive.dir.y = Math.sin(newAngle);
            }
          }
        }
        if (warpDrive.state !== 'active' && playerWarpState !== 'active') {
          warpDrive.entryProgress = 0;
        }
      }

      const driveState = warpDrive ? warpDrive.state : 'idle';
      let speedLimit = npc.maxSpeed || 0;
      let followGain = 1.3;
      let matchGain = 2.2;
      let dampenClose = true;

      if (driveState === 'charging') {
        followGain = 1.8;
        matchGain = 3.3;
        speedLimit = Math.max(speedLimit, npc.maxSpeed || 0);
      } else if (driveState === 'active') {
        const ramp = warpDrive ? smoothstep01(warpDrive.entryProgress) : 1;
        followGain = 2.6 + 1.2 * ramp;
        matchGain = 3.8 + 1.8 * ramp;
        speedLimit = Math.max(speedLimit, warp.speed * 1.05);
        dampenClose = false;
      } else if (driveState === 'exiting') {
        followGain = 2.2;
        matchGain = 3.0;
        speedLimit = Math.max(speedLimit, Math.hypot(ship.vel.x, ship.vel.y) + 260, npc.maxSpeed || 0);
      }

      const desiredVel = {
        x: ship.vel.x + toTarget.x * followGain,
        y: ship.vel.y + toTarget.y * followGain
      };

      npc.vx += (desiredVel.x - npc.vx) * Math.min(1, matchGain * dt);
      npc.vy += (desiredVel.y - npc.vy) * Math.min(1, matchGain * dt);

      if (dampenClose && dist < 90) {
        const slow = Math.exp(-1.5 * dt);
        npc.vx *= slow;
        npc.vy *= slow;
      }

      limitSpeed(npc, speedLimit);

      if (driveState === 'active' && warpDrive) {
        const desiredAngle = Math.atan2(warpDrive.dir.y, warpDrive.dir.x);
        const diff = wrapAngle(desiredAngle - npc.angle);
        const maxAlign = warpDrive.alignRate * dt;
        npc.angle = wrapAngle(npc.angle + clamp(diff, -maxAlign, maxAlign));
      } else {
        const spd = Math.hypot(npc.vx, npc.vy);
        if (spd > 1) {
          npc.angle = Math.atan2(npc.vy, npc.vx);
        } else {
          const desiredAngle = Math.atan2(ship.pos.y - npc.y, ship.pos.x - npc.x);
          const diff = wrapAngle(desiredAngle - npc.angle);
          const turnLimit = (entry.template?.turn ?? npc.turn ?? 0) * dt;
          npc.angle = wrapAngle(npc.angle + clamp(diff, -turnLimit, turnLimit));
        }
      }
      npc.desiredAngle = npc.angle;

      const attackTarget = selectCarrierTarget(entry);
      if (attackTarget) {
        const desiredAngle = Math.atan2(attackTarget.y - npc.y, attackTarget.x - npc.x);
        const diff = wrapAngle(desiredAngle - npc.angle);
        const turnLimit = (entry.template?.turn ?? npc.turn ?? 0) * dt;
        npc.angle = wrapAngle(npc.angle + clamp(diff, -turnLimit, turnLimit));
        npc.desiredAngle = npc.angle;
      }

      updateCarrierWeapons(entry, dt, 'guard', attackTarget);
      spawnCarrierEngineFx(entry);

      const shield = npc.shield;
      if (shield) {
        if (shield.regenTimer > 0) {
          shield.regenTimer = Math.max(0, shield.regenTimer - dt);
        } else if (shield.val < shield.max) {
          const before = shield.val;
          shield.val = Math.min(shield.max, shield.val + shield.regenRate * dt);
          if (Math.abs(before - shield.val) > 0.5) {
            entry.status.shield = shield.val;
            markFleetDirty();
          }
        }
        if (Math.abs(entry.status.shield - shield.val) > 0.5) {
          entry.status.shield = shield.val;
          markFleetDirty();
        }
      } else if (entry.status.shield !== 0) {
        entry.status.shield = 0;
        markFleetDirty();
      }

      if (Math.abs(entry.status.hull - npc.hp) > 0.5) {
        entry.status.hull = Math.max(0, npc.hp);
        markFleetDirty();
      }
    }

    function spawnFriendlyCarrier(opts = {}) {
      const existing = getFriendlyCarrierEntity();
      if (existing) return existing;

      const au = getAuToWorldUnits();
      const angle = Number.isFinite(ship?.angle) ? ship.angle : Math.random() * Math.PI * 2;
      const spawnPos = (opts.pos && Number.isFinite(opts.pos.x) && Number.isFinite(opts.pos.y))
        ? opts.pos
        : {
          x: ship.pos.x + Math.cos(angle) * au,
          y: ship.pos.y + Math.sin(angle) * au
        };

      const carrier = createCapitalShipEntry('carrier', {
        pos: spawnPos,
        formationOffset: { x: 0, y: 0 }
      });
      if (!carrier) return null;

      addFleetShip(carrier);
      return carrier.entity;
    }

    function initFleet() {
      Fleet.ships.length = 0;
      markFleetDirty();
      if (Fleet.ui?.root) Fleet.ui.root.classList.add('hidden');
    }

    function makeRailgun(cfg) { return { ...cfg }; }
    function makeRocketPod(cfg) { return { ...cfg }; }
    function makeGatling(cfg) { return { ...cfg }; }
    function spawnPirate(kind, station) {
      // 1. Znajd≈∫ szablon
      let template = SUPPORT_SHIP_TEMPLATES[kind];

      // Fallback: je≈õli wpisano 'fighter', a w szablonach jest 'interceptor' (lub odwrotnie)
      if (!template) {
        if (kind === 'fighter') template = SUPPORT_SHIP_TEMPLATES['interceptor'];
        else if (kind === 'interceptor') template = SUPPORT_SHIP_TEMPLATES['fighter'];
      }

      // Je≈õli nadal brak szablonu, u≈ºyj domy≈õlnego interceptora (≈ºeby gra siƒô nie wysypa≈Ça)
      if (!template) {
        console.warn(`Nieznany typ pirata: ${kind}. Spawnujƒô interceptor.`);
        template = SUPPORT_SHIP_TEMPLATES['interceptor'];
      }

      // 2. Pozycja startowa
      const angle = Math.random() * Math.PI * 2;
      const dist = (station.r || 100) + 150;
      const pos = {
        x: station.x + Math.cos(angle) * dist,
        y: station.y + Math.sin(angle) * dist
      };

      // 3. Stworzenie bazy NPC z szablonu
      const npc = makeNPCBase(pos, { ...template.stats, shield: template.shield });

      // 4. Nadpisanie w≈Ça≈õciwo≈õci pod PIRATA
      npc.type = kind;
      npc.friendly = false;
      npc.isPirate = true;
      npc.mission = true;
      npc.color = '#ff5c7c'; // Czerwony kolor pirata

      // Przypisanie referencji do stacji (wa≈ºne dla logiki patrolu)
      npc.home = station;

      // 5. Konfiguracja uzbrojenia i AI z szablonu
      if (template.configure) {
        template.configure(npc);
      }

      // 6. PoczƒÖtkowy obr√≥t w stronƒô gracza
      npc.angle = Math.atan2(ship.pos.y - npc.y, ship.pos.x - npc.x);

      // 7. Rejestracja w grze
      npcs.push(npc);
      return npc;
    }

    function spawnPirateHeavyFleet(station) {
      if (!station) return;
      const dx = ship.pos.x - station.x;
      const dy = ship.pos.y - station.y;
      const dist = Math.hypot(dx, dy) || 1;

      const fwd = { x: dx / dist, y: dy / dist };
      const right = { x: -fwd.y, y: fwd.x };

      const startDist = 3500;
      const endDist = 800;

      const fleetComposition = [
        'destroyer', 'destroyer',
        'battleship', 'battleship', 'battleship',
        'destroyer', 'destroyer', 'destroyer'
      ];

      // POPRAWKA 1: Zwiƒôkszony odstƒôp, ≈ºeby Battleshipy (szeroko≈õƒá ~280) siƒô nie zderza≈Çy
      const spacing = 1600;
      const totalWidth = (fleetComposition.length - 1) * spacing;

      fleetComposition.forEach((type, i) => {
        const offset = (i * spacing) - (totalWidth / 2);
        const startX = station.x - (fwd.x * startDist) + (right.x * offset);
        const startY = station.y - (fwd.y * startDist) + (right.y * offset);
        const targetX = station.x + (fwd.x * endDist) + (right.x * offset);
        const targetY = station.y + (fwd.y * endDist) + (right.y * offset);

        const npc = spawnPirate(type, station);
        npc.x = startX;
        npc.y = startY;
        npc.angle = Math.atan2(fwd.y, fwd.x);
        npc.state = 'warping_in';
        npc.isCollidable = false;

        // Lekka losowo≈õƒá hamowania, ≈ºeby nie wyglƒÖda≈Çy jak roboty
        const randomBrake = 280 + Math.random() * 40;

        npc.warpData = {
          targetX,
          targetY,
          speed: 4000,
          brakingDist: randomBrake
        };
        npc.vx = 0;
        npc.vy = 0;
      });

      pushZoneMessage("WARNING: HOSTILE CAPITAL SIGNATURES DETECTED", 4.0);
      if (window.AudioSys) AudioSys.playSound('shieldHit');
    }

    // POPRAWKA 2: Przypisanie do window (teraz bƒôdzie widoczne globalnie)
    window.spawnPirateHeavyFleet = spawnPirateHeavyFleet;
    // Lista na martwe, dryfujƒÖce kawa≈Çki
    window.createWreckage = function (parentEntity, shards) {
      if (!shards || shards.length === 0) return;

      // 1. Oblicz ≈õrodek masy nowej grupy
      let sumLx = 0, sumLy = 0;
      for (const s of shards) {
        sumLx += s.lx;
        sumLy += s.ly;
      }
      const avgLx = sumLx / shards.length;
      const avgLy = sumLy / shards.length;

      let sumC = 0, sumR = 0;
      for (const s of shards) {
        sumC += s.c;
        sumR += s.r;
      }
      const avgC = Math.round(sumC / shards.length);
      const avgR = Math.round(sumR / shards.length);

      const scale = parentEntity.visual?.spriteScale || 1.0;
      const c = Math.cos(parentEntity.angle);
      const s = Math.sin(parentEntity.angle);

      const worldX = parentEntity.x + (avgLx * scale * c - avgLy * scale * s);
      const worldY = parentEntity.y + (avgLx * scale * s + avgLy * scale * c);

      // --- PRZYGOTOWANIE CACHE DLA WRAKU (FIX) ---
      // U≈ºywamy wymiar√≥w orygina≈Çu, aby zachowaƒá sp√≥jno≈õƒá koordynat√≥w
      const srcW = parentEntity.hexGrid.srcWidth;
      const srcH = parentEntity.hexGrid.srcHeight;
      const cacheCanvas = document.createElement('canvas');
      cacheCanvas.width = srcW;
      cacheCanvas.height = srcH;
      // -------------------------------------------

      const wreck = {
        x: worldX,
        y: worldY,
        vx: (parentEntity.vx || parentEntity.vel?.x || 0),
        vy: (parentEntity.vy || parentEntity.vel?.y || 0),
        angle: parentEntity.angle,
        angVel: parentEntity.angVel || 0,
        mass: shards.length * 10,
        friction: 0.998,
        dead: false,
        isWreck: true,
        visual: { spriteScale: scale },

        hexGrid: {
          shards: [],
          map: {},
          offsetX: 0,
          offsetY: 0,
          srcWidth: srcW,
          srcHeight: srcH,
          // --- FIX: Dodajemy wymagane pola cache ---
          cacheCanvas: cacheCanvas,
          cacheCtx: cacheCanvas.getContext('2d', { willReadFrequently: true }),
          cacheDirty: true // Wymu≈õ narysowanie w pierwszej klatce
          // ----------------------------------------
        }
      };

      let maxR2 = 0;

      for (const shard of shards) {
        shard.lx -= avgLx;
        shard.ly -= avgLy;
        shard.origLx -= avgLx;
        shard.origLy -= avgLy;
        shard.c -= avgC;
        shard.r -= avgR;

        const d2 = shard.lx * shard.lx + shard.ly * shard.ly;
        if (d2 > maxR2) maxR2 = d2;

        wreck.hexGrid.shards.push(shard);
        wreck.hexGrid.map[shard.c + "," + shard.r] = shard;
      }

      wreck.radius = (Math.sqrt(maxR2) + 20) * scale;

      if (window.wrecks) {
        window.wrecks.push(wreck);
      }

      if (window.spawnParticle) {
        for (let i = 0; i < 3; i++) {
          window.spawnParticle({ x: worldX, y: worldY }, { x: wreck.vx, y: wreck.vy }, 1.0, '#aaaaaa', 5, false);
        }
      }
    };
    function spawnPirateSquad(station, type, count, mode = 'guard', opts = {}) {
      const squad = new Squad('pirate', 'fighter');
      window.SQUADS.push(squad);

      // Parametry orbity / pozycji
      const radius = opts.radius || (station.r + 200);
      const speed = opts.speed || 0.3;
      const startPhase = Math.random() * Math.PI * 2;
      const phaseStep = (Math.PI * 2) / count;

      // Parametry ataku (tylko dla mode='attack')
      let attackAngle = 0;
      let attackDir = { x: 0, y: 0 };
      if (mode === 'attack') {
        // Oblicz kƒÖt w stronƒô gracza
        const dx = ship.pos.x - station.x;
        const dy = ship.pos.y - station.y;
        attackAngle = Math.atan2(dy, dx);
        attackDir = { x: Math.cos(attackAngle), y: Math.sin(attackAngle) };
      }

      for (let i = 0; i < count; i++) {
        // 1. Spawn jednostki
        const npc = spawnPirate(type, station);

        // 2. Pozycja startowa (dla obu tryb√≥w startujƒÖ wok√≥≈Ç stacji)
        // Dla ataku: spawnujemy ich w sektorze skierowanym do gracza, ≈ºeby nie lecieli przez stacjƒô
        const angle = (mode === 'attack')
          ? attackAngle + (i - (count - 1) / 2) * 0.15 // Wachlarz w stronƒô gracza
          : startPhase + (i * phaseStep);          // R√≥wnomiernie dooko≈Ça (orbita)

        const spawnR = (mode === 'attack') ? station.r + 50 : radius; // AtakujƒÖcy wylatujƒÖ z dok√≥w

        npc.x = station.x + Math.cos(angle) * spawnR;
        npc.y = station.y + Math.sin(angle) * spawnR;

        // 3. Konfiguracja zachowania
        if (mode === 'guard') {
          // --- TRYB STRA≈ªNIKA (Orbitowanie) ---
          npc.state = 'guard';
          // Lider dostaje dane do orbitowania
          if (i === 0) {
            npc.guardStation = station;
            npc.guardOrbitRadius = radius;
            npc.guardOrbitSpeed = speed;
            npc.guardPhase = angle;
          }
          // Prƒôdko≈õƒá styczna (≈ºeby ju≈º p≈Çynƒôli po orbicie)
          npc.vx = -Math.sin(angle) * radius * speed;
          npc.vy = Math.cos(angle) * radius * speed;
          npc.angle = angle + (speed > 0 ? Math.PI / 2 : -Math.PI / 2);
        }
        else {
          // --- TRYB ATAKU (Swarm / Posi≈Çki) ---
          npc.state = 'engage_formation';

          // Wyczy≈õƒá guardStation, ≈ºeby nie orbitowali
          npc.guardStation = null;

          // Nadaj du≈ºƒÖ prƒôdko≈õƒá w stronƒô gracza (Wyrzut z hangaru)
          const launchSpeed = 400;
          npc.vx = Math.cos(angle) * launchSpeed;
          npc.vy = Math.sin(angle) * launchSpeed;
          npc.angle = angle;

          // Wymu≈õ szukanie celu
          npc.forceTarget = null;
          npc.target = null;
          npc.retargetTimer = 0;
        }

        squad.addUnit(npc);

        // Offsety formacji (dla obu tryb√≥w, ≈ºeby ≈Çadnie latali w grupie)
        if (i > 0) {
          const row = Math.floor((i + 1) / 2);
          const side = (i % 2 === 0) ? 1 : -1;
          npc.formationOffset = { x: -row * 50, y: side * row * 40 };
        } else {
          npc.formationOffset = { x: 0, y: 0 };
        }
      }

      return squad;
    }
    const TRAFFIC_WEIGHTS = {
      mercury: { civilian: 0.02, convoy: 0.25 },
      venus: { civilian: 0.03, convoy: 0.25 },
      earth: { civilian: 1.80, convoy: 0.50 },
      mars: { civilian: 1.60, convoy: 0.55 },
      default: { civilian: 0.40, convoy: 0.40 }
    };

    function trafficWeightFor(station, kind) {
      const table = TRAFFIC_WEIGHTS[station.id] || TRAFFIC_WEIGHTS.default;
      if (kind === 'convoy') return table.convoy ?? TRAFFIC_WEIGHTS.default.convoy;
      if (kind === 'civilian') return table.civilian ?? TRAFFIC_WEIGHTS.default.civilian;
      if (kind && typeof table[kind] === 'number') return table[kind];
      return table.civilian ?? TRAFFIC_WEIGHTS.default.civilian;
    }

    function weightedPickStation(kind, scope) {
      let pool;
      if (Array.isArray(scope)) {
        pool = scope.slice();
      } else if (scope === 'inner' || scope === 'outer') {
        const match = scope === 'inner';
        pool = stations.filter(s => s.inner === match);
      } else if (typeof scope === 'boolean') {
        pool = stations.filter(s => s.inner === scope);
      } else {
        pool = stations.slice();
      }
      if (!pool.length) return null;
      let total = 0;
      const weighted = pool.map(st => {
        const w = Math.max(0, trafficWeightFor(st, kind));
        total += w;
        return { st, w };
      });
      if (total <= 0) {
        return pool[Math.floor(Math.random() * pool.length)];
      }
      let r = Math.random() * total;
      for (const { st, w } of weighted) {
        r -= w;
        if (r <= 0) return st;
      }
      return weighted[weighted.length - 1].st;
    }

    function preferEarthMarsRoute(stationId) {
      return (stationId === 'earth' || stationId === 'mars') && Math.random() < 0.7;
    }

    function pickNextStation(startStationId, type) {
      const start = stations.find(s => s.id === startStationId) || stations[0];
      if (!start) return startStationId;
      if (preferEarthMarsRoute(start.id)) {
        return start.id === 'earth' ? 'mars' : 'earth';
      }
      const isCivil = type && (type.startsWith('civilian') || type.startsWith('freighter'));
      const sameSphere = stations.filter(s => s.inner === start.inner && s.id !== start.id);
      const otherSphere = stations.filter(s => s.inner !== start.inner);
      let pool = sameSphere.length ? sameSphere : stations.filter(s => s.id !== start.id);
      if (isCivil && otherSphere.length && Math.random() < 0.35) {
        pool = otherSphere;
      }
      let target = weightedPickStation(isCivil ? 'civilian' : null, pool);
      if (!target || target.id === start.id) {
        const fallbackPool = pool.length ? pool : stations.filter(s => s.id !== start.id);
        if (fallbackPool.length) {
          return fallbackPool[Math.floor(Math.random() * fallbackPool.length)].id;
        }
        return startStationId;
      }
      return target.id;
    }
    const NPC_TYPES = {
      'freighter-small': { radius: 10, speed: 100, hp: 100, color: '#8ab4d6', weapon: null, isCollidable: false },
      'freighter-medium': { radius: 15, speed: 100, hp: 150, color: '#769cb8', weapon: null, isCollidable: false },
      'freighter-large': { radius: 25, speed: 100, hp: 200, color: '#5d829c', weapon: null, isCollidable: false },
      'freighter-capital': { radius: 48, speed: 100, hp: 400, color: '#45667d', weapon: null, isCollidable: false },
      'police': { radius: 24, speed: 100, hp: 200, color: '#44aaff', weapon: 'null', isCollidable: true },
      'civilian-small': { radius: 6, speed: 100, hp: 10, color: '#cccccc', weapon: null, isCollidable: false },
      'civilian-large': { radius: 12, speed: 100, hp: 50, color: '#bbbbbb', weapon: null, isCollidable: false },
      'guard': { radius: 20, speed: 100, hp: 100, color: '#ff9933', weapon: 'gun', isCollidable: true },
      'mercenary': { radius: 25, speed: 100, hp: 100, color: '#ff6633', weapon: 'gun', isCollidable: true }
    };
    // ==========================================================================================
    // 1. BAZA DANYCH AI SPACE (Statystyki broni i pocisk√≥w)
    // ==========================================================================================

    const AISPACE_FLAK = {
      flak_L: { name: 'Flak L', burst: 1, rps: 0.8, speed: 380, range: 520, radius: 48, dmg: 28, color: '#ffef8a' }
    };

    const AISPACE_BS_BROADSIDE = {
      dmg: 80, rps: 0.6, speed: 620, range: 1200, spread: 2.5, color: '#ff9b4b'
    };

    // Hardpoint-friendly rejestr broni z AISPACE
    const AISPACE_HARDPOINT_WEAPONS = (() => {
      const toWeapon = (id, def, type) => ({
        id,
        type,
        name: def.name,
        dps: def.dps,
        damage: def.dmg,
        rps: def.rps,
        cooldown: def.rps ? +(1 / def.rps).toFixed(2) : null,
        range: def.range,
        speed: def.speed,
        spread: def.spread,
        color: def.color,
        aispaceDef: def
      });

      const guns = {
        ais_laser_s: toWeapon('ais_laser_s', AISPACE_GUNS.laserS, HP.MAIN),
        ais_pulse: toWeapon('ais_pulse', AISPACE_GUNS.pulse, HP.MAIN),
        ais_rail_micro: toWeapon('ais_rail_micro', AISPACE_GUNS.rail, HP.MAIN),
        ais_gatling: toWeapon('ais_gatling', AISPACE_GUNS.gatling, HP.MAIN),
        ais_m_beam: toWeapon('ais_m_beam', AISPACE_GUNS_M.m_beam, HP.MAIN),
        ais_m_pulse: toWeapon('ais_m_pulse', AISPACE_GUNS_M.m_pulse, HP.MAIN),
        ais_m_rail: toWeapon('ais_m_rail', AISPACE_GUNS_M.m_rail, HP.MAIN),
        ais_m_autocannon: toWeapon('ais_m_autocannon', AISPACE_GUNS_M.m_autocannon, HP.MAIN),
        ais_h_beam: toWeapon('ais_h_beam', AISPACE_GUNS_M.h_beam, HP.MAIN),
        ais_h_rapid: toWeapon('ais_h_rapid', AISPACE_GUNS_M.h_rapid, HP.MAIN),
        ais_broadside: toWeapon('ais_broadside', AISPACE_BS_BROADSIDE, HP.MAIN)
      };

      const pd = {
        ais_pd_mk1: {
          id: 'ais_pd_mk1',
          type: HP.AUX,
          name: AISPACE_PD.pd_mk1.name,
          damage: AISPACE_PD.pd_mk1.dmg,
          rps: AISPACE_PD.pd_mk1.rps,
          cooldown: AISPACE_PD.pd_mk1.rps ? +(1 / AISPACE_PD.pd_mk1.rps).toFixed(2) : null,
          range: AISPACE_PD.pd_mk1.range,
          spread: AISPACE_PD.pd_mk1.spread,
          color: AISPACE_PD.pd_mk1.color,
          aispacePdId: 'pd_mk1'
        },
        ais_pd_laser: {
          id: 'ais_pd_laser',
          type: HP.AUX,
          name: AISPACE_PD.pd_laser.name,
          damage: AISPACE_PD.pd_laser.dmg,
          rps: AISPACE_PD.pd_laser.rps,
          cooldown: AISPACE_PD.pd_laser.rps ? +(1 / AISPACE_PD.pd_laser.rps).toFixed(2) : null,
          range: AISPACE_PD.pd_laser.range,
          spread: AISPACE_PD.pd_laser.spread,
          color: AISPACE_PD.pd_laser.color,
          aispacePdId: 'pd_laser'
        },
        ais_flak_L: {
          id: 'ais_flak_L',
          type: HP.AUX,
          name: AISPACE_FLAK.flak_L.name,
          damage: AISPACE_FLAK.flak_L.dmg,
          rps: AISPACE_FLAK.flak_L.rps,
          cooldown: AISPACE_FLAK.flak_L.rps ? +(1 / AISPACE_FLAK.flak_L.rps).toFixed(2) : null,
          range: AISPACE_FLAK.flak_L.range,
          spread: AISPACE_FLAK.flak_L.spread,
          color: AISPACE_FLAK.flak_L.color,
          aispaceFlakId: 'flak_L'
        }
      };

      const missileDefaults = 12;
      const missileRange = def => (def.speed && def.life) ? def.speed * def.life : def.range;
      const missiles = {
        ais_msl_AF: {
          id: 'ais_msl_AF', type: HP.MISSILE, name: AISPACE_MISSILES.AF.name, damage: AISPACE_MISSILES.AF.dmg,
          ammo: missileDefaults, rps: null, cooldown: null, range: missileRange(AISPACE_MISSILES.AF),
          color: AISPACE_MISSILES.AF.color, aispaceMissileId: 'AF', missileStats: { ...AISPACE_MISSILES.AF, range: missileRange(AISPACE_MISSILES.AF) }
        },
        ais_msl_AS: {
          id: 'ais_msl_AS', type: HP.MISSILE, name: AISPACE_MISSILES.AS.name, damage: AISPACE_MISSILES.AS.dmg,
          ammo: missileDefaults, rps: null, cooldown: null, range: missileRange(AISPACE_MISSILES.AS),
          color: AISPACE_MISSILES.AS.color, aispaceMissileId: 'AS', missileStats: { ...AISPACE_MISSILES.AS, range: missileRange(AISPACE_MISSILES.AS) }
        },
        ais_msl_HE: {
          id: 'ais_msl_HE', type: HP.MISSILE, name: AISPACE_MISSILES.HE.name, damage: AISPACE_MISSILES.HE.dmg,
          ammo: missileDefaults, rps: null, cooldown: null, range: missileRange(AISPACE_MISSILES.HE),
          color: AISPACE_MISSILES.HE.color, aispaceMissileId: 'HE', missileStats: { ...AISPACE_MISSILES.HE, range: missileRange(AISPACE_MISSILES.HE) }
        },
        ais_msl_SW: {
          id: 'ais_msl_SW', type: HP.MISSILE, name: AISPACE_MISSILES.SW.name, damage: AISPACE_MISSILES.SW.dmg,
          ammo: missileDefaults, rps: null, cooldown: null, range: missileRange(AISPACE_MISSILES.SW),
          color: AISPACE_MISSILES.SW.color, aispaceMissileId: 'SW', missileStats: { ...AISPACE_MISSILES.SW, range: missileRange(AISPACE_MISSILES.SW) }
        }
      };

      return { ...guns, ...pd, ...missiles };
    })();

    window.AISPACE_GUNS = AISPACE_GUNS;
    window.AISPACE_PD = AISPACE_PD;
    window.AISPACE_FLAK = AISPACE_FLAK;
    window.AISPACE_MISSILES = AISPACE_MISSILES;
    window.AISPACE_GUNS_M = AISPACE_GUNS_M;
    window.AISPACE_BS_BROADSIDE = AISPACE_BS_BROADSIDE;

    Object.assign(WEAPONS, AISPACE_HARDPOINT_WEAPONS);
    for (const weaponId of Object.keys(AISPACE_HARDPOINT_WEAPONS)) {
      mergedInventory.add(weaponId);
    }

    // ==========================================================================================
    // 2. ADAPTER SYSTEMU (Most miƒôdzy AI SPACE a Super Capital: Battle for Solar System)
    // ==========================================================================================

    // Ten obiekt udaje silnik z AI Space, ≈ºeby≈õmy nie musieli przepisywaƒá ka≈ºdej linijki AI
    const PirateSim = {
      time: 0,
      get units() {
        // Zwraca listƒô cel√≥w: Gracz + jego sojusznicy + wrodzy piraci (dla friendly fire check)
        return [ship, ...npcs.filter(n => !n.dead)];
      },
      // Symulacja pocisk√≥w i eksplozji nie jest potrzebna tutaj, bo gra ma w≈ÇasnƒÖ w main loop
      projectiles: [],
      wrecks
    };

    // Funkcja strzelania - T≈ÅUMACZY bro≈Ñ z AI Space na pociski w grze
    window.spawnBulletAdapter = function (owner, target, weaponDef, opts = {}) {
      if (!weaponDef) return;

      const origin = opts.origin || owner;
      const originVel = opts.originVel || { x: owner.vx ?? owner.vel?.x ?? 0, y: owner.vy ?? owner.vel?.y ?? 0 };
      const baseAngle = opts.angleOverride ?? owner.angle ?? 0;
      const bulletSpeed = weaponDef.speed || 500;
      const bulletLife = weaponDef.life ?? ((weaponDef.range || 800) / bulletSpeed);
      const vfxKey = resolveBulletVfxKey(opts.vfxKey || weaponDef.id || weaponDef.name, opts.type || weaponDef.type);

      // 1. Celowanie
      let aimPoint;
      if (target) {
        aimPoint = window.getLeadAim(origin, target, bulletSpeed);
      } else {
        const angle = baseAngle;
        aimPoint = {
          x: origin.x + Math.cos(angle) * 1000,
          y: origin.y + Math.sin(angle) * 1000
        };
      }

      const adjustedAng = Math.atan2(aimPoint.y - origin.y, aimPoint.x - origin.x);
      const spreadRad = (weaponDef.spread || 0) * (Math.PI / 180);
      const finalAngle = adjustedAng + (Math.random() - 0.5) * spreadRad;

      // 2. OBS≈ÅUGA LASER√ìW (BEAM) - Przywr√≥cona i naprawiona
      if (weaponDef.isBeam || opts.type === 'beam') {
        const beamRange = weaponDef.range || 800;
        // Punkt ko≈Ñcowy promienia
        const endX = origin.x + Math.cos(finalAngle) * beamRange;
        const endY = origin.y + Math.sin(finalAngle) * beamRange;
        const endPoint = { x: endX, y: endY };

        // Rysowanie promienia
        spawnLaserBeam({ x: origin.x, y: origin.y }, endPoint, opts.beamWidth || 8, {
          life: weaponDef.beamLife || 0.12,
          colorOuter: weaponDef.color || '#ff0000',
          colorInner: '#ffffff',
          glowColor: weaponDef.color,
          glowBlur: 20
        });

        // Natychmiastowe obra≈ºenia (Hitscan)
        if (target) {
          // Sprawd≈∫ czy cel jest w linii strza≈Çu (prosta kolizja)
          // Dla uproszczenia zak≈Çadamy trafienie je≈õli celowany by≈Ç target
          const dist = Math.hypot(target.x - origin.x, target.y - origin.y);
          if (dist <= beamRange) {
            const dmg = weaponDef.dmg || 10;
            if (target === window.ship) applyDamageToPlayer(dmg);
            else if (target.isStation) applyDamageToStation(target, dmg);
            else if (target.isPlatform) applyDamageToPlatform(target, dmg);
            else applyDamageToNPC(target, dmg, 'beam');

            // Efekt trafienia
            spawnWeaponImpactFromPreset('beam', weaponDef.color, 1.0, target.x, target.y);
          }
        }
        return; // Laser to hitscan, nie dodajemy pocisku fizycznego
      }

      // 3. OBS≈ÅUGA POCISK√ìW (FIXED VISUALS)
      let bType = 'default'; // Domy≈õlnie iskry
      let size = 3;
      const name = (weaponDef.name || '').toLowerCase();

      if (name.includes('rail') || name.includes('beam')) { bType = 'rail'; size = 4; }
      else if (name.includes('flak') || name.includes('armata')) { bType = 'armata'; size = 5; }
      else if (name.includes('auto') || name.includes('gatling')) { bType = 'autocannon'; size = 2; }
      else if (name.includes('pulse') || name.includes('plasma')) { bType = 'plasma'; size = 3; }
      else if (name.includes('laser')) { bType = 'default'; size = 2.5; }

      if (opts.type) bType = opts.type;

      window.bullets.push({
        x: origin.x,
        y: origin.y,
        vx: Math.cos(finalAngle) * bulletSpeed + originVel.x * 0.2,
        vy: Math.sin(finalAngle) * bulletSpeed + originVel.y * 0.2,
        life: bulletLife,
        r: size,
        owner: owner.friendly ? 'player' : 'npc',
        damage: weaponDef.dmg || 10,
        type: bType,
        color: weaponDef.color || '#fff',
        source: owner,
        explodeRadius: (bType === 'armata' || name.includes('flak')) ? (weaponDef.radius || 50) : 0,
        penetration: (bType === 'rail') ? 2 : 0
      });
    };

    // --- HELPER: T≈Çumacz typ√≥w dla AI (AI Space Port) ---
    function getUnitKind(npc) {
      if (!npc) return 'unknown';
      if (npc === window.ship) return 'battleship'; // Gracz to dla AI du≈ºy statek

      // Czy to my≈õliwiec?
      if (npc.fighter || npc.type === 'fighter' || npc.type === 'interceptor' || npc.type === 'drone') {
        return 'fighter';
      }

      // Czy to fregata?
      if (npc.type && (npc.type.includes('frigate') || npc.type === 'corvette')) {
        return 'frigate';
      }

      // Czy to niszczyciel?
      if (npc.type === 'destroyer') {
        return 'destroyer';
      }

      // Czy to pancernik / capital?
      if (npc.type === 'battleship' || npc.type === 'carrier' || npc.isCapitalShip) {
        return 'battleship';
      }

      return 'other';
    }
    window.getUnitKind = getUnitKind;
    function pirateRoleKind(npc) {
      if (!npc) return 'other';
      const type = npc.type || '';
      if (npc.fighter || type === 'fighter' || type === 'interceptor' || type === 'drone') return 'fighter';
      if (type.includes('frigate')) return npc.subType === 'laser' ? 'frigate_laser' : 'frigate';
      if (type === 'destroyer') return 'destroyer';
      if (type === 'battleship' || npc.isCapitalShip) return 'battleship';
      return 'other';
    }

    function pirateTargetKind(target) {
      if (!target) return 'other';
      if (target === ship) return 'battleship';
      const type = target.type || '';
      if (target.fighter || type === 'fighter' || type === 'interceptor' || type === 'drone') return 'fighter';
      if (type.includes('frigate')) return 'frigate';
      if (type === 'destroyer') return 'destroyer';
      if (type === 'battleship' || target.isCapitalShip) return 'battleship';
      return 'other';
    }

    function pirateEffectiveHp(target) {
      if (!target) return 0;
      const hull = (target.hp ?? target.hull?.val ?? 0);
      const shield = (target.shield?.val ?? target.shield ?? 0);
      return Math.max(0, hull + shield);
    }

    function pirateEngageScore(attacker, target) {
      const attackerKind = pirateRoleKind(attacker);
      const targetKind = pirateTargetKind(target);
      const tx = target?.pos?.x ?? target?.x ?? 0;
      const ty = target?.pos?.y ?? target?.y ?? 0;
      const dx = tx - (attacker?.x ?? 0);
      const dy = ty - (attacker?.y ?? 0);
      const distSq = dx * dx + dy * dy;

      let score = -distSq * 0.0008;

      if (attackerKind === 'fighter') {
        if (targetKind === 'fighter') {
          score += distSq < 6250000 ? 40000 : 1000;
        } else {
          score += 1000;
        }
      } else if (attackerKind === 'frigate') {
        if (targetKind === 'fighter') score += 2000;
        else if (targetKind === 'frigate') score += 800;
        else score += 200;
      } else if (attackerKind === 'frigate_laser') {
        if (targetKind === 'battleship') score += 2500;
        else if (targetKind === 'destroyer') score += 2000;
        else if (targetKind === 'frigate') score += 1500;
        else score -= 300;
      } else if (attackerKind === 'destroyer') {
        if (targetKind === 'frigate') score += 4500;
        else if (targetKind === 'destroyer') score += 2500;
        else if (targetKind === 'battleship') score += 1000;
        else score += 500;
      } else if (attackerKind === 'battleship') {
        if (targetKind === 'battleship') score += 4000;
        else if (targetKind === 'destroyer') score += 3000;
        else if (targetKind === 'frigate') score += 2000;
        else score -= 500;
      }

      if (distSq < 122500) {
        if (attackerKind === 'fighter' && targetKind !== 'fighter') score += 6000;
        else score += 8000;
      }

      const effHp = pirateEffectiveHp(target);
      const incoming = target?.incomingDamage ?? 0;
      if (effHp > 0) {
        const overkill = incoming / (effHp + 1);
        if (overkill > 1.2) score -= 1500 * (overkill - 1.0);
      }

      score += Math.random() * 250;
      return score;
    }

    function pickPirateEngageTarget(npc) {
      if (!npc?.isPirate || mercMission?.alertStage !== 'engage') return null;
      const candidates = [ship, ...npcs.filter(n => n.friendly && !n.dead)];
      let best = null;
      let bestScore = -Infinity;
      for (const target of candidates) {
        const score = pirateEngageScore(npc, target);
        if (score > bestScore) {
          bestScore = score;
          best = target;
        }
      }
      return best;
    }
    // ==========================================================================================
    // 2. LOGIKA AI (M√ìZGI STATK√ìW - "AI SPACE PORT")
    // ==========================================================================================

    // Helper: Znajdowanie najlepszego celu (Gracz lub sojusznik)
    function aiPickTarget(npc) {
      if (npc?.isPirate) {
        if (mercMission?.alertStage === 'guard' && npc.guardHold) return null;
        const engageTarget = pickPirateEngageTarget(npc);
        if (engageTarget) return engageTarget;
      }
      if (npc && npc.forceTarget && !npc.forceTarget.dead) {
        return npc.forceTarget;
      }
      let best = null;
      let maxScore = -Infinity;

      const targets = npc.friendly
        ? npcs.filter(n => n.isPirate && !n.dead)
        : [ship, ...npcs.filter(n => n.friendly && !n.dead)];

      // RADAR POKRYWAJƒÑCY CA≈ÅƒÑ STACJƒò PIRACKƒÑ
      const RADAR_RANGE_SQ = 20000 * 20000;

      for (const t of targets) {
        const tx = t.pos ? t.pos.x : t.x;
        const ty = t.pos ? t.pos.y : t.y;
        const distSq = (tx - npc.x) ** 2 + (ty - npc.y) ** 2;

        if (distSq > RADAR_RANGE_SQ) continue;

        let score = -distSq;
        if (t === ship) score += 10000000;
        if (t.isCapitalShip) score += 5000000;

        if (score > maxScore) {
          maxScore = score;
          best = t;
        }
      }
      return best;
    }
    window.aiPickTarget = aiPickTarget;

    function initNPCs() {
      npcs = [];
	  window.npcs = npcs;
      SQUADS.length = 0; // Reset eskadr
      let npcCounter = 0;

      // 1. Stw√≥rz eskadrƒô pirackich my≈õliwc√≥w (Interceptor Squad)
      const pirateSquad = new Squad('pirate', 'fighter');
      SQUADS.push(pirateSquad);

      const startX = ship.pos.x + 2000;
      const startY = ship.pos.y;

      // Spawn 5 my≈õliwc√≥w w formacji
      for (let i = 0; i < 5; i++) {
        const npc = makeNPCBase({ x: startX + Math.random() * 100, y: startY + Math.random() * 100 }, {
          hp: 80,
          accel: 220, // Wy≈ºsze przyspieszenie dla nowej fizyki
          maxSpeed: 450,
          turn: 6.0,
          radius: 18
        });

        npc.id = `pirate_${npcCounter++}`;
        npc.friendly = false;
        npc.isPirate = true;
        npc.type = 'interceptor';
        npc.fighter = true;
        npc.color = '#ff5c7c'; // Czerwony z AI SPACE
        npc.mission = true; // Misje u≈ºywajƒÖ nowego AI; omijaj cywilny autopilot
        npc.gunCD = 0;

        // *** KLUCZOWA ZMIANA: Przypisanie nowego AI ***
        npc.ai = (dt) => { if (window.runAdvancedFighterAI) window.runAdvancedFighterAI(npc, dt); };

        npcs.push(npc);
        pirateSquad.addUnit(npc);
      }

      // 2. Stw√≥rz eskadrƒô sojuszniczƒÖ (je≈õli chcesz testowaƒá dogfight)
      const allySquad = new Squad('player', 'fighter');
      SQUADS.push(allySquad);

      for (let i = 0; i < 3; i++) {
        const npc = makeNPCBase({ x: ship.pos.x - 200, y: ship.pos.y + 200 }, {
          hp: 100, accel: 220, maxSpeed: 450, turn: 6.0, radius: 18
        });
        npc.id = `ally_${npcCounter++}`;
        npc.friendly = true;
        npc.type = 'ally_fighter';
        npc.fighter = true;
        npc.color = '#7cff91'; // Zielony z AI SPACE
        npc.mission = true; // Wymu≈õ ≈õcie≈ºkƒô mission dla runAdvancedFighterAI
        npc.ai = (dt) => { if (window.runAdvancedFighterAI) window.runAdvancedFighterAI(npc, dt); };

        npcs.push(npc);
        allySquad.addUnit(npc);
      }
    }
    // Ensure Three.js modules are loaded before initializing 3D objects
    window.addEventListener('DOMContentLoaded', () => {
      const planetInitResult = initPlanets3D(planets, SUN);
      const sceneFromInit = asThreeScene(planetInitResult);
      if (sceneFromInit) {
        planetScene3D = sceneFromInit;
      }
      // overlay main scene
      let overlayScene = null;
      if (typeof window.initWorld3D === 'function') {
        const res = initWorld3D();
        const candidate = asThreeScene(res?.scene || res);
        if (candidate) {
          mainScene3D = candidate;
          overlayScene = candidate;
        } else if (res?.scene) {
          mainScene3D = res.scene;
          overlayScene = res.scene;
        }
        window.mainScene3D = mainScene3D;
      }
      // stacje ‚Äì w≈Çasna warstwa 3D (ortho), bez world3D
      if (typeof window.initStations3D === 'function') {
        window.initStations3D(null, stations);
        planetScene3D = overlayScene;
        planetStationsReady = true;
      }
      if (!planetStationsReady && !ensurePlanetStationsInit(stations)) {
        let tries = 0;
        const maxTries = 240;
        (function poll() {
          if (ensurePlanetStationsInit(stations) || tries++ > maxTries) return;
          requestAnimationFrame(poll);
        })();
      }
    });

    function waitForPlanetsReady() {
      if (planetScene3D || planetStationsReady) return Promise.resolve();
      return waitForCondition(() => planetScene3D || planetStationsReady, 2500);
    }

    // =============== Bullets & effects ===============

    // const particles = []; // USUNIƒòTE
    const shockwaves = [];
    const MAX_PARTICLES = 8000;          // twardy sufit (dobry balans)
    const MAX_PARTICLES_DRAW = 4500;     // ile maks. rysujemy na ekranie

    // === POCZƒÑTEK NOWEGO KODU (Pula CzƒÖsteczek) ===
    const particlePool = [];
    let nextParticleIndex = 0;
    (function initParticlePool() { // Samowywo≈ÇujƒÖca siƒô funkcja do zainicjowania puli
      for (let i = 0; i < MAX_PARTICLES; i++) {
        particlePool.push({
          pos: { x: 0, y: 0 },
          vel: { x: 0, y: 0 },
          life: 0,
          age: 0,
          color: '#fff',
          size: 1,
          flash: false,
          beam: false,
          start: { x: 0, y: 0 },
          end: { x: 0, y: 0 },
          width: 0,
          alpha: 1,
          fadeWithLife: true,
          glowColor: null,
          colorOuter: null,
          colorInner: null,
          glowBlur: 0,
          outerWidthMul: 1,
          innerWidthMul: 1,
          active: false // Flaga 'aktywno≈õci' jest kluczowa
        });
      }
    })();
    // === KONIEC NOWEGO KODU ===

    // Nowa tablica na efekty b≈Çyskawic (sƒÖ rysowane liniami, nie sprite'ami)
    const lightningParticles = [];

    function spawnLightningSpark(pos, life, size, angle) {
      lightningParticles.push({
        x: pos.x, y: pos.y,
        life: life, maxLife: life,
        size: size,
        angle: angle,
        age: 0
      });
    }

    function updateLightnings(dt) {
      for (let i = lightningParticles.length - 1; i >= 0; i--) {
        const p = lightningParticles[i];
        p.age += dt;
        if (p.age >= p.maxLife) lightningParticles.splice(i, 1);
      }
    }

    function pushParticleSafe(p) {
      // Ta funkcja nie jest ju≈º potrzebna, ale zostawiamy jƒÖ pustƒÖ,
      // na wypadek gdyby inne czƒô≈õci kodu jƒÖ wo≈Ça≈Çy (jak spawnLaserBeam).
      // spawnParticle jest teraz g≈Ç√≥wnƒÖ funkcjƒÖ.
    }

    function spawnParticle(pos, vel, life, color, size, flash) {
      const p = particlePool[nextParticleIndex]; // We≈∫ nastƒôpnƒÖ czƒÖsteczkƒô z puli

      // Ustaw jej w≈Ça≈õciwo≈õci
      p.pos.x = pos.x;
      p.pos.y = pos.y;
      p.vel.x = vel.x;
      p.vel.y = vel.y;
      p.life = life;
      p.age = 0;
      p.color = color || '#ffb677';
      p.size = size || 2;
      p.flash = !!flash;
      p.beam = false;
      p.start.x = 0;
      p.start.y = 0;
      p.end.x = 0;
      p.end.y = 0;
      p.width = 0;
      p.alpha = 1;
      p.fadeWithLife = true;
      p.colorOuter = null;
      p.colorInner = null;
      p.glowColor = null;
      p.glowBlur = 0;
      p.outerWidthMul = 1;
      p.innerWidthMul = 1;
      p.active = true; // <-- AKTYWUJ CZƒÑSTECZKƒò

      // Przesu≈Ñ indeks na nastƒôpne wolne miejsce
      nextParticleIndex = (nextParticleIndex + 1) % MAX_PARTICLES;
    }

    function hexToRgb(hex) {
      if (!hex || typeof hex !== 'string') return null;
      const clean = hex.replace('#', '');
      if (clean.length === 3) {
        const r = clean[0], g = clean[1], b = clean[2];
        return {
          r: parseInt(r + r, 16),
          g: parseInt(g + g, 16),
          b: parseInt(b + b, 16)
        };
      }
      if (clean.length !== 6) return null;
      return {
        r: parseInt(clean.slice(0, 2), 16),
        g: parseInt(clean.slice(2, 4), 16),
        b: parseInt(clean.slice(4, 6), 16)
      };
    }
    function rgbaFromHex(hex, alpha) {
      const rgb = hexToRgb(hex);
      if (!rgb) return null;
      return `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
    }
    function rgbaPrefixFromHex(hex, fallback = 'rgba(255,200,150,') {
      const rgb = hexToRgb(hex);
      if (!rgb) return fallback;
      return `rgba(${rgb.r},${rgb.g},${rgb.b},`;
    }
    function resolveAlphaColor(color, alpha, fallback) {
      const rgba = rgbaFromHex(color, alpha);
      if (rgba) return rgba;
      if (color?.startsWith('rgba(')) {
        const parts = color.split(',');
        if (parts.length >= 3) {
          return `${parts[0]},${parts[1]},${parts[2]},${alpha})`;
        }
      }
      return fallback || color || '#ffffff';
    }

    const WEAPON_VFX_PRESETS = {
      rail: {
        key: 'rail',
        color: '#9cc9ff',
        len: 32,
        widthOuter: 12,
        widthInner: 4,
        glowBlur: 22,
        sparkCount: 18,
        sparkSpeed: [260, 420],
        sparkSize: [1.6, 2.4],
        shock: { r: 12, maxR: 120, w: 3.0, life: 0.32 },
      },
      armata: {
        key: 'armata',
        color: '#ffb46b',
        len: 34,
        widthOuter: 18,
        widthInner: 6,
        glowBlur: 26,
        sparkCount: 26,
        sparkSpeed: [240, 420],
        sparkSize: [2.2, 3.4],
        smoke: 6,
        smokeColor: 'rgba(120,90,60,0.55)',
        shock: { r: 16, maxR: 150, w: 3.6, life: 0.4 },
      },
      autocannon: {
        key: 'autocannon',
        color: '#ffcc8a',
        len: 18,
        widthOuter: 10,
        widthInner: 4,
        glowBlur: 18,
        sparkCount: 14,
        sparkSpeed: [220, 360],
        sparkSize: [1.4, 2.4],
        smoke: 4,
        smokeColor: 'rgba(90,110,180,0.5)',
        shock: { r: 10, maxR: 90, w: 2.8, life: 0.26 },
      },
      plasma: {
        key: 'plasma',
        color: '#7cff9c',
        len: 20,
        widthOuter: 10,
        widthInner: 6,
        glowBlur: 18,
        trailFromPrev: true,
        sparkCount: 14,
        sparkSpeed: [180, 320],
        sparkSize: [1.4, 2.4],
        shock: { r: 12, maxR: 110, w: 2.8, life: 0.3 },
      },
      pulse: {
        key: 'pulse',
        color: '#ffd36e',
        len: 22,
        widthOuter: 12,
        widthInner: 6,
        glowBlur: 20,
        trailFromPrev: true,
        sparkCount: 16,
        sparkSpeed: [200, 360],
        sparkSize: [1.6, 2.6],
        shock: { r: 12, maxR: 130, w: 3.0, life: 0.32 },
      },
      laser: {
        key: 'laser',
        color: '#86f7ff',
        len: 28,
        widthOuter: 11,
        widthInner: 3.5,
        glowBlur: 24,
        sparkCount: 12,
        sparkSpeed: [220, 360],
        sparkSize: [1.2, 2.0],
        shock: { r: 10, maxR: 100, w: 2.4, life: 0.26 },
      },
      beam: {
        key: 'beam',
        color: '#ff7c7c',
        len: 30,
        widthOuter: 12,
        widthInner: 5,
        glowBlur: 26,
        sparkCount: 16,
        sparkSpeed: [260, 380],
        sparkSize: [1.6, 2.8],
        shock: { r: 16, maxR: 160, w: 3.4, life: 0.36 },
      },
      flak: {
        key: 'flak',
        color: '#ffef8a',
        len: 20,
        widthOuter: 14,
        widthInner: 6,
        glowBlur: 22,
        sparkCount: 22,
        sparkSpeed: [200, 360],
        sparkSize: [1.6, 3.0],
        smoke: 8,
        smokeColor: 'rgba(120,90,60,0.4)',
        shock: { r: 18, maxR: 170, w: 3.8, life: 0.42 },
      },
      broadside: {
        key: 'broadside',
        color: '#ff9b4b',
        len: 24,
        widthOuter: 14,
        widthInner: 6,
        glowBlur: 22,
        sparkCount: 20,
        sparkSpeed: [220, 360],
        sparkSize: [1.8, 2.8],
        smoke: 5,
        smokeColor: 'rgba(120,80,60,0.45)',
        shock: { r: 16, maxR: 160, w: 3.4, life: 0.4 },
      },
      ciws: {
        key: 'ciws',
        color: '#8cffd0',
        len: 14,
        widthOuter: 8,
        widthInner: 3,
        glowBlur: 14,
        sparkCount: 10,
        sparkSpeed: [180, 280],
        sparkSize: [1.0, 1.8],
        shock: { r: 8, maxR: 70, w: 2.0, life: 0.2 },
      },
      default: {
        key: 'default',
        color: '#ffd86b',
        len: 18,
        widthOuter: 10,
        widthInner: 4,
        glowBlur: 18,
        sparkCount: 14,
        sparkSpeed: [200, 320],
        sparkSize: [1.2, 2.0],
        shock: { r: 10, maxR: 100, w: 2.6, life: 0.3 },
      },
    };

    function resolveBulletVfxKey(rawKey, type) {
      const key = (rawKey || '').toString().toLowerCase();
      if (key.includes('broadside')) return 'broadside';
      if (key.includes('flak')) return 'flak';
      if (key.includes('beam') || key.includes('laser')) return key.includes('heavy') ? 'beam' : 'laser';
      if (key.includes('rail')) return 'rail';
      if (key.includes('armata')) return 'armata';
      if (key.includes('auto') || key.includes('gatling')) return 'autocannon';
      if (key.includes('pulse')) return 'pulse';
      if (key.includes('pd')) return 'ciws';
      if (key.includes('missile') || key.includes('aim-') || key.includes('asm') || key.includes('het') || key.includes('swarm')) return 'armata';
      if (type === 'beam') return 'beam';
      if (type === 'rail') return 'rail';
      if (type === 'armata') return 'armata';
      if (type === 'ciws') return 'ciws';
      if (type === 'autocannon') return 'autocannon';
      if (type === 'plasma') return 'plasma';
      return 'default';
    }

    function buildBulletVfxInstance(presetKey, color) {
      const preset = WEAPON_VFX_PRESETS[presetKey] || WEAPON_VFX_PRESETS.default;
      const resolvedColor = color || preset.color;
      return {
        ...preset,
        key: preset.key,
        color: resolvedColor,
        glowColor: preset.glowColor || resolvedColor,
        trailColor: preset.trailColor || resolvedColor,
        shockColorPrefix: rgbaPrefixFromHex(preset.shockColor || resolvedColor, 'rgba(255,200,150,'),
      };
    }

    function spawnWeaponImpactFromPreset(presetKey, color, scale = 1, x = 0, y = 0) {
      const fx = buildBulletVfxInstance(presetKey, color);
      const sparks = Math.round((fx.sparkCount || 12) * scale);
      for (let i = 0; i < sparks; i++) {
        const a = Math.random() * Math.PI * 2;
        const speedMin = fx.sparkSpeed?.[0] || 200;
        const speedMax = fx.sparkSpeed?.[1] || 360;
        const speed = speedMin + Math.random() * (speedMax - speedMin);
        const sizeMin = fx.sparkSize?.[0] || 1.4;
        const sizeMax = fx.sparkSize?.[1] || 2.6;
        const size = sizeMin + Math.random() * (sizeMax - sizeMin);
        spawnParticle(
          { x, y },
          { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
          0.2 + Math.random() * 0.18,
          resolveAlphaColor(fx.color, 0.9, fx.color),
          size * scale,
          true
        );
      }

      if (fx.smoke && fx.smokeColor) {
        for (let i = 0; i < fx.smoke * scale; i++) {
          const a = Math.random() * Math.PI * 2;
          const speed = 60 + Math.random() * 100;
          spawnParticle(
            { x, y },
            { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
            0.32 + Math.random() * 0.24,
            fx.smokeColor,
            3 * scale,
            false
          );
        }
      }

      spawnParticle({ x, y }, { x: 0, y: 0 }, 0.12, resolveAlphaColor(fx.color, 1, '#ffffff'), (6 + (fx.widthInner || 4)) * 0.7 * scale, true);
      spawnShockwave(x, y, {
        r: (fx.shock?.r || 10) * scale,
        maxR: (fx.shock?.maxR || 100) * scale,
        w: (fx.shock?.w || 2.6) * scale,
        maxLife: fx.shock?.life || 0.32,
        color: fx.shockColorPrefix
      });
    }

    function resolveBulletVfx(bullet) {
      if (!bullet.vfx) {
        const presetKey = resolveBulletVfxKey(bullet.vfxKey || bullet.weaponId || bullet.weaponName, bullet.type);
        bullet.vfx = buildBulletVfxInstance(presetKey, bullet.vfxColor || bullet.color);
      }
      return bullet.vfx;
    }

    function drawBulletVisual(ctx, b, cam) {
      const vfx = resolveBulletVfx(b);
      const s = worldToScreen(b.x, b.y, cam);
      const prevS = worldToScreen(b.px ?? b.x, b.py ?? b.y, cam);
      const angle = Math.atan2(b.vy, b.vx);
      const lenPx = (vfx.len || 50) * camera.zoom;

      if (b.type === 'rail') {
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(angle);

        const coreGrad = ctx.createLinearGradient(-lenPx / 2, 0, lenPx / 2, 0);
        coreGrad.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
        coreGrad.addColorStop(1, 'rgba(255, 255, 255, 1.0)');
        ctx.fillStyle = coreGrad;

        const width = (vfx.widthInner || 3) * camera.zoom;
        ctx.beginPath();
        ctx.roundRect(-lenPx / 2, -width / 2, lenPx, width, width / 2);
        ctx.fill();

        const headSize = width * 6;
        const headGrad = ctx.createRadialGradient(lenPx / 2, 0, 0, lenPx / 2, 0, headSize);
        headGrad.addColorStop(0, 'rgba(255, 255, 255, 1)');
        headGrad.addColorStop(0.3, 'rgba(200, 230, 255, 0.5)');
        headGrad.addColorStop(1, 'rgba(100, 100, 255, 0)');
        ctx.fillStyle = headGrad;
        ctx.globalCompositeOperation = 'lighter';
        ctx.beginPath();
        ctx.arc(lenPx / 2, 0, headSize, 0, Math.PI * 2);
        ctx.fill();

        if (Math.random() < 0.3) {
          const jitter = 10;
          const jx = (Math.random() - 0.5) * jitter;
          const jy = (Math.random() - 0.5) * jitter;
          spawnLightningSpark(
            { x: b.x + jx, y: b.y + jy },
            0.3,
            18,
            Math.random() * Math.PI * 2
          );
        }

        ctx.restore();
        return;
      }

      const dx = Math.cos(angle) * (lenPx * 0.5);
      const dy = Math.sin(angle) * (lenPx * 0.5);

      if (vfx.trailFromPrev) {
        const grad = ctx.createLinearGradient(prevS.x, prevS.y, s.x, s.y);
        grad.addColorStop(0, resolveAlphaColor(vfx.trailColor, 0, vfx.color));
        grad.addColorStop(1, resolveAlphaColor(vfx.trailColor, 0.8, vfx.color));
        ctx.save();
        ctx.lineCap = 'round';
        ctx.strokeStyle = grad;
        if (camera.zoom > 0.5) {
          ctx.shadowBlur = (vfx.glowBlur || 14) * 0.6 * camera.zoom;
          ctx.shadowColor = resolveAlphaColor(vfx.glowColor, 0.6, vfx.color);
        } else {
          ctx.shadowBlur = 0;
        }
        ctx.lineWidth = Math.max(1.2, (vfx.widthOuter || 8) * 0.6 * camera.zoom);
        ctx.beginPath(); ctx.moveTo(prevS.x, prevS.y); ctx.lineTo(s.x, s.y); ctx.stroke();
        ctx.restore();
      }

      ctx.save();
      ctx.lineCap = 'round';
      if (camera.zoom > 0.5) {
        ctx.shadowBlur = (vfx.glowBlur || 16) * camera.zoom;
        ctx.shadowColor = resolveAlphaColor(vfx.glowColor, 0.9, vfx.color);
      } else {
        ctx.shadowBlur = 0;
      }
      ctx.strokeStyle = resolveAlphaColor(vfx.trailColor, 0.75, vfx.color);
      ctx.lineWidth = (vfx.widthOuter || 10) * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx, s.y - dy); ctx.lineTo(s.x + dx, s.y + dy); ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.lineCap = 'round';
      ctx.strokeStyle = resolveAlphaColor('#ffffff', 0.95, vfx.color);
      ctx.lineWidth = Math.max(1.2, (vfx.widthInner || 4) * camera.zoom);
      ctx.beginPath(); ctx.moveTo(s.x - dx * 0.35, s.y - dy * 0.35); ctx.lineTo(s.x + dx * 0.9, s.y + dy * 0.9); ctx.stroke();
      ctx.restore();
    }
    function spawnExplosionPlasma(x, y, scale = 1) {
      spawnParticle(
        { x, y },         // Pozycja
        { x: 0, y: 0 },   // Brak ruchu
        0.1,            // Bardzo kr√≥tki czas ≈ºycia (0.1s)
        '#AAFFAA',      // Ja≈õniejszy ≈õrodek
        4 * scale,      // Ma≈Çy rozmiar (np. 4px)
        true            // Flash (efekt ≈õwiecenia)
      );
      spawnShockwave(x, y, {
        r: 2,               // Startuje od punktu
        maxR: 14 * scale,   // Ro≈õnie tylko do ~14 pikseli (bardzo ma≈Çe)
        w: 2,               // Cienka linia
        maxLife: 0.15,      // Bardzo szybki zanik
        color: 'rgba(124, 255, 124,'
      });
    }
    function spawnRailHitEffect(x, y, scale = 1) {
      // Tylko 3D (skalowane parametrem efektu)
      triggerRailgunExplosion3D(x, y, ship.h * 0.22 * scale);
    }

    function spawnArmataHitEffect(x, y, scale = 1) {
      triggerArmataImpact3D(x, y, ship.h * 0.3 * scale);
      const count = Math.round(28 * scale);
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const speed = 200 + Math.random() * 280;
        const color = (Math.random() < 0.45) ? '#ffd2a0' : '#ff9f58';
        spawnParticle(
          { x, y },
          { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
          0.22 + Math.random() * 0.18,
          color,
          2.2 + Math.random() * 2.6,
          true
        );
      }
      spawnParticle({ x, y }, { x: 0, y: 0 }, 0.12, '#fff2d0', 7.5 * scale, true);
      spawnShockwave(x, y, { r: 14 * scale, maxR: 120 * scale, w: 3.2 * scale, maxLife: 0.42, color: 'rgba(255,170,90,' });
    }

    function spawnAutocannonHitEffect(x, y, scale = 1) {
      triggerAutocannonImpact3D(x, y, ship.h * 0.18 * scale);
      const sparkCount = Math.round(20 * scale);
      for (let i = 0; i < sparkCount; i++) {
        const a = Math.random() * Math.PI * 2;
        const speed = 280 + Math.random() * 240;
        const color = (Math.random() < 0.5) ? '#ffe4a8' : '#ffba60';
        spawnParticle(
          { x, y },
          { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
          0.18 + Math.random() * 0.14,
          color,
          1.6 + Math.random() * 1.4,
          true
        );
      }
      const smokeCount = Math.round(6 * scale);
      for (let i = 0; i < smokeCount; i++) {
        const a = Math.random() * Math.PI * 2;
        const speed = 60 + Math.random() * 80;
        spawnParticle(
          { x, y },
          { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
          0.32 + Math.random() * 0.18,
          'rgba(90,110,180,0.55)',
          3.2 * scale,
          false
        );
      }
      spawnParticle({ x, y }, { x: 0, y: 0 }, 0.1, '#ffffff', 5.4 * scale, true);
      spawnShockwave(x, y, { r: 10 * scale, maxR: 90 * scale, w: 2.6 * scale, maxLife: 0.28, color: 'rgba(255,205,140,' });
    }

    function spawnRailMuzzle(pos, dir, baseVel, scale = 1) {
      spawnParticle({ x: pos.x, y: pos.y }, baseVel, 0.08, '#ffffff', 22 * scale, true);

      const angle = Math.atan2(dir.y, dir.x);

      for (let i = 0; i < 3; i++) {
        spawnParticle(
          { x: pos.x + dir.x * i * 12 * scale, y: pos.y + dir.y * i * 12 * scale },
          { x: dir.x * 60 + baseVel.x, y: dir.y * 60 + baseVel.y },
          0.06, '#bfe7ff', (14 - i * 4) * scale, true
        );
      }

      const sparkCount = 12;
      for (let i = 0; i < sparkCount; i++) {
        const aa = angle + (Math.random() - 0.5) * 0.25;
        const speed = (500 + Math.random() * 300) * scale;

        spawnParticle(
          { x: pos.x, y: pos.y },
          { x: Math.cos(aa) * speed + baseVel.x * 0.2, y: Math.sin(aa) * speed + baseVel.y * 0.2 },
          0.15 + Math.random() * 0.1,
          '#ffffff',
          (1.5 + Math.random() * 2.0) * scale,
          false
        );
      }
    }

    function spawnArmataMuzzle(pos, dir, baseVel, scale = 1) {
      const angle = Math.atan2(dir.y, dir.x);
      spawnParticle(
        { x: pos.x, y: pos.y },
        { x: dir.x * 160 + baseVel.x * 0.12, y: dir.y * 160 + baseVel.y * 0.12 },
        0.16,
        '#ffd6a0',
        9 * scale,
        true
      );
      for (let i = 0; i < 10; i++) {
        const spread = (Math.random() - 0.5) * 0.38;
        const aa = angle + spread;
        const speed = 260 + Math.random() * 140;
        const size = 2.6 + Math.random() * 2.8;
        const life = 0.16 + Math.random() * 0.14;
        const color = (Math.random() < 0.5) ? '#ffbe7a' : '#ffcfa0';
        spawnParticle(
          { x: pos.x + Math.cos(aa) * 8 * scale, y: pos.y + Math.sin(aa) * 8 * scale },
          { x: Math.cos(aa) * speed + baseVel.x * 0.18, y: Math.sin(aa) * speed + baseVel.y * 0.18 },
          life,
          color,
          size * scale,
          true
        );
      }
      for (let i = 0; i < 4; i++) {
        const aa = angle + (Math.random() - 0.5) * 0.25;
        const speed = 120 + Math.random() * 60;
        spawnParticle(
          { x: pos.x + Math.cos(aa) * 4 * scale, y: pos.y + Math.sin(aa) * 4 * scale },
          { x: Math.cos(aa) * speed + baseVel.x * 0.08, y: Math.sin(aa) * speed + baseVel.y * 0.08 },
          0.3 + Math.random() * 0.18,
          '#d76926',
          1.8 * scale,
          false
        );
      }
      spawnShockwave(pos.x, pos.y, { r: 10 * scale, maxR: 80 * scale, w: 2.6 * scale, maxLife: 0.3, color: 'rgba(255,170,90,' });
    }

    function spawnAutocannonMuzzle(pos, dir, baseVel, scale = 1) {
      const angle = Math.atan2(dir.y, dir.x);
      spawnParticle(
        { x: pos.x, y: pos.y },
        { x: dir.x * 220 + baseVel.x * 0.18, y: dir.y * 220 + baseVel.y * 0.18 },
        0.12,
        '#ffdba6',
        7 * scale,
        true
      );
      for (let i = 0; i < 8; i++) {
        const spread = (Math.random() - 0.5) * 0.32;
        const aa = angle + spread;
        const speed = 300 + Math.random() * 180;
        const color = (Math.random() < 0.35) ? '#ffe6b0' : '#ffbf6b';
        const size = 1.6 + Math.random() * 1.6;
        spawnParticle(
          { x: pos.x + Math.cos(aa) * 6 * scale, y: pos.y + Math.sin(aa) * 6 * scale },
          { x: Math.cos(aa) * speed + baseVel.x * 0.16, y: Math.sin(aa) * speed + baseVel.y * 0.16 },
          0.16 + Math.random() * 0.12,
          color,
          size * scale,
          true
        );
      }
      for (let i = 0; i < 4; i++) {
        const aa = angle + (Math.random() - 0.5) * 0.2;
        const speed = 120 + Math.random() * 60;
        spawnParticle(
          { x: pos.x + Math.cos(aa) * 4 * scale, y: pos.y + Math.sin(aa) * 4 * scale },
          { x: Math.cos(aa) * speed + baseVel.x * 0.08, y: Math.sin(aa) * speed + baseVel.y * 0.08 },
          0.24 + Math.random() * 0.18,
          '#6b7cff',
          1.4 * scale,
          false
        );
      }
      spawnShockwave(pos.x, pos.y, { r: 8 * scale, maxR: 70 * scale, w: 2.2 * scale, maxLife: 0.22, color: 'rgba(255,200,120,' });
    }

    function spawnSiegeMuzzle(pos, dir, baseVel, scale = 1) {
      const angle = Math.atan2(dir.y, dir.x);
      spawnParticle(
        { x: pos.x, y: pos.y },
        { x: dir.x * 200 + baseVel.x * 0.15, y: dir.y * 200 + baseVel.y * 0.15 },
        0.18,
        '#ffe6b0',
        12 * scale,
        true
      );
      for (let i = 0; i < 14; i++) {
        const spread = (Math.random() - 0.5) * 0.32;
        const aa = angle + spread;
        const speed = 320 + Math.random() * 160;
        const color = (Math.random() < 0.4) ? '#ffcf7f' : '#ffdca8';
        const vel = {
          x: Math.cos(aa) * speed + baseVel.x * 0.16,
          y: Math.sin(aa) * speed + baseVel.y * 0.16
        };
        spawnParticle(
          { x: pos.x + Math.cos(aa) * 10 * scale, y: pos.y + Math.sin(aa) * 10 * scale },
          vel,
          0.22 + Math.random() * 0.14,
          color,
          2.4 * scale,
          true
        );
      }
      spawnShockwave(pos.x, pos.y, { r: 12 * scale, maxR: 100 * scale, w: 3.0 * scale, maxLife: 0.32, color: 'rgba(255,190,110,' });
    }

    function spawnSiegeHitEffect(x, y, scale = 1) {
      triggerArmataImpact3D(x, y, ship.h * 0.36 * scale);
      const count = Math.round(36 * scale);
      for (let i = 0; i < count; i++) {
        const a = Math.random() * Math.PI * 2;
        const speed = 240 + Math.random() * 320;
        const color = (Math.random() < 0.45) ? '#ffd09a' : '#ffb670';
        spawnParticle(
          { x, y },
          { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
          0.26 + Math.random() * 0.18,
          color,
          2.6 + Math.random() * 2.8,
          true
        );
      }
      spawnParticle({ x, y }, { x: 0, y: 0 }, 0.16, '#fff6d6', 9.5 * scale, true);
      spawnShockwave(x, y, { r: 16 * scale, maxR: 150 * scale, w: 3.4 * scale, maxLife: 0.42, color: 'rgba(255,195,120,' });
    }
    function spawnDefaultHit(x, y, scale = 1) {
      spawnParticle(
        { x, y },
        { x: 0, y: 0 },
        0.15,
        '#fff5d6',
        7 * scale,
        true            // Tryb flash (≈õwiecenie)
      );

      // 2. Fala uderzeniowa (Shockwave)
      spawnShockwave(x, y, {
        r: 4 * scale,
        maxR: 45 * scale, // Mniejszy zasiƒôg fali (rakiety majƒÖ ~100+)
        w: 3 * scale,     // Cie≈Ñsza linia
        maxLife: 0.25,    // Szybszy zanik
        color: 'rgba(255, 220, 180,' // Kolor fali (ciep≈Çy bia≈Çy/≈º√≥≈Çty)
      });
    }

    function spawnShockwave(x, y, opts = {}) {
      shockwaves.push({
        x, y,
        r: opts.r || 20,
        maxR: opts.maxR || 800,
        w: opts.w || 8,
        life: 0,
        maxLife: opts.maxLife || 0.6,
        color: opts.color || 'rgba(180,200,255,'
      });
    }

    // =============== Station UI ===============
    let stationUI = {
      open: false,
      visible: false,
      awaitingCamera: false,
      appear: 0,
      autoPosition: true,
      tab: 'upgrades',
      station: null,
      cursorOver: false,
      hoverId: null,
      x: (W - 450) / 2,
      y: (H - 520) / 2,
      w: 450,
      h: 520,
      dragging: false,
      dragDX: 0,
      dragDY: 0,
      editorMode: false
    };

    function stationUnderCursor() {
      const world = screenToWorld(mouse.x, mouse.y);
      for (const s of stations) {
        const d = Math.hypot(world.x - s.x, world.y - s.y);
        if (d < (s.r || 120)) return s;
      }
      return null;
    }

    function openStationUI(station) {
      if (!station) return;
      setStationEditorMode(false);
      stationUI.open = true;
      stationUI.visible = false;
      stationUI.awaitingCamera = true;
      stationUI.station = station;
      stationUI.tab = 'upgrades';
      stationUI.appear = 0;
      stationUI.autoPosition = true;
      stationUI.x = (W - stationUI.w) / 2;
      stationUI.y = (H - stationUI.h) / 2;
      stationUI.dragging = false;
      stationUI.editorMode = false;
      mouse.left = false;
      mouse.right = false;
      setInfrastructureActiveStation(station);
      camera.focusOnStation(station);
    }

    function closeStationUI() {
      if (!stationUI.open) return;
      setStationEditorMode(false);
      stationUI.open = false;
      stationUI.visible = false;
      stationUI.awaitingCamera = false;
      stationUI.station = null;
      stationUI.dragging = false;
      stationUI.autoPosition = false;
      stationUI.editorMode = false;
      setInfrastructureActiveStation(null);
      setInfrastructureUIVisible(false);
      camera.clearFocus();
    }

    function setStationEditorMode(enabled) {
      const body = document.body;
      const overlay = infrastructureBuilder.overlay;
      const allow = !!enabled && !!stationUI.station && stationUI.open && !stationUI.awaitingCamera;
      if (allow === stationUI.editorMode) return;
      stationUI.editorMode = allow;
      if (body) {
        body.classList.toggle('infrastructure-editor', stationUI.editorMode);
      }
      if (!stationUI.editorMode) {
        infrastructureBuilder.hoveredCell = null;
        infrastructureBuilder.draggingBuildingId = null;
        if (overlay) overlay.classList.remove('editor-active');
        if (stationUI.open && stationUI.station) {
          camera.focusOnStation(stationUI.station);
        } else {
          camera.clearFocus();
        }
        return;
      }
      if (overlay) overlay.classList.add('editor-active');
      const station = stationUI.station;
      if (!station) return;
      const state = ensureInfrastructureState(station);
      const layout = state?.layout;
      camera.focusOnInfrastructure(station, layout);
    }

    function updateStationUIState(dt) {
      if (!stationUI.open && stationUI.awaitingCamera) {
        stationUI.awaitingCamera = false;
      }

      if (stationUI.open && stationUI.awaitingCamera) {
        const sameStation = camera.mode === 'focus' && camera.focusStation === stationUI.station;
        if (sameStation) {
          const dx = camera.x - camera.targetX;
          const dy = camera.y - camera.targetY;
          const closeEnough = Math.hypot(dx, dy) < 2.0 && Math.abs(camera.zoom - camera.targetZoom) < 0.02;
          const arrived = camera.focusArrived || closeEnough;
          if (!camera.transition && arrived) {
            stationUI.awaitingCamera = false;
            stationUI.visible = true;
            stationUI.appear = Math.max(0, stationUI.appear);
            stationUI.autoPosition = true;
            camera.focusArrived = false;
          }
        }
        if (camera.mode !== 'focus' || camera.focusStation !== stationUI.station) {
          stationUI.awaitingCamera = false;
        }
      }

      const shouldBeVisible = stationUI.open && stationUI.visible && !stationUI.awaitingCamera;
      const targetAlpha = shouldBeVisible ? 1 : 0;
      const fadeInSpeed = 4;
      const fadeOutSpeed = 5;
      if (targetAlpha > stationUI.appear) {
        stationUI.appear = Math.min(targetAlpha, stationUI.appear + dt * fadeInSpeed);
      } else if (targetAlpha < stationUI.appear) {
        stationUI.appear = Math.max(targetAlpha, stationUI.appear - dt * fadeOutSpeed);
      }

      if (!stationUI.open && stationUI.appear <= 0.0001) {
        stationUI.appear = 0;
        stationUI.visible = false;
        stationUI.station = null;
        stationUI.autoPosition = true;
      }

      const wantsEditor = stationUI.open && stationUI.visible && !stationUI.awaitingCamera && stationUI.tab === 'infrastructure';
      setStationEditorMode(wantsEditor);
    }

    const hoverInfoState = {
      el: document.getElementById('hover-info'),
      title: document.querySelector('#hover-info .hover-title'),
      subtitle: document.querySelector('#hover-info .hover-subtitle'),
      content: document.querySelector('#hover-info .hover-content'),
      type: null,
      target: null
    };

    function toTitleCaseFromKey(value) {
      return String(value || '')
        .split(/[-_\s]+/g)
        .filter(Boolean)
        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
        .join(' ');
    }

    function availableStationTabs(station) {
      if (Array.isArray(station?.tabs) && station.tabs.length) {
        return station.tabs.map(toTitleCaseFromKey);
      }
      return ['Upgrades', 'Trade', 'Cantina', 'Hangar', 'Mechanic', 'Infrastructure'];
    }

    function formatNpcName(npc) {
      if (!npc) return '';
      if (typeof npc.name === 'string' && npc.name.trim()) return npc.name;
      if (typeof npc.callsign === 'string' && npc.callsign.trim()) return npc.callsign;
      if (npc.type) return toTitleCaseFromKey(npc.type);
      if (npc.id != null) return `Jednostka #${npc.id}`;
      return 'Jednostka';
    }

    function formatShieldValue(entity) {
      const shield = entity?.shield;
      if (shield && typeof shield.val === 'number' && typeof shield.max === 'number') {
        return `${Math.max(0, Math.round(shield.val))}/${Math.max(0, Math.round(shield.max))}`;
      }
      return 'Brak';
    }

    function formatWeaponName(weapon) {
      if (!weapon) return 'Brak';
      if (typeof weapon === 'string') return toTitleCaseFromKey(weapon);
      if (weapon.name) return toTitleCaseFromKey(weapon.name);
      return 'Brak';
    }

    function hideHoverInfo() {
      const { el, content } = hoverInfoState;
      if (!el) return;
      if (content) content.innerHTML = '';
      if (!el.classList.contains('hidden')) el.classList.add('hidden');
      hoverInfoState.type = null;
      hoverInfoState.target = null;
    }

    function updateHoverInfo(target, type) {
      const { el, title, subtitle, content } = hoverInfoState;
      if (!el) return;
      if (!target || !type) {
        hideHoverInfo();
        return;
      }
      hoverInfoState.type = type;
      hoverInfoState.target = target;
      el.classList.remove('hidden');
      if (content) content.innerHTML = '';

      if (type === 'station') {
        if (title) title.textContent = target.name || (target.id ? `Stacja ${String(target.id).toUpperCase()}` : 'Stacja');
        if (subtitle) subtitle.textContent = 'STACJA ORBITALNA';
        if (content) {
          const section = document.createElement('div');
          section.className = 'hover-section';
          section.textContent = 'Zak≈Çadki';
          content.appendChild(section);

          const tags = document.createElement('div');
          tags.className = 'hover-tags';
          for (const tab of availableStationTabs(target)) {
            const span = document.createElement('span');
            span.className = 'hover-tag';
            span.textContent = tab;
            tags.appendChild(span);
          }
          content.appendChild(tags);
        }
      } else if (type === 'npc') {
        if (title) title.textContent = formatNpcName(target);
        if (subtitle) subtitle.textContent = target.friendly ? 'SOJUSZNIK' : 'CELE NPC';
        if (content) {
          const lines = [
            { label: 'HP', value: `${Math.max(0, Math.round(target.hp ?? 0))}/${Math.max(0, Math.round(target.maxHp ?? target.hp ?? 0))}` },
            { label: 'Tarcza', value: formatShieldValue(target) },
            { label: 'Bro≈Ñ', value: formatWeaponName(target.weapon) }
          ];
          for (const line of lines) {
            const row = document.createElement('div');
            row.className = 'hover-line';
            const strong = document.createElement('strong');
            strong.textContent = `${line.label}:`;
            const span = document.createElement('span');
            span.textContent = line.value;
            row.appendChild(strong);
            row.appendChild(span);
            content.appendChild(row);
          }
        }
      } else if (type === 'platform') {
        if (title) title.textContent = target.label || 'Platforma obronna';
        if (subtitle) subtitle.textContent = 'PIRACKA OBRONA';
        if (content) {
          const lines = [];
          if (target.shield) {
            lines.push({ label: 'Os≈Çony', value: `${Math.max(0, Math.round(target.shield.val))}/${target.shield.max}` });
          }
          lines.push({ label: 'Kad≈Çub', value: `${Math.max(0, Math.round(target.hp ?? 0))}/${Math.max(0, Math.round(target.maxHp ?? target.hp ?? 0))}` });
          lines.push({ label: 'Orbita', value: `${Math.round(target.orbitRadius)} u` });
          for (const line of lines) {
            const row = document.createElement('div');
            row.className = 'hover-line';
            const strong = document.createElement('strong');
            strong.textContent = `${line.label}:`;
            const span = document.createElement('span');
            span.textContent = line.value;
            row.appendChild(strong);
            row.appendChild(span);
            content.appendChild(row);
          }
        }
      }
    }

    window.addEventListener('keydown', (e) => {
      if (stationUI.open) {
        if (e.code === 'Escape') { closeStationUI(); e.stopImmediatePropagation(); return; }
        if (e.code === 'Digit1') stationUI.tab = 'upgrades';
        if (e.code === 'Digit2') stationUI.tab = 'trade';
        if (e.code === 'Digit3') stationUI.tab = 'cantina';
        if (e.code === 'Digit4') stationUI.tab = 'hangar';
        if (e.code === 'Digit5') stationUI.tab = 'mechanic';
        if (e.code === 'Digit6') stationUI.tab = 'infrastructure';
      }
    });

    window.addEventListener('keydown', (e) => {
      if (e.code === 'KeyO' && !stationUI.open) { OPTIONS_OPEN = !OPTIONS_OPEN; }
    });

    function renderStationUI() {
      const alpha = clamp(stationUI.appear, 0, 1);

      const shouldShow = stationUI.open && stationUI.visible && !stationUI.awaitingCamera && alpha > 0.001;
      const showInfrastructure = shouldShow && stationUI.tab === 'infrastructure';

      setInfrastructureUIVisible(showInfrastructure);

      const topDock = document.getElementById('hud-top-dock');
      if (topDock) {
        topDock.classList.toggle('expanded', shouldShow);
      }

      if (shouldShow) {
        renderStationOverlay(stationUI.tab, stationUI.station);
      }
    }

    function positionStationUIPanel() {
      const st = stationUI.station;
      if (!st) return;
      const screen = worldToScreen(st.x, st.y, camera);
      const margin = 48;
      const maxX = W - stationUI.w - margin;
      stationUI.x = clamp(screen.x + margin, margin, maxX);
      const centeredY = (H - stationUI.h) / 2;
      stationUI.y = clamp(centeredY, margin, H - stationUI.h - margin);
    }

    function setMechanicUIVisible(visible) {
      const overlay = document.getElementById('mechanic-overlay');
      if (!overlay) return;
      const panel = document.getElementById('tab-mechanic');
      const tabBtn = overlay.querySelector('li[data-tab="mechanic"]');
      const active = !!visible;
      overlay.classList.toggle('hidden', !active);
      if (panel) panel.classList.toggle('hidden', !active);
      if (tabBtn) tabBtn.classList.toggle('active', active);
    }

    const INFRASTRUCTURE_BUILDINGS = [
      { id: 'solar_array', name: 'Orbitalna Elektrownia S≈Çoneczna', buildTime: 75, icon: 'solar', footprint: { w: 4, h: 4 } },
      { id: 'dock_s', name: 'Dok Orbitalny (S)', buildTime: 55, icon: 'dock', footprint: { w: 1, h: 1 } },
      { id: 'dock_m', name: 'Dok Orbitalny (M)', buildTime: 75, icon: 'dock', footprint: { w: 2, h: 1 }, rotatable: true },
      { id: 'dock_l', name: 'Dok Orbitalny (L)', buildTime: 105, icon: 'dock', footprint: { w: 2, h: 2 } },
      { id: 'dock_capital', name: 'Dok Orbitalny (Capital)', buildTime: 140, icon: 'dock', footprint: { w: 3, h: 3 } },
      { id: 'shipyard_s', name: 'Fighter Factory', buildTime: 90, icon: 'shipyard', tier: 'S', footprint: { w: 3, h: 3 }, rotatable: true },
      { id: 'shipyard_m', name: 'Orbitalna Stocznia (M)', buildTime: 110, icon: 'shipyard', tier: 'M', footprint: { w: 2, h: 2 } },
      { id: 'shipyard_l', name: 'Orbitalna Stocznia (L)', buildTime: 140, icon: 'shipyard', tier: 'L', footprint: { w: 3, h: 2 }, rotatable: true },
      { id: 'shipyard_capital', name: 'Orbitalna Stocznia (Capital)', buildTime: 170, icon: 'shipyard', tier: 'C', footprint: { w: 3, h: 4 }, rotatable: true },
      { id: 'shipyard_supercapital', name: 'Orbitalna Stocznia (SuperCapital)', buildTime: 210, icon: 'shipyard', tier: 'SC', footprint: { w: 3, h: 4 }, rotatable: true },
      { id: 'storage_metal', name: 'Magazyn Metali', buildTime: 60, icon: 'storage', label: 'M', color: '#60a5fa', footprint: { w: 4, h: 4 } },
      { id: 'storage_fuel', name: 'Magazyn Paliwa', buildTime: 70, icon: 'storage', label: 'F', color: '#f97316', footprint: { w: 4, h: 4 } },
      { id: 'storage_gas', name: 'Magazyn Gaz√≥w', buildTime: 65, icon: 'storage', label: 'G', color: '#14b8a6', footprint: { w: 4, h: 4 } },
      { id: 'storage_plastics', name: 'Magazyn Tworzyw Sztucznych', buildTime: 85, icon: 'storage', label: 'P', color: '#a855f7', footprint: { w: 4, h: 4 } },
      { id: 'metal_harvester', name: 'Metal Harvester', buildTime: 95, icon: 'metal_harvester', footprint: { w: 4, h: 4 }, allowedPlanetTypes: ['rocky'] },
      { id: 'metal_refinery', name: 'Metal Refinery', buildTime: 125, icon: 'metal_refinery', footprint: { w: 4, h: 4 }, allowedPlanetTypes: ['rocky'] },
      { id: 'gas_harvester', name: 'Gas Harvester', buildTime: 110, icon: 'gas_harvester', footprint: { w: 4, h: 4 }, requiresSolarSystem: true, allowedPlanetTypes: ['gas'] },
      { id: 'gas_refinery', name: 'Gas Refinery', buildTime: 140, icon: 'gas_refinery', footprint: { w: 4, h: 4 }, requiresSolarSystem: true, allowedPlanetTypes: ['gas'] }
    ];
    const ECONOMY_RESOURCES = {
      gas: { label: 'Gaz' },
      fuel: { label: 'Paliwo' },
      rawMetal: { label: 'Surowy metal' },
      refinedMetal: { label: 'Rafinowany metal' }
    };
    const ECONOMY_RESOURCE_KEYS = Object.keys(ECONOMY_RESOURCES);
    const ECONOMY_BASE_CAPACITY = { gas: 60, fuel: 90, rawMetal: 140, refinedMetal: 100 };
    const ECONOMY_STORAGE_BONUS = {
      storage_gas: { gas: 260 },
      storage_fuel: { fuel: 240 },
      storage_metal: { rawMetal: 320, refinedMetal: 240 }
    };
    const ECONOMY_BUILDING_RULES = {
      gas_harvester: { produce: { gas: 22 } },
      gas_refinery: { consume: { gas: 16 }, produce: { fuel: 14 } },
      metal_harvester: { produce: { rawMetal: 24 } },
      metal_refinery: { consume: { rawMetal: 18 }, produce: { refinedMetal: 12 } }
    };
    const ECONOMY_TICK_SECONDS = 60;
    const INFRA_BUILDING_MAP = new Map(INFRASTRUCTURE_BUILDINGS.map(b => [b.id, b]));

    const INFRA_CELL_WORLD_SIZE = 220;
    const INFRA_CELL_WORLD_GAP = 60;
    const INFRA_CELL_WORLD_STEP = INFRA_CELL_WORLD_SIZE + INFRA_CELL_WORLD_GAP;
    const INFRA_STATION_CORE_SIZE = 4;
    const INFRA_MIN_GRID = 8;
    const INFRA_MAX_GRID = 26;
    let infrastructureLayoutCache = null;
    let infrastructureLayoutKey = '';

    function computeInfrastructureLayout(cols, rows) {
      const width = INFRA_CELL_WORLD_SIZE + (cols - 1) * INFRA_CELL_WORLD_STEP;
      const height = INFRA_CELL_WORLD_SIZE + (rows - 1) * INFRA_CELL_WORLD_STEP;
      const originOffset = { x: -width / 2, y: -height / 2 };
      const cells = [];
      const coreStartCol = Math.max(0, Math.floor((cols - INFRA_STATION_CORE_SIZE) / 2));
      const coreStartRow = Math.max(0, Math.floor((rows - INFRA_STATION_CORE_SIZE) / 2));
      const coreEndCol = Math.min(cols, coreStartCol + INFRA_STATION_CORE_SIZE) - 1;
      const coreEndRow = Math.min(rows, coreStartRow + INFRA_STATION_CORE_SIZE) - 1;
      const coreIndices = [];
      const centerIndex = (coreStartRow + Math.floor(INFRA_STATION_CORE_SIZE / 2)) * cols + coreStartCol + Math.floor(INFRA_STATION_CORE_SIZE / 2);
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const idx = row * cols + col;
          const local = {
            x: originOffset.x + col * INFRA_CELL_WORLD_STEP + INFRA_CELL_WORLD_SIZE / 2,
            y: originOffset.y + row * INFRA_CELL_WORLD_STEP + INFRA_CELL_WORLD_SIZE / 2
          };
          const blocked = col >= coreStartCol && col <= coreEndCol && row >= coreStartRow && row <= coreEndRow;
          if (blocked) coreIndices.push(idx);
          cells.push({ index: idx, col, row, local, blocked });
        }
      }
      return {
        cellSize: INFRA_CELL_WORLD_SIZE,
        cellGap: INFRA_CELL_WORLD_GAP,
        step: INFRA_CELL_WORLD_STEP,
        cols,
        rows,
        originOffset,
        width,
        height,
        cells,
        centerIndex,
        core: { startCol: coreStartCol, startRow: coreStartRow, indices: coreIndices }
      };
    }

    function getInfrastructureLayout(cols, rows) {
      const key = `${cols}x${rows}`;
      if (!infrastructureLayoutCache || infrastructureLayoutKey !== key) {
        infrastructureLayoutCache = computeInfrastructureLayout(cols, rows);
        infrastructureLayoutKey = key;
      }
      return infrastructureLayoutCache;
    }

    function computeInfrastructureGridSize(station) {
      const planet = station?.planet;
      const orbitRadii = planet ? planetOrbitRadii(planet) : null;
      const innerOrbitRadius = orbitRadii?.inner || Math.max(1200, (station?.r || 0) * 10);
      const squareSide = innerOrbitRadius * Math.SQRT2;
      const approximateCols = Math.floor(squareSide / INFRA_CELL_WORLD_STEP);
      let cols = Math.max(INFRA_MIN_GRID, Math.min(INFRA_MAX_GRID, approximateCols));
      if (cols % 2 !== 0) cols += 1; // symetria wzglƒôdem ≈õrodka stacji
      const rows = cols;
      return { cols, rows };
    }

    function rebuildInfrastructureGrid(layout) {
      const grid = infrastructureBuilder.grid;
      if (!grid) return;
      const cols = infrastructureBuilder.gridCols;
      grid.style.setProperty('--infra-cols', cols);
      grid.innerHTML = '';
      infrastructureBuilder.gridCells = [];
      const total = cols * infrastructureBuilder.gridRows;
      for (let i = 0; i < total; i++) {
        const meta = layout.cells?.[i];
        const cell = document.createElement('div');
        cell.className = 'infra-cell empty';
        cell.dataset.index = String(i);
        if (meta?.blocked) {
          cell.classList.add('core');
          cell.classList.remove('empty');
          cell.dataset.blocked = '1';
        } else {
          cell.dataset.blocked = '0';
        }
        const canvas = document.createElement('canvas');
        canvas.width = 96;
        canvas.height = 96;
        cell.appendChild(canvas);
        const progressBar = document.createElement('div');
        progressBar.className = 'infra-progress-bar';
        const fill = document.createElement('div');
        fill.className = 'infra-progress-fill';
        progressBar.appendChild(fill);
        cell.appendChild(progressBar);
        const status = document.createElement('div');
        status.className = 'infra-cell-status';
        status.textContent = meta?.blocked ? 'Rdze≈Ñ stacji' : 'Puste';
        cell.appendChild(status);
        cell.addEventListener('dragenter', handleInfrastructureCellDragEnter);
        cell.addEventListener('dragover', handleInfrastructureCellDragOver);
        cell.addEventListener('dragleave', handleInfrastructureCellDragLeave);
        cell.addEventListener('drop', handleInfrastructureCellDrop);
        cell.addEventListener('click', () => {
          const state = getActiveInfrastructureState();
          const rootIdx = state ? getRootCellIndex(state, i) : null;
          infrastructureBuilder.selectedCell = rootIdx != null ? rootIdx : i;
          renderInfrastructureOverlay();
        });
        infrastructureBuilder.gridCells.push(cell);
        grid.appendChild(cell);
      }
    }

    function updateInfrastructureGridForStation(station) {
      const size = computeInfrastructureGridSize(station);
      const changed = size && (size.cols !== infrastructureBuilder.gridCols || size.rows !== infrastructureBuilder.gridRows);
      if (changed) {
        infrastructureBuilder.gridCols = size.cols;
        infrastructureBuilder.gridRows = size.rows;
        infrastructureLayoutCache = null;
        infrastructureLayoutKey = '';
        infrastructureBuilder.selectedCell = null;
        infrastructureBuilder.hoveredCell = null;
      }
      const layout = getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      if (changed || !infrastructureBuilder.layout) {
        infrastructureBuilder.layout = layout;
        rebuildInfrastructureGrid(layout);
        infrastructureBuilder.needsRender = true;
      }
      return layout;
    }

    const infrastructureBuilder = {
      overlay: document.getElementById('infrastructure-overlay'),
      list: document.getElementById('infra-building-list'),
      grid: document.getElementById('infra-grid'),
      info: document.getElementById('infra-info'),
      gridCols: INFRA_MIN_GRID,
      gridRows: INFRA_MIN_GRID,
      gridCells: [],
      stationStates: new Map(),
      selectedCell: null,
      activeStationKey: null,
      activeStationRef: null,
      hideTimer: null,
      isVisible: false,
      needsRender: false,
      hoveredCell: null,
      draggingBuildingId: null,
      draggingOverlay: false,
      overlayOffset: { x: 0, y: 0 },
      overlayPosition: null,
      editorAlpha: 0,
      ghostAlpha: 0,
      ghostRotation: 0,
      layout: null
    };

    function clampInfrastructureOverlayPosition(pos, overlay) {
      const maxX = Math.max(8, window.innerWidth - overlay.offsetWidth - 8);
      const maxY = Math.max(12, window.innerHeight - overlay.offsetHeight - 12);
      return {
        x: Math.min(Math.max(8, pos.x), maxX),
        y: Math.min(Math.max(12, pos.y), maxY)
      };
    }

    function applyInfrastructureOverlayPosition() {
      const overlay = infrastructureBuilder.overlay;
      if (!overlay) return;
      if (!infrastructureBuilder.overlayPosition) {
        const rect = overlay.getBoundingClientRect();
        infrastructureBuilder.overlayPosition = { x: rect.left, y: rect.top };
      }
      const pos = clampInfrastructureOverlayPosition(infrastructureBuilder.overlayPosition, overlay);
      infrastructureBuilder.overlayPosition = pos;
      overlay.style.left = `${pos.x}px`;
      overlay.style.top = `${pos.y}px`;
      overlay.style.right = 'auto';
      overlay.style.bottom = 'auto';
    }

    function setupInfrastructureOverlayDrag() {
      const overlay = infrastructureBuilder.overlay;
      if (!overlay) return;
      const header = overlay.querySelector('h3');
      if (!header) return;

      const endDrag = () => {
        if (!infrastructureBuilder.draggingOverlay) return;
        infrastructureBuilder.draggingOverlay = false;
        overlay.classList.remove('dragging');
        document.removeEventListener('pointermove', onMove);
        document.removeEventListener('pointerup', endDrag);
      };

      const onMove = (ev) => {
        if (!infrastructureBuilder.draggingOverlay) return;
        const nextPos = {
          x: ev.clientX - infrastructureBuilder.overlayOffset.x,
          y: ev.clientY - infrastructureBuilder.overlayOffset.y
        };
        infrastructureBuilder.overlayPosition = clampInfrastructureOverlayPosition(nextPos, overlay);
        overlay.style.left = `${infrastructureBuilder.overlayPosition.x}px`;
        overlay.style.top = `${infrastructureBuilder.overlayPosition.y}px`;
      };

      header.addEventListener('pointerdown', (ev) => {
        if (ev.button !== 0 || !infrastructureBuilder.isVisible) return;
        const rect = overlay.getBoundingClientRect();
        infrastructureBuilder.overlayOffset = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
        infrastructureBuilder.overlayPosition = { x: rect.left, y: rect.top };
        infrastructureBuilder.draggingOverlay = true;
        overlay.classList.add('dragging');
        applyInfrastructureOverlayPosition();
        document.addEventListener('pointermove', onMove);
        document.addEventListener('pointerup', endDrag);
      });

      window.addEventListener('resize', () => {
        if (infrastructureBuilder.overlayPosition && infrastructureBuilder.isVisible) {
          applyInfrastructureOverlayPosition();
        }
      });
    }

    setupInfrastructureOverlayDrag();

    function handleInfrastructureRotationWheel(ev) {
      if (!infrastructureBuilder.draggingBuildingId) return;
      if (!stationUI.open || stationUI.tab !== 'infrastructure') return;
      const building = INFRA_BUILDING_MAP.get(infrastructureBuilder.draggingBuildingId);
      const fp = building?.footprint;
      const canRotate = building && (building.rotatable || (fp && fp.w !== fp.h));
      if (!canRotate) return;
      ev.preventDefault();
      const delta = ev.deltaY > 0 ? 1 : -1;
      infrastructureBuilder.ghostRotation = (infrastructureBuilder.ghostRotation + delta + 2) % 2;
      infrastructureBuilder.needsRender = true;
    }
    window.addEventListener('wheel', handleInfrastructureRotationWheel, { passive: false });

    function getInfrastructureStationKey(station) {
      if (!station) return null;
      if (station.id != null) return `station-${station.id}`;
      if (station.name) return `station-${station.name}`;
      const x = Math.round(station.x ?? 0);
      const y = Math.round(station.y ?? 0);
      return `station-${x}-${y}`;
    }

    function findStationByKey(key) {
      if (!key) return null;
      for (const st of stations) {
        if (getInfrastructureStationKey(st) === key) return st;
      }
      return null;
    }

    function ensureInfrastructureState(station) {
      const key = getInfrastructureStationKey(station);
      if (!key) return null;
      const layout = updateInfrastructureGridForStation(station);
      const cols = infrastructureBuilder.gridCols;
      const rows = infrastructureBuilder.gridRows;
      const totalCells = cols * rows;
      infrastructureBuilder.layout = layout;
      let state = infrastructureBuilder.stationStates.get(key);
      if (!state) {
        state = {
          stationKey: key,
          stationRef: station || null,
          stationName: station?.name || null,
          cells: Array.from({ length: totalCells }, () => null),
          cellMeta: layout.cells,
          layout,
          centerIndex: layout.centerIndex
        };
        infrastructureBuilder.stationStates.set(key, state);
      } else {
        if (state.cells.length !== totalCells) {
          if (state.cells.length > totalCells) {
            state.cells.length = totalCells;
          } else {
            state.cells = state.cells.concat(Array(totalCells - state.cells.length).fill(null));
          }
        }
        state.cellMeta = layout.cells;
        state.layout = layout;
        state.centerIndex = layout.centerIndex;
        if (station) state.stationRef = station;
        if (station?.name) state.stationName = station.name;
      }
      if (!state.stationRef) {
        state.stationRef = station || findStationByKey(key) || null;
      }
      return state;
    }

    function createEmptyEconomyResources() {
      const res = {};
      for (const key of ECONOMY_RESOURCE_KEYS) {
        res[key] = 0;
      }
      return res;
    }

    function getEconomyStationKey(ctx) {
      if (!ctx) return null;
      if (ctx.stationKey) return ctx.stationKey;
      if (ctx.stationRef) return getInfrastructureStationKey(ctx.stationRef);
      return getInfrastructureStationKey(ctx);
    }

    function ensureStationEconomy(ctx) {
      const key = getEconomyStationKey(ctx);
      if (!key) return null;
      if (!Game.stationEconomy) Game.stationEconomy = new Map();
      let econ = Game.stationEconomy.get(key);
      if (!econ) {
        econ = {
          stationKey: key,
          resources: createEmptyEconomyResources(),
          capacity: { ...ECONOMY_BASE_CAPACITY },
          timer: 0
        };
        Game.stationEconomy.set(key, econ);
      }
      econ.stationRef = ctx?.stationRef || ctx || findStationByKey(key);
      return econ;
    }

    function computeEconomyCapacities(buildingCounts) {
      const capacity = { ...ECONOMY_BASE_CAPACITY };
      for (const [buildingId, bonus] of Object.entries(ECONOMY_STORAGE_BONUS)) {
        const count = buildingCounts?.[buildingId] || 0;
        if (!count) continue;
        for (const [res, value] of Object.entries(bonus)) {
          capacity[res] = (capacity[res] || 0) + value * count;
        }
      }
      return capacity;
    }

    function clampEconomyResources(econ) {
      if (!econ) return;
      for (const key of ECONOMY_RESOURCE_KEYS) {
        const cap = econ.capacity?.[key];
        const value = econ.resources?.[key] ?? 0;
        econ.resources[key] = Number.isFinite(cap) ? clamp(value, 0, cap) : Math.max(0, value);
      }
    }

    function applyEconomyProduction(econ, buildingCounts, ticks) {
      if (!econ || ticks <= 0) return;
      for (const [buildingId, rule] of Object.entries(ECONOMY_BUILDING_RULES)) {
        const count = buildingCounts?.[buildingId] || 0;
        if (!count) continue;
        const cycles = count * ticks;
        let ratio = 1;
        if (rule.consume) {
          for (const [res, amount] of Object.entries(rule.consume)) {
            const required = amount * cycles;
            if (required <= 0) continue;
            const available = econ.resources?.[res] ?? 0;
            ratio = Math.min(ratio, available / required);
          }
        }
        if (ratio <= 0) continue;
        if (rule.consume) {
          for (const [res, amount] of Object.entries(rule.consume)) {
            const delta = amount * cycles * ratio;
            econ.resources[res] = Math.max(0, (econ.resources?.[res] ?? 0) - delta);
          }
        }
        if (rule.produce) {
          for (const [res, amount] of Object.entries(rule.produce)) {
            const current = econ.resources?.[res] ?? 0;
            const cap = econ.capacity?.[res];
            const next = current + amount * cycles * ratio;
            econ.resources[res] = Number.isFinite(cap) ? Math.min(cap, next) : next;
          }
        }
      }
      clampEconomyResources(econ);
    }

    function updateStationEconomyFromBuildings(state, buildingCounts, dt) {
      const econ = ensureStationEconomy(state);
      if (!econ) return;
      econ.capacity = computeEconomyCapacities(buildingCounts || {});
      clampEconomyResources(econ);
      econ.timer = (econ.timer || 0) + dt;
      if (econ.timer < ECONOMY_TICK_SECONDS) return;
      const ticks = Math.floor(econ.timer / ECONOMY_TICK_SECONDS);
      econ.timer -= ticks * ECONOMY_TICK_SECONDS;
      applyEconomyProduction(econ, buildingCounts, ticks);
    }

    function setInfrastructureActiveStation(station) {
      updateInfrastructureGridForStation(station);
      const key = getInfrastructureStationKey(station);
      if (infrastructureBuilder.activeStationKey === key) {
        infrastructureBuilder.activeStationRef = station || null;
        if (key) {
          const state = ensureInfrastructureState(station || findStationByKey(key));
          if (state && station) state.stationRef = station;
        }
        return;
      }
      infrastructureBuilder.activeStationKey = key;
      infrastructureBuilder.activeStationRef = station || null;
      if (key) {
        const state = ensureInfrastructureState(station || findStationByKey(key));
        if (state && station) state.stationRef = station;
      }
      infrastructureBuilder.selectedCell = null;
      infrastructureBuilder.needsRender = true;
      if (infrastructureBuilder.isVisible) {
        renderInfrastructureOverlay();
      }
    }

    function getActiveInfrastructureState() {
      const station = infrastructureBuilder.activeStationRef || stationUI.station;
      return station ? ensureInfrastructureState(station) : null;
    }

    function getRootCellIndex(state, idx) {
      if (!state || !state.cells || !Number.isInteger(idx)) return null;
      const cell = state.cells[idx];
      if (!cell) return null;
      if (Number.isInteger(cell.rootIndex)) return cell.rootIndex;
      return idx;
    }

    function getRootCell(state, idx) {
      const rootIdx = getRootCellIndex(state, idx);
      if (rootIdx == null) return null;
      return state.cells[rootIdx] || null;
    }

    function buildingFootprint(building, rotation = 0) {
      const base = building?.footprint || { w: 1, h: 1 };
      const rotated = (rotation % 2 !== 0) ? { w: base.h, h: base.w } : base;
      return { ...rotated };
    }

    function computeFootprintCells(layout, anchorIdx, building, rotation) {
      if (!layout || !layout.cells || !building || !Number.isInteger(anchorIdx)) return null;
      const anchorMeta = layout.cells[anchorIdx];
      if (!anchorMeta) return null;
      const fp = buildingFootprint(building, rotation);
      const width = fp.w || 1;
      const height = fp.h || 1;
      if (anchorMeta.col + width > layout.cols || anchorMeta.row + height > layout.rows) return null;
      const cells = [];
      for (let dy = 0; dy < height; dy++) {
        for (let dx = 0; dx < width; dx++) {
          const col = anchorMeta.col + dx;
          const row = anchorMeta.row + dy;
          const idx = row * layout.cols + col;
          const meta = layout.cells[idx];
          if (!meta) return null;
          cells.push(meta);
        }
      }
      const center = cells.reduce((acc, meta) => {
        acc.x += meta.local.x; acc.y += meta.local.y; return acc;
      }, { x: 0, y: 0 });
      center.x /= cells.length;
      center.y /= cells.length;
      return { cells, width, height, center };
    }

    function isBuildingAllowedOnStation(building, station) {
      if (!building) return { allowed: false, reason: 'Brak definicji budynku.' };
      if (building.requiresSolarSystem && !USE_SOLAR) {
        return { allowed: false, reason: 'Dostƒôpne tylko w Uk≈Çadzie S≈Çonecznym.' };
      }
      if (Array.isArray(building.allowedPlanetTypes) && building.allowedPlanetTypes.length) {
        const allowed = building.allowedPlanetTypes.map(t => String(t).toLowerCase());
        const planetType = typeof station?.planet?.type === 'string' ? station.planet.type.toLowerCase() : null;
        if (!planetType || !allowed.includes(planetType)) {
          return { allowed: false, reason: 'Wymaga planety gazowej.' };
        }
      }
      return { allowed: true, reason: null };
    }

    function validateInfrastructurePlacement(state, anchorIdx, building, rotation) {
      const layout = state?.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      const station = state?.stationRef || stationUI.station || null;
      const availability = isBuildingAllowedOnStation(building, station);
      if (!availability.allowed) return { valid: false, footprint: null, reason: availability.reason };
      const footprint = computeFootprintCells(layout, anchorIdx, building, rotation);
      if (!layout || !footprint) return { valid: false, footprint: null };
      const blocked = footprint.cells.some(meta => meta.blocked);
      const occupied = footprint.cells.some(meta => state.cells?.[meta.index]);
      return { valid: !blocked && !occupied, blocked, occupied, layout, footprint };
    }

    function infrastructureHasBuildings(state) {
      if (!state || !Array.isArray(state.cells)) return false;
      return state.cells.some(Boolean);
    }

    function finalizeInfrastructurePlacement(state, anchorIdx, building, placement, rotation) {
      if (!state || !placement || !building || !placement.footprint) return null;
      const layout = placement.layout || state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      const normalizedRotation = Math.abs(rotation || 0) % 2;
      const duration = Math.max(1, building.buildTime);
      const base = {
        buildingId: building.id,
        status: 'completed',
        elapsed: duration,
        duration,
        progress: 1,
        startedAt: (performance.now() / 1000) - duration,
        cellIndex: anchorIdx,
        rootIndex: anchorIdx,
        rotation: normalizedRotation,
        footprint: { w: placement.footprint.width, h: placement.footprint.height },
        cells: placement.footprint.cells.map(meta => meta.index),
        gridX: layout.cells?.[anchorIdx]?.col ?? 0,
        gridY: layout.cells?.[anchorIdx]?.row ?? 0,
        localPos: { x: placement.footprint.center.x, y: placement.footprint.center.y },
        emitted: false
      };
      for (const meta of placement.footprint.cells) {
        state.cells[meta.index] = base;
        if (state.cellMeta) state.cellMeta[meta.index] = layout.cells?.[meta.index] || meta;
      }
      return base;
    }

    function autoplaceInfrastructureBuilding(state, buildingId, desiredCol, desiredRow, rotation = 0) {
      const building = INFRA_BUILDING_MAP.get(buildingId);
      if (!state || !building) return false;
      const availability = isBuildingAllowedOnStation(building, state.stationRef || null);
      if (!availability.allowed) return false;
      const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      const fp = buildingFootprint(building, rotation);
      if (!fp || !layout) return false;
      const targetCol = clamp(Math.round(desiredCol), 0, Math.max(0, layout.cols - fp.w));
      const targetRow = clamp(Math.round(desiredRow), 0, Math.max(0, layout.rows - fp.h));
      const targetCenterCol = targetCol + (fp.w - 1) / 2;
      const targetCenterRow = targetRow + (fp.h - 1) / 2;
      const candidates = layout.cells.filter(meta => !meta.blocked);
      candidates.sort((a, b) => {
        const ac = { col: a.col + (fp.w - 1) / 2, row: a.row + (fp.h - 1) / 2 };
        const bc = { col: b.col + (fp.w - 1) / 2, row: b.row + (fp.h - 1) / 2 };
        const da = Math.hypot(ac.col - targetCenterCol, ac.row - targetCenterRow);
        const db = Math.hypot(bc.col - targetCenterCol, bc.row - targetCenterRow);
        return da - db;
      });
      for (const meta of candidates) {
        const placement = validateInfrastructurePlacement(state, meta.index, building, rotation);
        if (placement && placement.valid) {
          finalizeInfrastructurePlacement(state, meta.index, building, placement, rotation);
          return true;
        }
      }
      return false;
    }

    function autoplaceBuildingByOffset(state, buildingId, offsetCol, offsetRow, rotation = 0) {
      if (!state) return false;
      const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      if (!layout) return false;
      const building = INFRA_BUILDING_MAP.get(buildingId);
      if (!building) return false;
      const fp = buildingFootprint(building, rotation);
      const centerCol = (layout.cols - 1) / 2 + offsetCol;
      const centerRow = (layout.rows - 1) / 2 + offsetRow;
      const anchorCol = centerCol - (fp.w - 1) / 2;
      const anchorRow = centerRow - (fp.h - 1) / 2;
      return autoplaceInfrastructureBuilding(state, buildingId, anchorCol, anchorRow, rotation);
    }

    function drawMetalHarvesterIcon(ctx) {
      ctx.save();
      ctx.fillStyle = 'rgba(59,130,246,0.10)';
      ctx.strokeStyle = '#60a5fa';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.rect(-34, -26, 68, 52);
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = '#93c5fd';
      ctx.lineWidth = 2.5;
      const gearTeeth = 8;
      for (let i = 0; i < gearTeeth; i++) {
        const angle = i * (Math.PI * 2 / gearTeeth);
        const x = Math.cos(angle) * 26;
        const y = Math.sin(angle) * 26;
        ctx.beginPath();
        ctx.moveTo(x * 0.6, y * 0.6);
        ctx.lineTo(x, y);
        ctx.stroke();
      }

      ctx.fillStyle = '#0b1224';
      ctx.strokeStyle = '#38bdf8';
      ctx.beginPath();
      ctx.arc(0, 0, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function drawMetalRefineryIcon(ctx) {
      ctx.save();
      ctx.fillStyle = 'rgba(12,74,110,0.12)';
      ctx.strokeStyle = '#38bdf8';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.rect(-30, -30, 60, 60);
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = '#67e8f9';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-24, 12);
      ctx.lineTo(24, 12);
      ctx.moveTo(-18, 4);
      ctx.lineTo(18, 4);
      ctx.moveTo(-12, -4);
      ctx.lineTo(12, -4);
      ctx.moveTo(-6, -12);
      ctx.lineTo(6, -12);
      ctx.stroke();

      ctx.fillStyle = '#0f172a';
      ctx.strokeStyle = '#e0f2fe';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(-18, 18);
      ctx.lineTo(0, -14);
      ctx.lineTo(18, 18);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function drawGasHarvesterIcon(ctx) {
      ctx.save();
      ctx.fillStyle = 'rgba(20,184,166,0.12)';
      ctx.strokeStyle = '#14b8a6';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, 36, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = '#5eead4';
      ctx.lineWidth = 2.5;
      for (let i = 0; i < 3; i++) {
        const angle = (-Math.PI / 2) + i * (Math.PI * 2 / 3);
        const x = Math.cos(angle) * 18;
        const y = Math.sin(angle) * 18;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(x, y);
        ctx.stroke();
      }

      ctx.fillStyle = '#0f172a';
      ctx.strokeStyle = '#22c55e';
      ctx.beginPath();
      ctx.arc(0, 0, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
    }

    function drawGasRefineryIcon(ctx) {
      ctx.save();
      ctx.fillStyle = 'rgba(30,64,175,0.12)';
      ctx.strokeStyle = '#38bdf8';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.rect(-32, -28, 64, 56);
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = '#0f172a';
      ctx.strokeStyle = '#fbbf24';
      ctx.beginPath();
      ctx.moveTo(-20, 18); ctx.lineTo(0, -18); ctx.lineTo(20, 18); ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.strokeStyle = '#22d3ee';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-18, 8);
      ctx.lineTo(18, 8);
      ctx.moveTo(-12, 0);
      ctx.lineTo(12, 0);
      ctx.moveTo(-6, -8);
      ctx.lineTo(6, -8);
      ctx.stroke();
      ctx.restore();
    }

    function drawDockIcon(ctx, size = 72) {
      const sprite = [
        '..cc..cc..',
        '.cddccddc.',
        'cddddddddc',
        '.cddddddc.',
        '..cddddc..',
        '..cddddc..',
        '.cddccddc.',
        'cddddddddc',
        '.cddddddc.',
        '..cddcc...',
        '..cc.....'
      ];
      const palette = {
        c: '#a5b4fc',
        d: '#38bdf8'
      };
      const cols = sprite[0].length;
      const rows = sprite.length;
      const cell = size / cols;
      ctx.save();
      ctx.translate(-(cols * cell) / 2, -(rows * cell) / 2);
      for (let y = 0; y < rows; y++) {
        const row = sprite[y];
        for (let x = 0; x < cols; x++) {
          const ch = row[x];
          if (palette[ch]) {
            ctx.fillStyle = palette[ch];
            ctx.fillRect(x * cell, y * cell, cell - 0.5, cell - 0.5);
          }
        }
      }
      ctx.restore();
    }

    function drawBuildingPreview(canvas, building) {
      if (!canvas || !building) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      const w = canvas.width;
      const h = canvas.height;
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, w, h);
      ctx.fillStyle = 'rgba(6,10,24,0.95)';
      ctx.fillRect(0, 0, w, h);
      ctx.translate(w / 2, h / 2);
      ctx.shadowColor = 'rgba(32,64,128,0.45)';
      ctx.shadowBlur = 12;
      if (window.drawInfrastructureIcon) {
        const size = Math.min(w, h) * 0.6;
        window.drawInfrastructureIcon(ctx, building, { x: 0, y: 0 }, size, 1, null);
      }
      ctx.restore();
    }

    function infrastructureDragBuildingId(ev) {
      let id = null;
      if (ev && ev.dataTransfer) {
        id = ev.dataTransfer.getData('text/infrastructure-building') || ev.dataTransfer.getData('text/plain');
      }
      if (!id) {
        id = infrastructureBuilder.draggingBuildingId;
      }
      if (!id) return null;
      return INFRA_BUILDING_MAP.has(id) ? id : null;
    }

    function handleInfrastructureCellDragEnter(ev) {
      const id = infrastructureDragBuildingId(ev);
      const cellEl = ev.currentTarget;
      const idx = Number.parseInt(cellEl.dataset.index, 10);
      const state = getActiveInfrastructureState();
      const building = INFRA_BUILDING_MAP.get(id);
      const placement = building ? validateInfrastructurePlacement(state, idx, building, infrastructureBuilder.ghostRotation) : null;
      if (!id || !state || !placement || !placement.footprint) return;
      ev.preventDefault();
      infrastructureBuilder.hoveredCell = idx;
      cellEl.classList.add('drag-over');
    }

    function handleInfrastructureCellDragOver(ev) {
      const id = infrastructureDragBuildingId(ev);
      const cellEl = ev.currentTarget;
      const idx = Number.parseInt(cellEl.dataset.index, 10);
      const state = getActiveInfrastructureState();
      const building = INFRA_BUILDING_MAP.get(id);
      const placement = building ? validateInfrastructurePlacement(state, idx, building, infrastructureBuilder.ghostRotation) : null;
      if (!id || !state || !placement || !placement.footprint) return;
      ev.preventDefault();
      if (ev.dataTransfer) {
        ev.dataTransfer.dropEffect = placement.valid ? 'copy' : 'none';
      }
      infrastructureBuilder.hoveredCell = idx;
    }

    function handleInfrastructureCellDragLeave(ev) {
      const cellEl = ev.currentTarget;
      cellEl.classList.remove('drag-over');
      const related = ev.relatedTarget;
      if (!cellEl.contains(related)) { // left the cell entirely
        const idx = Number.parseInt(cellEl.dataset.index, 10);
        if (Number.isInteger(idx) && infrastructureBuilder.hoveredCell === idx) {
          infrastructureBuilder.hoveredCell = null;
        }
      }
    }

    function handleInfrastructureCellDrop(ev) {
      ev.preventDefault();
      const cellEl = ev.currentTarget;
      cellEl.classList.remove('drag-over');
      const id = infrastructureDragBuildingId(ev);
      if (!id) return;
      const idx = Number.parseInt(cellEl.dataset.index, 10);
      if (!Number.isInteger(idx)) return;
      const state = getActiveInfrastructureState();
      if (!state) return;
      const building = INFRA_BUILDING_MAP.get(id);
      const placement = building ? validateInfrastructurePlacement(state, idx, building, infrastructureBuilder.ghostRotation) : null;
      if (!placement || !placement.valid) return;
      startInfrastructureBuildAtCell(state, idx, id, infrastructureBuilder.ghostRotation, placement.footprint);
      infrastructureBuilder.hoveredCell = idx;
      renderInfrastructureOverlay();
    }

    function infrastructureCellFromWorld(worldPos, station, layout) {
      if (!worldPos || !station || !layout) return null;
      const localX = worldPos.x - station.x;
      const localY = worldPos.y - station.y;
      const col = Math.floor((localX - layout.originOffset.x) / layout.step);
      const row = Math.floor((localY - layout.originOffset.y) / layout.step);
      if (col < 0 || row < 0 || col >= layout.cols || row >= layout.rows) return null;
      return row * layout.cols + col;
    }

    function getInfrastructureDragContext(ev) {
      if (!stationUI.editorMode || stationUI.tab !== 'infrastructure') return null;
      const station = stationUI.station || infrastructureBuilder.activeStationRef;
      if (!station) return null;
      const state = ensureInfrastructureState(station);
      const layout = state?.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      const world = screenToWorld(ev.clientX ?? mouse.x, ev.clientY ?? mouse.y);
      const idx = infrastructureCellFromWorld(world, station, layout);
      if (idx == null) return null;
      return { station, state, layout, idx };
    }

    function handleInfrastructureCanvasDragOver(ev) {
      if (!stationUI.editorMode || stationUI.tab !== 'infrastructure') return;
      const id = infrastructureDragBuildingId(ev);
      const ctx = getInfrastructureDragContext(ev);
      if (!ctx) {
        infrastructureBuilder.hoveredCell = null;
        return;
      }
      if (!id || !ctx.state) return;
      const building = INFRA_BUILDING_MAP.get(id);
      const placement = building ? validateInfrastructurePlacement(ctx.state, ctx.idx, building, infrastructureBuilder.ghostRotation) : null;
      if (placement && placement.footprint) {
        ev.preventDefault();
        if (ev.dataTransfer) {
          ev.dataTransfer.dropEffect = placement.valid ? 'copy' : 'none';
        }
        infrastructureBuilder.hoveredCell = ctx.idx;
        infrastructureBuilder.needsRender = true;
      }
    }

    function handleInfrastructureCanvasDrop(ev) {
      if (!stationUI.editorMode || stationUI.tab !== 'infrastructure') return;
      const id = infrastructureDragBuildingId(ev);
      if (!id) return;
      const ctx = getInfrastructureDragContext(ev);
      if (!ctx || !ctx.state) return;
      const building = INFRA_BUILDING_MAP.get(id);
      const placement = building ? validateInfrastructurePlacement(ctx.state, ctx.idx, building, infrastructureBuilder.ghostRotation) : null;
      if (!placement || !placement.valid) return;
      ev.preventDefault();
      startInfrastructureBuildAtCell(ctx.state, ctx.idx, id, infrastructureBuilder.ghostRotation, placement.footprint);
      infrastructureBuilder.hoveredCell = ctx.idx;
      renderInfrastructureOverlay();
    }

    function handleInfrastructureCanvasDragLeave() {
      infrastructureBuilder.hoveredCell = null;
    }

    function startInfrastructureBuildAtCell(state, idx, buildingId, rotation = 0, footprintOverride = null) {
      const building = INFRA_BUILDING_MAP.get(buildingId);
      if (!state || !building) return false;
      const station = state.stationRef || stationUI.station || null;
      const availability = isBuildingAllowedOnStation(building, station);
      if (!availability.allowed) return false;
      const totalCells = infrastructureBuilder.gridCols * infrastructureBuilder.gridRows;
      if (idx < 0 || idx >= totalCells) return false;
      const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      const placement = footprintOverride ? { footprint: footprintOverride, layout } : validateInfrastructurePlacement(state, idx, building, rotation);
      if (!placement || !placement.footprint || placement.blocked || placement.occupied) return false;
      const footprint = placement.footprint;
      const normalizedRotation = Math.abs(rotation) % 2;
      const base = {
        buildingId,
        status: 'building',
        elapsed: 0,
        duration: Math.max(1, building.buildTime),
        progress: 0,
        startedAt: performance.now() / 1000,
        cellIndex: idx,
        rootIndex: idx,
        rotation: normalizedRotation,
        footprint: { w: footprint.width, h: footprint.height },
        cells: footprint.cells.map(meta => meta.index),
        gridX: layout.cells[idx]?.col ?? 0,
        gridY: layout.cells[idx]?.row ?? 0,
        localPos: { x: footprint.center.x, y: footprint.center.y },
        emitted: false
      };
      for (const meta of footprint.cells) {
        state.cells[meta.index] = base;
      }
      infrastructureBuilder.selectedCell = idx;
      infrastructureBuilder.needsRender = true;
      return true;
    }

    function infrastructureLocalToWorld(station, local) {
      if (!station || !local) return { x: station?.x ?? 0, y: station?.y ?? 0 };
      return { x: station.x + local.x, y: station.y + local.y };
    }

    function emitInfrastructureCompletion(state, idx, cell) {
      if (!state || !cell || cell.emitted) return;
      const station = state.stationRef || findStationByKey(state.stationKey);
      if (!station) return;
      const rootIdx = getRootCellIndex(state, idx);
      const meta = state.cellMeta?.[rootIdx ?? idx];
      const local = cell.localPos || meta?.local;
      if (!local) return;
      cell.localPos = { x: local.x, y: local.y };
      const worldPos = infrastructureLocalToWorld(station, cell.localPos);
      if (!Game.infrastructure) Game.infrastructure = new Map();
      let list = Game.infrastructure.get(state.stationKey);
      if (!list) {
        list = [];
        Game.infrastructure.set(state.stationKey, list);
      }
      let existing = list.find(inst => inst.cellIndex === idx);
      if (!existing) {
        existing = { cellIndex: idx };
        list.push(existing);
      }
      existing.buildingId = cell.buildingId;
      existing.stationKey = state.stationKey;
      existing.localPos = { x: cell.localPos.x, y: cell.localPos.y };
      existing.worldPos = worldPos;
      existing.stationRef = station;
      existing.footprint = cell.footprint;
      existing.rotation = cell.rotation;
      existing.status = 'completed';
      cell.emitted = true;
    }

    function drawInfrastructureGrid(ctx, cam, station, state) {
      if (!ctx || !cam || !station || !state) return;
      const alpha = infrastructureBuilder.editorAlpha;
      if (alpha <= 0.001) return;
      const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      const cellSizeWorld = layout?.cellSize ?? INFRA_CELL_WORLD_SIZE;
      const cellSize = cellSizeWorld * cam.zoom;
      const half = cellSize / 2;
      ctx.save();
      ctx.globalAlpha = alpha * 0.85;
      const processedRoots = new Set();
      for (let i = 0; i < layout.cells.length; i++) {
        const meta = layout.cells[i];
        const worldCenter = infrastructureLocalToWorld(station, meta.local);
        const screen = worldToScreen(worldCenter.x, worldCenter.y, cam);
        const rootIdx = getRootCellIndex(state, i);
        const rootCell = rootIdx != null ? state.cells[rootIdx] : null;
        const building = rootCell ? INFRA_BUILDING_MAP.get(rootCell.buildingId) : null;
        const blocked = !!meta.blocked;
        const done = rootCell?.status === 'completed';
        const progress = clamp(rootCell?.progress ?? 0, 0, 1);
        const belongsToBuilding = rootCell && rootCell.cells?.includes(meta.index);

        if (blocked) {
          ctx.beginPath();
          ctx.strokeStyle = 'rgba(255,110,90,0.65)';
          ctx.setLineDash([8 * cam.zoom, 6 * cam.zoom]);
          ctx.lineDashOffset = performance.now() * 0.04;
          ctx.strokeRect(screen.x - half, screen.y - half, cellSize, cellSize);
          ctx.setLineDash([]);
          continue;
        }

        if (belongsToBuilding) {
          ctx.fillStyle = done ? 'rgba(56,180,135,0.26)' : 'rgba(90,140,220,0.28)';
          ctx.fillRect(screen.x - half, screen.y - half, cellSize, cellSize);
          ctx.lineWidth = Math.max(1, 1.3 * cam.zoom);
          ctx.strokeStyle = done ? 'rgba(82,205,150,0.8)' : 'rgba(108,170,255,0.75)';
          ctx.strokeRect(screen.x - half, screen.y - half, cellSize, cellSize);
        } else {
          ctx.fillStyle = 'rgba(60,100,180,0.18)';
          ctx.fillRect(screen.x - half, screen.y - half, cellSize, cellSize);
          ctx.lineWidth = Math.max(1, 1.3 * cam.zoom);
          ctx.strokeStyle = 'rgba(130,170,255,0.35)';
          ctx.strokeRect(screen.x - half, screen.y - half, cellSize, cellSize);
        }

        if (rootCell && building && !processedRoots.has(rootIdx)) {
          processedRoots.add(rootIdx);
          const centerWorld = infrastructureLocalToWorld(station, rootCell.localPos || meta.local);
          const centerScreen = worldToScreen(centerWorld.x, centerWorld.y, cam);
          const footprintScale = Math.max(rootCell.footprint?.w || 1, rootCell.footprint?.h || 1);
          const iconSize = cellSize * 0.72 * footprintScale;
          ctx.globalAlpha = done ? alpha * 0.92 : alpha * 0.85;
          if (window.drawInfrastructureIcon) {
            window.drawInfrastructureIcon(ctx, building, centerScreen, iconSize, alpha, null);
          }
          if (!done) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(96,165,250,0.85)';
            ctx.lineWidth = Math.max(1.4, cam.zoom * 2.2);
            ctx.arc(centerScreen.x, centerScreen.y, (cellSize * 0.38) * footprintScale, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * progress);
            ctx.stroke();
          }
        }
      }

      const hovered = infrastructureBuilder.hoveredCell;
      const ghostId = infrastructureBuilder.draggingBuildingId;
      if (ghostId && hovered != null) {
        const building = INFRA_BUILDING_MAP.get(ghostId);
        const placement = building ? validateInfrastructurePlacement(state, hovered, building, infrastructureBuilder.ghostRotation) : null;
        if (placement && placement.footprint) {
          const ghostAlpha = infrastructureBuilder.ghostAlpha * alpha;
          if (ghostAlpha > 0.02) {
            const blocked = placement.blocked || placement.occupied;
            ctx.globalAlpha = ghostAlpha * 0.9;
            ctx.fillStyle = blocked ? 'rgba(220,70,70,0.35)' : 'rgba(80,150,255,0.3)';
            for (const meta of placement.footprint.cells) {
              const worldCenter = infrastructureLocalToWorld(station, meta.local);
              const screen = worldToScreen(worldCenter.x, worldCenter.y, cam);
              ctx.fillRect(screen.x - half, screen.y - half, cellSize, cellSize);
            }
            if (!blocked) {
              const centerWorld = infrastructureLocalToWorld(station, placement.footprint.center);
              const centerScreen = worldToScreen(centerWorld.x, centerWorld.y, cam);
              const footprintScale = Math.max(placement.footprint.width, placement.footprint.height);
              if (window.drawInfrastructureIcon) {
                window.drawInfrastructureIcon(ctx, building, centerScreen, cellSize * 0.72 * footprintScale, ghostAlpha, null);
              }
            }
            ctx.globalAlpha = alpha * 0.85;
          }
        }
      }
      ctx.restore();
    }

    function drawInfrastructureInstances(ctx, cam) {
      if (!ctx || !cam || !Game.infrastructure) return;
      const activeKey = (stationUI.editorMode && stationUI.station) ? getInfrastructureStationKey(stationUI.station) : null;
      ctx.save();
      Game.infrastructure.forEach((list, key) => {
        if (activeKey && key === activeKey) return;
        for (const inst of list) {
          if (!inst || !inst.worldPos || !inst.buildingId) continue;
          const building = INFRA_BUILDING_MAP.get(inst.buildingId);
          if (!building) continue;
          const screen = worldToScreen(inst.worldPos.x, inst.worldPos.y, cam);
          const footprintScale = inst.footprint ? Math.max(inst.footprint.w || 1, inst.footprint.h || 1) : 1;
          const size = INFRA_CELL_WORLD_SIZE * cam.zoom * 0.6 * footprintScale;
          ctx.globalAlpha = 0.9;
          if (window.drawInfrastructureIcon) {
            window.drawInfrastructureIcon(ctx, building, screen, size, 0.95, inst);
          }
        }
      });
      ctx.restore();
    }

    function initInfrastructureUI() {
      const overlay = infrastructureBuilder.overlay;
      if (!overlay) return;
      const tabBtn = overlay.querySelector('li[data-tab="infrastructure"]');
      if (tabBtn) {
        tabBtn.addEventListener('click', () => {
          stationUI.open = true;
          stationUI.tab = 'infrastructure';
          setInfrastructureUIVisible(true);
        });
      }

      const list = infrastructureBuilder.list;
      if (list) {
        list.innerHTML = '';
        for (const building of INFRASTRUCTURE_BUILDINGS) {
          const item = document.createElement('div');
          item.className = 'infra-building';
          item.draggable = true;
          item.dataset.building = building.id;
          const canvas = document.createElement('canvas');
          canvas.width = 96;
          canvas.height = 96;
          canvas.className = 'infra-building-canvas';
          item.appendChild(canvas);
          const name = document.createElement('div');
          name.className = 'infra-building-name';
          name.textContent = building.name;
          item.appendChild(name);
          const meta = document.createElement('div');
          meta.className = 'infra-building-meta';
          const fp = buildingFootprint(building);
          meta.textContent = `Czas budowy: ${building.buildTime}s ‚Ä¢ Rozmiar: ${fp.w}√ó${fp.h}`;
          item.appendChild(meta);
          item.addEventListener('dragstart', (ev) => {
            item.classList.add('dragging');
            infrastructureBuilder.draggingBuildingId = building.id;
            infrastructureBuilder.ghostRotation = 0;
            if (ev.dataTransfer) {
              ev.dataTransfer.effectAllowed = 'copy';
              ev.dataTransfer.setData('text/plain', building.id);
              ev.dataTransfer.setData('text/infrastructure-building', building.id);
            }
          });
          item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
            infrastructureBuilder.draggingBuildingId = null;
            infrastructureBuilder.ghostRotation = 0;
            infrastructureBuilder.hoveredCell = null;
          });
          list.appendChild(item);
          drawBuildingPreview(canvas, building);
        }
      }

      const grid = infrastructureBuilder.grid;
      if (grid) {
        const layout = updateInfrastructureGridForStation(stationUI.station || null);
        rebuildInfrastructureGrid(layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows));
      }

      setInfrastructureUIVisible(false);
      renderInfrastructureOverlay();
    }

    function setInfrastructureUIVisible(visible) {
      const overlay = infrastructureBuilder.overlay;
      if (!overlay) return;
      if (visible) {
        if (infrastructureBuilder.isVisible) {
          if (stationUI.station) {
            setInfrastructureActiveStation(stationUI.station);
          }
          if (infrastructureBuilder.needsRender) {
            renderInfrastructureOverlay();
          }
          return;
        }
        if (infrastructureBuilder.hideTimer) {
          clearTimeout(infrastructureBuilder.hideTimer);
          infrastructureBuilder.hideTimer = null;
        }
        overlay.classList.remove('hidden');
        overlay.classList.remove('infra-hiding');
        void overlay.offsetWidth;
        overlay.classList.add('infra-visible');
        applyInfrastructureOverlayPosition();
        infrastructureBuilder.isVisible = true;
        if (stationUI.station) {
          setInfrastructureActiveStation(stationUI.station);
        }
        renderInfrastructureOverlay();
      } else {
        if (!infrastructureBuilder.isVisible) {
          overlay.classList.add('hidden');
          return;
        }
        overlay.classList.remove('infra-visible');
        overlay.classList.add('infra-hiding');
        infrastructureBuilder.isVisible = false;
        if (infrastructureBuilder.hideTimer) {
          clearTimeout(infrastructureBuilder.hideTimer);
        }
        infrastructureBuilder.hideTimer = setTimeout(() => {
          overlay.classList.add('hidden');
          overlay.classList.remove('infra-hiding');
        }, 220);
        infrastructureBuilder.hoveredCell = null;
        infrastructureBuilder.draggingOverlay = false;
        overlay.classList.remove('dragging');
      }
    }

    function renderInfrastructureInfo(state, uniqueRoots = new Set(), completedRoots = new Set()) {
      const info = infrastructureBuilder.info;
      if (!info) return;
      info.innerHTML = '';
      const station = infrastructureBuilder.activeStationRef || stationUI.station;
      const title = document.createElement('h4');
      title.textContent = station?.name ? `Infrastruktura: ${station.name}` : 'Budowa stacji';
      info.appendChild(title);

      if (!state) {
        const p = document.createElement('p');
        p.textContent = 'Brak aktywnej stacji. Wybierz stacjƒô, aby rozpoczƒÖƒá budowƒô.';
        info.appendChild(p);
        return;
      }

      const totalUsed = uniqueRoots.size || state.cells.filter(Boolean).length;
      const completed = completedRoots.size || state.cells.filter(cell => cell && cell.status === 'completed').length;

      if (infrastructureBuilder.selectedCell == null) {
        const p = document.createElement('p');
        p.textContent = 'PrzeciƒÖgnij budynek z listy na siatkƒô wok√≥≈Ç stacji, aby rozpoczƒÖƒá budowƒô.';
        info.appendChild(p);
        const summary = document.createElement('p');
        summary.textContent = `Uko≈Ñczone budynki: ${completed}/${totalUsed}.`;
        summary.style.fontSize = '12px';
        summary.style.color = '#94a9d6';
        info.appendChild(summary);
        return;
      }

      const idx = getRootCellIndex(state, infrastructureBuilder.selectedCell ?? 0);
      const meta = state.cellMeta?.[idx ?? 0];
      if (!meta) {
        const p = document.createElement('p');
        p.textContent = 'Nie mo≈ºna odczytaƒá danych pola. Od≈õwie≈º interfejs.';
        info.appendChild(p);
        return;
      }
      const cell = getRootCell(state, idx);
      const local = cell?.localPos || meta.local;
      if (cell && !cell.localPos && local) {
        cell.localPos = { x: local.x, y: local.y };
      }
      if (meta.blocked && !cell) {
        const p = document.createElement('p');
        p.textContent = 'Rdze≈Ñ stacji ‚Äî strefa serwisowa niedostƒôpna dla infrastruktury.';
        info.appendChild(p);
        const coords = document.createElement('p');
        coords.textContent = `Po≈Ço≈ºenie rdzenia: Œîx ${Math.round(local?.x ?? 0)}, Œîy ${Math.round(local?.y ?? 0)}.`;
        coords.style.fontSize = '12px';
        coords.style.color = '#94a9d6';
        info.appendChild(coords);
        return;
      }
      if (!cell) {
        const p = document.createElement('p');
        p.textContent = 'Puste pole. Upu≈õƒá budynek z listy po lewej, aby rozpoczƒÖƒá konstrukcjƒô.';
        info.appendChild(p);
        if (local) {
          const coords = document.createElement('p');
          coords.textContent = `Po≈Ço≈ºenie wzglƒôdem centrum: Œîx ${Math.round(local.x)}, Œîy ${Math.round(local.y)}.`;
          coords.style.fontSize = '12px';
          coords.style.color = '#94a9d6';
          info.appendChild(coords);
        }
        return;
      }

      const building = INFRA_BUILDING_MAP.get(cell.buildingId);
      const name = document.createElement('p');
      name.textContent = building?.name || 'Budowa';
      name.style.fontWeight = '600';
      info.appendChild(name);

      const status = document.createElement('p');
      const progress = cell.status === 'completed' ? 1 : clamp(cell.progress ?? 0, 0, 1);
      if (cell.status === 'completed') {
        status.textContent = 'Status: Zako≈Ñczono budowƒô.';
      } else {
        const remaining = Math.max(0, (cell.duration ?? 0) - (cell.elapsed ?? 0));
        status.textContent = `Status: W budowie ‚Äî ${Math.round(progress * 100)}% (pozosta≈Ço ${remaining.toFixed(1)}s).`;
      }
      info.appendChild(status);

      const buildTime = document.createElement('p');
      buildTime.textContent = `Czas budowy: ${building?.buildTime ?? '?'} s`;
      buildTime.style.fontSize = '13px';
      buildTime.style.color = '#a8b4d9';
      info.appendChild(buildTime);

      if (cell.footprint) {
        const fp = cell.footprint;
        const footprint = document.createElement('p');
        footprint.textContent = `Zajƒôto≈õƒá siatki: ${fp.w}√ó${fp.h}`;
        footprint.style.fontSize = '12px';
        footprint.style.color = '#94a9d6';
        info.appendChild(footprint);
      }

      if (local) {
        const coords = document.createElement('p');
        coords.textContent = `Po≈Ço≈ºenie wzglƒôdem stacji: Œîx ${Math.round(local.x)}, Œîy ${Math.round(local.y)}.`;
        coords.style.fontSize = '12px';
        coords.style.color = '#94a9d6';
        info.appendChild(coords);
      }

      const progressWrap = document.createElement('div');
      progressWrap.className = 'infra-info-progress';
      const strong = document.createElement('strong');
      strong.textContent = 'Postƒôp';
      progressWrap.appendChild(strong);
      const bar = document.createElement('div');
      bar.className = 'infra-progress-bar';
      const fill = document.createElement('div');
      fill.className = 'infra-progress-fill';
      fill.style.width = `${Math.round(progress * 100)}%`;
      bar.appendChild(fill);
      progressWrap.appendChild(bar);
      info.appendChild(progressWrap);
    }

    function renderInfrastructureOverlay() {
      const station = infrastructureBuilder.activeStationRef || stationUI.station;
      const state = station ? ensureInfrastructureState(station) : null;
      if (station && !infrastructureBuilder.activeStationRef) {
        infrastructureBuilder.activeStationRef = station;
      }
      const uniqueRoots = new Set();
      const completedRoots = new Set();
      if (state) {
        state.cells.forEach((cell, idx) => {
          if (!cell) return;
          const rootIdx = getRootCellIndex(state, idx) ?? idx;
          uniqueRoots.add(rootIdx);
          if (cell.status === 'completed') completedRoots.add(rootIdx);
        });
      }
      infrastructureBuilder.needsRender = false;
      renderInfrastructureInfo(state || null, uniqueRoots, completedRoots);
    }

    function renderInfrastructureTab() {
      uiTitle('Infrastruktura stacji');
      const station = stationUI.station;
      if (!station) {
        uiText('Brak aktywnej stacji.');
        return;
      }
      const state = ensureInfrastructureState(station);
      const totalUsed = state.cells.filter(Boolean).length;
      const completed = state.cells.filter(cell => cell && cell.status === 'completed').length;
      uiText('ZarzƒÖdzaj infrastrukturƒÖ w panelu Infrastructure obok.');
      uiText(`Budowy uko≈Ñczone: ${completed}/${totalUsed}.`);
      uiText('PrzeciƒÖgnij budynek na siatkƒô, aby rozpoczƒÖƒá konstrukcjƒô lub kliknij pole, by zobaczyƒá postƒôp.');
    }

    function updateInfrastructureEditorState(dt) {
      const target = stationUI.editorMode ? 1 : 0;
      if (target > infrastructureBuilder.editorAlpha) {
        infrastructureBuilder.editorAlpha = Math.min(target, infrastructureBuilder.editorAlpha + dt * 4.2);
      } else if (target < infrastructureBuilder.editorAlpha) {
        infrastructureBuilder.editorAlpha = Math.max(target, infrastructureBuilder.editorAlpha - dt * 5.6);
        if (infrastructureBuilder.editorAlpha <= 0.001) {
          infrastructureBuilder.editorAlpha = 0;
          infrastructureBuilder.hoveredCell = null;
        }
      }

      const ghostTarget = infrastructureBuilder.draggingBuildingId ? 1 : 0;
      if (ghostTarget > infrastructureBuilder.ghostAlpha) {
        infrastructureBuilder.ghostAlpha = Math.min(ghostTarget, infrastructureBuilder.ghostAlpha + dt * 10);
      } else if (ghostTarget < infrastructureBuilder.ghostAlpha) {
        infrastructureBuilder.ghostAlpha = Math.max(ghostTarget, infrastructureBuilder.ghostAlpha - dt * 8);
      }
    }

    function updateInfrastructureState(dt) {
      let changed = false;
      infrastructureBuilder.stationStates.forEach(state => {
        if (!state || !state.cells) return;
        const processed = new Set();
        const buildingCounts = {};
        state.cells.forEach((cell, idx) => {
          if (!cell) return;
          const rootIdx = getRootCellIndex(state, idx);
          if (rootIdx == null || processed.has(rootIdx)) return;
          processed.add(rootIdx);
          if (cell.status === 'building') {
            const prev = cell.progress || 0;
            cell.elapsed = (cell.elapsed || 0) + dt;
            const duration = Math.max(0.1, cell.duration || 1);
            cell.progress = clamp(cell.elapsed / duration, 0, 1);
            if (cell.progress !== prev) changed = true;
            if (cell.progress >= 1 && cell.status !== 'completed') {
              cell.status = 'completed';
              changed = true;
            }
          }
          if (cell.status === 'completed') {
            buildingCounts[cell.buildingId] = (buildingCounts[cell.buildingId] || 0) + 1;
          }
          if (cell.status === 'completed' && !cell.emitted) {
            emitInfrastructureCompletion(state, rootIdx, cell);
            changed = true;
          }
        });
        updateStationEconomyFromBuildings(state, buildingCounts, dt);
      });
      if (changed) {
        if (infrastructureBuilder.isVisible) {
          renderInfrastructureOverlay();
        } else {
          infrastructureBuilder.needsRender = true;
        }
      } else if (infrastructureBuilder.isVisible && infrastructureBuilder.needsRender) {
        renderInfrastructureOverlay();
      }
    }

    function syncInfrastructureWorldPositions() {
      if (!Game.infrastructure) return;
      Game.infrastructure.forEach((list, key) => {
        const station = findStationByKey(key);
        if (!station) return;
        for (const inst of list) {
          if (!inst || !inst.localPos) continue;
          inst.stationRef = station;
          inst.worldPos = infrastructureLocalToWorld(station, inst.localPos);
        }
      });
    }

    function populateStationInfrastructureDefaults(station, preset) {
      if (!station || !preset) return false;
      const state = ensureInfrastructureState(station);
      if (!state || infrastructureHasBuildings(state)) return false;
      const stationKey = getInfrastructureStationKey(station);
      const existingList = stationKey && Game.infrastructure ? Game.infrastructure.get(stationKey) : null;
      if (existingList && existingList.length) return false;
      const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      if (!layout) return false;

      const bandBase = Math.floor(Math.min(layout.cols, layout.rows) / 4);
      const midBand = Math.max(bandBase, INFRA_STATION_CORE_SIZE + 3);
      const farBand = Math.max(Math.floor(Math.min(layout.cols, layout.rows) / 3), midBand + 2);

      const plans = {
        mercury: [
          { id: 'metal_harvester', offset: { col: -midBand, row: 0 }, rotation: 0 },
          { id: 'metal_harvester', offset: { col: midBand, row: 0 }, rotation: 0 },
          { id: 'metal_refinery', offset: { col: 0, row: -midBand }, rotation: 0 },
          { id: 'metal_refinery', offset: { col: 0, row: midBand }, rotation: 0 },
          { id: 'solar_array', offset: { col: -midBand + 1, row: midBand - 1 }, rotation: 0 },
          { id: 'solar_array', offset: { col: midBand - 1, row: midBand - 1 }, rotation: 0 },
        ],
        earth: [
          { id: 'shipyard_capital', offset: { col: midBand + 2, row: 0 }, rotation: 0 },
          { id: 'shipyard_l', offset: { col: -(midBand + 2), row: 0 }, rotation: 0 },
          { id: 'shipyard_m', offset: { col: 0, row: -midBand }, rotation: 0 },
          { id: 'shipyard_s', offset: { col: -2, row: midBand - 1 }, rotation: 0 },
          { id: 'shipyard_s', offset: { col: 2, row: midBand - 1 }, rotation: 0 },
          { id: 'solar_array', offset: { col: -midBand + 1, row: -(midBand + 1) }, rotation: 0 },
          { id: 'solar_array', offset: { col: midBand - 1, row: -(midBand + 1) }, rotation: 0 },
          { id: 'solar_array', offset: { col: 0, row: midBand }, rotation: 0 },
          { id: 'storage_metal', offset: { col: -farBand, row: -farBand }, rotation: 0 },
          { id: 'storage_metal', offset: { col: -farBand, row: farBand }, rotation: 0 },
          { id: 'storage_fuel', offset: { col: farBand, row: -farBand }, rotation: 0 },
          { id: 'storage_fuel', offset: { col: farBand, row: farBand }, rotation: 0 },
          { id: 'storage_gas', offset: { col: -(farBand + 2), row: 0 }, rotation: 0 },
          { id: 'storage_gas', offset: { col: farBand + 2, row: 0 }, rotation: 0 },
          { id: 'storage_plastics', offset: { col: 0, row: -(farBand + 2) }, rotation: 0 },
          { id: 'storage_plastics', offset: { col: 0, row: farBand + 2 }, rotation: 0 },
        ],
        mars: [
          { id: 'shipyard_l', offset: { col: midBand, row: 0 }, rotation: 0 },
          { id: 'solar_array', offset: { col: -midBand + 1, row: -(midBand + 1) }, rotation: 0 },
          { id: 'solar_array', offset: { col: midBand - 1, row: midBand - 1 }, rotation: 0 },
          { id: 'metal_harvester', offset: { col: -farBand, row: -farBand }, rotation: 0 },
          { id: 'metal_refinery', offset: { col: farBand, row: farBand }, rotation: 0 },
          { id: 'storage_metal', offset: { col: -farBand, row: 0 }, rotation: 0 },
          { id: 'storage_fuel', offset: { col: 0, row: -farBand }, rotation: 0 },
          { id: 'storage_gas', offset: { col: farBand, row: 0 }, rotation: 0 },
          { id: 'storage_plastics', offset: { col: 0, row: farBand }, rotation: 0 },
        ],
        jupiter: [
          { id: 'gas_harvester', offset: { col: -farBand, row: -farBand }, rotation: 0 },
          { id: 'gas_harvester', offset: { col: farBand, row: -farBand }, rotation: 0 },
          { id: 'gas_harvester', offset: { col: -farBand, row: farBand }, rotation: 0 },
          { id: 'gas_harvester', offset: { col: farBand, row: farBand }, rotation: 0 },
          { id: 'gas_refinery', offset: { col: midBand, row: 0 }, rotation: 0 },
          { id: 'gas_refinery', offset: { col: -midBand, row: 0 }, rotation: 0 },
          { id: 'storage_fuel', offset: { col: 0, row: -(midBand + 2) }, rotation: 0 },
        ]
      };

      const plan = plans[preset];
      if (!Array.isArray(plan)) return false;

      let placedAny = false;
      for (const step of plan) {
        const success = autoplaceBuildingByOffset(state, step.id, step.offset.col, step.offset.row, step.rotation || 0);
        placedAny = placedAny || success;
      }
      return placedAny;
    }

    function autopopulateDefaultInfrastructure() {
      if (!Array.isArray(stations) || !stations.length) return;
      let changed = false;
      for (const st of stations) {
        if (!st || !st.id) continue;
        const key = st.id.toLowerCase();
        if (key === 'mercury') changed = populateStationInfrastructureDefaults(st, 'mercury') || changed;
        if (key === 'earth') changed = populateStationInfrastructureDefaults(st, 'earth') || changed;
        if (key === 'mars') changed = populateStationInfrastructureDefaults(st, 'mars') || changed;
        if (key === 'jupiter') changed = populateStationInfrastructureDefaults(st, 'jupiter') || changed;
      }
      if (changed) {
        updateInfrastructureState(0.001);
        syncInfrastructureWorldPositions();
      }
    }

    function renderMechanicTab() {
      uiTitle('Mechanic');
      uiText('ZarzƒÖdzaj hardpointami i uzbrojeniem w panelu obok.');
    }

    function initMechanicUI() {
      // Ta funkcja jest teraz uproszczona, poniewa≈º logika zosta≈Ça przeniesiona 
      // bezpo≈õrednio do buildMechanicPanel w g≈Ç√≥wnym oknie stacji.
      // Zachowujemy jƒÖ tylko dla kompatybilno≈õci, je≈õli co≈õ jƒÖ wywo≈Çuje.
    }

    const HP_GROUP_META = {
      [HP.MAIN]: { title: 'Bro≈Ñ g≈Ç√≥wna', css: 'hp-main' },
      [HP.MISSILE]: { title: 'Rakiety', css: 'hp-miss' },
      [HP.AUX]: { title: 'Bro≈Ñ dodatkowa', css: 'hp-aux' },
      [HP.HANGAR]: { title: 'Hangary', css: 'hp-hangar' },
      [HP.SPECIAL]: { title: 'Bro≈Ñ specjalna', css: 'hp-spec' },
    };
    let mechanicWeaponFilter = 'all';
    let mechanicHardpointFilter = 'all';
    let mechanicDragWeaponId = null;

    function mechanicIconForWeapon(weapon, hpType) {
      const iconPath = weapon ? WEAPON_ICON_PATHS[weapon.id] : null;
      const hasIcon = !!iconPath;
      if (hasIcon) {
        const wrap = document.createElement('span');
        wrap.className = 'weapon-icon-wrap';
        const img = document.createElement('img');
        img.src = iconPath;
        img.loading = 'lazy';
        img.alt = weapon?.name || 'Bro≈Ñ';
        wrap.appendChild(img);
        return wrap;
      }
      const placeholder = document.createElement('span');
      placeholder.className = 'weapon-icon-placeholder';
      placeholder.dataset.type = hpType;
      placeholder.textContent = weapon ? 'NO ART' : 'EMPTY';
      return placeholder;
    }

    function weaponMetaText(weapon) {
      if (!weapon) return '';
      const parts = [];
      if (weapon.dps != null) parts.push(`${weapon.dps} dps`);
      if (weapon.damage != null) parts.push(`${weapon.damage} dmg`);
      if (weapon.cooldown != null) parts.push(`${weapon.cooldown}s cd`);
      if (weapon.ammo != null) parts.push(`${weapon.ammo} ammo`);
      if (weapon.energy != null) parts.push(`${weapon.energy}e`);
      return parts.join(' ‚Ä¢ ');
    }

    function applyWeaponToHardpoint(hp, weaponId) {
      if (!hp) return;
      const weapon = weaponId ? WEAPONS[weaponId] : null;
      setHardpointMount(hp, weaponId);
      if (weapon && weapon.ammo != null) {
        hp.ammo = weapon.ammo;
        hp.maxAmmo = weapon.ammo;
      }
      syncWeaponSystems();
      renderMechanic();
      saveLoadout();
    }

    function attachSlotDnD(slot, hp) {
      slot.addEventListener('dragover', (e) => {
        const weaponId = mechanicDragWeaponId || e.dataTransfer?.getData('text/plain');
        const weapon = weaponId ? WEAPONS[weaponId] : null;
        if (!weapon || weapon.type !== hp.type) return;
        e.preventDefault();
        slot.classList.add('drag-over');
      });
      slot.addEventListener('dragleave', () => { slot.classList.remove('drag-over'); });
      slot.addEventListener('drop', (e) => {
        const weaponId = e.dataTransfer?.getData('text/plain') || mechanicDragWeaponId;
        const weapon = weaponId ? WEAPONS[weaponId] : null;
        slot.classList.remove('drag-over');
        if (!weapon || weapon.type !== hp.type) return;
        e.preventDefault();
        applyWeaponToHardpoint(hp, weapon.id);
      });
    }

    function quickMountWeapon(weapon) {
      if (!weapon) return;
      const targetHp = Game.player.hardpoints.find(h => h.type === weapon.type);
      if (targetHp) {
        applyWeaponToHardpoint(targetHp, weapon.id);
      }
    }

    function createWeaponRow(weapon) {
      const row = document.createElement('div');
      row.className = 'weapon-row'; // Nowa klasa CSS
      row.draggable = true;
      row.dataset.weaponId = weapon.id;
      row.dataset.weaponType = weapon.type;

      // 1. Ma≈Ça ikona
      const iconWrap = document.createElement('div');
      const iconPath = WEAPON_ICON_PATHS[weapon.id];
      if (iconPath) {
        iconWrap.className = 'weapon-row-icon';
        const img = document.createElement('img');
        img.src = iconPath;
        iconWrap.appendChild(img);
      } else {
        iconWrap.className = 'weapon-row-icon placeholder';
        iconWrap.textContent = 'IMG';
      }
      row.appendChild(iconWrap);

      // 2. Nazwa
      const nameEl = document.createElement('div');
      nameEl.className = 'weapon-row-name';
      nameEl.textContent = weapon.name;
      row.appendChild(nameEl);

      // 3. Statystyki (Dmg/Cd) - skr√≥cone w jednej linii
      const metaEl = document.createElement('div');
      metaEl.className = 'weapon-row-meta';
      let stats = '';
      if (weapon.damage) stats = `${weapon.damage}dmg`;
      else if (weapon.dps) stats = `${weapon.dps}dps`;
      if (weapon.cooldown) stats += ` / ${weapon.cooldown}s`;
      if (weapon.ammo) stats += ` [${weapon.ammo}]`;
      metaEl.textContent = stats;
      row.appendChild(metaEl);

      // Obs≈Çuga przeciƒÖgania (Drag & Drop)
      row.addEventListener('dragstart', (e) => {
        mechanicDragWeaponId = weapon.id;
        row.classList.add('dragging');
        if (e.dataTransfer) {
          e.dataTransfer.setData('text/plain', weapon.id);
          e.dataTransfer.effectAllowed = 'copy';
        }
      });
      row.addEventListener('dragend', () => {
        mechanicDragWeaponId = null;
        row.classList.remove('dragging');
      });
      row.addEventListener('dblclick', () => quickMountWeapon(weapon));

      return row;
    }

    function setMechanicFilterActive(containerId, value) {
      const container = document.getElementById(containerId);
      if (!container) return;
      container.querySelectorAll('button[data-filter]').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.filter === value);
      });
    }

    function initMechanicFilter(containerId, getValue, setValue) {
      const container = document.getElementById(containerId);
      if (!container) return;
      container.querySelectorAll('button[data-filter]').forEach(btn => {
        btn.addEventListener('click', () => {
          const val = btn.dataset.filter;
          if (!val) return;
          setValue(val);
          renderMechanic();
        });
      });
      setMechanicFilterActive(containerId, getValue());
    }

    function renderAvailableWeapons(root) {
      if (!root) return;
      root.innerHTML = '';
      const inventory = Game.player?.inventory || new Set();
      const filter = mechanicWeaponFilter;
      const weapons = [...inventory]
        .map(id => WEAPONS[id])
        .filter(Boolean)
        .filter(w => filter === 'all' || w.type === filter);

      // Sortowanie i grupowanie
      const grouped = {};
      for (const t of Object.values(HP)) grouped[t] = [];
      for (const w of weapons) grouped[w.type].push(w);

      for (const type of Object.values(HP)) {
        if (!grouped[type].length) continue;

        // Nag≈Ç√≥wek grupy (np. "MAIN") - teraz jako prosty tekst
        const header = document.createElement('div');
        header.className = 'list-group-header';
        const meta = HP_GROUP_META[type];
        header.textContent = meta ? meta.title : type;
        root.appendChild(header);

        // Sortowanie alfabetyczne (z ochronƒÖ przed brakujƒÖcymi nazwami)
        grouped[type].sort((a, b) => (a?.name || '').localeCompare(b?.name || ''));

        // Generowanie wierszy
        for (const weapon of grouped[type]) {
          root.appendChild(createWeaponRow(weapon));
        }
      }

      if (weapons.length === 0) {
        const empty = document.createElement('div');
        empty.style.padding = '10px';
        empty.style.color = '#777';
        empty.textContent = filter === 'all' ? 'Pusty magazyn.' : 'Brak broni w wybranej kategorii.';
        root.appendChild(empty);
      }
    }

    function createHpRow(hp, idx) {
      const row = document.createElement('div');
      row.className = 'hp-row'; // Nowa klasa CSS
      row.dataset.hpId = hp.id;
      row.dataset.hpType = hp.type;

      // 1. Ikona zamontowanej broni (lub puste miejsce)
      const weapon = hp.mount ? WEAPONS[hp.mount] : null;
      const iconWrap = document.createElement('div');
      const iconPath = weapon ? WEAPON_ICON_PATHS[weapon.id] : null;

      if (iconPath) {
        iconWrap.className = 'weapon-row-icon';
        iconWrap.innerHTML = `<img src="${iconPath}">`;
      } else {
        // Pusty kwadracik lub znak zapytania
        iconWrap.className = 'weapon-row-icon placeholder';
        iconWrap.textContent = weapon ? '?' : '-';
      }
      row.appendChild(iconWrap);

      // 2. Typ slotu (np. MAIN #1) - ma≈Ça etykieta
      const label = document.createElement('div');
      label.className = 'hp-row-label';
      label.textContent = `${hp.type.toUpperCase()} #${idx + 1}`;
      row.appendChild(label);

      // 3. Nazwa zamontowanej broni lub "Puste"
      const mountInfo = document.createElement('div');
      mountInfo.className = 'hp-row-mount';
      if (weapon) {
        mountInfo.textContent = weapon.name;
        mountInfo.classList.remove('empty');
      } else {
        mountInfo.textContent = 'Puste';
        mountInfo.classList.add('empty');
      }
      row.appendChild(mountInfo);

      // 4. Przycisk "X" do odczepiania
      const clearBtn = document.createElement('button');
      clearBtn.className = 'hp-row-clear';
      clearBtn.textContent = '√ó';
      clearBtn.title = "Odczep bro≈Ñ";
      clearBtn.disabled = !hp.mount;
      clearBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        applyWeaponToHardpoint(hp, null);
      });
      row.appendChild(clearBtn);

      // Podpiƒôcie upuszczania (Drop)
      attachSlotDnD(row, hp); // Ta funkcja pomocnicza zostaje bez zmian w kodzie
      return row;
    }

    function renderInstalledHardpoints(root) {
      if (!root) return;
      root.innerHTML = '';

      const filter = mechanicHardpointFilter;
      const source = filter === 'all'
        ? Game.player.hardpoints
        : Game.player.hardpoints.filter(hp => hp.type === filter);

      const listByType = {};
      for (const t of Object.values(HP)) listByType[t] = [];
      for (const hp of source) listByType[hp.type].push(hp);

      for (const type of Object.values(HP)) {
        const slots = listByType[type];
        if (!slots || slots.length === 0) continue;

        // Nag≈Ç√≥wek grupy (np. "MAIN (4)")
        const meta = HP_GROUP_META[type];
        const header = document.createElement('div');
        header.className = 'list-group-header';
        header.textContent = `${meta ? meta.title : type} (${slots.length})`;
        header.style.marginBottom = '4px';
        root.appendChild(header);

        // Generowanie wierszy slot√≥w
        slots.forEach((hp, idx) => {
          root.appendChild(createHpRow(hp, idx));
        });
      }

      if (source.length === 0) {
        const empty = document.createElement('div');
        empty.textContent = filter === 'all' ? 'Brak slot√≥w na uzbrojenie.' : 'Brak slot√≥w dla wybranego filtra.';
        empty.style.padding = '10px';
        root.appendChild(empty);
      }
    }
    function renderMechanic() {
      setMechanicFilterActive('weapon-filter-tabs', mechanicWeaponFilter);
      setMechanicFilterActive('hp-filter-tabs', mechanicHardpointFilter);
      renderAvailableWeapons(document.getElementById('mechanic-available'));
      renderInstalledHardpoints(document.getElementById('hp-groups'));
      const sel = document.getElementById('ship-frame-select');
      if (sel && sel.value !== Game.player.shipFrame) {
        sel.value = Game.player.shipFrame;
      }
    }

    // --- Zak≈Çadki ---
    const PLAYER = { credits: 1200, cargo: {}, shipId: 'starter' };
    const BLUEPRINTS = {
      upgrades: [
        { id: 'rail_cooler', name: 'Ch≈Çodzenie raila', cost: 600, apply() { rail.heatCap *= 1.25; rail.coolRate *= 1.15; } },
        {
          id: 'boost_core', name: 'Wzmocniony boost', cost: 700, apply() {
            boost.extraThrustMul *= 1.15;
            boost.consumeRate *= 0.9;
            boost.handlingMultiplier *= 1.05;
          }
        },
        {
          id: 'agility', name: 'Zwrotno≈õƒá +', cost: 500, apply() {
            ship.angularDamping *= 0.9;
            ship.engines.torqueLeft.maxThrust = Math.round(ship.engines.torqueLeft.maxThrust * 1.12);
            ship.engines.torqueRight.maxThrust = Math.round(ship.engines.torqueRight.maxThrust * 1.12);
          }
        },
      ],
      ships: [
        { id: 'scout', name: 'Scout', cost: 2500, stats: { hp: 0.8, speed: 1.3, cargo: 0.6 } },
        { id: 'frigate', name: 'Fregata', cost: 4200, stats: { hp: 1.6, speed: 0.85, cargo: 1.4 } },
      ],
    };

    const STATION_TAB_CONFIG = [
      { id: 'upgrades', label: 'Ulepszenia' },
      { id: 'trade', label: 'Handel' },
      { id: 'cantina', label: 'Kantyna' },
      { id: 'hangar', label: 'Hangar' },
      { id: 'mechanic', label: 'Mechanik' },
      { id: 'infrastructure', label: 'Infrastruktura' },
    ];

    const MARKET = { // ceny przyk≈Çadowe
      buy: { ruda: 22, paliwo: 15, ≈ºywno≈õƒá: 8 },
      sell: { ruda: 18, paliwo: 12, ≈ºywno≈õƒá: 6 }
    };
    const RESOURCE_SVGS = {
      gas: '<svg viewBox="0 0 24 24" fill="none"><path d="M12 3c-3.2 3.5-5 6.3-5 9a5 5 0 1010 0c0-2.7-1.8-5.5-5-9z" fill="#22d3ee" stroke="#67e8f9" stroke-width="1.5"/><circle cx="12" cy="13" r="2.6" fill="#0ea5e9" stroke="#bae6fd" stroke-width="0.8" opacity="0.9"/></svg>',
      fuel: '<svg viewBox="0 0 24 24" fill="none"><path d="M12 4c1.5 2 4 4.5 4 7.5A4.5 4.5 0 0112 16a4.5 4.5 0 01-4-4.5c0-1.6.5-3.3 1.7-5.1L12 4z" fill="#f97316" stroke="#fdba74" stroke-width="1.4"/><path d="M11.2 9.8c-.6.7-.9 1.4-.9 2.2 0 1.4 1 2.4 2.2 2.4 1.1 0 2-.8 2.2-2" stroke="#fff7ed" stroke-width="1.1" stroke-linecap="round"/></svg>',
      rawMetal: '<svg viewBox="0 0 24 24" fill="none"><path d="M12 3 18 7v10l-6 4-6-4V7z" fill="#94a3b8" stroke="#cbd5e1" stroke-width="1.2"/><path d="M12 3v8l6 6" stroke="#e2e8f0" stroke-width="1" stroke-linecap="round"/></svg>',
      refinedMetal: '<svg viewBox="0 0 24 24" fill="none"><rect x="4.5" y="6.5" width="15" height="4" rx="1.2" fill="#d1d5db" stroke="#e5e7eb"/><rect x="6" y="11.5" width="13" height="4" rx="1.2" fill="#cbd5e1" stroke="#e5e7eb"/><rect x="7.5" y="16.5" width="10" height="3" rx="1" fill="#94a3b8" stroke="#cbd5e1"/></svg>'
    };

    const stationOverlayDom = {
      root: document.getElementById('top-drawer'),
      tabs: document.getElementById('station-tabs'),
      title: document.getElementById('station-title'),
      subtitle: document.getElementById('station-subtitle'),
      credits: document.getElementById('station-credits'),
      panels: {
        upgrades: document.getElementById('tab-upgrades'),
        trade: document.getElementById('tab-trade'),
        cantina: document.getElementById('tab-cantina'),
        hangar: document.getElementById('tab-hangar'),
        mechanic: document.getElementById('tab-mechanic-html'),
        infrastructure: document.getElementById('tab-infrastructure-html'),
      }
    };

    const stationOverlayState = {
      built: false,
      activeTab: null,
      stationKey: null
    };

    function createResourceIcon(key) {
      const wrap = document.createElement('span');
      wrap.className = 'resource-icon-wrap';
      wrap.innerHTML = RESOURCE_SVGS[key] || '';
      const svg = wrap.querySelector('svg');
      if (svg) svg.classList.add('resource-icon');
      return wrap;
    }

    function getResourceLabel(key) {
      return ECONOMY_RESOURCES[key]?.label || toTitleCaseFromKey(key);
    }

    function createStationCard({ title, badge, description, meta = [], actions = [], dataset = null }) {
      const card = document.createElement('div');
      card.className = 'station-card-aero';
      if (dataset) {
        for (const [key, val] of Object.entries(dataset)) {
          card.dataset[key] = val;
        }
      }

      const header = document.createElement('div');
      header.className = 'card-header';
      const titleEl = document.createElement('div');
      titleEl.className = 'card-title';
      titleEl.textContent = title;
      header.appendChild(titleEl);
      if (badge) {
        const chip = document.createElement('span');
        chip.className = 'card-badge';
        chip.textContent = badge;
        header.appendChild(chip);
      }
      card.appendChild(header);

      if (description) {
        const desc = document.createElement('p');
        desc.className = 'card-desc';
        desc.textContent = description;
        card.appendChild(desc);
      }

      if (meta.length) {
        const metaEl = document.createElement('div');
        metaEl.className = 'card-desc';
        metaEl.dataset.cardMeta = 'true';
        metaEl.innerHTML = meta.map(text => `<div>${text}</div>`).join('');
        card.appendChild(metaEl);
      }

      if (actions.length) {
        const actionsEl = document.createElement('div');
        actionsEl.className = 'card-actions';
        actions.forEach(action => {
          const btn = document.createElement('button');
          btn.textContent = action.label;
          if (action.dataset) {
            for (const [k, v] of Object.entries(action.dataset)) {
              btn.dataset[k] = v;
            }
          }
          if (typeof action.disabled === 'boolean') btn.disabled = action.disabled;
          btn.addEventListener('click', action.onClick);
          actionsEl.appendChild(btn);
        });
        card.appendChild(actionsEl);
      }

      return card;
    }

    function initStationOverlayTabs() {
      if (!stationOverlayDom.tabs) return;
      stationOverlayDom.tabs.innerHTML = '';
      for (const tab of STATION_TAB_CONFIG) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'station-tab-btn';
        btn.dataset.tab = tab.id;
        btn.textContent = tab.label;
        btn.addEventListener('click', () => {
          stationUI.tab = tab.id;
          renderStationUI();
        });
        stationOverlayDom.tabs.appendChild(btn);
      }
    }

    function buildUpgradesPanel() {
      const pane = stationOverlayDom.panels.upgrades;
      if (!pane) return;
      pane.innerHTML = '';
      for (const upgrade of BLUEPRINTS.upgrades) {
        const card = createStationCard({
          title: upgrade.name,
          badge: 'Upgrade',
          description: 'Ulepszenie statku instalowane przez warsztat stacji.',
          meta: [`Koszt: ${upgrade.cost} cr`],
          actions: [{
            label: 'Kup',
            dataset: { upgradeId: upgrade.id, cost: upgrade.cost },
            onClick: () => purchaseUpgrade(upgrade)
          }]
        });
        pane.appendChild(card);
      }
    }

    function buildTradePanel() {
      const pane = stationOverlayDom.panels.trade;
      if (!pane) return;
      pane.innerHTML = '';

      const resourcesCard = document.createElement('div');
      resourcesCard.className = 'station-card-aero trade-resource-card';

      const resHeader = document.createElement('div');
      resHeader.className = 'card-header';
      const resTitle = document.createElement('div');
      resTitle.className = 'card-title';
      resTitle.textContent = 'Magazyny i produkcja';
      resHeader.appendChild(resTitle);
      const resBadge = document.createElement('span');
      resBadge.className = 'card-badge';
      resBadge.textContent = 'Trade';
      resHeader.appendChild(resBadge);
      resourcesCard.appendChild(resHeader);

      const resDesc = document.createElement('p');
      resDesc.className = 'card-desc';
      resDesc.textContent = 'Aktualny stan surowc√≥w na orbicie planety.';
      resourcesCard.appendChild(resDesc);

      const resMeta = document.createElement('div');
      resMeta.className = 'card-desc';
      const resNote = document.createElement('span');
      resNote.className = 'trade-resource-note';
      resNote.textContent = 'Magazyny stacji orbitalnej.';
      resMeta.appendChild(resNote);
      resourcesCard.appendChild(resMeta);

      const resTable = document.createElement('table');
      resTable.className = 'trade-resource-table';
      for (const key of ECONOMY_RESOURCE_KEYS) {
        const row = document.createElement('tr');
        row.dataset.resourceKey = key;
        const labelCell = document.createElement('td');
        labelCell.className = 'trade-resource-label';
        labelCell.appendChild(createResourceIcon(key));
        const label = document.createElement('span');
        label.textContent = getResourceLabel(key);
        labelCell.appendChild(label);
        const values = document.createElement('td');
        values.className = 'trade-resource-values';
        const amount = document.createElement('span');
        amount.dataset.field = 'amount';
        amount.className = 'trade-resource-amount';
        amount.textContent = '0';
        const cap = document.createElement('span');
        cap.dataset.field = 'capacity';
        cap.className = 'trade-resource-capacity';
        cap.textContent = '0';
        values.appendChild(amount);
        values.append(' / ');
        values.appendChild(cap);
        row.appendChild(labelCell);
        row.appendChild(values);
        resTable.appendChild(row);
      }
      resourcesCard.appendChild(resTable);
      pane.appendChild(resourcesCard);
      const allItems = new Set([...Object.keys(MARKET.buy), ...Object.keys(MARKET.sell)]);
      for (const item of allItems) {
        const buyPrice = MARKET.buy[item];
        const sellPrice = MARKET.sell[item];
        const card = createStationCard({
          title: toTitleCaseFromKey(item),
          badge: 'Rynek',
          description: 'Handluj surowcami z dokami stacji.',
          meta: [
            buyPrice ? `Kupno: ${buyPrice} cr` : 'Kupno: niedostƒôpne',
            sellPrice ? `Sprzeda≈º: ${sellPrice} cr` : 'Sprzeda≈º: niedostƒôpna',
            `≈Åadownia: ${PLAYER.cargo[item] || 0}`
          ],
          dataset: { tradeCard: 'market', tradeItem: item },
          actions: [
            buyPrice ? {
              label: 'Kup',
              dataset: { tradeItem: item, tradeType: 'buy', price: buyPrice },
              onClick: () => handleTrade('buy', item, buyPrice)
            } : null,
            sellPrice ? {
              label: 'Sprzedaj',
              dataset: { tradeItem: item, tradeType: 'sell', price: sellPrice },
              onClick: () => handleTrade('sell', item, sellPrice)
            } : null
          ].filter(Boolean)
        });
        pane.appendChild(card);
      }
    }

    function buildCantinaPanel() {
      const pane = stationOverlayDom.panels.cantina;
      if (!pane) return;
      pane.innerHTML = '';
      pane.appendChild(createStationCard({
        title: 'Najemnik: piracka stacja',
        badge: 'Misja',
        description: 'Odbierz kontrakt na zniszczenie pirackiej plac√≥wki w pobliskim sektorze.',
        meta: ['Nagrody za eliminacjƒô wrog√≥w'],
        actions: [{ label: 'Przyjmij', onClick: startMercenaryMission }]
      }));
      pane.appendChild(createStationCard({
        title: 'Wojna o terytorium',
        badge: 'Misja',
        description: 'Do≈ÇƒÖcz do si≈Ç sojuszniczych i odbij punkt kontrolny z rƒÖk pirat√≥w.',
        meta: ['Aktywuje wrogie fale w sektorze'],
        actions: [{ label: 'Do≈ÇƒÖcz', onClick: startTerritoryWarMission }]
      }));
    }

    function buildHangarPanel() {
      const pane = stationOverlayDom.panels.hangar;
      if (!pane) return;
      pane.innerHTML = '';

      const repairCard = createStationCard({
        title: 'Naprawy kad≈Çuba',
        badge: 'Serwis',
        description: 'Przywr√≥ƒá kad≈Çub statku do pe≈Çnej sprawno≈õci.',
        meta: ['Status: 0% uszkodze≈Ñ'],
        actions: [{ label: 'Napraw', dataset: { action: 'repair' }, onClick: handleRepair }]
      });
      pane.appendChild(repairCard);

      for (const shipBP of BLUEPRINTS.ships) {
        const card = createStationCard({
          title: shipBP.name,
          badge: 'Hangar',
          description: 'Zam√≥w nowƒÖ ramƒô statku i prze≈Çaduj systemy.',
          meta: [
            `Koszt: ${shipBP.cost} cr`,
            `Kad≈Çub: ${Math.round(shipBP.stats.hp * 100)}%`,
            `Prƒôdko≈õƒá: ${Math.round(shipBP.stats.speed * 100)}%`
          ],
          actions: [{
            label: 'Kup',
            dataset: { shipId: shipBP.id, cost: shipBP.cost },
            onClick: () => purchaseShip(shipBP)
          }]
        });
        pane.appendChild(card);
      }
    }

    function buildMechanicPanel() {
      const pane = stationOverlayDom.panels.mechanic;
      if (!pane) return;

      // Wstrzykujemy strukturƒô HTML warsztatu bezpo≈õrednio do zak≈Çadki
      pane.innerHTML = `
    <div class="mechanic-toolbar">
      <label>Rama statku:</label>
      <select id="ship-frame-select" style="margin-left:8px; width:200px; background:#060e1c; color:#fff; border:1px solid #2a3a5a; padding:4px; border-radius:4px;"></select>
    </div>
    <div class="mechanic-body" style="margin-top:12px;">
      <div class="mechanic-column mechanic-parts">
        <div class="mechanic-section">
          <div class="mechanic-section-head">
            <div>
              <p class="mechanic-kicker">Dostƒôpne czƒô≈õci</p>
              <h4>Magazyn broni</h4>
              <p class="mechanic-sub">PrzeciƒÖgnij bro≈Ñ na slot hardpointu, aby jƒÖ zamontowaƒá.</p>
            </div>
          </div>
          <div class="mechanic-tabs" id="weapon-filter-tabs">
            <button class="mechanic-tab-btn" data-filter="all">Wszystkie</button>
            <button class="mechanic-tab-btn" data-filter="main">Bro≈Ñ g≈Ç√≥wna</button>
            <button class="mechanic-tab-btn" data-filter="missile">Rakiety</button>
            <button class="mechanic-tab-btn" data-filter="aux">Bro≈Ñ dodatkowa</button>
          </div>
          <div id="mechanic-available" class="weapon-pool"></div>
        </div>
      </div>
      <div class="mechanic-column mechanic-install">
        <div class="mechanic-section">
          <div class="mechanic-section-head">
            <div>
              <p class="mechanic-kicker">Uzbrojenie statku</p>
              <h4>Hardpointy</h4>
              <p class="mechanic-sub">Upu≈õƒá czƒô≈õƒá na slot po prawej, aby zamieniƒá uzbrojenie.</p>
            </div>
          </div>
          <div class="mechanic-tabs" id="hp-filter-tabs">
            <button class="mechanic-tab-btn" data-filter="all">Wszystkie</button>
            <button class="mechanic-tab-btn" data-filter="main">Bro≈Ñ g≈Ç√≥wna</button>
            <button class="mechanic-tab-btn" data-filter="missile">Rakiety</button>
            <button class="mechanic-tab-btn" data-filter="aux">Bro≈Ñ dodatkowa</button>
          </div>
          <div id="hp-groups" class="hp-groups mechanic-grid"></div>
        </div>
      </div>
    </div>
  `;

      // Inicjalizacja listy wyboru statku (poniewa≈º w≈Ça≈õnie stworzyli≈õmy element select)
      const sel = document.getElementById('ship-frame-select');
      if (sel) {
        sel.innerHTML = Object.values(SHIPS).map(s =>
          `<option value="${s.id}" ${Game.player.shipFrame === s.id ? 'selected' : ''}>${s.name}</option>`
        ).join('');

        sel.onchange = () => {
          Game.player.shipFrame = sel.value;
          // Przelicz hardpointy dla nowej ramy
          const prev = Game.player.hardpoints.map(h => ({ type: h.type, mount: h.mount, ammo: h.ammo, maxAmmo: h.maxAmmo }));
          if (typeof rebuildHardpointsForFrame === 'function') rebuildHardpointsForFrame();
          if (typeof tryPreserveMounts === 'function') tryPreserveMounts(prev);
          if (typeof syncWeaponSystems === 'function') syncWeaponSystems();
          renderMechanic();
          if (typeof saveLoadout === 'function') saveLoadout();
        };
      }

      initMechanicFilter('weapon-filter-tabs', () => mechanicWeaponFilter, (val) => { mechanicWeaponFilter = val; });
      initMechanicFilter('hp-filter-tabs', () => mechanicHardpointFilter, (val) => { mechanicHardpointFilter = val; });

      // Wymu≈õ renderowanie zawarto≈õci (ikony broni i sloty)
      renderMechanic();
    }

    function buildInfrastructurePanel() {
      const pane = stationOverlayDom.panels.infrastructure;
      if (!pane) return;
      pane.innerHTML = '';
      pane.appendChild(createStationCard({
        title: 'Infrastruktura stacji',
        badge: 'Budowa',
        description: 'PrzeciƒÖgaj budynki na siatkƒô infrastruktury, aby rozwijaƒá stacjƒô.',
        meta: ['Skr√≥t klawiatury: [6]'],
        actions: [{
          label: 'Otw√≥rz budowƒô',
          onClick: () => {
            stationUI.tab = 'infrastructure';
            setInfrastructureUIVisible(true);
            renderStationUI();
          }
        }]
      }));
    }

    function initStationOverlay() {
      if (!stationOverlayDom.root) return;
      initStationOverlayTabs();
      buildUpgradesPanel();
      buildTradePanel();
      buildCantinaPanel();
      buildHangarPanel();
      buildMechanicPanel();
      buildInfrastructurePanel();
      stationOverlayState.built = true;
    }

    function updateStationHeader(station) {
      if (stationOverlayDom.title) {
        stationOverlayDom.title.textContent = station?.name || 'Stacja orbitalna';
      }
      if (stationOverlayDom.subtitle) {
        const parts = [];
        if (station?.planet?.name) parts.push(`Orbita: ${station.planet.name}`);
        if (Number.isFinite(station?.x) && Number.isFinite(station?.y)) {
          parts.push(`Pozycja: ${Math.round(station.x)}, ${Math.round(station.y)}`);
        }
        stationOverlayDom.subtitle.textContent = parts.join(' ‚Ä¢ ') || 'Przestrze≈Ñ cywilna';
      }
      if (stationOverlayDom.credits) {
        stationOverlayDom.credits.textContent = `${Math.round(PLAYER.credits)} CR`;
      }
    }

    function setActiveStationTab(tab) {
      if (stationOverlayDom.tabs) {
        stationOverlayDom.tabs.querySelectorAll('.station-tab-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.tab === tab);
        });
      }
      for (const [key, pane] of Object.entries(stationOverlayDom.panels)) {
        if (!pane) continue;
        const match = key === tab;
        pane.classList.toggle('active', match);
        pane.classList.toggle('hidden', !match);
      }
    }

    function updateUpgradeButtons() {
      const buttons = stationOverlayDom.panels.upgrades?.querySelectorAll('button[data-upgrade-id]');
      if (!buttons) return;
      buttons.forEach(btn => {
        const cost = Number(btn.dataset.cost) || 0;
        btn.disabled = PLAYER.credits < cost;
      });
    }

    function updateTradeResourceTable(station) {
      const pane = stationOverlayDom.panels.trade;
      if (!pane) return;
      const table = pane.querySelector('.trade-resource-table');
      if (!table) return;
      const econ = station ? ensureStationEconomy(station) : null;
      if (!econ) return;
      table.querySelectorAll('tr[data-resource-key]').forEach(row => {
        const key = row.dataset.resourceKey;
        const amountEl = row.querySelector('[data-field="amount"]');
        const capEl = row.querySelector('[data-field="capacity"]');
        if (amountEl) amountEl.textContent = `${Math.round(econ.resources?.[key] ?? 0)}`;
        if (capEl) capEl.textContent = `${Math.round(econ.capacity?.[key] ?? 0)}`;
      });
      const note = pane.querySelector('.trade-resource-note');
      if (note) {
        const label = station?.planet?.name || station?.name;
        note.textContent = label ? `Magazyny: ${label}` : 'Magazyny stacji orbitalnej.';
      }
    }

    function updateTradeCards(station) {
      updateTradeResourceTable(station);
      const cards = stationOverlayDom.panels.trade?.querySelectorAll('.station-card-aero[data-trade-card="market"]');
      if (!cards) return;
      cards.forEach(card => {
        const item = card.dataset.tradeItem
          || card.querySelector('[data-trade-item]')?.dataset.tradeItem
          || card.querySelector('button[data-trade-item]')?.dataset.tradeItem;
        if (!item) return;
        const meta = card.querySelector('[data-card-meta="true"]');
        if (meta) {
          const metaLines = [...meta.querySelectorAll('div')];
          if (metaLines[2]) metaLines[2].textContent = `≈Åadownia: ${PLAYER.cargo[item] || 0}`;
        }
        card.querySelectorAll('button[data-trade-type]').forEach(btn => {
          const price = Number(btn.dataset.price) || 0;
          const type = btn.dataset.tradeType;
          if (type === 'buy') {
            btn.disabled = PLAYER.credits < price;
          }
          if (type === 'sell') {
            btn.disabled = (PLAYER.cargo[item] || 0) <= 0;
          }
        });
      });
    }

    function updateHangarCards() {
      const pane = stationOverlayDom.panels.hangar;
      if (!pane) return;
      const cards = [...pane.querySelectorAll('.station-card-aero')];
      const damageFrac = 1 - (ship.hull.val / ship.hull.max);
      const damagePct = Math.ceil(damageFrac * 100);
      const repairCost = Math.ceil(damageFrac * 600);
      const repairCard = cards.find(card => card.querySelector('button[data-action="repair"]'));
      if (repairCard) {
        const meta = repairCard.querySelector('[data-card-meta="true"] div');
        if (meta) meta.textContent = `Status: ${damagePct}% uszkodze≈Ñ`;
        const btn = repairCard.querySelector('button[data-action="repair"]');
        if (btn) btn.disabled = damagePct <= 0 || PLAYER.credits < repairCost;
      }
      for (const btn of pane.querySelectorAll('button[data-ship-id]')) {
        const cost = Number(btn.dataset.cost) || 0;
        btn.disabled = PLAYER.credits < cost;
      }
    }

    function renderStationOverlay(tab, station) {
      if (!stationOverlayState.built) initStationOverlay();
      if (!stationOverlayDom.root) return;
      const stationKey = getInfrastructureStationKey(station) || station?.name || 'station';
      if (stationOverlayState.activeTab !== tab || stationOverlayState.stationKey !== stationKey) {
        setActiveStationTab(tab);
        stationOverlayState.activeTab = tab;
        stationOverlayState.stationKey = stationKey;
      }
      updateStationHeader(station);
      updateUpgradeButtons();
      updateTradeCards(station);
      updateHangarCards();
    }

    function handleTrade(type, item, price) {
      if (type === 'buy') {
        if (PLAYER.credits >= price) {
          PLAYER.credits -= price;
          PLAYER.cargo[item] = (PLAYER.cargo[item] || 0) + 1;
        } else {
          toast('Za ma≈Ço kredyt√≥w');
        }
      } else if (type === 'sell') {
        if ((PLAYER.cargo[item] || 0) > 0) {
          PLAYER.cargo[item] -= 1;
          PLAYER.credits += price;
        }
      }
      updateStationOverlay(stationUI.tab, stationUI.station);
    }

    function purchaseUpgrade(upgrade) {
      if (!upgrade) return;
      if (PLAYER.credits >= upgrade.cost) {
        PLAYER.credits -= upgrade.cost;
        upgrade.apply();
        toast('Zainstalowano: ' + upgrade.name);
      } else {
        toast('Za ma≈Ço kredyt√≥w');
      }
      updateStationOverlay(stationUI.tab, stationUI.station);
    }

    function purchaseShip(shipBP) {
      if (!shipBP) return;
      if (PLAYER.credits >= shipBP.cost) {
        PLAYER.credits -= shipBP.cost;
        PLAYER.shipId = shipBP.id;
        applyShipStats(shipBP.stats);
        toast('Zakupiono: ' + shipBP.name);
      } else {
        toast('Za ma≈Ço kredyt√≥w');
      }
      updateStationOverlay(stationUI.tab, stationUI.station);
    }

    function handleRepair() {
      const damageFrac = 1 - (ship.hull.val / ship.hull.max);
      const repairCost = Math.ceil(damageFrac * 600);
      if (damageFrac <= 0) {
        toast('Kad≈Çub jest w pe≈Çni sprawny');
        return;
      }
      if (PLAYER.credits >= repairCost) {
        PLAYER.credits -= repairCost;
        ship.hull.val = ship.hull.max;
        toast('Naprawiono kad≈Çub.');
      } else {
        toast('Za ma≈Ço kredyt√≥w');
      }
      updateStationOverlay(stationUI.tab, stationUI.station);
    }

    function updateStationOverlay(tab, station) {
      renderStationOverlay(tab, station);
    }

    initMechanicUI();
    initInfrastructureUI();
    autopopulateDefaultInfrastructure();
    function startMercenaryMission() {
      if (mercMission) { toast('Misja ju≈º aktywna. Wci≈õnij J aby zobaczyƒá dziennik.'); return; }

      const beltTarget = (() => {
        if (!ASTEROID_BELT) return null;
        const inner = ASTEROID_BELT.inner;
        if (!Number.isFinite(inner)) return null;
        const safeMargin = Math.max(1200, ZONE_APPROACH_DISTANCE * 0.6);
        const radius = Math.max(500, inner - safeMargin);
        return { radius, angle: Math.random() * Math.PI * 2 };
      })();

      const earth = planets.find(p => p.id === 'earth' || p.name === 'earth');
      const targetPlanet = earth || planets[2] || planets[0];
      const earthOrbit = targetPlanet ? planetOrbitRadii(targetPlanet) : null;

      const orbitRadius = beltTarget?.radius
        ?? earthOrbit?.outer
        ?? Math.max(1600, (targetPlanet?.r || 0) * 4);
      const angle = beltTarget?.angle ?? (Math.random() * Math.PI * 2);
      const centerX = beltTarget ? SUN.x : (targetPlanet?.x || SUN.x);
      const centerY = beltTarget ? SUN.y : (targetPlanet?.y || SUN.y);
      const x = centerX + Math.cos(angle) * orbitRadius;
      const y = centerY + Math.sin(angle) * orbitRadius;

      const r = 220;
      const portOffset = r + 60;
      const ports = [
        { x: portOffset, y: 0 },
        { x: 0, y: portOffset },
        { x: -portOffset, y: 0 },
        { x: 0, y: -portOffset }
      ];

      const station = {
        id: 'PIR',
        x, y, r,
        baseR: r,
        isPirate: true,
        hp: 10000, maxHp: 10000,
        static: true, mission: true,
        ports,
        style: STATION_STYLES[Math.floor(Math.random() * STATION_STYLES.length)],
        shield: {
          max: 9000,
          val: 9000,
          regenRate: 650,
          regenDelay: 4.5,
          regenTimer: 0
        }
      };

      stations.push(station);
      if (typeof window.attachPirateStation3D === 'function') {
        if (!mainScene3D && typeof window.initWorld3D === 'function') {
          const res = initWorld3D();
          mainScene3D = res?.scene || mainScene3D;
        }
        window.attachPirateStation3D(mainScene3D, station);
      }
      mercMission = {
        station,
        npcsSpawned: false,
        alertStage: 'idle',
        guardConfigured: false,
        weaponPlatforms: [],
        // --- SWARM control ---
        swarm: {
          active: false,
          maxAlive: 200,     // <- zwiƒôkszony limit
          timer: 2,
          baseInterval: 1.0, // skraca siƒô wraz z utratƒÖ HP stacji
          queue: []
        }
      };

      mercMission.guards = [];

      // 1. Eskadra Interceptor√≥w (6 sztuk)
      // U≈ºywamy nowej funkcji: tworzy eskadrƒô, kt√≥ra orbituje (mode='guard')
      spawnPirateSquad(station, 'interceptor', 6, 'guard', {
        radius: station.r + 320,
        speed: 0.45
      });

      // 2. Fregaty (2 sztuki)
      // Du≈ºe statki spawnujemy osobno, ≈ºeby nie lata≈Çy "na ogonie" lidera jak my≈õliwce,
      // tylko dostojnie krƒÖ≈ºy≈Çy po dalszej orbicie.
      const frigateTypes = ['frigate_pd', 'frigate_laser']; // R√≥≈ºne typy dla urozmaicenia

      for (let i = 0; i < 2; i++) {
        const type = frigateTypes[i % frigateTypes.length];
        const npc = spawnPirate(type, station); // U≈ºywamy g≈Ç√≥wnego spawnera

        // Konfiguracja orbitowania (Guard)
        npc.state = 'guard';
        npc.guardStation = station;
        npc.guardOrbitRadius = station.r + 550; // Dalsza orbita
        npc.guardOrbitSpeed = (i === 0 ? 1 : -1) * 0.15; // LecƒÖ w przeciwnych kierunkach
        npc.guardPhase = i * Math.PI; // StartujƒÖ po przeciwnych stronach (0 i 180 stopni)

        // Pozycja startowa na orbicie (≈ºeby nie dolatywa≈Çy z ≈õrodka)
        npc.x = station.x + Math.cos(npc.guardPhase) * npc.guardOrbitRadius;
        npc.y = station.y + Math.sin(npc.guardPhase) * npc.guardOrbitRadius;
        npc.angle = npc.guardPhase + (npc.guardOrbitSpeed > 0 ? Math.PI / 2 : -Math.PI / 2);

        mercMission.guards.push(npc);
      }
      if (typeof window.resetSwarmQueue === 'function') {
        window.resetSwarmQueue();
      }

      // Zapis do dziennika + koordy do markera mapy
      const exists = MISSIONS.active.find(m => m.id === 'merc_pirate_station' && m.status === 'active');
      if (!exists) {
        MISSIONS.active.push({
          id: 'merc_pirate_station',
          title: 'Najemnik: piracka stacja',
          type: 'mercenary',
          stationId: station.id,
          pos: { x, y },
          status: 'active'
        });
      }

      toast('Misja najemnik rozpoczƒôta. Wci≈õnij M aby otworzyƒá mapƒô ‚Äî cel oznaczony X. Dziennik: J.');
    }

    function spawnWeaponPlatform(station, config = {}) {
      const radius = config.radius ?? 52;
      const canvasSize = Math.max(64, Math.ceil(radius * 2.6));
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = canvasSize;
      const ctxPlatform = canvas.getContext('2d');
      const center = canvasSize / 2;

      // baza platformy
      const baseR = canvasSize * 0.38;
      const outerR = canvasSize * 0.46;
      const innerR = canvasSize * 0.18;
      const glowGrad = ctxPlatform.createRadialGradient(center, center, innerR, center, center, outerR);
      glowGrad.addColorStop(0, 'rgba(120,180,255,0.4)');
      glowGrad.addColorStop(1, 'rgba(0,20,40,0.02)');
      ctxPlatform.fillStyle = glowGrad;
      ctxPlatform.beginPath(); ctxPlatform.arc(center, center, outerR, 0, Math.PI * 2); ctxPlatform.fill();

      ctxPlatform.fillStyle = '#1c2338';
      ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR, 0, Math.PI * 2); ctxPlatform.fill();

      const plateGrad = ctxPlatform.createRadialGradient(center, center, innerR * 0.4, center, center, baseR);
      plateGrad.addColorStop(0, '#6f87c8');
      plateGrad.addColorStop(0.6, '#3c4f7a');
      plateGrad.addColorStop(1, '#2a3556');
      ctxPlatform.fillStyle = plateGrad;
      ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR * 0.88, 0, Math.PI * 2); ctxPlatform.fill();

      ctxPlatform.strokeStyle = 'rgba(184,196,255,0.28)';
      ctxPlatform.lineWidth = Math.max(1.5, canvasSize * 0.02);
      ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR * 0.72, 0, Math.PI * 2); ctxPlatform.stroke();

      ctxPlatform.strokeStyle = 'rgba(62,112,182,0.65)';
      ctxPlatform.lineWidth = Math.max(1.2, canvasSize * 0.015);
      ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR * 0.52, 0, Math.PI * 2); ctxPlatform.stroke();

      ctxPlatform.fillStyle = '#182030';
      ctxPlatform.beginPath(); ctxPlatform.arc(center, center, innerR, 0, Math.PI * 2); ctxPlatform.fill();

      ctxPlatform.fillStyle = '#93b6ff';
      for (let i = 0; i < 6; i++) {
        const a = (i / 6) * Math.PI * 2;
        const slotR = innerR * 1.35;
        const px = center + Math.cos(a) * slotR;
        const py = center + Math.sin(a) * slotR;
        ctxPlatform.save();
        ctxPlatform.translate(px, py);
        ctxPlatform.rotate(a);
        ctxPlatform.fillRect(-canvasSize * 0.02, -canvasSize * 0.09, canvasSize * 0.04, canvasSize * 0.18);
        ctxPlatform.restore();
      }

      ctxPlatform.strokeStyle = 'rgba(255,255,255,0.35)';
      ctxPlatform.lineWidth = Math.max(1.0, canvasSize * 0.01);
      ctxPlatform.beginPath(); ctxPlatform.arc(center, center, innerR * 0.65, 0, Math.PI * 2); ctxPlatform.stroke();

      const orbitRadius = config.orbitRadius ?? (station.r + 220 + Math.random() * 120);
      const orbitSpeed = config.orbitSpeed ?? ((Math.random() < 0.5 ? -1 : 1) * (0.14 + Math.random() * 0.07));
      const angle = config.angle ?? (Math.random() * Math.PI * 2);
      const hpMax = config.hp ?? 1800;
      const shieldMax = (config.shield && config.shield.max) || config.shieldMax || 720;
      const shieldRegen = (config.shield && config.shield.regenRate) || config.shieldRegen || 240;
      const shieldDelay = (config.shield && config.shield.regenDelay) || config.shieldDelay || 3.5;
      const missileCd = config.missileCd ?? (3.2 + Math.random() * 0.6);
      const railCd = config.railCd ?? (1.2 + Math.random() * 0.4);

      const platform = {
        id: config.id || uid(),
        type: 'weapon_platform',
        label: config.label || 'Platforma',
        station,
        radius,
        canvas,
        orbitRadius,
        orbitSpeed,
        angle,
        rotation: Math.random() * Math.PI * 2,
        spin: config.spin ?? (Math.random() * 0.6 - 0.3),
        hp: hpMax,
        maxHp: hpMax,
        shield: (shieldMax > 0) ? { max: shieldMax, val: shieldMax, regenRate: shieldRegen, regenDelay: shieldDelay, regenTimer: 0 } : null,
        rail: { cd: railCd * Math.random(), cdMax: railCd, scatter: config.railScatter ?? 0.04, damage: config.railDamage ?? 60 },
        missile: { cd: missileCd * Math.random(), cdMax: missileCd, damage: config.missileDamage ?? SIDE_BULLET_DAMAGE },
        hitFlash: 0,
        destroyed: false,
        deathTimer: 0,
        removed: false
      };

      platform.x = station.x + Math.cos(angle) * orbitRadius;
      platform.y = station.y + Math.sin(angle) * orbitRadius;

      return platform;
    }

    function resetMercMission() {
      if (!mercMission) return;
      if (mercMission.weaponPlatforms) {
        mercMission.weaponPlatforms.length = 0;
      }
      mercMission = null;
    }
    function startTerritoryWarMission() { toast('Do≈ÇƒÖczono do wojny terytorialnej'); }

    function renderOptions() {
      if (!OPTIONS_OPEN) return;
      hudBeginPanel();
      uiTitle('Opcje');

      // --- NOWE: Wyb√≥r jako≈õci t≈Ça ---
      uiQualitySelector();
      // ------------------------------
      slider('VFX: temperatura (K)', 1000, 20000, 500, OPTIONS.vfx, 'colorTempK');
      slider('VFX: bloom', 0.2, 2.5, 0.05, OPTIONS.vfx, 'bloomGain');
      slider('VFX: silnik (g≈Ço≈õno≈õƒá)', 0, 1.5, 0.05, OPTIONS.vfx, 'engineGain');
      slider('Audio: master', 0, 1, 0.05, OPTIONS.audio, 'master');
      slider('Audio: SFX', 0, 1, 0.05, OPTIONS.audio, 'sfx');
      slider('Audio: muzyka', 0, 1, 0.05, OPTIONS.audio, 'music');
      slider('Mysz: czu≈Ço≈õƒá', 0.3, 2.0, 0.05, OPTIONS.controls, 'mouseSensitivity');
      // brak opcji odwr√≥cenia osi zgodnie z pro≈õbƒÖ
      hudEndPanel();
    }

    function renderMissionJournal() {
      if (!MISSIONS.show) return;
      const w = 420, h = 260;
      const x = (W - w) / 2, y = 60;
      hudBeginPanel(x, y, w, h);
      uiTitle('Dziennik misji [J]');
      if (MISSIONS.active.length === 0) {
        uiText('Brak przyjƒôtych misji.');
      } else {
        for (const m of MISSIONS.active) {
          const status = m.status === 'active' ? 'AKTYWNA' : 'ZAKO≈ÉCZONA';
          uiText(`${m.title} ‚Äî ${status}`);
        }
      }
      hudEndPanel();
    }

    function spawnLaserBeam(start, end, width, opts = {}) {
      const p = particlePool[nextParticleIndex];
      p.pos.x = start.x;
      p.pos.y = start.y;
      p.vel.x = 0;
      p.vel.y = 0;
      p.life = (opts && opts.life != null) ? opts.life : 0.12;
      p.age = 0;
      p.flash = false;
      p.beam = true;
      p.start.x = start.x;
      p.start.y = start.y;
      p.end.x = end.x;
      p.end.y = end.y;
      p.width = width;
      p.alpha = opts?.alpha ?? 1;
      p.fadeWithLife = (opts && Object.prototype.hasOwnProperty.call(opts, 'fadeWithLife')) ? opts.fadeWithLife : undefined;
      p.colorOuter = opts?.colorOuter ?? null;
      p.colorInner = opts?.colorInner ?? null;
      p.glowColor = opts?.glowColor ?? null;
      p.glowBlur = opts?.glowBlur ?? 0;
      p.outerWidthMul = opts?.outerWidthMul ?? 1;
      p.innerWidthMul = opts?.innerWidthMul ?? 1;
      p.size = 0;
      p.color = '#fff';
      p.active = true;
      nextParticleIndex = (nextParticleIndex + 1) % MAX_PARTICLES;
    }

    // =============== Input ===============
    const input = { main: 0, leftSide: 0, rightSide: 0, torque: 0 };
    const enginePower = { target: 0, current: 0 };
    const ENGINE_TARGET_RATE = 2.4; // 0..1 na sekundƒô (szybka regulacja)
    const ENGINE_RESPONSE_RATE = 1.6; // jak szybko aktualna moc dogania target
    const keys = {};
    let showMap = false;
    let shiftBinding = null;
    const mapView = {
      zoom: 1,
      targetZoom: 1,
      minZoom: 0.6,
      maxZoom: 6,
      viewX: null,
      viewY: null,
      smoothness: 0.15,
      followShip: true,
      dragging: false,
      layout: null,
    };
    let PAUSED = false;
    let lastCameraModeBeforePause = null;

    function setPaused(state) {
      const next = !!state;
      if (next === PAUSED) return;
      PAUSED = next;
      if (PAUSED) {
        lastCameraModeBeforePause = camera.mode;
        if (camera.mode !== 'free') camera.enterFreeMode();
      } else {
        if (lastCameraModeBeforePause && lastCameraModeBeforePause !== 'free') {
          camera.exitFreeMode();
        }
        lastCameraModeBeforePause = null;
      }
    }

    function togglePause() {
      setPaused(!PAUSED);
    }

    window.addEventListener('keydown', e => {
      if (e.code !== 'Escape') return;
      if (stationUI.open) return;
      if (!gameStarted) {
        showMainMenu('home');
        return;
      }
      toggleMainMenu();
    });

    function currentShiftMode() {
      return isPlanetOrbitZoneId(zoneState.current?.id) ? 'boost' : 'warp';
    }

    function activateBoostIfAllowed() {
      if (!isPlanetOrbitZoneId(zoneState.current?.id)) return false;
      if (boost.fuel > 0) {
        boost.state = 'active';
        return true;
      }
      return false;
    }

    function stopBoost() {
      if (boost.state === 'active') {
        boost.state = 'idle';
      }
    }

    function playerHasManualInput() {
      return keys['w'] || keys['s'] || keys['a'] || keys['d'] || keys['q'] || keys['e'];
    }

    function updatePlayerCommand(dt) {
      if (ship.destroyed) return;
      const cmd = ship.command;
      if (!cmd || !cmd.target) return;
      if (PAUSED || warp.state !== 'idle') return;
      if (playerHasManualInput()) { ship.command = null; return; }

      const dx = cmd.target.x - ship.pos.x;
      const dy = cmd.target.y - ship.pos.y;
      const dist = Math.hypot(dx, dy);
      const arrival = cmd.arrival || 90;
      if (dist <= arrival) {
        ship.command = null;
        applyPlayerInput(ship, { controller: 'player', main: 0, thrustY: 0, torque: 0, leftSide: 0, rightSide: 0 }, input);
        return;
      }

      const desiredAng = Math.atan2(dy, dx);
      const angDiff = wrapAngle(desiredAng - ship.angle);
      const torque = clamp(angDiff * 2.2, -1, 1);
      const main = clamp(dist / 800, 0, 1);

      applyPlayerInput(ship, {
        controller: 'player',
        thrustY: main,
        main,
        torque,
        leftSide: 0,
        rightSide: 0
      }, input);
    }

    function handleWarpKeyDown() {
      if (warp.state === 'idle' && (DevFlags.unlimitedWarp || warp.fuel > 0)) {
        warp.state = 'charging';
        warp.charge = 0;
      }
    }

    function handleWarpKeyUp() {
      if (warp.state === 'charging') { warp.state = 'idle'; warp.charge = 0; }
      else if (warp.state === 'active') { warp.state = 'idle'; exitWarp(); }
    }

    function handleShiftDown() {
      if (ship.destroyed) return;
      shiftBinding = currentShiftMode();
      if (shiftBinding === 'boost') {
        activateBoostIfAllowed();
      } else {
        handleWarpKeyDown();
      }
    }

    function handleShiftUp() {
      if (ship.destroyed) return;
      const mode = shiftBinding || currentShiftMode();
      if (mode === 'boost') {
        stopBoost();
      } else {
        handleWarpKeyUp();
      }
      shiftBinding = null;
    }
    window.addEventListener('keydown', e => {
      if (e.repeat) return;
      if (e.code === 'Space') { e.preventDefault(); }
      if (e.code === 'ShiftLeft' || e.code === 'ShiftRight') { e.preventDefault(); }
      if (isMainMenuVisible()) return;
      const k = e.key.toLowerCase();
      keys[k] = true;
      if (k === 'shift') {
        handleShiftDown();
      }
      if (k === 'm') {
        showMap = !showMap;
        if (showMap) {
          mapView.targetZoom = clamp(mapView.targetZoom, mapView.minZoom, mapView.maxZoom);
          mapView.viewX = null;
          mapView.viewY = null;
          mapView.followShip = true;
          mapView.dragging = false;
        } else {
          mapView.dragging = false;
        }
      }
      if (k === 'j') MISSIONS.show = !MISSIONS.show;
      if (k === 'g' && !stationUI.open) {
        camera.toggleFreeMode();
        pushZoneMessage(camera.mode === 'free' ? 'Free camera mode ON' : 'Free camera mode OFF');
      }
      if (k === ' ') {
        togglePause();
        updateInput();
        return;
      }
      if (k === 'x') {
        triggerScanWave();
        hudPingNpcStations();
        togglePlanetRadarVisibility();
      }
      if (k === 'z') {
        if (!(Game.player.weapons?.[HP.HANGAR]?.length)) { toast('Brak dostƒôpnych hangar√≥w.'); return; }
        if (SQUAD.order === 'idle' || SQUAD.list.length === 0) {
          // start + ESKORTA
          SQUAD.list = [];
          for (let i = 0; i < FIGHTERS_PER_LAUNCH; i++) {
            const f = spawnFighter();
            f.formIndex = i;              // <- indeks w formacji
            SQUAD.list.push(f);
          }
          SQUAD.order = 'escort';
          SQUAD.targets = [];
          toast('My≈õliwce: ESKORTA');
        } else if (SQUAD.order === 'escort') {
          SQUAD.targets = pickSquadTargets();
          SQUAD.order = 'attack';
          toast(SQUAD.targets.length ? 'My≈õliwce: ATAK' : 'My≈õliwce: ATAK (brak oznacze≈Ñ ‚Äî wybiorƒÖ najbli≈ºszych)');
        } else if (SQUAD.order === 'attack') {
          SQUAD.order = 'return';
          toast('My≈õliwce: POWR√ìT');
        } else if (SQUAD.order === 'return') {
          SQUAD.order = 'escort';
          SQUAD.targets = [];
          toast('My≈õliwce: ESKORTA');
        }
      }
      if (k === 'r') {
        if (highlightedEnemies.length) {
          lockedTargets = highlightedEnemies.filter(isHostileNpc)
            .sort((a, b) => Math.hypot(a.x - ship.pos.x, a.y - ship.pos.y) - Math.hypot(b.x - ship.pos.x, b.y - ship.pos.y));
          highlightTimer = 0;
          highlightedEnemies = [];
        } else if (scan.scanned && isHostileNpc(scan.scanned)) {
          lockedTarget = scan.scanned;
        } else {
          lockedTarget = null;
        }
      }
      updateInput();
    });
    window.addEventListener('keyup', e => {
      const k = e.key.toLowerCase();
      keys[k] = false;
      if (k === 'shift') {
        handleShiftUp();
      }
      updateInput();
    });
    function updateInput() {
      if (ship.destroyed) {
        applyPlayerInput(ship, { controller: 'player', main: 0, thrustX: 0, thrustY: 0, leftSide: 0, rightSide: 0, torque: 0 }, input);
        return;
      }
      const leftSide = keys['e'] ? 1 : 0;
      const rightSide = keys['q'] ? 1 : 0;
      let torque = 0; if (keys['a']) torque -= 1; if (keys['d']) torque += 1;
      applyPlayerInput(ship, {
        controller: 'player',
        thrustX: torque,
        thrustY: input.main,
        main: input.main,
        leftSide,
        rightSide,
        torque
      }, input);
      if (keys['f']) tryFireSpecial();
    }

    function approachValue(current, target, delta) {
      if (current < target) return Math.min(target, current + delta);
      if (current > target) return Math.max(target, current - delta);
      return target;
    }

    function updateEnginePower(dt) {
      if (ship.destroyed) {
        enginePower.target = 0;
        enginePower.current = 0;
        input.main = 0;
        return;
      }
      const manualInput = playerHasManualInput();
      if (ship.command && !manualInput) {
        enginePower.target = clamp(input.main, 0, 1);
        enginePower.current = enginePower.target;
        return;
      }
      
      // ZMIANA: Reaktywny pasek mocy (zamiast tempomatu)
      // W = 100% mocy, S = 40% mocy (wsteczny), Brak = 0% (wygasanie)
      let target = 0;
      if (keys['w']) target = 1.0;
      else if (keys['s']) target = 0.4; 

      enginePower.target = target;
      
      // Szybka reakcja paska (6.0), ≈ºeby wizualnie pasowa≈Ço do nowej fizyki
      enginePower.current = approachValue(enginePower.current, enginePower.target, 6.0 * dt);
      input.main = enginePower.current;
    }

    // targeting / scanning
    const SCAN_RANGE = 10000;
    const SCAN_VFX_SPEED = 4000;
    const SCAN_ARROW_LIFE = 1.5;
    const scan = { target: null, scanned: null, targetType: null };
    let lockedTarget = null;
    let lockedTargets = [];
    let highlightedEnemies = [];
    let highlightTimer = 0;
    const HIGHLIGHT_TIME = 3;
    const HIGHLIGHT_RANGE = 2000;
    const radarPings = [];
    const scanWaves = [];
    const scanArrows = [];

    function isHostileNpc(n) {
      return !!(n && !n.dead && !n.friendly);
    }

    function isPirateScanTarget(n) {
      if (!isHostileNpc(n)) return false;
      if (!n.isPirate) return false;
      const type = String(n.type || '').toLowerCase();
      if (type === 'destroyer' || type === 'battleship') return false;
      if (n.isCapitalShip) return false;
      return true;
    }
    const NPC_DESPAWN_RADIUS = 20000;
    function spawnRadarPing(x, y) { radarPings.push({ x, y, age: 0, life: 1 }); }
    function triggerScanWave() {
      const wave = { x: ship.pos.x, y: ship.pos.y, r: 0, speed: SCAN_VFX_SPEED, max: SCAN_RANGE, hit: new Set() };
      scanWaves.push(wave);
      scanArrows.length = 0;
      // Merge of branches:
      // 1) codex/add-various-npc-types-and-groups ‚Üí prefer enemies that have weapons
      // 2) main ‚Üí only highlight those within HIGHLIGHT_RANGE
      const inRange = (n) => Math.hypot(n.x - ship.pos.x, n.y - ship.pos.y) <= HIGHLIGHT_RANGE;
      highlightedEnemies = npcs.filter(n => isPirateScanTarget(n) && inRange(n));
      highlightTimer = HIGHLIGHT_TIME;
      for (const st of stations) {
        const dist = Math.hypot(st.x - ship.pos.x, st.y - ship.pos.y);
        spawnRadarPing(st.x, st.y);
        if (dist <= SCAN_RANGE) {
          scanArrows.push({ target: st, age: 0, life: SCAN_ARROW_LIFE });
          wave.hit.add(st);
        }
      }
    }

    const mouse = { x: W / 2, y: H / 2, left: false, right: false, click: false, overCanvas: false, dx: 0, dy: 0 };
    const Selection = { active: false, rect: null, units: new Set() };

    function clearSelection() {
      Selection.active = false;
      Selection.rect = null;
      Selection.units.clear();
    }

    function startSelection(worldPoint) {
      Selection.active = true;
      Selection.rect = { x0: worldPoint.x, y0: worldPoint.y, x1: worldPoint.x, y1: worldPoint.y };
    }

    function updateSelectionRect(worldPoint) {
      if (!Selection.active || !Selection.rect) return;
      Selection.rect.x1 = worldPoint.x;
      Selection.rect.y1 = worldPoint.y;
    }

    function selectableAllies() {
      const allies = [];
      if (ship) allies.push(ship);
      for (const npc of npcs) {
        if (!npc || npc.dead || !npc.friendly) continue;
        allies.push(npc);
      }
      return allies;
    }

    function finishSelection() {
      if (!Selection.rect) { clearSelection(); return; }
      const x0 = Math.min(Selection.rect.x0, Selection.rect.x1);
      const y0 = Math.min(Selection.rect.y0, Selection.rect.y1);
      const x1 = Math.max(Selection.rect.x0, Selection.rect.x1);
      const y1 = Math.max(Selection.rect.y0, Selection.rect.y1);
      Selection.units.clear();
      for (const unit of selectableAllies()) {
        const ux = unit.pos ? unit.pos.x : unit.x;
        const uy = unit.pos ? unit.pos.y : unit.y;
        if (ux >= x0 && ux <= x1 && uy >= y0 && uy <= y1) {
          Selection.units.add(unit);
        }
      }
      Selection.active = false;
    }

    function categorizeUnit(unit) {
      if (unit === ship) return 'player';
      if (unit.fighter || unit.type === 'fighter') return 'fighter';
      if (unit.type && String(unit.type).includes('frigate')) return 'frigate';
      if (unit.type === 'destroyer') return 'destroyer';
      if (unit.type === 'battleship' || unit.isCapitalShip) return 'battleship';
      return 'other';
    }

    function formationTargets(units, anchor) {
      const fighters = [];
      const frigates = [];
      const destroyers = [];
      const battleships = [];
      const others = [];
      for (const u of units) {
        const cat = categorizeUnit(u);
        if (cat === 'fighter') fighters.push(u);
        else if (cat === 'frigate') frigates.push(u);
        else if (cat === 'destroyer' || cat === 'player') destroyers.push(u);
        else if (cat === 'battleship') battleships.push(u);
        else others.push(u);
      }
      const enemy = npcs.find(n => n && !n.dead && !n.friendly) || null;
      const ang = enemy ? Math.atan2(enemy.y - anchor.y, enemy.x - anchor.x) : ship.angle;
      const forward = { x: Math.cos(ang), y: Math.sin(ang) };
      const right = { x: -forward.y, y: forward.x };

      const result = new Map();
      let depth = 0;
      const placeLine = (list, spacing) => {
        if (!list.length) return;
        const sorted = [...list].sort((a, b) => String(a.id || '').localeCompare(String(b.id || '')));
        const totalW = (sorted.length - 1) * spacing;
        const cx = anchor.x + forward.x * depth;
        const cy = anchor.y + forward.y * depth;
        const startX = cx - right.x * totalW / 2;
        const startY = cy - right.y * totalW / 2;
        sorted.forEach((u, i) => {
          result.set(u, {
            x: startX + right.x * (i * spacing),
            y: startY + right.y * (i * spacing)
          });
        });
        depth += spacing * 0.9;
      };

      placeLine(fighters, 200);
      depth += fighters.length ? 60 : 0;
      placeLine(frigates, 150);
      placeLine(destroyers, 200);
      placeLine(battleships, 230);
      placeLine(others, 170);
      return result;
    }

    function issueMoveOrder(point, opts = {}) {
      const units = [...Selection.units].filter(u => u && !u.dead);
      if (!units.length) return;
      const targets = formationTargets(units, point);
      for (const unit of units) {
        const t = targets.get(unit) || point;
        const arrival = (unit.radius || unit.w || 30) + 25;
        unit.command = { type: opts.attackMove ? 'attack-move' : 'move', target: { x: t.x, y: t.y }, arrival };
      }
    }

    function handleSelectionCommand(event) {
      if (!Selection.units.size) return true;
      const rect = canvas.getBoundingClientRect();
      const pt = screenToWorld(event.clientX - rect.left, event.clientY - rect.top);
      let clickedEnemy = null;
      let bestDistSq = Infinity;
      for (const npc of npcs) {
        if (!npc || npc.dead || npc.friendly) continue;
        const dx = npc.x - pt.x;
        const dy = npc.y - pt.y;
        const distSq = dx * dx + dy * dy;
        const hitR = (npc.radius || 20) + 20;
        if (distSq < hitR * hitR && distSq < bestDistSq) {
          bestDistSq = distSq;
          clickedEnemy = npc;
        }
      }
      issueMoveOrder(clickedEnemy ? { x: clickedEnemy.x, y: clickedEnemy.y } : pt, { attackMove: !!clickedEnemy });
      return true;
    }

    canvas.addEventListener('mousemove', e => {
      mouse.x = e.clientX; mouse.y = e.clientY;
      mouse.overCanvas = true;
      const hasMovement = typeof e.movementX === 'number' && typeof e.movementY === 'number';
      const movementX = hasMovement ? e.movementX : ((camera.lastPointerX == null) ? 0 : e.clientX - camera.lastPointerX);
      const movementY = hasMovement ? e.movementY : ((camera.lastPointerY == null) ? 0 : e.clientY - camera.lastPointerY);
      mouse.dx += movementX;
      mouse.dy += movementY;
      camera.lastPointerX = e.clientX;
      camera.lastPointerY = e.clientY;
      if (showMap && mapView.dragging) {
        mapView.followShip = false;
        mapView.viewX = (mapView.viewX ?? 0) + movementX;
        mapView.viewY = (mapView.viewY ?? 0) + movementY;
        const clamped = clampMapViewPosition(mapView.viewX, mapView.viewY);
        mapView.viewX = clamped.x;
        mapView.viewY = clamped.y;
        return;
      }
      if (PAUSED && Selection.active) {
        const rect = canvas.getBoundingClientRect();
        const cur = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
        updateSelectionRect(cur);
      }
      if (stationUI.open && stationUI.dragging) {
        stationUI.x = mouse.x - stationUI.dragDX;
        stationUI.y = mouse.y - stationUI.dragDY;
        stationUI.autoPosition = false;
      }
    });
    canvas.addEventListener('mouseenter', e => {
      mouse.overCanvas = true;
      if (e) {
        camera.lastPointerX = e.clientX;
        camera.lastPointerY = e.clientY;
      }
    });
    canvas.addEventListener('dragover', handleInfrastructureCanvasDragOver);
    canvas.addEventListener('drop', handleInfrastructureCanvasDrop);
    canvas.addEventListener('dragleave', handleInfrastructureCanvasDragLeave);
    canvas.addEventListener('mouseleave', () => {
      mouse.overCanvas = false;
      mouse.left = false;
      mouse.right = false;
      mouse.click = false;
      mapView.dragging = false;
      scan.target = null;
      scan.scanned = null;
      scan.targetType = null;
      hideHoverInfo();
      camera.lastPointerX = null;
      camera.lastPointerY = null;
    });
    canvas.addEventListener('mousedown', e => {
      if (showMap && e.button === 0) {
        mapView.dragging = true;
        mapView.followShip = false;
        const layout = syncMapViewLayout();
        if (mapView.viewX == null || mapView.viewY == null) {
          mapView.viewX = layout.targetX0;
          mapView.viewY = layout.targetY0;
        }
        const clamped = clampMapViewPosition(mapView.viewX, mapView.viewY);
        mapView.viewX = clamped.x;
        mapView.viewY = clamped.y;
        return;
      }
      if (PAUSED && !stationUI.open && e.button === 0) {
        const rect = canvas.getBoundingClientRect();
        const start = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
        startSelection(start);
        return;
      }
      if (e.button === 0) {
        if (stationUI.open) {
          const interactive = stationUI.visible && !stationUI.awaitingCamera && stationUI.appear > 0.05;
          if (interactive) {
            const inX = mouse.x >= stationUI.x && mouse.x <= stationUI.x + stationUI.w;
            const inY = mouse.y >= stationUI.y && mouse.y <= stationUI.y + stationUI.h;
            if (inX && inY && mouse.y <= stationUI.y + 24) {
              stationUI.dragging = true;
              stationUI.dragDX = mouse.x - stationUI.x;
              stationUI.dragDY = mouse.y - stationUI.y;
              stationUI.autoPosition = false;
            }
          }
          return;
        }
        mouse.left = true;
        if (scan.targetType === 'station' && mouse.overCanvas) {
          return;
        }
        if (!stationUI.open && !warp.isBusy()) triggerRailVolley();
      }
      if (e.button === 2) {
        e.preventDefault();
        if (PAUSED && Selection.units.size && !stationUI.open) return;
        if (stationUI.open) return;
        const firedSpecial = (!showMap && gameStarted)
          ? Superweapon.tryFireSuperweapon()
          : false;
        mouse.right = !firedSpecial;
        if (!firedSpecial && !warp.isBusy()) {
          const mouseWorld = screenToWorld(mouse.x, mouse.y);
          const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
          const side = (local.x >= 0) ? 'right' : 'left';
          fireRocket(side);
          rocketCooldown = ROCKET_FIRE_INTERVAL;
        }
      }
      if (e.button === 1) {
        e.preventDefault();
        camera.zoom = Math.abs(camera.zoom - camera.defaultZoom) < 0.03 ? camera.altZoom : camera.defaultZoom;
        camera.targetZoom = camera.zoom;
        camera.manualZoom = true;
        if (camera.transition && camera.transition.kind === 'ship') camera.transition = null;
        zoomIndicator.show(camera.zoom);
      }
    });
    canvas.addEventListener('mouseup', e => {
      if (showMap && e.button === 0) {
        mapView.dragging = false;
        mouse.left = false;
        mouse.click = false;
        return;
      }
      if (e.button === 0) {
        if (PAUSED && Selection.active) {
          finishSelection();
          return;
        }
        const wasDragging = stationUI.dragging;
        if (stationUI.dragging) {
          stationUI.dragging = false;
        }
        if (stationUI.open) {
          if (!wasDragging) {
            mouse.click = true;
          }
          return;
        }
        mouse.left = false;
        if (!wasDragging) {
          mouse.click = true;
        }
      }
      if (e.button === 2) {
        if (PAUSED && Selection.units.size && !stationUI.open) {
          handleSelectionCommand(e);
          mouse.right = false;
          return;
        }
        if (stationUI.open) return;
        mouse.right = false;
      }
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());
    canvas.addEventListener('wheel', e => {
      if (stationUI.open) return;
      e.preventDefault();
      if (showMap) {
        const zoomFactor = 1 - e.deltaY * 0.0016;
        mapView.targetZoom = clamp(mapView.targetZoom * zoomFactor, mapView.minZoom, mapView.maxZoom);
        return;
      }
      const f = 1 - e.deltaY * camera.wheelSpeed;
      camera.zoom = clamp(camera.zoom * f, camera.minZoom, camera.maxZoom);
      camera.targetZoom = camera.zoom;
      camera.manualZoom = true;
      if (camera.transition && camera.transition.kind === 'ship') camera.transition = null;
      zoomIndicator.show(camera.zoom);
    }, { passive: false });

    const GAMEPAD = { enabled: true, dead: 0.15, last: {} };

    function applyGamepad() {
      const pads = navigator.getGamepads?.() || [];
      const p = pads[0];
      if (!p) return;
      const ax = (v) => (Math.abs(v) < GAMEPAD.dead ? 0 : v);
      const lx = ax(p.axes[0] || 0), ly = ax(p.axes[1] || 0);
      const rx = ax(p.axes[2] || 0), ry = ax(p.axes[3] || 0);
      const forward = ly * -1;
      applyPlayerInput(ship, {
        controller: 'player',
        thrustX: lx,
        thrustY: forward,
        aimX: rx,
        aimY: ry * -1,
        main: Math.max(0, forward),
        torque: lx,
        leftSide: 0,
        rightSide: 0
      }, input);
      // przyciski
      const btn = (i) => !!(p.buttons[i] && p.buttons[i].pressed);
      if (btn(0)) triggerRailVolley();      // A / Cross
      if (btn(1)) fireRocket();             // B / Circle
      if (btn(2)) {
        activateBoostIfAllowed();
      } else if (boost.state === 'active' && !btn(2)) {
        stopBoost();
      }
      if (btn(3)) attemptWarp();            // Y / Triangle
      if (btn(9)) togglePause();            // START
    }

    // =============== Side rockets ===============
    const ROCKET_FIRE_INTERVAL = 0.11;
    let rocketCooldown = 0;
    let nextRocketIndexLeft = 0, nextRocketIndexRight = 0;
    const SIDE_BULLET_SPEED = 760, SIDE_BULLET_DAMAGE = 20;
    const SIDE_PLASMA_EXPLODE_RADIUS = 48;
    const SIDE_ROCKET_TURN_RATE = 6;
    window.SIDE_ROCKET_TURN_RATE = SIDE_ROCKET_TURN_RATE;
    const SIDE_ROCKET_HOMING_DELAY = 0.25;
    const SPECIAL_COOLDOWN = 10; ship.special.cooldownTimer = 0;
    const SPECIAL_DAMAGE = 1500;

    function selectMissileLoadout(side) {
      const entries = Game.player.weapons?.[HP.MISSILE] || [];
      const available = entries.filter(entry => entry.hp.mount && (entry.hp.ammo === null || entry.hp.ammo > 0));
      if (!available.length) return null;
      let preferred = null;
      if (side === 'left') {
        preferred = available.find(entry => (entry.hp.pos?.x || 0) <= 0);
      } else if (side === 'right') {
        preferred = available.find(entry => (entry.hp.pos?.x || 0) >= 0);
      }
      return preferred || available[0];
    }

    function consumeMissileAmmo(loadout) {
      const hp = loadout?.hp;
      if (!hp) return false;
      if (typeof hp.ammo === 'number') {
        hp.ammo = Math.max(0, hp.ammo - 1);
      }
      rocketAmmo = missileAmmoTotal();
      saveLoadout();
      return true;
    }

    function getMissileStats(loadout) {
      const weapon = loadout?.weapon;
      if (weapon?.missileStats) return weapon.missileStats;
      if (weapon?.aispaceMissileId) return AISPACE_MISSILES[weapon.aispaceMissileId];
      return null;
    }

    function fireRocket(side) {
      if (!(Game.player.weapons?.[HP.MISSILE]?.length)) return;
      if (rocketAmmoMax > 0 && rocketAmmo <= 0) return;
      const loadout = selectMissileLoadout(side);
      if (!loadout) return;
      const guns = side === 'left' ? ship.sideGunsLeft : ship.sideGunsRight;
      const idx = side === 'left' ? nextRocketIndexLeft : nextRocketIndexRight;
      const gunOff = guns[idx % guns.length];
      const target = (lockedTarget && !lockedTarget.dead) ? lockedTarget : null;
      if (!consumeMissileAmmo(loadout)) return;
      const missileDef = getMissileStats(loadout);
      fireSideGunAtOffset(gunOff, side, target, missileDef);
      if (side === 'left') nextRocketIndexLeft = (idx + 1) % guns.length;
      else nextRocketIndexRight = (idx + 1) % guns.length;
    }

    function fireSideGunAtOffset(gunOff, side, target = null, missileDef = null) {
      const gunWorld = add(ship.pos, rotate(gunOff, ship.angle));
      const dl = side === 'left' ? -1 : 1;
      const baseDir = rotate({ x: dl, y: 0 }, ship.angle);
      const speed = missileDef?.speed || SIDE_BULLET_SPEED;
      const damage = missileDef?.dmg ?? missileDef?.damage ?? SIDE_BULLET_DAMAGE;
      const life = missileDef?.life ?? ((missileDef?.range && missileDef.speed) ? (missileDef.range / missileDef.speed) : 2.4);
      const turnRate = ((missileDef?.turn || SIDE_ROCKET_TURN_RATE) * Math.PI) / 180;
      const explodeRadius = missileDef?.radius ?? SIDE_PLASMA_EXPLODE_RADIUS;
      const homingDelay = missileDef?.homingDelay ?? SIDE_ROCKET_HOMING_DELAY;
      const swarmCount = missileDef?.swarm || 1;
      const spread = ((missileDef?.spread || 0) * Math.PI) / 180;

      for (let n = 0; n < swarmCount; n++) {
        const offsetAng = spread ? (Math.random() - 0.5) * spread : 0;
        const dir = rotate(baseDir, offsetAng);
        window.bullets.push({
          x: gunWorld.x, y: gunWorld.y, px: gunWorld.x, py: gunWorld.y,
          vx: dir.x * speed + ship.vel.x, vy: dir.y * speed + ship.vel.y,
          life: life || 2.4, r: 5, owner: 'player', damage, penetration: 0, type: 'rocket',
          explodeRadius, homingDelay, target,
          color: missileDef?.color,
          turnRate,
          source: ship, spawnGrace: 0.08
        });
      }
      spawnParticle({ x: gunWorld.x, y: gunWorld.y }, { x: baseDir.x * 120 + ship.vel.x * 0.1, y: baseDir.y * 120 + ship.vel.y * 0.1 }, 0.14, '#b4ffb4', 3.2, true);
      for (let k = 0; k < 6; k++) {
        const aa = Math.atan2(baseDir.y, baseDir.x) + (Math.random() - 0.5) * 0.9;
        spawnParticle({ x: gunWorld.x + Math.cos(aa) * 6, y: gunWorld.y + Math.sin(aa) * 6 }, { x: Math.cos(aa) * 160, y: Math.sin(aa) * 160 }, 0.14 + Math.random() * 0.06, '#a8ff9a', 1.1, true);
      }
    }

    // =============== Fighters ===============
    const FIGHTER_ORBIT_RADIUS = 200;  // by≈Çy zbyt blisko
    const FIGHTER_ORBIT_SPEED = 1.8;
    const FIGHTER_ATTACK_RANGE = 1000;
    const FIGHTERS_PER_LAUNCH = 10;
    const FIGHTER_ACCEL = 880;
    const FIGHTER_MAX_SPEED = 1180;
    const FIGHTER_TURN_RATE = 9.6;
    const FIGHTER_DRAG_COEFF = 2.6;
    const FIGHTER_ESCORT_POSITION_GAIN = 3.0;
    const FIGHTER_ESCORT_FOLLOW_GAIN = 7.5;

    // Bliska eskorta - lokalne offsety wzglƒôdem kad≈Çuba (w pikselach)
    const FIGHTER_FORMATION = [
      { x: -150, y: -120 }, { x: 150, y: -120 },
      { x: -190, y: -70 }, { x: 190, y: -70 },
      { x: -190, y: -10 }, { x: 190, y: -10 },
      { x: -150, y: 60 }, { x: 150, y: 60 },
      { x: -100, y: -180 }, { x: 100, y: -180 }
    ];


    const SQUAD = {
      id: 'player_squad',
      list: [],
      order: 'idle',
      targets: []
    };
    window.SQUAD = SQUAD;
    function pickSquadTargets() {
      // Zwraca wszystkich ≈ºywych wrog√≥w (nie-friendly)
      return npcs.filter(n => !n.friendly && !n.dead);
    }
    window.pickSquadTargets = pickSquadTargets;
    window.spawnFighter = function () {
      // 1. Sprawd≈∫ czy statek i hangar istniejƒÖ
      if (!window.ship) return;

      const hasHangar = Game.player.weapons && Game.player.weapons.hangar && Game.player.weapons.hangar.length > 0;
      if (!hasHangar) {
        if (typeof toast === 'function') toast('Brak modu≈Çu hangaru!');
        return;
      }

      // 2. Definicja 2 Hangar√≥w (Lewy i Prawy)
      const halfW = (ship.w || 60) * 0.5;
      const halfH = (ship.h || 120) * 0.1; // Lekko przesuniƒôte do ty≈Çu wzglƒôdem ≈õrodka

      const hangarSlots = [
        { x: -halfW, y: halfH, side: -1 }, // Lewa burta
        { x: halfW, y: halfH, side: 1 }  // Prawa burta
      ];

      const createdFighters = [];

      // 3. PƒòTLA: Generuj oba my≈õliwce natychmiast
      for (const slot of hangarSlots) {

        // Obliczanie pozycji w ≈õwiecie (Rotacja)
        const c = Math.cos(ship.angle);
        const s = Math.sin(ship.angle);

        const spawnX = ship.pos.x + (slot.x * c - slot.y * s);
        const spawnY = ship.pos.y + (slot.x * s + slot.y * c);

        // Stworzenie obiektu
        const f = makeNPCBase({ x: spawnX, y: spawnY }, {
          hp: 80,
          accel: 350,
          maxSpeed: 650,
          turn: 7.0,
          radius: 12
        });

        f.friendly = true;
        f.mission = true;
        f.fighter = true;
        f.color = '#7cff91';

        // Fizyka Wyrzutni (Wyrzut na boki)
        const launchSpeed = 180; // Trochƒô mocniejszy wyrzut
        // Wektor boczny (prostopad≈Çy do kad≈Çuba)
        const sideDirX = c;
        const sideDirY = s;

        f.vx = ship.vel.x + (sideDirX * launchSpeed * slot.side);
        f.vy = ship.vel.y + (sideDirY * launchSpeed * slot.side);
        f.angle = ship.angle;

        // Uzbrojenie
        f.gun = 'laserS';
        f.msl = 'AF'; f.mslAmmo = 4;
        f.gunCD = 0.5;

        // ZarzƒÖdzanie eskadrƒÖ
        if (!window.SQUAD) window.SQUAD = { list: [], order: 'idle', targets: [] };

        // WA≈ªNE: Pobieramy aktualnƒÖ d≈Çugo≈õƒá listy dla KA≈ªDEGO my≈õliwca z osobna,
        // ≈ºeby zajƒô≈Çy r√≥≈ºne miejsca w formacji
        const idx = window.SQUAD.list.length;
        f.formIndex = idx;

        // Pozycja w formacji "V"
        const row = Math.floor((idx + 1) / 2);
        const formSide = (idx % 2 === 0) ? 1 : -1;
        f.formationOffset = { x: -140 - (row * 50), y: formSide * (60 + row * 30) };

        f.squad = { leader: ship, type: 'fighter' };

        // AI
        f.ai = (dt) => { if (window.runAdvancedFighterAI) window.runAdvancedFighterAI(f, dt); };

        // Dodanie do gry
        window.SQUAD.list.push(f);
        npcs.push(f);
        createdFighters.push(f);

        // Efekt dymu przy wylocie
        if (window.spawnParticle) {
          for (let i = 0; i < 4; i++) {
            window.spawnParticle(
              { x: spawnX, y: spawnY },
              { x: ship.vel.x + (Math.random() - 0.5) * 40, y: ship.vel.y + (Math.random() - 0.5) * 40 },
              0.3, '#ffffff', 2 + Math.random() * 2, false
            );
          }
        }
      }

      return createdFighters;
    };



    function lineOffsets(count, spacing) {
      const start = -((count - 1) * spacing) / 2;
      const arr = [];
      for (let i = 0; i < count; i++) arr.push(start + i * spacing);
      return arr;
    }

    function buildMercSwarmQueue(station) {
      if (!station) return [];
      const toPlayer = norm({ x: ship.pos.x - station.x, y: ship.pos.y - station.y });
      const right = { x: -toPlayer.y, y: toPlayer.x };
      const baseDist = station.r + 220;
      const rowSpacing = 200;
      const queue = [];

      const addRow = (kinds, dist, spacing) => {
        const offsets = lineOffsets(kinds.length, spacing);
        kinds.forEach((kind, idx) => {
          const offset = offsets[idx];
          queue.push({
            kind,
            pos: {
              x: station.x + toPlayer.x * dist + right.x * offset,
              y: station.y + toPlayer.y * dist + right.y * offset
            },
            offset,
            right,
            forward: toPlayer
          });
        });
      };

      addRow(new Array(8).fill('fighter_squad'), baseDist + rowSpacing * 3, 180);
      addRow(['frigate_pd', 'frigate_laser', 'frigate_pd'], baseDist + rowSpacing * 2, 210);
      return queue;
    }

    function resetSwarmQueue() {
      if (!mercMission || !mercMission.swarm) return;
      mercMission.swarm.timer = 0.5;
      const st = mercMission.station;
      const formationQueue = buildMercSwarmQueue(st);
      if (formationQueue.length) {
        mercMission.swarm.queue = formationQueue;
        return;
      }
      // Fallback je≈õli nie da siƒô zbudowaƒá formacji
      const types = ['fighter_squad', 'interceptor', 'frigate_pd'];
      mercMission.swarm.queue = [];
      for (let i = 0; i < 5; i++) {
        mercMission.swarm.queue.push(types[Math.floor(Math.random() * types.length)]);
      }
    }
    window.resetSwarmQueue = resetSwarmQueue;



    function enterPirateInnerOrbit() {
      if (!mercMission || !mercMission.station) return;
      if (mercMission.alertStage !== 'engage') {
        mercMission.alertStage = 'engage';
      }
      if (!mercMission.aggro) triggerMercAggro('player_inner_orbit');
    }

    function triggerMercAggro(reason) {
      if (!mercMission) return;
      const wasAggro = mercMission.aggro;
      mercMission.aggro = true;
      mercMission.aggroReason = mercMission.aggroReason || reason;
      mercMission.alertStage = 'engage';

      if (!wasAggro) {
        console.log("PIRATE FLEET WARPING IN!");
        spawnPirateHeavyFleet(mercMission.station);
      }


      for (const npc of npcs) {
        if (npc.mission && npc.isPirate && !npc.dead) {
          if (npc.state === 'warping_in') continue;
          npc.state = 'engage_formation';
          npc.guardStation = null;
          npc.forceTarget = null;
          npc.target = null;
        }
      }

      if (mercMission.swarm) {
        mercMission.swarm.active = true;
        if (!mercMission.swarm.queue || !mercMission.swarm.queue.length) resetSwarmQueue();
        if (!mercMission.swarm.timer || mercMission.swarm.timer > 1.2) mercMission.swarm.timer = 1.2;
      }
    }


    // =============== Rail (2 lufy: serie A‚ÜíB, A‚ÜíB) ===============
    const RAIL_SPEED = 2600, RAIL_PEN = 3, RAIL_DAMAGE = 60;
    const ARMATA_SPLASH_RADIUS = 140;
    const ARMATA_SPLASH_FALLOFF_MIN = 0.2;
    const BASE_MAIN_BEHAVIOR = {
      id: 'default',
      priority: 1,
      cooldown: 0.38,
      burstsPerClick: 2,
      shotGap: 0.07,
      burstGap: 0.18,
      recoilKick: 14,
      recoilMax: 12,
      barrelsPerShot: 2,
      muzzleFx: spawnRailMuzzle,
      hitFx: spawnRailHitEffect,
      projectile: {
        type: 'rail',
        speed: RAIL_SPEED,
        life: 2.0,
        radius: 4,
        penetration: RAIL_PEN,
        effectScale: 1.0,
        vfxKey: 'rail'
      },
    };

    function createMainWeaponBehavior(overrides = {}) {
      const projectileOverrides = overrides.projectile || {};
      const behavior = {
        ...BASE_MAIN_BEHAVIOR,
        ...overrides,
        projectile: {
          ...BASE_MAIN_BEHAVIOR.projectile,
          ...projectileOverrides,
        },
        muzzleFx: overrides.muzzleFx || BASE_MAIN_BEHAVIOR.muzzleFx,
        hitFx: overrides.hitFx || BASE_MAIN_BEHAVIOR.hitFx,
      };
      behavior.id = overrides.id || behavior.id;
      behavior.priority = overrides.priority ?? behavior.priority ?? BASE_MAIN_BEHAVIOR.priority;
      behavior.barrelsPerShot = overrides.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot;
      return behavior;
    }

    const MAIN_WEAPON_BEHAVIOR = {
      default: createMainWeaponBehavior(),
      
      railgun_mk2: createMainWeaponBehavior({
        id: 'railgun_mk2',
        priority: 2,
        burstsPerClick: 1,
        barrelsPerShot: 1,
        shotGap: 0.12,
        cooldown: 0.15,
        recoilKick: 12,
        projectile: {
          vfxKey: 'rail',
          speed: 2800,
          life: 2.0
        }
      }),

      armata_mk1: createMainWeaponBehavior({
        id: 'armata_mk1',
        priority: 3,
        cooldown: 1.8,
        burstsPerClick: 1,
        shotGap: 0,
        burstGap: 0.32,
        recoilKick: 20,
        recoilMax: 18,
        barrelsPerShot: 1,
        muzzleFx: spawnArmataMuzzle,
        hitFx: spawnArmataHitEffect,
        projectile: {
          type: 'armata',
          speed: RAIL_SPEED * 0.78,
          life: 2.6,
          radius: 6,
          penetration: 0,
          explodeRadius: ARMATA_SPLASH_RADIUS,
          effectScale: 1.4,
          vfxKey: 'armata'
        },
      }),
      heavy_autocannon: createMainWeaponBehavior({
        id: 'heavy_autocannon',
        priority: 4,
        cooldown: 0.16,
        burstsPerClick: 1,
        shotGap: 0.045,
        burstGap: 0.1,
        recoilKick: 8,
        recoilMax: 10,
        barrelsPerShot: 1,
        projectile: {
          type: 'autocannon',
          speed: RAIL_SPEED * 0.82,
          life: 1.6,
          radius: 3,
          penetration: 1,
          effectScale: 0.9,
          vfxKey: 'autocannon'
        },
        muzzleFx: spawnAutocannonMuzzle,
        hitFx: spawnAutocannonHitEffect,
      }),
    };
    function fireAispaceMainShot(def, context) {
      const target = (context.target && !context.target.dead) ? context.target
        : ((lockedTarget && !lockedTarget.dead) ? lockedTarget : null);
      spawnBulletAdapter(ship, target, def, {
        type: def.isBeam ? 'beam' : undefined,
        origin: context.muzzle.pos,
        originVel: context.muzzle.baseVel,
        angleOverride: context.turret.angle
      });
      return {
        cooldown: def.rps ? 1 / def.rps : undefined,
        recoilKick: def.isBeam ? 6 : undefined,
        recoilMax: def.isBeam ? 10 : undefined
      };
    }
    function createAispaceMainBehavior(id, def) {
      const projectileType = def.isBeam ? 'beam'
        : (def.name?.toLowerCase().includes('rail') ? 'rail'
          : (def.name?.toLowerCase().includes('auto') || def.name?.toLowerCase().includes('gatling')) ? 'autocannon'
            : 'plasma');
      const projectileLife = (def.range && def.speed) ? (def.range / def.speed) : BASE_MAIN_BEHAVIOR.projectile.life;
      return createMainWeaponBehavior({
        id,
        priority: 5,
        cooldown: def.rps ? 1 / def.rps : BASE_MAIN_BEHAVIOR.cooldown,
        burstsPerClick: 1,
        shotGap: 0,
        burstGap: 0,
        recoilKick: def.isBeam ? 6 : 10,
        recoilMax: def.isBeam ? 10 : 14,
        barrelsPerShot: 1,
        projectile: {
          type: projectileType,
          speed: def.speed || BASE_MAIN_BEHAVIOR.projectile.speed,
          life: projectileLife,
          radius: def.isBeam ? 5 : 4,
          penetration: projectileType === 'rail' ? 2 : 0,
          effectScale: 1.0,
          color: def.color,
          vfxKey: id
        },
        customFire: ctx => fireAispaceMainShot(def, ctx)
      });
    }
    for (const [weaponId, weapon] of Object.entries(AISPACE_HARDPOINT_WEAPONS)) {
      if (weapon.type === HP.MAIN && weapon.aispaceDef) {
        MAIN_WEAPON_BEHAVIOR[weaponId] = createAispaceMainBehavior(weaponId, weapon.aispaceDef);
      }
    }
    MAIN_WEAPON_BEHAVIOR.railgun_mk1 = MAIN_WEAPON_BEHAVIOR.default;

    const rail = {
      cd: [0, 0],
      cdMax: MAIN_WEAPON_BEHAVIOR.default.cooldown,
      shotGap: MAIN_WEAPON_BEHAVIOR.default.shotGap,
      burstGap: MAIN_WEAPON_BEHAVIOR.default.burstGap,
      burstsPerClick: MAIN_WEAPON_BEHAVIOR.default.burstsPerClick,
      barrelsPerShot: MAIN_WEAPON_BEHAVIOR.default.barrelsPerShot,
      queue: [],
      nextStart: 0,
      behaviorId: MAIN_WEAPON_BEHAVIOR.default.id,
    };
    let railTimer = 0;

    rebuildHardpointsForFrame();
    loadLoadout();

    function computeMainMuzzle(offset, angle, barIndex, barrelsPerShot) {
      const spriteScale = ship.visual?.spriteScale || 1;
      const forwardLen = Math.min((ship.h * spriteScale) * 0.40, 52 * spriteScale);
      const gap = 10 * spriteScale;
      const normalizedIndex = Math.min(barIndex, barrelsPerShot - 1);
      const offsetFrac = barrelsPerShot === 1 ? 0 : (normalizedIndex / (barrelsPerShot - 1) - 0.5) * 2;
      const lateralOffset = (gap * 0.5) * offsetFrac;
      const a = angle;
      const f = { x: Math.cos(a), y: Math.sin(a) };
      const p = { x: -Math.sin(a), y: Math.cos(a) };
      const off = rotate(offset, ship.angle);
      const pos = {
        x: ship.pos.x + off.x + f.x * forwardLen + p.x * lateralOffset,
        y: ship.pos.y + off.y + f.y * forwardLen + p.y * lateralOffset
      };
      return {
        pos,
        dir: f,
        baseVel: { x: ship.vel.x, y: ship.vel.y }
      };
    }

    function computeTurretMuzzle(turret, barIndex, barrelsPerShot) {
      return computeMainMuzzle(turret.offset, turret.angle, barIndex, barrelsPerShot);
    }

    function getNearestTurretIndex(offset, turrets) {
      if (!offset || !turrets.length) return -1;
      let bestIndex = 0;
      let bestDist = Infinity;
      for (let i = 0; i < turrets.length; i++) {
        const t = turrets[i];
        const dx = offset.x - t.offset.x;
        const dy = offset.y - t.offset.y;
        const dist = dx * dx + dy * dy;
        if (dist < bestDist) {
          bestDist = dist;
          bestIndex = i;
        }
      }
      return bestIndex;
    }

    function triggerRailVolley() {
      const mainWeapons = Game.player.weapons?.[HP.MAIN];
      if (!mainWeapons || !mainWeapons.length) return;
      if (rail.queue.length) return;
      const start = rail.nextStart;
      rail.nextStart ^= 1;
      const barrels = Math.max(1, rail.barrelsPerShot || 2);
      const orderPair = barrels === 1 ? [start] : [start, 1 - start];
      for (let b = 0; b < rail.burstsPerClick; b++) {
        const baseDelay = b * (orderPair.length * rail.shotGap + rail.burstGap);
        for (let idx = 0; idx < orderPair.length; idx++) {
          const barrelBaseTime = baseDelay + idx * rail.shotGap;
          for (let w = 0; w < mainWeapons.length; w++) {
            const jitter = Math.random() * 0.12;
            rail.queue.push({
              timer: barrelBaseTime + jitter,
              barrel: orderPair[idx],
              weaponIndex: w,
              ignoreCD: true
            });
          }
        }
      }
    }
    function fireRailBarrel(barIndex, specificWeaponIdx = -1) {
      const mainWeapons = Game.player.weapons?.[HP.MAIN] || [];
      if (!mainWeapons.length) return;
      const turrets = [ship.turret, ship.turret2, ship.turret3, ship.turret4];
      let maxCooldown = 0;
      for (let i = 0; i < mainWeapons.length; i++) {
        if (specificWeaponIdx !== -1 && i !== specificWeaponIdx) continue;
        const weaponData = mainWeapons[i]?.weapon;
        const hpOffset = mainWeapons[i]?.hp?.pos;
        const turretIndex = hpOffset ? getNearestTurretIndex(hpOffset, turrets) : (i % turrets.length);
        const t = turrets[turretIndex];
        const aimAngle = t?.angle ?? ship.angle;
        const behavior = getMainWeaponBehaviorForWeaponId(weaponData?.id);
        const projectile = behavior.projectile || BASE_MAIN_BEHAVIOR.projectile;
        const barrelsPerShot = Math.max(1, behavior.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot);
        const muzzleOffset = hpOffset || t?.offset;
        const muzzle = computeMainMuzzle(muzzleOffset, aimAngle, barIndex, barrelsPerShot);
        let fireResult = null;
        if (behavior.customFire) {
          fireResult = behavior.customFire({
            turret: { angle: aimAngle },
            muzzle,
            weapon: weaponData,
            target: lockedTarget,
            behavior
          });
        } else {
          const damage = weaponData?.damage ?? weaponData?.dps ?? RAIL_DAMAGE;
          const vfxKey = projectile.vfxKey || weaponData?.id || projectile.type;
          const vfxColor = projectile.color || weaponData?.color;
          window.bullets.push({
            x: muzzle.pos.x,
            y: muzzle.pos.y,
            vx: muzzle.dir.x * (projectile.speed ?? RAIL_SPEED) + ship.vel.x,
            vy: muzzle.dir.y * (projectile.speed ?? RAIL_SPEED) + ship.vel.y,
            life: projectile.life ?? 2.0,
            r: projectile.radius ?? 4,
            owner: 'player',
            damage,
            penetration: (projectile.penetration != null) ? projectile.penetration : RAIL_PEN,
            type: projectile.type || 'rail',
            weaponId: weaponData?.id,
            color: projectile.color,
            effectScale: projectile.effectScale ?? 1.0,
            explodeRadius: projectile.explodeRadius,
            vfxKey,
            vfxColor,
            hitFx: projectile.type === 'beam'
              ? null
              : (behavior.hitFx
                ? (x, y, scale) => behavior.hitFx(x, y, scale)
                : (x, y, scale) => spawnWeaponImpactFromPreset(resolveBulletVfxKey(vfxKey, projectile.type), vfxColor, scale, x, y)),
          });

          const wId = weaponData?.id || 'default_gun';
          window.dispatchEvent(new CustomEvent('game_weapon_fired', {
            detail: {
              weaponId: wId,
              x: muzzle.pos.x,
              y: muzzle.pos.y
            }
          }));
        }
        const recoilKick = fireResult?.recoilKick ?? behavior.recoilKick ?? t.recoilKick;
        const recoilMax = fireResult?.recoilMax ?? behavior.recoilMax ?? t.recoilMax;
        if (t && Array.isArray(t.recoil)) {
          const idx = barIndex % 2;
          t.recoil[idx] = Math.min(t.recoil[idx] + recoilKick, recoilMax);
        } else if (t) {
          t.recoil = Math.min(t.recoil + recoilKick, recoilMax);
        }
        const muzzleFx = behavior.muzzleFx || spawnRailMuzzle;
        if (muzzleFx && projectile.type !== 'beam') {
          muzzleFx(muzzle.pos, muzzle.dir, ship.vel, projectile.effectScale ?? 1.0);
        }
        maxCooldown = Math.max(maxCooldown, fireResult?.cooldown ?? behavior.cooldown ?? rail.cdMax);
      }
      rail.cd[barIndex] = maxCooldown || rail.cdMax;
    }

    // =============== CIWS (point-defence) ===============
    const CIWS_FIRE_INTERVAL = 0.06;
    const CIWS_BULLET_SPEED = 900;
    const CIWS_DAMAGE = 8;
    const CIWS_RANGE = 600;

    const SIEGE_CANNON_COOLDOWN = 5.2;
    const SIEGE_CANNON_DAMAGE = 200;
    const SIEGE_CANNON_SPEED = 1700;
    const SIEGE_CANNON_RANGE = 1800;
    const SIEGE_CANNON_SPREAD = 0.0045;
    const SIEGE_CANNON_LIFE = 1.1 * (SIEGE_CANNON_RANGE / SIEGE_CANNON_SPEED);

    const LASER_PD_FIRE_INTERVAL = 0.18;
    const LASER_PD_DAMAGE = 16;
    const LASER_PD_RANGE = 620;
    const LASER_PD_BEAM_WIDTH = 6;

    function ciwsStep(dt) {
      const auxWeapons = Game.player.weapons?.[HP.AUX] || [];
      for (let i = 0; i < ship.ciws.length; i++) {
        if (i >= auxWeapons.length) break;
        const loadout = auxWeapons[i];
        if (!loadout || !loadout.weapon) continue;
        const weaponId = loadout.weapon.id;
        const pdDef = loadout.weapon.aispacePdId ? AISPACE_PD[loadout.weapon.aispacePdId] : null;
        const flakDef = loadout.weapon.aispaceFlakId ? AISPACE_FLAK[loadout.weapon.aispaceFlakId] : null;
        const isLaser = weaponId === 'laser_pd_mk1' || loadout.weapon.aispacePdId === 'pd_laser';
        const stats = pdDef || flakDef;
        const gun = ship.ciws[i];
        gun.cd = Math.max(0, gun.cd - dt);
        const off = rotate(gun.offset, ship.angle);
        const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
        const baseVel = { x: ship.vel.x - ship.angVel * off.y, y: ship.vel.y + ship.angVel * off.x };
        const range = stats?.range || (isLaser ? LASER_PD_RANGE : CIWS_RANGE);
        let target = null; let dist = range;
        for (const npc of npcs) {
          if (npc.dead || npc.friendly || !npc.isPirate) continue;
          const d = Math.hypot(npc.x - base.x, npc.y - base.y);
          if (d < dist) { dist = d; target = npc; }
        }
        if (!target) continue;

        const aimPoint = isLaser ? { x: target.x, y: target.y }
          : leadTarget(base, baseVel, target, stats?.speed || CIWS_BULLET_SPEED);
        const desired = Math.atan2(aimPoint.y - base.y, aimPoint.x - base.x);
        let diff = wrapAngle(desired - gun.angle);
        const aimStrength = isLaser ? 9 : 8;
        const maxVel = isLaser ? 6.5 : 6;
        let desiredVel = clamp(diff * aimStrength, -maxVel, maxVel);
        const velDelta = desiredVel - gun.angVel;
        const maxDelta = 40 * dt;
        gun.angVel += clamp(velDelta, -maxDelta, maxDelta);
        gun.angVel *= Math.exp(-8 * dt);
        gun.angVel = clamp(gun.angVel, -maxVel, maxVel);
        gun.angle = wrapAngle(gun.angle + gun.angVel * dt);

        const aimTolerance = isLaser ? 0.1 : 0.15;
        if (Math.abs(diff) >= aimTolerance || gun.cd > 0) continue;

        const fireInterval = stats?.rps ? (1 / stats.rps) : (isLaser ? LASER_PD_FIRE_INTERVAL : CIWS_FIRE_INTERVAL);
        if (flakDef) {
          fireAispaceFlakShell(gun, base, baseVel, target, flakDef, fireInterval);
        } else if (isLaser) {
          firePointDefenseLaser(gun, base, baseVel, target, pdDef, fireInterval);
        } else {
          fireCIWSGun(gun, base, baseVel, pdDef, fireInterval);
        }
      }
    }

    function fireCIWSGun(gun, base, baseVel, stats, fireInterval) {
      const dir = { x: Math.cos(gun.angle), y: Math.sin(gun.angle) };
      const px = base.x + dir.x * 6;
      const py = base.y + dir.y * 6;
      const damage = stats?.dmg ?? stats?.damage ?? CIWS_DAMAGE;
      const speed = stats?.speed ?? CIWS_BULLET_SPEED;
      window.bullets.push({
        x: px,
        y: py,
        vx: dir.x * speed + baseVel.x,
        vy: dir.y * speed + baseVel.y,
        life: 1.2,
        r: 2,
        owner: 'player',
        damage,
        color: stats?.color,
        type: 'ciws'
      });
      spawnParticle(
        { x: px, y: py },
        { x: dir.x * 120 + baseVel.x * 0.1, y: dir.y * 120 + baseVel.y * 0.1 },
        0.06,
        '#ffdf9e',
        2.0,
        true
      );
      gun.cd = fireInterval ?? CIWS_FIRE_INTERVAL;
    }

    function firePointDefenseLaser(gun, base, baseVel, target, stats, fireInterval) {
      const dir = { x: Math.cos(gun.angle), y: Math.sin(gun.angle) };
      const muzzle = { x: base.x + dir.x * 6, y: base.y + dir.y * 6 };
      const toTarget = { x: target.x - muzzle.x, y: target.y - muzzle.y };
      const range = stats?.range ?? LASER_PD_RANGE;
      const damage = stats?.dmg ?? LASER_PD_DAMAGE;
      const distance = clamp(Math.hypot(toTarget.x, toTarget.y), 0, range);
      const beamEnd = { x: muzzle.x + dir.x * distance, y: muzzle.y + dir.y * distance };

      spawnLaserBeam(muzzle, beamEnd, LASER_PD_BEAM_WIDTH, {
        life: 0.09,
        colorOuter: stats?.color || 'rgba(110,200,255,0.9)',
        colorInner: 'rgba(250,255,255,1.0)',
        glowColor: stats?.color || 'rgba(90,180,255,0.95)',
        glowBlur: 22,
        outerWidthMul: 1.05,
        innerWidthMul: 0.45
      });
      spawnPointDefenseLaserMuzzle(muzzle, dir, baseVel);
      spawnPointDefenseLaserHit(beamEnd.x, beamEnd.y);
      applyDamageToNPC(target, damage, 'laser_pd');
      gun.cd = fireInterval ?? LASER_PD_FIRE_INTERVAL;
    }

    function fireAispaceFlakShell(gun, base, baseVel, target, flakDef, fireInterval) {
      spawnBulletAdapter(ship, target, flakDef, {
        type: 'armata',
        origin: base,
        originVel: baseVel,
        angleOverride: gun.angle
      });
      gun.cd = fireInterval ?? (flakDef?.rps ? 1 / flakDef.rps : CIWS_FIRE_INTERVAL);
    }

    function spawnPointDefenseLaserMuzzle(pos, dir, baseVel) {
      const tangential = { x: -dir.y, y: dir.x };
      for (let i = 0; i < 3; i++) {
        const spread = (Math.random() - 0.5) * 0.6;
        const vel = {
          x: dir.x * (220 + Math.random() * 80) + tangential.x * spread * 80 + baseVel.x * 0.1,
          y: dir.y * (220 + Math.random() * 80) + tangential.y * spread * 80 + baseVel.y * 0.1
        };
        spawnParticle(
          { x: pos.x, y: pos.y },
          vel,
          0.08 + Math.random() * 0.05,
          '#8fe4ff',
          2.2 + Math.random() * 0.8,
          true
        );
      }
    }

    function spawnPointDefenseLaserHit(x, y) {
      for (let i = 0; i < 12; i++) {
        const a = Math.random() * Math.PI * 2;
        const speed = 160 + Math.random() * 200;
        spawnParticle(
          { x, y },
          { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
          0.16 + Math.random() * 0.14,
          '#78d9ff',
          1.4 + Math.random() * 1.6,
          true
        );
      }
      spawnParticle({ x, y }, { x: 0, y: 0 }, 0.05, '#ffffff', 4.4, true);
      spawnShockwave(x, y, { r: 5, maxR: 70, w: 2.4, maxLife: 0.35, color: 'rgba(110,200,255,' });
    }

    // =============== Specjal & dmg ===============
    function tryFireSpecial() {
      if (!(Game.player.weapons?.[HP.SPECIAL]?.length)) return;
      if (ship.special.cooldownTimer > 0) return;
      ship.special.cooldownTimer = SPECIAL_COOLDOWN;
      const specialWeaponsCount = Game.player.weapons?.[HP.SPECIAL]?.length || 0;
      if (window.AudioSys && specialWeaponsCount > 0) {
        const shotsTotal = specialWeaponsCount * 2;
        const shotDelayMs = 60;
        for (let i = 0; i < shotsTotal; i++) {
          setTimeout(() => AudioSys.playSound('specialTurret'), i * shotDelayMs);
        }
      }
      const dir = rotate({ x: 1, y: 0 }, ship.angle);
      const start = add(ship.pos, rotate({ x: ship.w / 2, y: 0 }, ship.angle));
      const length = 2000;
      const end = { x: start.x + dir.x * length, y: start.y + dir.y * length };
      const width = ship.w;
      const npcsInRange = npcs.filter(npc => !npc.dead && Math.hypot(npc.x - start.x, npc.y - start.y) < length + npc.radius);
      let hits = 0;
      const HIT_CAP = 80; // wystarczajƒÖco du≈ºo, by czuƒá ‚Äûmiot≈Çƒô", ale bez zgonu CPU
      for (const npc of npcsInRange) {
        if (hits >= HIT_CAP) break;
        const vx = npc.x - start.x, vy = npc.y - start.y;
        const proj = vx * dir.x + vy * dir.y;
        if (proj < 0 || proj > length) continue;
        const perp = Math.abs(vx * dir.y - vy * dir.x);
        if (perp <= npc.radius + width * 0.5) {
          applyDamageToNPC(npc, SPECIAL_DAMAGE, 'none');
          if ((hits & 1) === 0) spawnParticle({ x: npc.x, y: npc.y }, { x: 0, y: 0 }, 0.10, '#9ccfff', 5, true);
          hits++;
        }
      }
      spawnLaserBeam(start, end, width);
      for (let i = 0; i < 8; i++) {
        const t = i / 7;
        const px = start.x + dir.x * length * t + (Math.random() - 0.5) * width * 0.3;
        const py = start.y + dir.y * length * t + (Math.random() - 0.5) * width * 0.3;
        spawnParticle({ x: px, y: py }, { x: (Math.random() - 0.5) * 120, y: (Math.random() - 0.5) * 120 }, 0.2, '#9ccfff', 2.5, true);
      }
    }


    function handlePlayerDestroyed() {
      if (ship.destroyed) return;
      ship.destroyed = true;
      input.main = input.leftSide = input.rightSide = input.torque = 0;
      applyPlayerInput(ship, { controller: 'player', main: 0, thrustX: 0, thrustY: 0, leftSide: 0, rightSide: 0, torque: 0 }, input);
      ship.command = null;
      stopBoost();
      if (warp.state !== 'idle') {
        warp.state = 'idle';
        warp.charge = 0;
      }

      const reactorY = ship.pos.y + ship.h * 0.08;
      triggerReactorBlow3D(ship.pos.x, reactorY, ship.h * 0.35);
    }

    function applyDamageToPlayer(amount) {
      const prevHull = ship.hull.val;
      if (ship.shield.val > 0) { const s = Math.min(ship.shield.val, amount); ship.shield.val -= s; amount -= s; ship.shield.regenTimer = ship.shield.regenDelay; }
      if (amount > 0) ship.hull.val = Math.max(0, ship.hull.val - amount);
      if (!ship.destroyed && prevHull > 0 && ship.hull.val <= 0) {
        handlePlayerDestroyed();
      }
    }
    function applyDamageToNPC(npc, dmg, cause = 'default') {
      if (npc.dead) return;
      if (!Number.isFinite(dmg) || dmg <= 0) return;
      npc.hitFlash = 0.12;
      npc.damageHue = (npc.damageHue || 0) + dmg;

      let remaining = dmg;
      if (npc.shield && npc.shield.max > 0) {
        npc.shield.regenTimer = npc.shield.regenDelay ?? 0;
        const absorbed = Math.min(npc.shield.val, remaining);
        if (absorbed > 0) {
          npc.shield.val -= absorbed;
          remaining -= absorbed;
          if (npc.fleetEntry) {
            npc.fleetEntry.status.shield = npc.shield.val;
            markFleetDirty();
          }
        }
      }

      if (remaining <= 0) {
        return;
      }

      npc.hp -= remaining;
      if (npc.fleetEntry) {
        npc.fleetEntry.status.hull = npc.hp;
        markFleetDirty();
      }
      if (npc.hp <= 0) {
        npc.dead = true;
        npc.respawnTimer = 3 + Math.random() * 6;

        // Create wreck from surviving hexes (if any)
        if (npc.hexGrid && npc.hexGrid.shards && window.createWreckage) {
          const survivingShards = npc.hexGrid.shards.filter(s => s.active && !s.isDebris && s.hp > 0);
          if (survivingShards.length > 3) { // Only create wreck if enough hexes survived
            window.createWreckage(npc, survivingShards);
          }
        }

        if (cause === 'plasma') { spawnExplosionPlasma(npc.x, npc.y, 1.2); }
        else if (cause === 'default') { spawnDefaultHit(npc.x, npc.y, 1.2); }
      }
    }

    function applyDamageToStation(station, amount) {
      let dmg = amount || 0;
      if (dmg <= 0) return 0;
      if (station.shield) {
        station.shield.regenTimer = station.shield.regenDelay;
        const absorbed = Math.min(station.shield.val, dmg);
        station.shield.val -= absorbed;
        dmg -= absorbed;
      }
      if (dmg > 0) {
        station.hp = Math.max(0, station.hp - dmg);
      }
      return dmg;
    }

    function applyDamageToPlatform(platform, amount) {
      if (!platform || platform.destroyed) return 0;
      let dmg = amount || 0;
      if (dmg <= 0) return 0;
      if (platform.shield) {
        platform.shield.regenTimer = platform.shield.regenDelay;
        const absorbed = Math.min(platform.shield.val, dmg);
        platform.shield.val -= absorbed;
        dmg -= absorbed;
      }
      if (dmg > 0) {
        platform.hp = Math.max(0, platform.hp - dmg);
      }
      platform.hitFlash = 0.18;
      if (platform.hp <= 0 && !platform.destroyed) {
        platform.destroyed = true;
        platform.deathTimer = 0;
        spawnExplosionPlasma(platform.x, platform.y, 1.4);
        spawnShockwave(platform.x, platform.y, { maxR: 420, maxLife: 0.6, color: 'rgba(255,140,120,' });
      }
      return dmg;
    }

    // Optymalizacja 1: Prosty Spatial Grid
    const SpatialGrid = {
      cellSize: 4000, // Rozmiar kom√≥rki (musi byƒá wiƒôkszy ni≈º najwiƒôkszy obiekt)
      cells: new Map(),

      clear() {
        this.cells.clear();
      },

      getKey(x, y) {
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        return cx + "," + cy;
      },

      insert(entity) {
        // Rejestrujemy obiekt w kom√≥rce, w kt√≥rej jest jego ≈õrodek
        // (Dla du≈ºych obiekt√≥w mo≈ºna rejestrowaƒá w sƒÖsiednich, ale to wersja uproszczona)
        const key = this.getKey(entity.x, entity.y);
        if (!this.cells.has(key)) this.cells.set(key, []);
        this.cells.get(key).push(entity);
      },

      // Zwraca obiekty z kom√≥rki obiektu + 8 sƒÖsiednich
      getPotentialTargets(x, y) {
        const cx = Math.floor(x / this.cellSize);
        const cy = Math.floor(y / this.cellSize);
        const results = [];

        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            const key = (cx + i) + "," + (cy + j);
            const cell = this.cells.get(key);
            if (cell) {
              // Zamiast push(...cell) co alokuje pamiƒôƒá, iterujemy (dla wydajno≈õci JS)
              for (let k = 0; k < cell.length; k++) results.push(cell[k]);
            }
          }
        }
        return results;
      }
    };



 function bulletsAndCollisionsStep(dt) {
      // 1. Budowa SpatialGrid
      SpatialGrid.clear();
      for (let i = 0; i < npcs.length; i++) {
        const t = npcs[i];
        if (!t.dead) SpatialGrid.insert(t);
      }
      for (let i = 0; i < wrecks.length; i++) {
        const t = wrecks[i];
        if (t.isWreck) SpatialGrid.insert(t);
      }

      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.px = b.x; b.py = b.y;
        b.x += b.vx * dt; b.y += b.vy * dt;
        b.life -= dt;
        b.age = (b.age || 0) + dt;

        // --- RUCH I EFEKTY WIZUALNE POCISK√ìW ---
        if (b.type === 'plasma' || b.type === 'rocket') {
           const trailVel = { x: -b.vx * 0.02 + (Math.random() - 0.5) * 10, y: -b.vy * 0.02 + (Math.random() - 0.5) * 10 };
           spawnParticle({ x: b.x + (Math.random() - 0.5) * 3, y: b.y + (Math.random() - 0.5) * 3 }, trailVel, 0.28, '#8cff8c', 1.0, false);
           
           if (b.type === 'rocket' && b.homingDelay <= 0) {
              let target = b.target;
              if (!target && lockedTarget && !lockedTarget.dead) target = lockedTarget;
              if (target) {
                 const speed = Math.hypot(b.vx, b.vy);
                 const dir = norm({ x: target.x - b.x, y: target.y - b.y });
                 const current = Math.atan2(b.vy, b.vx);
                 const desired = Math.atan2(dir.y, dir.x);
                 const diff = wrapAngle(desired - current);
                 const maxTurn = (b.turnRate || SIDE_ROCKET_TURN_RATE) * dt;
                 const turn = Math.abs(diff) < maxTurn ? diff : Math.sign(diff) * maxTurn;
                 const newAng = current + turn;
                 b.vx = Math.cos(newAng) * speed; b.vy = Math.sin(newAng) * speed;
              }
           }
        } else if (b.type === 'autocannon') {
           const trailVel = { x: -b.vx * 0.015, y: -b.vy * 0.015 };
           spawnParticle({ x: b.x, y: b.y }, trailVel, 0.18, '#ffdca8', 1.1, true);
        }

        if (b.life <= 0) { bullets.splice(i, 1); continue; }

        // --- G≈Å√ìWNA PƒòTLA KOLIZJI ---
        let hitNPC = null;
        let didHitShield = false; 
        
        const nearbyTargets = SpatialGrid.getPotentialTargets(b.x, b.y);

        for (let k = 0; k < nearbyTargets.length; k++) {
          const npc = nearbyTargets[k];
          if (!npc.isWreck && (npc.dead || npc.isCollidable === false)) continue;
          if (b.source && b.source === npc && b.age < (b.spawnGrace || 0)) continue;
          
          let isHit = false;
          const shieldActive = npc.shield && npc.shield.val > 0;

          // 1. SPRAWDZENIE TARCZY
          if (shieldActive) {
            // Skala 1.5 - taka sama jak w shieldSystem.js
            const shieldScale = 1.5; 

            // Wymiary bazowe
            let w = npc.w || (npc.radius * 2) || 40;
            let h = npc.h || (npc.radius * 2) || 40;

            if (npc.capitalProfile) {
                const baseR = npc.radius || 20;
                const len = baseR * (npc.capitalProfile.lengthScale || 3.2);
                const wid = baseR * (npc.capitalProfile.widthScale || 1.2);
                // Bierzemy MAX, tak jak w grafice
                w = Math.max(w, len);
                h = Math.max(h, wid);
            } else if (npc.fighter || npc.type === 'fighter') {
                const size = Math.max(w, h);
                w = size; h = size;
            }

            const rx = (w / 2) * shieldScale;
            const ry = (h / 2) * shieldScale;

            // === FIX: POWR√ìT DO STANDARDOWEGO KƒÑTA ===
            // Usuwamy spriteRotation, bo debugger pokaza≈Ç, ≈ºe sam npc.angle pasuje do grafiki.
            const effectiveAngle = npc.angle;

            const dx = b.x - npc.x;
            const dy = b.y - npc.y;
            
            // Obr√≥t punktu wzglƒôdem ≈õrodka statku (Local Space)
            const cos = Math.cos(-effectiveAngle);
            const sin = Math.sin(-effectiveAngle);
            const localX = dx * cos - dy * sin;
            const localY = dx * sin + dy * cos;
            
            // Promie≈Ñ tarczy pod kƒÖtem uderzenia
            const impactAngle = Math.atan2(localY, localX);
            const rBase = (rx * ry) / Math.sqrt((ry * Math.cos(impactAngle)) ** 2 + (rx * Math.sin(impactAngle)) ** 2);
            
            // Sprawdzenie czy punkt jest wewnƒÖtrz elipsy
            // Dystans do kwadratu w uk≈Çadzie lokalnym
            const distSq = localX * localX + localY * localY;
            
            // Hitbox tarczy + promie≈Ñ pocisku
            const hitThreshold = rBase + b.r; 

            if (distSq <= hitThreshold * hitThreshold) {
              isHit = true;
              didHitShield = true; 
            }
          } else {
            // Brak tarczy -> zwyk≈Ça kolizja ko≈Çowa
            const dx = b.x - npc.x;
            const dy = b.y - npc.y;
            if ((dx*dx + dy*dy) <= (npc.radius + b.r)**2) {
              isHit = true;
              didHitShield = false;
            }
          }

          if (isHit) { hitNPC = npc; break; }
        }

        if (hitNPC) {
          const npcDamage = Number.isFinite(b.damage) ? b.damage : 0;
          
          // === FAILSAFE ===
          // Je≈õli tarcza jest aktywna, ale z jakiego≈õ powodu matematyka elipsy zawiod≈Ça (np. lag, tunelowanie),
          // a pocisk trafi≈Ç w fizyczny heks w ≈õrodku -> WYMUSZAMY trafienie w tarczƒô.
          const shieldActive = hitNPC.shield && hitNPC.shield.val > 0;
          
          // Czy trafiono w fizyczny kad≈Çub?
          let hexHit = false;
          if (hitNPC.hexGrid) {
             // Sprawdzamy kolizjƒô z heksem, ale na razie bez zadawania obra≈ºe≈Ñ (damage=0),
             // ≈ºeby nie zraniƒá statku pod tarczƒÖ.
             hexHit = DestructorSystem.applyImpact(hitNPC, b.x, b.y, 0, { x: 0, y: 0 });
          } else {
             // Dla ma≈Çych statk√≥w bez heks√≥w, uznajemy ≈ºe trafienie w og√≥le (isHit) to trafienie w kad≈Çub
             hexHit = true;
          }

          // Rozstrzygniƒôcie: TARCZA CZY KAD≈ÅUB?
          if (shieldActive && (didHitShield || hexHit)) {
             // Je≈õli tarcza dzia≈Ça ORAZ (trafiono w elipsƒô LUB trafiono w kad≈Çub) -> TARCZA BLOKUJE
             
             registerShieldImpact(hitNPC, b.x, b.y, npcDamage);
             if (window.AudioSys) AudioSys.playSound('shieldHit');
             
             // Odejmij HP tarczy
             const absorbed = Math.min(hitNPC.shield.val, npcDamage);
             hitNPC.shield.val -= absorbed;
             hitNPC.shield.regenTimer = hitNPC.shield.regenDelay || 3.0;
             
             // ZATRZYMAJ I USU≈É POCISK
             bullets.splice(i, 1);
             continue; 

          } else if (!shieldActive && hexHit) {
             // Tarcza nie dzia≈Ça, trafiono w kad≈Çub -> OBRA≈ªENIA
             
             // Pon√≥w sprawdzenie heksa, tym razem z prawdziwym DMG (≈ºeby odpad≈Ç kawa≈Çek)
             if (hitNPC.hexGrid) {
                DestructorSystem.applyImpact(hitNPC, b.x, b.y, npcDamage, { x: b.vx, y: b.vy });
             }

             applyDamageToNPC(hitNPC, npcDamage, b.type);

             // Efekty
             if (b.type === 'armata') spawnArmataHitEffect(b.x, b.y, 1.0);
             else if (b.type === 'rail') spawnRailHitEffect(b.x, b.y, 1.0);
             else if (b.type === 'autocannon') spawnAutocannonHitEffect(b.x, b.y, 1.0);
             else spawnDefaultHit(b.x, b.y, 1.0);

             if (b.type === 'rail') {
                b.penetration = (b.penetration || 1) - 1;
                if (b.penetration <= 0) bullets.splice(i, 1);
             } else {
                bullets.splice(i, 1);
             }
             continue;
          } else {
             // Pocisk minƒÖ≈Ç wszystko (np. dziura we wraku, albo minƒÖ≈Ç tarczƒô gdy by≈Ça wy≈ÇƒÖczona)
             hitNPC = null;
             continue;
          }
        }

        // --- KOLIZJE Z INNYMI OBIEKTAMI (BEZ ZMIAN) ---
        if (mercMission?.weaponPlatforms) {
           for (const p of mercMission.weaponPlatforms) {
              if (p && !p.destroyed && b.source !== p && Math.hypot(p.x-b.x, p.y-b.y) < p.radius+b.r) {
                 applyDamageToPlatform(p, b.damage||0);
                 triggerMercAggro('platform_hit');
                 spawnExplosionPlasma(b.x, b.y, 1.0);
                 bullets.splice(i, 1);
                 break;
              }
           }
        }
        for (const st of stations) {
           if (st.hp && b.source !== st && Math.hypot(st.x-b.x, st.y-b.y) < st.r+b.r) {
              applyDamageToStation(st, b.damage||0);
              if (mercMission?.station === st) triggerMercAggro('station_hit');
              spawnExplosionPlasma(b.x, b.y, 1.0);
              bullets.splice(i, 1);
              break;
           }
        }
      }
    }
    // =============== NPC movement/shooting ===============
    let npcFireTimer = 0;
    function npcShootingStep(dt) {
      npcFireTimer -= dt;
      if (npcFireTimer <= 0) {
        npcFireTimer = 0.45 + Math.random() * 0.8;
        const candidates = npcs.filter(n => !n.dead && n.weapon && !n.friendly && Math.hypot(n.x - ship.pos.x, n.y - ship.pos.y) < 900);
        if (candidates.length) {
          const shooter = candidates[Math.floor(Math.random() * candidates.length)];
          const dir = norm({ x: ship.pos.x - shooter.x, y: ship.pos.y - shooter.y });
          const bx = shooter.x + dir.x * (shooter.radius + 6), by = shooter.y + dir.y * (shooter.radius + 6);
          if (shooter.weapon === 'railgun') {
            window.bullets.push({ x: bx, y: by, vx: dir.x * 600 + shooter.vx, vy: dir.y * 600 + shooter.vy, life: 2.0, r: 4, owner: 'npc', damage: 40, type: 'rail', penetration: 1 });
          } else {
            window.bullets.push({ x: bx, y: by, vx: dir.x * 220 + shooter.vx, vy: dir.y * 220 + shooter.vy, life: 4, r: 3, owner: 'npc', damage: 12 });
          }
        }
      }
    }
    function npcStep(dt) {
      const DESPAWN_RADIUS_SQ = NPC_DESPAWN_RADIUS * NPC_DESPAWN_RADIUS;
      for (const npc of npcs) {
        if (npc.hitFlash) npc.hitFlash = Math.max(0, npc.hitFlash - dt);
        updateShieldFx(npc, dt);

        if (npc.shield && npc.shield.max > 0) {
          if (npc.shield.regenTimer > 0) {
            npc.shield.regenTimer = Math.max(0, npc.shield.regenTimer - dt);
          } else if (npc.shield.val < npc.shield.max) {
            npc.shield.val = Math.min(npc.shield.max, npc.shield.val + (npc.shield.regenRate || 0) * dt);
          }
        }

        // Despawn logic (poza misjƒÖ)
        if (!npc.mission) {
          const dx = npc.x - ship.pos.x;
          const dy = npc.y - ship.pos.y;
          if (dx * dx + dy * dy > DESPAWN_RADIUS_SQ) {
            npc.dead = true;
            npc.respawnTimer = 5;
            continue;
          }
        }

        // --- LOGIKA MISJI I WALKI ---
        if (npc.mission) {
          if (npc.dead) continue;

          if (npc.state === 'warping_in' && npc.warpData) {
            const dx = npc.warpData.targetX - npc.x;
            const dy = npc.warpData.targetY - npc.y;
            const dist = Math.hypot(dx, dy);

            if (dist < npc.warpData.brakingDist) {
              npc.state = 'engage_formation';
              npc.isCollidable = true;
              npc.vx *= 0.1;
              npc.vy *= 0.1;
              spawnShockwave(npc.x, npc.y, { maxR: 600, maxLife: 0.5, color: 'rgba(255, 100, 100,' });
              if (npc.type === 'battleship') camera.addShake(8, 0.4);
              else camera.addShake(3, 0.2);
              npc.warpData = null;
            } else {
              const dirX = dx / dist;
              const dirY = dy / dist;

              npc.vx = dirX * npc.warpData.speed;
              npc.vy = dirY * npc.warpData.speed;
              npc.angle = Math.atan2(npc.vy, npc.vx);

              spawnParticle(
                { x: npc.x, y: npc.y },
                { x: -dirX * 500, y: -dirY * 500 },
                0.2, '#ffaaaa', 4, false
              );

              npc.x += npc.vx * dt;
              npc.y += npc.vy * dt;
              continue;
            }
          }

          // 1. Komendy RTS (priorytet)
          if (handleCommandedNpc(npc, dt)) {
            npc.vx *= (npc.friction || 0.99);
            npc.vy *= (npc.friction || 0.99);
            npc.x += (npc.vx || 0) * dt;
            npc.y += (npc.vy || 0) * dt;
            npc.angle = Math.atan2(npc.vy || 0, npc.vx || 0);
            continue;
          }

          // 2. AI
          if (npc.ai) npc.ai(dt);

          // 3. Fizyka (Ruch)
          npc.x += (npc.vx || 0) * dt;
          npc.y += (npc.vy || 0) * dt;

          // --- FIZYKA PƒòDU (FRICTION) ---
          // U≈ºywamy friction z szablonu (np. 0.995 dla Destroyera - p≈Çynie d≈Çugo)
          // lub domy≈õlnego 0.92 dla ma≈Çych/lekkich obiekt√≥w, ≈ºeby nie lata≈Çy jak myd≈Ço.
          const friction = npc.friction || 1.0;

          npc.vx *= friction;
          npc.vy *= friction;

          // 4. Obr√≥t
          if (npc.keepAngle) {
            if (typeof npc.desiredAngle === 'number') npc.angle = npc.desiredAngle;
          } else if (!npc.fighter) {
            // My≈õliwce obracajƒÖ siƒô w AI, reszta tutaj
            const speed = Math.hypot(npc.vx, npc.vy);
            if (speed > 1) npc.angle = Math.atan2(npc.vy, npc.vx);
          }
          continue;
        }

        // --- LOGIKA CYWILNA (Reszta funkcji bez zmian) ---
        if (npc.dead) {
          npc.respawnTimer -= dt;
          if (npc.respawnTimer <= 0) {
            const base = stations.find(s => s.id === npc.lastStation) || stations[0];
            const group = stations.filter(s => s.inner === base.inner);
            const start = group[Math.floor(Math.random() * group.length)];
            const targetId = pickNextStation(start.id, npc.type);
            const startPort = Math.floor(Math.random() * start.ports.length);
            const spawnPos = stationPortWorld(start, startPort);
            npc.x = spawnPos.x; npc.y = spawnPos.y; npc.vx = 0; npc.vy = 0;
            npc.hp = npc.maxHp; npc.dead = false; npc.target = targetId; npc.fade = 1; npc.docking = false; npc.lastStation = start.id;
            const target = stations.find(s => s.id === targetId);
            npc.dockPort = target ? Math.floor(Math.random() * target.ports.length) : 0;
            if (target && start.inner === target.inner) {
              const route = getWarpRoute(start.id, targetId);
              if (route) { npc.warpRoute = route; npc.phase = 'toGate'; npc.lane = Math.floor(Math.random() * 2); }
              else { npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0; }
            } else {
              npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0;
            }
          }
          continue;
        }
        if (npc.docking) {
          const st = stations.find(s => s.id === npc.lastStation);
          if (st) { const portPos = stationPortWorld(st, npc.dockPort || 0); npc.x = portPos.x; npc.y = portPos.y; }
          npc.fade -= dt / 0.6;
          if (npc.fade <= 0 && st) {
            const targetId = pickNextStation(npc.lastStation, npc.type);
            const startPort = Math.floor(Math.random() * st.ports.length);
            const spawnPos = stationPortWorld(st, startPort);
            npc.x = spawnPos.x; npc.y = spawnPos.y; npc.vx = 0; npc.vy = 0;
            npc.target = targetId; npc.fade = 1; npc.docking = false; npc.lastStation = st.id;
            const target = stations.find(s => s.id === targetId);
            npc.dockPort = target ? Math.floor(Math.random() * target.ports.length) : 0;
            if (target && st.inner === target.inner) {
              const route = getWarpRoute(st.id, targetId);
              if (route) { npc.warpRoute = route; npc.phase = 'toGate'; npc.lane = Math.floor(Math.random() * 2); }
              else { npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0; }
            } else { npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0; }
          }
          continue;
        }
        if (npc.phase === 'warping') {
          npc.x += npc.vx * dt; npc.y += npc.vy * dt;
          npc.angle = Math.atan2(npc.vy || 0, npc.vx || 0);
          const route = npc.warpRoute;
          const traveled = (npc.x - route.start.x) * route.dir.x + (npc.y - route.start.y) * route.dir.y;
          if (traveled >= route.length) { npc.phase = 'toStation'; npc.x = route.end.x; npc.y = route.end.y; }
          continue;
        }
        if (npc.phase === 'toGate') {
          const gate = npc.warpRoute.start;
          const start = stations.find(s => s.id === npc.lastStation);
          const gv = { x: gate.x - start.x, y: gate.y - start.y };
          const gd = Math.hypot(gv.x, gv.y) || 1;
          const dirToGate = { x: gv.x / gd, y: gv.y / gd };
          const perp = { x: -dirToGate.y, y: dirToGate.x };
          const laneOffset = npc.lane ? 20 : -20;
          const gatePos = { x: gate.x + perp.x * laneOffset, y: gate.y + perp.y * laneOffset };
          const queue = gate.queues[npc.lane];
          let idx = queue.indexOf(npc);
          if (idx === -1) { queue.push(npc); idx = queue.length - 1; }
          const spacing = 30;
          const targetPos = { x: gatePos.x - dirToGate.x * idx * spacing, y: gatePos.y - dirToGate.y * idx * spacing };
          const distGate = Math.hypot(npc.x - gatePos.x, npc.y - gatePos.y);
          if (idx === 0 && distGate < 5) {
            queue.shift(); npc.phase = 'warping';
            npc.vx = npc.warpRoute.dir.x * 4000; npc.vy = npc.warpRoute.dir.y * 4000;
            npc.x = gatePos.x; npc.y = gatePos.y;
            continue;
          }
          const to = { x: targetPos.x - npc.x, y: targetPos.y - npc.y };
          const d = Math.hypot(to.x, to.y);
          if (d < 1) { npc.vx = 0; npc.vy = 0; continue; }
          const dir = { x: to.x / d, y: to.y / d };
          const desiredV = { x: dir.x * npc.speed, y: dir.y * npc.speed };
          npc.vx += (desiredV.x - (npc.vx || 0)) * clamp(1.5 * dt, 0, 1);
          npc.vy += (desiredV.y - (npc.vy || 0)) * clamp(1.5 * dt, 0, 1);
          npc.x += npc.vx * dt; npc.y += npc.vy * dt; npc.angle = Math.atan2(npc.vy || 0, npc.vx || 0);
          continue;
        }
        let targetPos, st = null;
        if (npc.leader != null) {
          const leader = npcs.find(n => n.id === npc.leader && !n.dead);
          if (leader) {
            targetPos = { x: leader.x + Math.cos(npc.orbitAngle) * npc.orbitRadius, y: leader.y + Math.sin(npc.orbitAngle) * npc.orbitRadius };
          } else { npc.leader = null; }
        }
        if (!targetPos) {
          st = stations.find(s => s.id === npc.target);
          if (!st) {
            npc.target = pickNextStation(npc.lastStation, npc.type);
            continue;
          }
          if (npc.phase === 'toStation' || npc.phase === 'direct') { targetPos = stationPortWorld(st, npc.dockPort || 0); }
          else { targetPos = { x: st.x, y: st.y }; }
        }
        const to = { x: targetPos.x - npc.x, y: targetPos.y - npc.y };
        const d = Math.hypot(to.x, to.y);
        const dir = d ? { x: to.x / d, y: to.y / d } : { x: 0, y: 0 };
        const desiredSpeed = npc.leader != null ? npc.speed : npc.speed * (d < 120 ? (d / 120) : 1);
        const desiredV = { x: dir.x * desiredSpeed, y: dir.y * desiredSpeed };
        npc.vx += (desiredV.x - (npc.vx || 0)) * clamp(1.5 * dt, 0, 1);
        npc.vy += (desiredV.y - (npc.vy || 0)) * clamp(1.5 * dt, 0, 1);
        const toP = { x: ship.pos.x - npc.x, y: ship.pos.y - npc.y }; const dp = Math.hypot(toP.x, toP.y);
        if (dp < 120) { npc.vx -= (toP.x / dp) * 40 * dt; npc.vy -= (toP.y / dp) * 40 * dt; }
        npc.x += npc.vx * dt; npc.y += npc.vy * dt; npc.angle = Math.atan2(npc.vy || 0, npc.vx || 0);
        const portPos = st ? stationPortWorld(st, npc.dockPort || 0) : null;
        const distToStation = portPos ? Math.hypot(portPos.x - npc.x, portPos.y - npc.y) : Infinity;
        if (npc.leader == null && st && distToStation < 20) {
          npc.docking = true; npc.x = portPos.x; npc.y = portPos.y; npc.vx = 0; npc.vy = 0; npc.lastStation = st.id;
        }
      }
    }
    function pirateMissionStep(dt) {
      if (!mercMission) return;
      const st = mercMission.station;
      if (!st) return;

      const orbitRadii = pirateOrbitRadii();
      const aggroRadius = mercMission.aggroRadius || orbitRadii.inner || (st.r + 1200);
      mercMission.aggroRadius = aggroRadius;
      const distToPlayer = Math.hypot(ship.pos.x - st.x, ship.pos.y - st.y);
      const zoneId = zoneState.current?.id;

      // --- ZMIANA: Usuniƒôto enterPirateOuterOrbit (nie resetujemy ju≈º formacji starym kodem) ---

      if (zoneId === 'pirate_inner') {
        enterPirateInnerOrbit();
      }

      const shouldAggro = zoneId === 'pirate_inner' || distToPlayer < aggroRadius;
      if (!mercMission.aggro && shouldAggro) {
        triggerMercAggro(zoneId === 'pirate_inner' ? 'player_inner_orbit' : 'player_inside_zone');
      }

      // --- ZMIANA: Usuniƒôto updatePirateGuardBehavior ---
      // To naprawia konflikt sterownik√≥w. Teraz tylko runAdvancedFighterAI steruje ruchem.

      // --- Platformy Obronne ---
      PirateSim.time = (PirateSim.time || 0) + dt;

      const platforms = mercMission.weaponPlatforms || [];
      const target = { x: ship.pos.x, y: ship.pos.y, vx: ship.vel.x, vy: ship.vel.y };
      for (const platform of platforms) {
        if (!platform) continue;
        platform.hitFlash = Math.max(0, platform.hitFlash - dt);
        if (platform.destroyed) {
          platform.deathTimer += dt;
          if (platform.deathTimer > 3) {
            platform.removed = true;
          }
          continue;
        }

        platform.angle += platform.orbitSpeed * dt;
        platform.rotation = wrapAngle(platform.rotation + platform.spin * dt);
        platform.x = st.x + Math.cos(platform.angle) * platform.orbitRadius;
        platform.y = st.y + Math.sin(platform.angle) * platform.orbitRadius;

        const tangentialVel = {
          x: -Math.sin(platform.angle) * platform.orbitRadius * platform.orbitSpeed,
          y: Math.cos(platform.angle) * platform.orbitRadius * platform.orbitSpeed
        };

        if (platform.shield) {
          if (platform.shield.regenTimer > 0) {
            platform.shield.regenTimer = Math.max(0, platform.shield.regenTimer - dt);
          } else {
            platform.shield.val = clamp(platform.shield.val + platform.shield.regenRate * dt, 0, platform.shield.max);
          }
        }

        platform.rail.cd = Math.max(0, platform.rail.cd - dt);
        platform.missile.cd = Math.max(0, platform.missile.cd - dt);

        const distToPlayerPlat = Math.hypot(target.x - platform.x, target.y - platform.y);

        if (platform.rail.cd === 0 && distToPlayerPlat < 2200) {
          const lead = leadTarget({ x: platform.x, y: platform.y }, tangentialVel, target, RAIL_SPEED * 0.9);
          const aim = Math.atan2(lead.y - platform.y, lead.x - platform.x);
          const jitter = (Math.random() - 0.5) * platform.rail.scatter;
          const dir = { x: Math.cos(aim + jitter), y: Math.sin(aim + jitter) };
          const muzzle = muzzlePosFor(platform, dir, 14);
          window.bullets.push({
            x: muzzle.x, y: muzzle.y,
            vx: dir.x * (RAIL_SPEED * 0.9), vy: dir.y * (RAIL_SPEED * 0.9),
            life: 2.0, r: 4, owner: 'npc', damage: platform.rail.damage, type: 'rail', penetration: 2,
            source: platform, spawnGrace: 0.08
          });
          spawnParticle({ x: muzzle.x, y: muzzle.y }, { x: 0, y: 0 }, 0.10, '#bfe7ff', 6, true);
          platform.rail.cd = platform.rail.cdMax;
        }

        if (platform.missile.cd === 0 && distToPlayerPlat < 2600) {
          const lead = leadTarget({ x: platform.x, y: platform.y }, tangentialVel, target, SIDE_BULLET_SPEED);
          const aim = Math.atan2(lead.y - platform.y, lead.x - platform.x);
          const dir = { x: Math.cos(aim), y: Math.sin(aim) };
          const muzzleR = muzzlePosFor(platform, dir, 16);
          window.bullets.push({
            x: muzzleR.x, y: muzzleR.y, px: muzzleR.x, py: muzzleR.y,
            vx: dir.x * SIDE_BULLET_SPEED, vy: dir.y * SIDE_BULLET_SPEED,
            life: 2.6, r: 5, owner: 'npc', damage: platform.missile.damage,
            type: 'rocket', explodeRadius: SIDE_PLASMA_EXPLODE_RADIUS,
            homingDelay: SIDE_ROCKET_HOMING_DELAY,
            source: platform, spawnGrace: 0.12
          });
          platform.missile.cd = platform.missile.cdMax;
        }
      }
      if (platforms.length) {
        mercMission.weaponPlatforms = platforms.filter(p => p && !p.removed);
      }

      if (mercMission.alertStage !== 'engage') return;

      // --- SWARM (Fale wrog√≥w) ---
      const swarm = mercMission.swarm;
      if (!swarm) return;
      if (!swarm.active) return;

      // Liczba ≈ºywych pirat√≥w
      const alive = npcs.reduce((a, n) => a + (n.mission && !n.friendly && !n.dead ? 1 : 0), 0);

      swarm.timer -= dt;

      // Je≈õli ma≈Ço wrog√≥w i up≈ÇynƒÖ≈Ç czas -> spawnuj
      if (swarm.timer <= 0 && alive < swarm.maxAlive) {
        // Reset timera (d≈Çu≈ºszy odstƒôp po spawnie fali)
        swarm.timer = 8.0;

        // Pobierz typ z kolejki
        const queued = Array.isArray(swarm.queue) ? swarm.queue.shift() : null;
        const descriptor = (queued && typeof queued === 'object') ? queued : { kind: queued };
        let kind = descriptor.kind || ((Math.random() < 0.6) ? 'fighter_squad' : 'frigate_pd');

        const spawnPos = descriptor.pos;
        const angleToPlayer = spawnPos
          ? Math.atan2(ship.pos.y - spawnPos.y, ship.pos.x - spawnPos.x)
          : Math.atan2(ship.pos.y - st.y, ship.pos.x - st.x);

        // 1. MY≈öLIWCE: U≈ºywamy spawnPirateSquad w trybie 'attack'
        // Tworzy eskadrƒô 7 interceptor√≥w, kt√≥re od razu lecƒÖ na gracza
        if (kind === 'fighter' || kind === 'interceptor' || kind === 'fighter_squad') {
          spawnPirateSquad(st, 'interceptor', 7, 'attack');
        }
        // 2. DU≈ªE STATKI: Spawnujemy pojedynczo przez spawnPirate
        else {
          const npc = spawnPirate(kind, st);

          // Je≈õli w kolejce by≈Ça zdefiniowana pozycja (np. dla formacji capitali)
          if (spawnPos) {
            npc.x = spawnPos.x; npc.y = spawnPos.y;
            npc.formationSlot = { x: descriptor.offset || 0, y: 0 };
            npc.angle = angleToPlayer;

            // KLUCZOWE: Nadaj pƒôd poczƒÖtkowy, ≈ºeby nie sta≈Çy w miejscu przy spawnie
            npc.vx += Math.cos(angleToPlayer) * 80;
            npc.vy += Math.sin(angleToPlayer) * 80;
          }

          // Wa≈ºne: Ustaw stan na atak, ≈ºeby nie wesz≈Çy w tryb Guard/Orbit
          npc.state = 'engage_formation';
          npc.guardStation = null;

          // Reset cel√≥w dla AI (niech aiPickBestTarget wybierze gracza lub jego my≈õliwce)
          npc.forceTarget = null;
          npc.target = null;
        }

        // Je≈õli kolejka pusta, odn√≥w jƒÖ
        if (swarm.queue && swarm.queue.length === 0) resetSwarmQueue();
      }
    }
    // =============== Warp (jak wcze≈õniej) ===============
    const warp = {
      state: 'idle', // idle | charging | active
      charge: 0, chargeTime: 0.8,
      orientTolerance: Math.PI / 30, // 6 stopni - to nas blokowa≈Ço!
      speed: 5000, // Prƒôdko≈õƒá przelotowa
      fuelMax: 60, fuel: 60, consumeRate: 1.0, regenRate: 5,
      dir: { x: 0, y: 0 },
      turnRate: Math.PI / 5, // maksymalna prƒôdko≈õƒá skrƒôtu w rad/s podczas warpa
      alignRate: Math.PI / 2.5, // szybko≈õƒá zgrywania kad≈Çuba do kierunku lotu
      entryProgress: 0,
      entryDuration: 0.9,
      entryBaseSpeed: 0,
      gravityBrake: {
        active: false,
        timer: 0,
        duration: 1.1,
        dir: { x: 0, y: 0 },
        startSpeed: 0,
        sourceId: null
      },
      isBusy() { return this.state !== 'idle'; }
    };
    // WA≈ªNE: Upubliczniamy warp, ≈ºeby planet3d.assets.js (gwiazdy) go widzia≈Çy!
    window.warp = warp;

    function exitWarp() {
      spawnShockwave(ship.pos.x, ship.pos.y, { maxR: 1200, maxLife: 0.7 });
      camera.addShake(18, 0.22);

      warp.entryProgress = 0;

      // TO JEST NAJWA≈ªNIEJSZE:
      // Ustawiamy timer na czas trwania efektu hamowania (np. 0.8 sekundy)
      warpBrakeTimer = 0.8;

      // Zachowujemy ostatni kierunek warpa, aby efekt hamowania wiedzia≈Ç, w kt√≥rƒÖ stronƒô rysowaƒá kreski
      // (Je≈õli warp.dir siƒô zeruje gdzie≈õ indziej, to tu go "zamra≈ºamy" dla efektu)
      if (!warp.lastDir) warp.lastDir = { x: warp.dir.x, y: warp.dir.y };
      warp.lastDir.x = warp.dir.x;
      warp.lastDir.y = warp.dir.y;
    }

    function triggerGravityWarpBrake(zoneId) {
      if (warp.state !== 'active') return;
      const source = resolveGravityWellSource(zoneId);
      const dirVec = source
        ? { x: source.x - ship.pos.x, y: source.y - ship.pos.y }
        : { x: warp.dir.x, y: warp.dir.y };
      const dir = norm(dirVec.x || dirVec.y ? dirVec : warp.dir);
      const brake = warp.gravityBrake;
      brake.active = true;
      brake.timer = brake.duration;
      brake.dir.x = dir.x || 0;
      brake.dir.y = dir.y || 0;
      brake.startSpeed = Math.hypot(ship.vel.x, ship.vel.y);
      brake.sourceId = zoneId;
      warp.state = 'idle';
      warp.charge = 0;
      exitWarp();
    }

    function updateGravityWarpBrake(dt) {
      const brake = warp.gravityBrake;
      if (!brake.active) return;
      brake.timer = Math.max(0, brake.timer - dt);
      const t = brake.duration > 0 ? clamp(brake.timer / brake.duration, 0, 1) : 0;
      const brakeRate = 10 + 6 * t;
      const lerpFactor = clamp(dt * brakeRate, 0, 1);
      ship.vel.x += (0 - ship.vel.x) * lerpFactor;
      ship.vel.y += (0 - ship.vel.y) * lerpFactor;
      ship.angVel += (0 - ship.angVel) * Math.min(1, dt * 6);
      if (brake.timer <= 0.0001 && Math.hypot(ship.vel.x, ship.vel.y) < 5) {
        brake.active = false;
        brake.sourceId = null;
      }
    }

    const boost = {
      state: 'idle',
      fuelMax: 45, fuel: 45,
      regenRate: 1.5,
      consumeRate: 1.0,
      extraThrustMul: 1.2,
      handlingMultiplier: 1.35,
      dampingFactor: 0.55,
      angularDampingFactor: 0.65,
      effectTime: 0, effectDuration: 0.25, effectDir: { x: 0, y: -1 }
    };

    function attemptWarp() {
      if (warp.state === 'idle' && (DevFlags.unlimitedWarp || warp.fuel > 0)) {
        warp.state = 'charging';
        warp.charge = 0;
        return;
      }
      if (warp.state === 'charging') {
        warp.state = 'idle';
        warp.charge = 0;
        return;
      }
      if (warp.state === 'active') {
        warp.state = 'idle';
        exitWarp();
      }
    }

    function engageWarp(dirToMouse) { // dirToMouse ignorujemy, bierzemy dzi√≥b statku
      
      // FIX: Pobieramy wektor z AKTUALNEGO kƒÖta statku
      // W tym silniku 0 stopni to g√≥ra (0, -1), obr√≥t zgodnie z zegarem
      const angle = ship.angle;
      const dirX = Math.cos(angle);
      const dirY = Math.sin(angle);

      warp.dir.x = dirX;
      warp.dir.y = dirY;
      
    
      
      ship.angVel = 0; // Tylko stabilizujemy obr√≥t
      
      warp.state = 'active';
      warp.entryProgress = 0;
      warp.entryBaseSpeed = Math.hypot(ship.vel.x, ship.vel.y);
      
      if (DevFlags.unlimitedWarp) {
        warp.fuel = warp.fuelMax;
      }
      
      // Efekty wizualne
      spawnParticle({ x: ship.pos.x, y: ship.pos.y }, { x: 0, y: 0 }, 0.14, '#bfe7ff', 8, true);
      for (let i = 0; i < 18; i++) {
        const a = Math.random() * Math.PI * 2;
        spawnParticle({ x: ship.pos.x, y: ship.pos.y }, { x: Math.cos(a) * 320, y: Math.sin(a) * 320 }, 0.18 + Math.random() * 0.18, '#cce6ff', 1.4, false);
      }
    }

    // =============== Fizyk ===============
    function physicsStep(dt) {
      updateCameraTarget(dt);
      updateStationUIState(dt);
      updateInfrastructureEditorState(dt);
      updateInfrastructureState(dt);
      if (window.updateInfrastructureAnimations) {
        window.updateInfrastructureAnimations(dt);
      }
      // czas gry
      gameTime = (gameTime + dt * TIME_SCALE) % (24 * 3600);
      // aktualizacja orbit planet i stacji
      for (const pl of planets) {
        pl.angle += pl.speed * dt * TIME_SCALE;
        const R = pl.devOrbitOverrideR ?? pl.orbitRadius ?? pl.orbit?.radius ?? pl.orbitR ?? BASE_ORBIT;
        if ('orbitRadius' in pl) pl.orbitRadius = R;
        if (pl.orbit && 'radius' in pl.orbit) pl.orbit.radius = R;
        if ('orbitR' in pl) pl.orbitR = R;
        pl.x = SUN.x + Math.cos(pl.angle) * R;
        pl.y = SUN.y + Math.sin(pl.angle) * R;
      }
      for (const st of stations) {
        if (st.static) continue;
        st.angle += st.speed * dt * TIME_SCALE;
        st.x = st.planet.x + Math.cos(st.angle) * st.orbitRadius;
        st.y = st.planet.y + Math.sin(st.angle) * st.orbitRadius;
      }
      for (const st of stations) {
        if (!st.warpGate) continue;
        const off = st.warpGate.offset;
        const ox = off && typeof off.x === 'number' ? off.x : 0;
        const oy = off && typeof off.y === 'number' ? off.y : 0;
        st.warpGate.x = st.x + ox;
        st.warpGate.y = st.y + oy;
      }
      for (const key in warpRoutes) {
        const route = warpRoutes[key];
        if (!route) continue;
        const from = route.fromRef;
        const to = route.toRef;
        if (!from || !to) continue;
        const sx = from.warpGate?.x ?? from.x;
        const sy = from.warpGate?.y ?? from.y;
        const ex = to.warpGate?.x ?? to.x;
        const ey = to.warpGate?.y ?? to.y;
        route.start.x = sx;
        route.start.y = sy;
        route.end.x = ex;
        route.end.y = ey;
        const dx = ex - sx;
        const dy = ey - sy;
        const dist = Math.hypot(dx, dy) || 1;
        route.dir.x = dx / dist;
        route.dir.y = dy / dist;
        route.length = dist;
      }
      syncInfrastructureWorldPositions();
      for (const st of stations) {
        if (!st.shield) continue;
        if (st.shield.regenTimer > 0) {
          st.shield.regenTimer = Math.max(0, st.shield.regenTimer - dt);
        } else {
          st.shield.val = clamp(st.shield.val + st.shield.regenRate * dt, 0, st.shield.max);
        }
      }
      for (const st of stations) {
        if (st.baseR == null) st.baseR = st.r;
        const scale = stationScaleFor(st);
        st.r = (st.baseR || st.r) * scale;
      }
      updateZoneState(dt);
      if (boost.state === 'active' && !isPlanetOrbitZoneId(zoneState.current?.id)) {
        boost.state = 'idle';
      }
      if (typeof warpBrakeTimer !== 'undefined' && warpBrakeTimer > 0) {
        warpBrakeTimer -= dt;
      }
      // regen paliwa gdy nie warpuje
      if (warp.state !== 'active') {
        warp.fuel = clamp(warp.fuel + warp.regenRate * dt, 0, warp.fuelMax);
        if (DevFlags.unlimitedWarp) warp.fuel = warp.fuelMax;
        warp.entryProgress = 0;
      }
      if (ship.controller === 'ai') {
        const aiControl = runShipAI(ship, dt);
        if (aiControl) {
          applyPlayerInput(ship, aiControl, input);
        }
      }
      const boostAllowed = isPlanetOrbitZoneId(zoneState.current?.id);
      let boostActive = boost.state === 'active' && boostAllowed;
      if (boost.state === 'active') {
        boost.fuel = clamp(boost.fuel - boost.consumeRate * dt, 0, boost.fuelMax);
        if (boost.fuel <= 0) {
          boost.state = 'idle';
          boostActive = false;
        } else {
          boostActive = true;
        }
      } else {
        boostActive = false;
        if (boost.effectTime <= 0) {
          boost.fuel = clamp(boost.fuel + boost.regenRate * dt, 0, boost.fuelMax);
        }
      }
      if (!boostActive && boost.effectTime > 0) boost.effectTime = Math.max(0, boost.effectTime - dt);

      // rail queue/cd
      rail.cd[0] = Math.max(0, rail.cd[0] - dt);
      rail.cd[1] = Math.max(0, rail.cd[1] - dt);
      const requiredBarrels = Math.max(1, rail.barrelsPerShot || 2);
      const secondaryReady = requiredBarrels < 2 || rail.cd[1] <= 0;
      if (!stationUI.open && mouse.left && rail.queue.length === 0 && rail.cd[0] <= 0 && secondaryReady && !warp.isBusy()) { triggerRailVolley(); }
      for (const q of rail.queue) q.timer -= dt;
      let firedSomething = true;
      while (firedSomething) {
        firedSomething = false;
        for (let i = 0; i < rail.queue.length; i++) {
          const q = rail.queue[i];
          const canFire = q.ignoreCD || rail.cd[q.barrel] <= 0;
          if (q.timer <= 0 && canFire && !warp.isBusy()) {
            fireRailBarrel(q.barrel, q.weaponIndex);
            rail.queue.splice(i, 1);
            firedSomething = true;
            break;
          }
        }
      }
      railTimer = (requiredBarrels > 1) ? Math.min(rail.cd[0], rail.cd[1]) : rail.cd[0];

      ship.special.cooldownTimer = Math.max(0, ship.special.cooldownTimer - dt);
      if (ship.shield.regenTimer > 0) ship.shield.regenTimer -= dt;
      else ship.shield.val = clamp(ship.shield.val + ship.shield.regenRate * dt, 0, ship.shield.max);
      updateShieldFx(ship, dt);
      rocketCooldown = Math.max(0, rocketCooldown - dt);
      // mouse world position
      const mouseWorld = screenToWorld(mouse.x, mouse.y);
      const hasMissilesEquipped = (Game.player.weapons?.[HP.MISSILE]?.length || 0) > 0;
      if (!stationUI.open && mouse.right && !warp.isBusy() && hasMissilesEquipped && (rocketAmmoMax === 0 || rocketAmmo > 0) && rocketCooldown <= 0) {
        const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
        const side = (local.x >= 0) ? 'right' : 'left';
        fireRocket(side);
        rocketCooldown = ROCKET_FIRE_INTERVAL;
      }

      // hover scanning
      let hover = null;
      let hoverType = null;
      if (mouse.overCanvas) {
        let bestDistSq = Infinity;
        const npcMargin = 20;
        for (const npc of npcs) {
          if (npc.dead) continue;
          const radius = (npc.radius || 0) + npcMargin;
          const dx = npc.x - mouseWorld.x;
          const dy = npc.y - mouseWorld.y;
          const distSq = dx * dx + dy * dy;
          if (distSq <= radius * radius && distSq < bestDistSq) {
            bestDistSq = distSq;
            hover = npc;
            hoverType = 'npc';
          }
        }
        const stationMargin = 24;
        for (const st of stations) {
          const baseR = ((st.r ?? st.baseR) || 120) + stationMargin;
          const dx = st.x - mouseWorld.x;
          const dy = st.y - mouseWorld.y;
          const distSq = dx * dx + dy * dy;
          if (distSq <= baseR * baseR && distSq < bestDistSq) {
            bestDistSq = distSq;
            hover = st;
            hoverType = 'station';
          }
        }
        if (mercMission && mercMission.weaponPlatforms) {
          const platformMargin = 18;
          for (const platform of mercMission.weaponPlatforms) {
            if (!platform || platform.removed) continue;
            const radius = (platform.radius || 0) + platformMargin;
            const dx = platform.x - mouseWorld.x;
            const dy = platform.y - mouseWorld.y;
            const distSq = dx * dx + dy * dy;
            if (distSq <= radius * radius && distSq < bestDistSq) {
              bestDistSq = distSq;
              hover = platform;
              hoverType = 'platform';
            }
          }
        }
      }

      if (hover) {
        scan.target = hover;
        scan.targetType = hoverType;
        scan.scanned = hover;
        updateHoverInfo(hover, hoverType);
        if (!stationUI.open && mouse.click && hoverType === 'station') {
          openStationUI(hover);
          mouse.click = false;
        }
      } else {
        if (scan.target || scan.scanned || scan.targetType) {
          scan.target = null;
          scan.scanned = null;
          scan.targetType = null;
        }
        hideHoverInfo();
      }
      if (lockedTarget && (!isHostileNpc(lockedTarget) || lockedTarget.dead)) lockedTarget = null;
      lockedTargets = lockedTargets.filter(isHostileNpc);
      if (highlightTimer > 0) {
        highlightTimer -= dt;
        if (highlightTimer <= 0) { highlightTimer = 0; highlightedEnemies = []; }
      }

      // update radar pings
      for (let i = radarPings.length - 1; i >= 0; i--) {
        const p = radarPings[i];
        p.age += dt; if (p.age > p.life) radarPings.splice(i, 1);
      }
      // update scan waves
      for (let i = scanWaves.length - 1; i >= 0; i--) {
        const w = scanWaves[i];
        w.r += w.speed * dt;
        for (const npc of npcs) {
          if (npc.dead) continue;
          if (!w.hit.has(npc) && Math.hypot(npc.x - w.x, npc.y - w.y) <= w.r) { w.hit.add(npc); spawnRadarPing(npc.x, npc.y); }
        }
        for (const st of stations) {
          if (!w.hit.has(st) && Math.hypot(st.x - w.x, st.y - w.y) <= w.r) { w.hit.add(st); spawnRadarPing(st.x, st.y); }
        }
        if (mercMission && mercMission.weaponPlatforms) {
          for (const platform of mercMission.weaponPlatforms) {
            if (!platform || platform.destroyed || platform.removed) continue;
            if (!w.hit.has(platform) && Math.hypot(platform.x - w.x, platform.y - w.y) <= w.r) {
              w.hit.add(platform);
              spawnRadarPing(platform.x, platform.y);
            }
          }
        }
        if (w.r > w.max) scanWaves.splice(i, 1);
      }

      // update scan arrows
      for (let i = scanArrows.length - 1; i >= 0; i--) {
        const a = scanArrows[i];
        if (warp.state !== 'active') a.age += dt;
        if (a.age > a.life) scanArrows.splice(i, 1);
      }

      // turret aim (poza warp active)
      if (warp.state !== 'active') {
        for (const t of [ship.turret, ship.turret2, ship.turret3, ship.turret4]) {
          const off = rotate(t.offset, ship.angle);
          const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
          const aimPos = (lockedTarget && !lockedTarget.dead)
            ? leadTarget(base, ship.vel, lockedTarget, RAIL_SPEED)
            : mouseWorld;
          let diffT = wrapAngle(Math.atan2(aimPos.y - base.y, aimPos.x - base.x) - t.angle);
          let desiredVel = clamp(diffT * 6.5, -t.maxSpeed, t.maxSpeed);
          const velDelta = desiredVel - t.angVel;
          const maxDelta = t.maxAccel * dt;
          t.angVel += clamp(velDelta, -maxDelta, maxDelta);
          t.angVel *= Math.exp(-t.damping * dt);
          t.angVel = clamp(t.angVel, -t.maxSpeed, t.maxSpeed);
          t.angle = wrapAngle(t.angle + t.angVel * dt);
        }
      }
      for (const t of [ship.turret, ship.turret2, ship.turret3, ship.turret4]) {
        if (Array.isArray(t.recoil)) {
          t.recoil[0] = Math.max(0, t.recoil[0] - t.recoilRecover * dt);
          t.recoil[1] = Math.max(0, t.recoil[1] - t.recoilRecover * dt);
        } else {
          t.recoil = Math.max(0, t.recoil - t.recoilRecover * dt);
        }
      }

      updatePlayerCommand(dt);
      updateEnginePower(dt);

      if (warp.state === 'active') {
        const turnInput = clamp(input.torque, -1, 1);
        if (Math.abs(turnInput) > 1e-3) {
          const currentAngle = Math.atan2(warp.dir.y, warp.dir.x);
          const maxTurn = warp.turnRate * dt;
          const delta = clamp(turnInput * warp.turnRate * dt, -maxTurn, maxTurn);
          const newAngle = currentAngle + delta;
          warp.dir.x = Math.cos(newAngle);
          warp.dir.y = Math.sin(newAngle);
        }
        const desiredBodyAngle = Math.atan2(warp.dir.y, warp.dir.x);
        const diffBody = wrapAngle(desiredBodyAngle - ship.angle);
        const maxAlign = warp.alignRate * dt;
        ship.angle = wrapAngle(ship.angle + clamp(diffBody, -maxAlign, maxAlign));
        ship.angVel = 0;

        warp.entryProgress = Math.min(1, warp.entryProgress + dt / Math.max(0.001, warp.entryDuration));
        const entryEase = smoothstep01(warp.entryProgress);
        const zoneWarpMul = zoneState.current?.warpMultiplier ?? 1;
        const maxWarpSpeed = warp.speed * zoneWarpMul;
        const entryStartSpeed = Math.min(warp.entryBaseSpeed, maxWarpSpeed);
        const targetSpeed = entryStartSpeed + (maxWarpSpeed - entryStartSpeed) * entryEase;
        const targetV = { x: warp.dir.x * targetSpeed, y: warp.dir.y * targetSpeed };
        ship.vel.x += (targetV.x - ship.vel.x) * clamp(6 * dt, 0, 1);
        ship.vel.y += (targetV.y - ship.vel.y) * clamp(6 * dt, 0, 1);
        if (!DevFlags.unlimitedWarp) {
          warp.fuel = Math.max(0, warp.fuel - warp.consumeRate * dt);
          if (warp.fuel <= 0) { warp.state = 'idle'; exitWarp(); }
        } else {
          warp.fuel = warp.fuelMax;
        }
      }
      else if (warp.state === 'charging') {
        const dirToMouse = norm({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y });
        warp.dir.x = dirToMouse.x;
        warp.dir.y = dirToMouse.y;

        const desiredBodyAngle = Math.atan2(dirToMouse.y, dirToMouse.x);

        // Logika obrotu podczas ≈Çadowania (Visual feel)
        const kp = 5.5, maxSpin = 2.5, accel = 8.0;
        const diffB = wrapAngle(desiredBodyAngle - ship.angle);
        const desiredSpin = clamp(diffB * kp, -maxSpin, maxSpin);
        const delta = clamp(desiredSpin - ship.angVel, -accel * dt, accel * dt);
        ship.angVel += delta;

        // ≈Åadowanie paska
        if (warp.charge < warp.chargeTime) {
          warp.charge += dt;
        }

        // WARUNEK WEJ≈öCIA:
        // Je≈õli na≈Çadowane -> wchodzimy. engageWarp() we≈∫mie obecny kƒÖt dziobu.
        if (warp.charge >= warp.chargeTime && (DevFlags.unlimitedWarp || warp.fuel > 0)) {
          engageWarp();
        }
      }
      else {
        // --- HYBRID PHYSICS IMPLEMENTATION (V46 PORT) ---
        // Zastƒôpuje stary model si≈Çowy modelem z dema

        // 1. Parametry
        const baseSpeed = SHIP_PHYSICS.SPEED;
        const rotSpeed = SHIP_PHYSICS.ROTATION_SPEED;

        // Boost
        const boostActive = (boost.state === 'active');
        const currentSpeed = boostActive ? baseSpeed * SHIP_PHYSICS.BOOST_MULT : baseSpeed;
        const currentRotSpeed = rotSpeed; // Mo≈ºna dodaƒá karƒô za boost je≈õli chcemy

        // Tarcie normalizowane do klatki (dt)
        // Wz√≥r: friction_factor = base_friction ^ (dt / 0.016)
        const frictionFactor = Math.pow(SHIP_PHYSICS.FRICTION, dt / 0.016);

        // KƒÖty
        const sin = Math.sin(ship.angle);
        const cos = Math.cos(ship.angle);
        const forward = { x: cos, y: sin }; // Dzi√≥b w prawo (+X)
        const right = { x: -sin, y: cos };  // Prawa burta (prostopad≈Çy)

        // 2. Rotacja (Kinematyczna - bezpo≈õrednia)
        if (input.torque !== 0) {
          ship.angle += input.torque * currentRotSpeed * dt;
          // Aktualizujemy angVel tylko dla system√≥w AI/kolizji, ≈ºeby wiedzia≈Çy ≈ºe siƒô krƒôcimy
          ship.angVel = input.torque * currentRotSpeed;

          // Efekty manewrowe
          if (input.torque < 0) { // W lewo (A)
            const e = ship.engines.torqueRight; // Prawy prz√≥d/ty≈Ç
            const wo = rotate(e.offset, ship.angle);
            spawnParticle(add(ship.pos, wo), add(ship.vel, mul(right, 100)), 0.22, '#cfe7ff', 1.0);
          } else { // W prawo (D)
            const e = ship.engines.torqueLeft; // Lewy prz√≥d/ty≈Ç
            const wo = rotate(e.offset, ship.angle);
            spawnParticle(add(ship.pos, wo), add(ship.vel, mul(right, -100)), 0.22, '#cfe7ff', 1.0);
          }
        } else {
          ship.angVel = 0;
        }
        ship.angle = wrapAngle(ship.angle);

        // 3. Ruch (Dynamiczny + Tarcie)

        // G≈Ç√≥wny ciƒÖg (W/S)
        if (input.main !== 0) {
          // Uwaga: input.main w starym kodzie to 0..1 (przepustnica). 
          // Je≈õli gracz trzyma S, input.main mo≈ºe byƒá obs≈Çugiwane inaczej w applyPlayerInput.
          // Tutaj upraszczamy: keys['w'] daje +speed, keys['s'] daje -speed.
          // Musimy sprawdziƒá surowe klawisze lub zaufaƒá, ≈ºe input.thrustY ma znak.
          // W `applyPlayerInput` thrustY jest przepisywane.

          let thrust = 0;
          if (keys['w']) thrust = 1;
          else if (keys['s']) thrust = -0.4; // Wsteczny wolniejszy

          if (thrust !== 0) {
            ship.vel.x += forward.x * thrust * currentSpeed * dt;
            ship.vel.y += forward.y * thrust * currentSpeed * dt;

            // Efekt g≈Ç√≥wnego silnika
            if (thrust > 0) {
              // CzƒÖsteczki spawnuje osobna pƒôtla `draw` (VFX), tutaj dodajemy tylko fizyczny impuls
              // Ale dla sp√≥jno≈õci dodajmy te≈º ma≈Çy impuls dla 'feeling'
            }
          }
        }

        // Strafe (Q/E) - input.leftSide / input.rightSide
        const sideSpeed = currentSpeed * SHIP_PHYSICS.SIDE_POWER;
        if (input.leftSide > 0) {
          ship.vel.x -= right.x * sideSpeed * input.leftSide * dt;
          ship.vel.y -= right.y * sideSpeed * input.leftSide * dt;

          const e = ship.engines.sideRight; // Odpalasz prawy, lecisz w lewo
          const wo = rotate(e.offset, ship.angle);
          spawnParticle(add(ship.pos, wo), add(ship.vel, mul(right, 150)), 0.30, '#cfe7ff', 1.0);
        }
        if (input.rightSide > 0) {
          ship.vel.x += right.x * sideSpeed * input.rightSide * dt;
          ship.vel.y += right.y * sideSpeed * input.rightSide * dt;

          const e = ship.engines.sideLeft; // Odpalasz lewy, lecisz w prawo
          const wo = rotate(e.offset, ship.angle);
          spawnParticle(add(ship.pos, wo), add(ship.vel, mul(right, -150)), 0.30, '#cfe7ff', 1.0);
        }

        // 4. Aplikacja Tarcia (Klucz do "Driftu")
        ship.vel.x *= frictionFactor;
        ship.vel.y *= frictionFactor;

        // Boost logic (Update Timer)
        if (boostActive) {
          boost.effectTime = boost.effectDuration;
          boost.effectDir = { x: forward.x, y: forward.y };
        }
        if (!boostActive && boost.effectTime > 0) boost.effectTime = Math.max(0, boost.effectTime - dt);
      }

      // integracja ruchu (pozycja)
      // W modelu V46 nie u≈ºywamy F=ma, tylko bezpo≈õrednio v += speed*dt, wiƒôc ax/ay nie sƒÖ potrzebne
      // Jednak dla kolizji i wrak√≥w warto zachowaƒá jakƒÖ≈õ "masƒô" w kolizjach, ale ruch gracza jest nadrzƒôdny.
      updateGravityWarpBrake(dt);
      ship.pos.x += ship.vel.x * dt;
      ship.pos.y += ship.vel.y * dt;

      // granice
      const margin = Math.max(50, getAuToWorldUnits() * WORLD_EDGE_MARGIN_AU);
      ship.pos.x = clamp(ship.pos.x, margin, WORLD.w - margin);
      ship.pos.y = clamp(ship.pos.y, margin, WORLD.h - margin);

      ship.x = ship.pos.x;
      ship.y = ship.pos.y;

      // obr√≥t (STARY KOD USUNIƒòTY - zastƒÖpiony powy≈ºej kinematycznym)
      /* const angAcc = totalTorque / ship.inertia;
      ship.angVel += angAcc * dt;
      ship.angVel *= Math.exp(-ship.angularDamping * (boostActive ? boost.angularDampingFactor : 1) * dt);
      ship.angle += ship.angVel * dt;
      */
      // ship.angle = wrapAngle(ship.angle);
      // Aktualizacja wrak√≥w
      for (let i = wrecks.length - 1; i >= 0; i--) {
        const w = wrecks[i];

        // Fizyka ruchu
        w.x += w.vx * dt;
        w.y += w.vy * dt;
        w.angle += w.angVel * dt;
        w.vx *= w.friction;
        w.vy *= w.friction;
        w.angVel *= w.friction;

        // Despawn je≈õli wrak nie ma ju≈º heks√≥w lub jest bardzo daleko
        const distToPlayer = Math.hypot(w.x - ship.pos.x, w.y - ship.pos.y);
        const hasHexesLeft = w.hexGrid && w.hexGrid.shards &&
          w.hexGrid.shards.some(s => s.active && !s.isDebris && s.hp > 0);

        // Usu≈Ñ tylko je≈õli: brak heks√≥w LUB ekstremalna odleg≈Ço≈õƒá (50km)
        if (!hasHexesLeft || distToPlayer > 50000) {
          wrecks.splice(i, 1);
        }
      }
      // Aktualizacja logiki eskadr
      SQUADS.forEach(s => s.update());
      updateSupportWing(dt);
      npcStep(dt);
      pirateMissionStep(dt);
      ciwsStep(dt);
      bulletsAndCollisionsStep(dt);
      npcShootingStep(dt);
      hudUpdateNav(dt);
    }

    // ======= Efekty VFX =======
    let _engineVFX = null;
    let _engineVFXLoading = false;

    function getEngineVFX() {
      if (_engineVFX) return _engineVFX;

      if (typeof THREE === "undefined") return null;

      // 1) Upewnij siƒô, ≈ºe mamy konstruktory efekt√≥w
      if (typeof window.createShortNeedleExhaust !== "function") {
        if (!_engineVFXLoading) {
          _engineVFXLoading = true;
          import("./Engineeffects.js").then(mod => {
            window.createShortNeedleExhaust = mod.createShortNeedleExhaust;
            window.createWarpExhaustBlue = mod.createWarpExhaustBlue;
          }).catch(err => console.warn("Engineeffects.js failed to load", err))
            .finally(() => { _engineVFXLoading = false; });
        }
        return null;
      }

      // 2) Offscreen canvas i scena
      const canvas = document.createElement("canvas");
      // wiƒôcej miejsca, ≈ºeby ogon nie by≈Ç ≈õcinany
      canvas.width = 128;
      canvas.height = 256;
      const ctx2d = canvas.getContext("2d");

      const scene = new THREE.Scene();
      scene.background = null;

      const camera = new THREE.OrthographicCamera(-64, 64, 64, -192, -1000, 1000);
      camera.position.z = 10;
      camera.lookAt(0, 0, 0);

      const exhaust = window.createShortNeedleExhaust();
      exhaust.group.position.y = 0; // zero ‚Äî unikamy clipu przy obrocie
      scene.add(exhaust.group);

      // 3) Renderer: u≈ºyj wsp√≥≈Çdzielonego je≈õli jest, w przeciwnym razie lokalnego
      let localRenderer = null;
      function pickRenderer(w, h) {
        if (typeof window.getSharedRenderer === "function") {
          const r = window.getSharedRenderer(w, h);
          return r || null;
        }
        if (!localRenderer) {
          localRenderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true,
            premultipliedAlpha: true,
            preserveDrawingBuffer: true
          });
          localRenderer.setPixelRatio(1);
        }
        // dopasuj rozmiar je≈õli siƒô zmieni≈Ç
        const d = localRenderer.getSize(new THREE.Vector2());
        if (d.x !== w || d.y !== h) localRenderer.setSize(w, h, false);
        return localRenderer;
      }

      function resetRendererForVFX(renderer, width, height) {
        if (!renderer) return;
        if (typeof renderer.setRenderTarget === 'function') renderer.setRenderTarget(null);
        if (typeof renderer.setPixelRatio === 'function') renderer.setPixelRatio(1);
        if (typeof renderer.setSize === 'function') renderer.setSize(width, height, false);
        if (typeof renderer.setViewport === 'function') renderer.setViewport(0, 0, width, height);
        if (renderer.state && typeof renderer.state.reset === 'function') renderer.state.reset();
        if (typeof renderer.setScissorTest === 'function') renderer.setScissorTest(false);
        if (typeof renderer.setClearColor === 'function') renderer.setClearColor(0x000000, 0);
        if (typeof renderer.clear === 'function') renderer.clear(true, true, false);
      }

      _engineVFX = {
        canvas, ctx2d, camera, scene, exhaust,
        render(time, overrides = null) {
          const r = pickRenderer(canvas.width, canvas.height);
          if (!r) return;
          // pe≈Çny reset i przezroczyste czyszczenie
          resetRendererForVFX(r, canvas.width, canvas.height);

          // dynamiczny throttle
          const spd = Math.hypot(ship.vel.x, ship.vel.y);
          const moveGlowBase = Math.min(spd / 900, 0.6);
          const thrust = input.main > 0 ? input.main : 0;
          const boostAmpBase = (boost.effectDuration > 0)
            ? clamp(boost.effectTime / boost.effectDuration, 0, 1)
            : 0;
          const warpActiveAmp = (warp.state === 'active') ? smoothstep01(warp.entryProgress) : 0;
          const warpChargeAmp = (warp.state === 'charging')
            ? smoothstep01(Math.min(1, warp.charge / warp.chargeTime)) * 0.6
            : 0;
          const warpAmpBase = Math.max(warpActiveAmp, warpChargeAmp);
          const moveGlow = (overrides && typeof overrides.moveGlowOverride === 'number')
            ? clamp(overrides.moveGlowOverride, 0, 1)
            : moveGlowBase;
          const throttleBase = Math.max(thrust, moveGlow * 0.8);
          const throttle = (overrides && typeof overrides.throttleOverride === 'number')
            ? clamp(overrides.throttleOverride, 0, 1)
            : throttleBase;
          const boostAmp = (overrides && typeof overrides.boostOverride === 'number')
            ? clamp(overrides.boostOverride, 0, 1)
            : boostAmpBase;
          const warpAmp = (overrides && typeof overrides.warpOverride === 'number')
            ? clamp(overrides.warpOverride, 0, 1)
            : warpAmpBase;

          exhaust.setThrottle(throttle);
          exhaust.setWarpBoost(Math.max(boostAmp, warpAmp));
          // Mo≈ºesz dopasowaƒá temperaturƒô i bloom z poziomu opcji (D3):
          exhaust.setColorTemp(OPTIONS.vfx.colorTempK);
          exhaust.setBloomGain(OPTIONS.vfx.bloomGain);

          exhaust.update(time);
          r.render(scene, camera);

          // skopiuj do 2D
          ctx2d.clearRect(0, 0, canvas.width, canvas.height);
          ctx2d.drawImage(r.domElement, 0, 0, canvas.width, canvas.height);
        }
      };

      return _engineVFX;
    }

    // Prosty fallback 2D ‚Äî ≈ºeby ZAWSZE co≈õ by≈Ço widaƒá, gdy evfx==null
    function drawEngineFallback2D() {
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      const g = ctx.createLinearGradient(0, 0, 0, 90);
      g.addColorStop(0, 'rgba(170,210,255,0.55)');
      g.addColorStop(1, 'rgba(170,210,255,0)');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.moveTo(-14, 0);
      ctx.quadraticCurveTo(0, 70, 14, 0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawWarpChargeEffectLocal(progress, radius, spriteScale) {
      if (progress <= 0) return;
      const eased = smoothstep01(progress);
      const baseAlpha = 0.3 + 0.5 * eased;
      const glowR = radius * (0.65 + 0.25 * eased);
      const ringR = radius * (0.9 + 0.35 * eased);
      const lineBase = (6 + 22 * eased) * spriteScale;
      const arcLine = (10 + 18 * eased) * spriteScale;

      ctx.save();
      ctx.globalCompositeOperation = 'lighter';

      const glow = ctx.createRadialGradient(0, 0, glowR * 0.35, 0, 0, glowR);
      glow.addColorStop(0, `rgba(186,232,255,${baseAlpha})`);
      glow.addColorStop(1, 'rgba(125,211,252,0)');
      ctx.fillStyle = glow;
      ctx.beginPath(); ctx.arc(0, 0, glowR, 0, Math.PI * 2); ctx.fill();

      ctx.lineWidth = lineBase;
      ctx.strokeStyle = `rgba(125,211,252,${0.35 + 0.4 * eased})`;
      ctx.beginPath(); ctx.arc(0, 0, ringR, 0, Math.PI * 2); ctx.stroke();

      const segments = 4;
      const arcLen = Math.PI * (0.22 + 0.4 * eased);
      ctx.lineWidth = arcLine;
      ctx.strokeStyle = `rgba(206,244,255,${0.45 + 0.45 * eased})`;
      for (let i = 0; i < segments; i++) {
        const offset = (vfxTime * 1.4 + i / segments) * Math.PI * 2;
        ctx.beginPath();
        ctx.arc(0, 0, ringR, offset, offset + arcLen);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawNeedleEngineVfxLocal(localPos, forward, options = {}) {
      const {
        widthScale = 1.5,
        lengthScale = 0.6,
        yNudge = -68,
        alpha = 1,
        overrides = null,
        fallback = true
      } = options || {};

      const safeWidth = Math.max(0.0001, widthScale);
      const safeLength = Math.max(0.0001, lengthScale);

      ctx.save();
      ctx.translate(localPos.x, localPos.y);
      ctx.scale(safeWidth, safeLength);
      ctx.rotate(Math.atan2(forward.y, forward.x));
      ctx.globalCompositeOperation = 'lighter';
      const prevAlpha = ctx.globalAlpha;
      const engineGain = clamp(OPTIONS?.vfx?.engineGain ?? 1, 0, 1.5);
      ctx.globalAlpha = prevAlpha * alpha * engineGain;

      const evfx = getEngineVFX();
      if (evfx) {
        evfx.render(vfxTime, overrides);
        const w = evfx.canvas.width, h = evfx.canvas.height;
        ctx.drawImage(evfx.canvas, -w / 2, yNudge / safeLength, w, h);
      } else if (fallback) {
        drawEngineFallback2D();
      }

      ctx.globalAlpha = prevAlpha;
      ctx.restore();
    }
    function updateParticles(dt) {
      for (const p of particlePool) {
        if (!p.active) continue;

        p.age += dt;
        if (p.age >= p.life) {
          p.active = false;
          continue;
        }

        if (p.beam) continue;

        // Prosta fizyka czƒÖsteczek
        p.vel.x *= 0.98; // Tarcie
        p.vel.y *= 0.98;
        p.vel.y += 8 * dt; // Grawitacja (je≈õli u≈ºywana)
        p.pos.x += p.vel.x * dt;
        p.pos.y += p.vel.y * dt;
      }
    }
    // =============== Main loop ===============
    let lastTime = performance.now();
    const PHYS_DT = 1 / 120;
    let acc = 0;
    let vfxTime = 0;
    let prevState = null;
    let firstFrameResolver = null;
    function saveState() { prevState = { pos: { ...ship.pos }, angle: ship.angle, turretAngle: ship.turret.angle, turretAngle2: ship.turret2.angle, turretAngle3: ship.turret3.angle, turretAngle4: ship.turret4.angle, ciwsAngles: ship.ciws.map(c => c.angle) }; }
    saveState();
    function loop(now) {
      const frame = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;
      applyGamepad();
      if (PAUSED) {
        saveState();
        updateCameraTarget(frame);
        zoomIndicator.update(frame);
        render(0, frame);
        if (overlay3D) {
          overlay3D.tick(frame);
        }
        if (firstFrameResolver) {
          firstFrameResolver();
          firstFrameResolver = null;
        }
        requestAnimationFrame(loop);
        return;
      }
      acc += frame;
      vfxTime += frame;
      saveState();
      let steps = 0;
      while (acc >= PHYS_DT && steps < 10) {
        physicsStep(PHYS_DT);
        acc -= PHYS_DT; steps++;
      }

      const allDestructibles = [ship, ...npcs, ...wrecks];
      DestructorSystem.update(frame, allDestructibles);

      const mWorld = screenToWorld(mouse.x, mouse.y);
      Superweapon.updateSuperweapon(frame, ship, mWorld);

      // >>> TO JEST KLUCZOWE - ODDZIELNA AKTUALIZACJA WIZUALI√ìW <<<
      updateParticles(frame);
      updateLightnings(frame);
      // >>> BEZ TEGO CZƒÑSTECZKI STOJƒÑ W MIEJSCU <<<

      const alpha = acc / PHYS_DT;
      frameId++;
      missionCompleteBanner.update(frame);
      // Shockwaves
      for (let i = shockwaves.length - 1; i >= 0; i--) {
        const s = shockwaves[i];
        s.life += frame;
        const k = Math.min(1, s.life / s.maxLife);
        s.r = s.maxR * k;
        s.w = Math.max(1, (1 - k) * (s.maxR * 0.06));
        if (s.life >= s.maxLife) shockwaves.splice(i, 1);
      }
      if (camera.shakeTime > 0) {
        camera.shakeTime -= frame;
        if (camera.shakeTime <= 0) camera.shakeMag = 0;
      }
      zoomIndicator.update(frame);

      // --- AUDIO UPDATE ---
      if (ship && ship.engineSound) {
        if (!ship.destroyed) {
          // input.main to warto≈õƒá 0..1 (moc silnika)
          let throttle = input.main;

          // Je≈õli masz BOOST (Shift), dodajemy kopa do d≈∫wiƒôku (+0.5 do pitcha)
          if (typeof boost !== 'undefined' && boost.state === 'active') {
            throttle += 0.5;
          }

          // Aktualizuj d≈∫wiƒôk
          ship.engineSound.update(throttle);
        } else {
          // Je≈õli statek zniszczony - wycisz natychmiast
          ship.engineSound.gain.gain.setTargetAtTime(0, AudioSys.ctx.currentTime, 0.1);
        }
      }
      // --------------------

      render(alpha, frame);

      // WA≈ªNE: Eksportujemy globalne zmienne dla modu≈Çu superweapon
      window.camera = camera;
      window.spawnParticle = spawnParticle;
      window.spawnShockwave = spawnShockwave;
      window.worldToScreen = worldToScreen;

      if (overlay3D) {
        overlay3D.tick(frame);
      }
      if (firstFrameResolver) {
        firstFrameResolver();
        firstFrameResolver = null;
      }
      requestAnimationFrame(loop);
    }

    // =============== Render ===============
    function worldToScreen(wx, wy, cam) { return { x: (wx - cam.x) * camera.zoom + W / 2, y: (wy - cam.y) * camera.zoom + H / 2 }; }

    function stationPortWorld(st, idx) {
      const off = st.ports[idx % st.ports.length];
      return { x: st.x + off.x, y: st.y + off.y };
    }

    function glowCircle(ctx, x, y, r, color) {
      ctx.save();
      ctx.shadowColor = color;
      ctx.shadowBlur = r * 0.5;
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    }

    function drawStationShadow(ctx, st, cam) {
      const s = worldToScreen(st.x, st.y, cam);
      const toSun = { x: (SUN.x - st.x), y: (SUN.y - st.y) };
      const ang = Math.atan2(toSun.y, toSun.x) + Math.PI; // cie≈Ñ ‚Äûod‚Äù S≈Ço≈Ñca
      const scale = stationScaleFor(st);
      const base = (st.baseR || st.r || 120) * scale;
      const off = base * 1.2 * cam.zoom;
      const w = base * 1.6 * cam.zoom;
      const h = base * 0.7 * cam.zoom;

      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(ang);
      const g = ctx.createRadialGradient(off, 0, 0, off, 0, w);
      g.addColorStop(0.00, 'rgba(0,0,0,0.35)');
      g.addColorStop(1.00, 'rgba(0,0,0,0.00)');
      ctx.globalCompositeOperation = 'multiply';
      ctx.beginPath();
      ctx.ellipse(off, 0, w, h, 0, 0, Math.PI * 2);
      ctx.fillStyle = g;
      ctx.fill();
      ctx.restore();
    }

    function drawStationVFX(ctx, st, x, y, r, t) {
      ctx.save();
      ctx.translate(x, y);
      switch (st.style) {
        case 'ringGate':
          ctx.strokeStyle = '#273447';
          ctx.lineWidth = Math.max(1, r * 0.2);
          ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.stroke();
          ctx.save(); ctx.rotate(t * 0.6);
          for (let i = 0; i < 6; i++) { ctx.rotate(Math.PI / 3); glowCircle(ctx, r * 0.6, 0, r * 0.12, '#6dd6ff'); }
          ctx.restore();
          glowCircle(ctx, 0, 0, r * 0.3, '#6dd6ff');
          break;
        case 'hexHub':
          ctx.strokeStyle = '#273447';
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let i = 0; i < 6; i++) { const a = i * Math.PI / 3; const px = Math.cos(a) * r * 0.6; const py = Math.sin(a) * r * 0.6; if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py); }
          ctx.closePath(); ctx.stroke();
          break;
        case 'triRing':
          ctx.strokeStyle = '#273447'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(0, 0, r * 0.9, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2); ctx.stroke();
          ctx.beginPath(); ctx.arc(0, 0, r * 0.3, 0, Math.PI * 2); ctx.stroke();
          break;
        case 'solarPetals':
          ctx.save(); ctx.rotate(t * 0.5);
          for (let i = 0; i < 8; i++) { ctx.rotate(Math.PI / 4); ctx.fillStyle = '#274a7d'; ctx.fillRect(r * 0.3, -r * 0.1, r * 0.4, r * 0.2); }
          ctx.restore();
          glowCircle(ctx, 0, 0, r * 0.25, '#8fd0ff');
          break;
        case 'shipyard':
          ctx.save();
          for (let i = 0; i < 4; i++) { ctx.rotate(Math.PI / 2); ctx.fillStyle = '#344a74'; ctx.fillRect(r * 0.2, -r * 0.05, r * 0.8, r * 0.1); }
          ctx.restore();
          break;
        case 'tradeSpindle':
          ctx.fillStyle = '#3b517d'; ctx.fillRect(-r * 0.1, -r, r * 0.2, r * 2);
          for (let i = -3; i <= 3; i++) { ctx.fillStyle = '#6ea0ff'; ctx.fillRect(r * 0.3, i * r * 0.2 - r * 0.05, r * 0.3, r * 0.1); ctx.fillRect(-r * 0.6, i * r * 0.2 - r * 0.05, r * 0.3, r * 0.1); }
          break;
        default:
          ctx.fillStyle = '#273447';
          ctx.beginPath(); ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2); ctx.fill();
          break;
      }

      if (st.shield && st.shield.val > 0) {
        const frac = clamp(st.shield.val / st.shield.max, 0, 1);
        const pulse = (Math.sin(t * 1.6) + 1) * 0.5;
        const shieldR = r * (1.18 + 0.04 * pulse);
        const fresnel = ctx.createRadialGradient(0, 0, shieldR * 0.72, 0, 0, shieldR);
        fresnel.addColorStop(0, 'rgba(120,200,255,0)');
        fresnel.addColorStop(1, `rgba(120,200,255,${0.22 + 0.25 * frac})`);
        ctx.save();
        ctx.fillStyle = fresnel;
        ctx.globalAlpha = 0.45 + 0.25 * pulse * frac;
        ctx.beginPath(); ctx.arc(0, 0, shieldR, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
        ctx.lineWidth = Math.max(3, r * 0.08);
        ctx.strokeStyle = `rgba(120,200,255,${0.32 + 0.4 * frac})`;
        ctx.beginPath(); ctx.arc(0, 0, shieldR, 0, Math.PI * 2); ctx.stroke();
        ctx.restore();
      }

      ctx.restore();
      ctx.strokeStyle = 'rgba(175,210,255,0.12)';
      ctx.lineWidth = Math.max(1, 2);
      ctx.beginPath(); ctx.arc(x, y, r * 1.05, 0, Math.PI * 2); ctx.stroke();
    }

    function drawPlanetLabels(ctx, cam) {
      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      const fontSize = Math.round(clamp(18 * camera.zoom, 12, 30));
      ctx.font = `600 ${fontSize}px Inter,system-ui,monospace`;
      ctx.lineJoin = 'round';
      for (const pl of planets) {
        if (!pl || !pl.label) continue;
        const screen = worldToScreen(pl.x, pl.y, cam);
        if (screen.x < -160 || screen.x > W + 160 || screen.y < -160 || screen.y > H + 160) continue;
        const offset = ((pl.r || 0) + 40) * camera.zoom;
        const y = screen.y - offset;
        ctx.save();
        ctx.shadowColor = 'rgba(12, 22, 42, 0.7)';
        ctx.shadowBlur = fontSize * 0.4;
        ctx.lineWidth = Math.max(2, fontSize * 0.18);
        ctx.strokeStyle = 'rgba(10, 20, 36, 0.85)';
        ctx.fillStyle = 'rgba(223, 231, 255, 0.95)';
        ctx.strokeText(pl.label, screen.x, y);
        ctx.fillText(pl.label, screen.x, y);
        ctx.restore();
      }
      ctx.restore();
    }

    function drawStars(cam) {
      // --- KONFIGURACJA EFEKTU WARP ---
      const STEADY_LENGTH = 60; // D≈Çugo≈õƒá kresek podczas stabilnego lotu (nie kropki, ale linie)
      const KICK_STRENGTH = 4.0; // Mno≈ºnik przy starcie (np. 60 * 4 = 240px przy uderzeniu)
      const BRAKE_STRENGTH = 5.0; // Mno≈ºnik przy hamowaniu (np. 60 * 5 = 300px przy wyj≈õciu)
      // --------------------------------

      const zoom = cam?.zoom ?? camera.zoom ?? 1;
      const marginW = (W / 2) / zoom + 2000;
      const marginH = (H / 2) / zoom + 2000;
      const minX = Math.floor((cam.x - marginW) / STAR_CELL);
      const maxX = Math.floor((cam.x + marginW) / STAR_CELL);
      const minY = Math.floor((cam.y - marginH) / STAR_CELL);
      const maxY = Math.floor((cam.y + marginH) / STAR_CELL);

      for (let iy = minY; iy <= maxY; iy++) {
        for (let ix = minX; ix <= maxX; ix++) {
          const cell = getCell(ix, iy);
          for (const s of cell.stars) {
            const sx = (s.x - cam.x) * zoom + W / 2;
            const sy = (s.y - cam.y) * zoom + H / 2;
            if (sx < -50 || sx > W + 50 || sy < -50 || sy > H + 50) continue;

            // 1. FAZA LOTU I STARTU (Active)
            if (warp.state === 'active') {

              let currentStretch = 1.0; // Domy≈õlnie 1.0 = STEADY_LENGTH

              // Je≈õli dopiero wchodzimy w warp (entryProgress < 1), dodajemy "kopa"
              if (warp.entryProgress < 1.0) {
                // Sinusoida daje p≈Çynny skok w g√≥rƒô i powr√≥t
                const kick = Math.sin(warp.entryProgress * Math.PI);
                currentStretch = 1.0 + (kick * KICK_STRENGTH);
              }

              // Obliczamy finalnƒÖ d≈Çugo≈õƒá dla tej klatki
              // Dodajemy te≈º ma≈Çy wp≈Çyw paliwa (opcjonalnie), ≈ºeby smugi s≈Çab≈Çy jak brakuje energii
              const L = STEADY_LENGTH * currentStretch * (0.8 + 0.2 * (warp.fuel / warp.fuelMax));

              // Kierunek smug (przeciwny do lotu)
              const dx = -warp.dir.x * L * zoom;
              const dy = -warp.dir.y * L * zoom;

              ctx.strokeStyle = 'rgba(200,220,255,0.35)';
              ctx.lineWidth = 2;
              ctx.beginPath(); ctx.moveTo(sx + dx, sy + dy); ctx.lineTo(sx, sy); ctx.stroke();
            }

            // 2. FAZA HAMOWANIA LUB SPOCZYNKU
            else {

              // Je≈õli timer hamowania jest aktywny
              if (typeof warpBrakeTimer !== 'undefined' && warpBrakeTimer > 0) {
                // t schodzi od 1.0 do 0.0
                const t = warpBrakeTimer / 0.8;

                // U≈ºywamy t^3, aby d≈Çugo≈õƒá mala≈Ça bardzo szybko (dynamiczny "snap back")
                const tCubed = t * t * t;

                // D≈Çugo≈õƒá: Mno≈ºymy przez BRAKE_STRENGTH
                const brakeLen = STEADY_LENGTH * BRAKE_STRENGTH * tCubed;

                // Kierunek
                let dirX = 1, dirY = 0;
                if (warp.lastDir) {
                  dirX = warp.lastDir.x;
                  dirY = warp.lastDir.y;
                } else if (ship.vel.x || ship.vel.y) {
                  const vLen = Math.hypot(ship.vel.x, ship.vel.y) || 1;
                  dirX = ship.vel.x / vLen;
                  dirY = ship.vel.y / vLen;
                }

                const dx = -dirX * brakeLen * zoom;
                const dy = -dirY * brakeLen * zoom;

                // --- POPRAWKA JASNO≈öCI ---
                // Wcze≈õniej by≈Ço: 0.2 + 0.6*t (Max 0.8 -> zbyt jasne!)
                // Teraz: Max 0.3 (delikatna smuga, kt√≥ra nie przepala ekranu)
                const alpha = 0.05 + 0.25 * t;

                ctx.strokeStyle = `rgba(200,220,255,${alpha})`;
                ctx.lineWidth = 2; // Mo≈ºesz zmieniƒá na 1.5 dla cie≈Ñszych linii

                ctx.beginPath();
                ctx.moveTo(sx + dx, sy + dy);
                ctx.lineTo(sx, sy);
                ctx.stroke();

                // USUNIƒòTO: ctx.fillRect(...) 
                // Nie rysujemy kropki na ko≈Ñcu smugi podczas hamowania, 
                // bo nak≈Çadanie siƒô smugi i kropki powodowa≈Ço "bia≈Çe punkty".

              }

              // 3. ZWYK≈ÅY STAN (Spoczynek - rysujemy tylko kropki)
              else {
                ctx.globalAlpha = s.bright;
                ctx.fillStyle = '#ffffff';
                const flicker = 0.8 + 0.2 * Math.random();
                const baseSize = s.size * flicker * zoom;
                const minSize = 0.6 * zoom;
                const sz = Math.max(minSize, baseSize);
                const drawSize = Math.max(1, Math.ceil(sz));

                ctx.fillRect(Math.round(sx), Math.round(sy), drawSize, drawSize);
                ctx.globalAlpha = 1;
              }
            }
          }
        }
      }
      pruneStarCells();
    }

    function drawRangeRuler(ctx, cam) {
      if (!DevFlags.showRuler) return;

      const cx = W / 2;
      const cy = H / 2;
      const zoom = cam?.zoom ?? camera.zoom ?? 1;

      ctx.save();
      ctx.globalAlpha = 0.5;
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#6db6ff';

      const step = 500;
      const maxWorldR = Math.min(W, H) / zoom * 0.5 * 0.95;

      for (let r = step; r < maxWorldR; r += step) {
        const rr = r * zoom;
        ctx.beginPath();
        ctx.arc(cx, cy, rr, 0, Math.PI * 2);
        ctx.stroke();

        if (r % 1000 === 0) {
          ctx.fillStyle = '#cfe6ff';
          ctx.font = '11px monospace';
          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          ctx.fillText(`${r}`, cx + rr + 4, cy);
        }
      }

      ctx.globalAlpha = 0.25;
      const axisR = maxWorldR * zoom;
      ctx.beginPath(); ctx.moveTo(cx - axisR, cy); ctx.lineTo(cx + axisR, cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx, cy - axisR); ctx.lineTo(cx, cy + axisR); ctx.stroke();

      ctx.restore();
    }

    function drawPlanetOrbitRings(ctx, cam) {
      if (!DevFlags.showPlanetOrbits) return;
      const planetList = Array.isArray(window.planets) ? window.planets : [];
      if (!planetList.length) return;

      const zoom = cam?.zoom ?? camera.zoom ?? 1;
      ctx.save();
      ctx.lineWidth = Math.max(1, 1.5 * zoom);

      for (const planet of planetList) {
        if (!planet || !Number.isFinite(planet.x) || !Number.isFinite(planet.y)) continue;
        const radii = planetOrbitRadii(planet);
        const s = worldToScreen(planet.x, planet.y, cam);

        if (Number.isFinite(radii.inner)) {
          ctx.strokeStyle = 'rgba(90, 180, 255, 0.55)';
          ctx.beginPath();
          ctx.arc(s.x, s.y, radii.inner * zoom, 0, Math.PI * 2);
          ctx.stroke();
        }
        if (Number.isFinite(radii.outer)) {
          ctx.strokeStyle = 'rgba(140, 210, 255, 0.45)';
          ctx.beginPath();
          ctx.arc(s.x, s.y, radii.outer * zoom, 0, Math.PI * 2);
          ctx.stroke();
        }
        if (Number.isFinite(radii.gravityWell)) {
          ctx.strokeStyle = 'rgba(170, 150, 255, 0.35)';
          ctx.beginPath();
          ctx.arc(s.x, s.y, radii.gravityWell * zoom, 0, Math.PI * 2);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    function drawFrigateHull(ctx, npc, screenPos) {
      const hullSprite = getHullSpriteForNpc(npc);
      if (hullSprite) {
        const targetH = Math.max(4, (npc.radius || 28) * 2 * (camera.zoom || 1));
        const aspect = hullSprite.width / hullSprite.height;
        const targetW = targetH * (Number.isFinite(aspect) && aspect > 0 ? aspect : 1);
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(npc.angle || 0);
        ctx.globalAlpha = npc.fade ?? 1;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(hullSprite.image, -targetW * 0.5, -targetH * 0.5, targetW, targetH);
        ctx.restore();
        return;
      }

      const w = (npc.size?.w || npc.radius * 2.2) * (camera.zoom || 1);
      const h = (npc.size?.h || npc.radius * 0.9) * (camera.zoom || 1);
      ctx.save();
      ctx.globalAlpha = npc.fade ?? 1;
      ctx.translate(screenPos.x, screenPos.y);
      ctx.rotate(npc.angle || 0);
      ctx.fillStyle = npc.subType === 'laser' ? '#3c2d54' : '#284b36';
      ctx.strokeStyle = npc.friendly ? '#7cff91' : '#ff5c7c';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.rect(-w * 0.5, -h * 0.5, w, h);
      ctx.fill(); ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, 0); ctx.lineTo(w * 0.6, 0);
      ctx.stroke();
      if (npc.subType === 'laser') {
        ctx.strokeStyle = '#f0f';
        ctx.beginPath();
        ctx.moveTo(w * 0.1, -h * 0.25); ctx.lineTo(w * 0.5, -h * 0.25);
        ctx.moveTo(w * 0.1, h * 0.25); ctx.lineTo(w * 0.5, h * 0.25);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawDestroyer(ctx, npc, screenPos) {
      const hullSprite = getHullSpriteForNpc(npc);
      if (hullSprite) {
        const targetH = Math.max(6, (npc.radius || 45) * 2 * camera.zoom);
        const aspect = hullSprite.width / hullSprite.height;
        const targetW = targetH * (Number.isFinite(aspect) && aspect > 0 ? aspect : 1);
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(npc.angle);
        ctx.globalAlpha = npc.fade ?? 1;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(hullSprite.image, -targetW * 0.5, -targetH * 0.5, targetW, targetH);
        ctx.restore();
        return;
      }

      const zoomScale = camera.zoom;
      const baseRadius = npc.radius || 70;
      const w = (npc.size?.w || baseRadius * 1.6) * zoomScale;
      const h = (npc.size?.h || baseRadius * 0.49) * zoomScale;
      ctx.save();
      ctx.translate(screenPos.x, screenPos.y);
      ctx.rotate(npc.angle);
      ctx.fillStyle = '#563c2c'; // BrƒÖzowy (Pirat)
      ctx.strokeStyle = '#ff5c7c';
      ctx.lineWidth = 2;

      // Kad≈Çub
      ctx.beginPath();
      ctx.rect(-w * 0.5, -h * 0.5, w * 0.8, h);
      ctx.fill(); ctx.stroke();

      // Nadbud√≥wka
      ctx.fillStyle = '#6e4d3d';
      ctx.beginPath();
      ctx.moveTo(w * 0.1, -h * 0.3);
      ctx.lineTo(w * 0.4, 0);
      ctx.lineTo(w * 0.1, h * 0.3);
      ctx.fill();

      ctx.restore();
    }

    function drawBattleship(ctx, npc, screenPos) {
      const hullSprite = getHullSpriteForNpc(npc);
      if (hullSprite) {
        const targetH = Math.max(8, (npc.radius || 70) * 2 * camera.zoom);
        const aspect = hullSprite.width / hullSprite.height;
        const targetW = targetH * (Number.isFinite(aspect) && aspect > 0 ? aspect : 1);
        ctx.save();
        ctx.translate(screenPos.x, screenPos.y);
        ctx.rotate(npc.angle);
        ctx.globalAlpha = npc.fade ?? 1;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(hullSprite.image, -targetW * 0.5, -targetH * 0.5, targetW, targetH);
        ctx.restore();
        return;
      }

      const zoomScale = camera.zoom;
      const baseRadius = npc.radius || 140;
      const w = (npc.size?.w || baseRadius * 1.72) * zoomScale;
      const h = (npc.size?.h || baseRadius * 0.6) * zoomScale;
      ctx.save();
      ctx.translate(screenPos.x, screenPos.y);
      ctx.rotate(npc.angle);
      ctx.fillStyle = '#462c1c'; // Ciemny brƒÖz
      ctx.strokeStyle = '#ff5c7c'; // Czerwony obrys
      ctx.lineWidth = 3;

      // G≈Ç√≥wny kad≈Çub (agresywny kszta≈Çt)
      ctx.beginPath();
      ctx.moveTo(w * 0.5, 0);
      ctx.lineTo(w * 0.3, h * 0.5);
      ctx.lineTo(-w * 0.5, h * 0.5);
      ctx.lineTo(-w * 0.4, 0);
      ctx.lineTo(-w * 0.5, -h * 0.5);
      ctx.lineTo(w * 0.3, -h * 0.5);
      ctx.closePath();
      ctx.fill(); ctx.stroke();

      // Wie≈ºyczki boczne (symboliczne)
      ctx.fillStyle = '#ff9b4b'; // Pomara≈Ñczowe
      ctx.fillRect(-w * 0.2, -h * 0.6, w * 0.1, h * 0.2); // Lewa burta
      ctx.fillRect(-w * 0.2, h * 0.4, w * 0.1, h * 0.2);  // Prawa burta

      ctx.restore();
    }






    function drawCapitalShipSprite(ctx, npc, screenPos, pixR) {
      ctx.imageSmoothingEnabled = false;

      const profile = npc.capitalProfile || {};
      const lengthScale = Number.isFinite(profile.lengthScale) ? profile.lengthScale : 3.2;
      const widthScale = Number.isFinite(profile.widthScale) ? profile.widthScale : 1.2;

      // Obliczamy wymiary na ekranie
      const length = Math.max(1, pixR * lengthScale);
      const width = Math.max(1, pixR * widthScale);

      const dims = { length, width, halfL: length * 0.5, halfW: width * 0.5 };

      const hullColor = profile.hullColor || (npc.friendly ? '#5477bf' : '#c85a5a');
      const deckColor = profile.deckColor || '#1f2a46';
      const accentColor = profile.accentColor || '#9dc5ff';
      const engineColor = profile.engineColor || 'rgba(130,200,255,0.85)';
      const hangarGlow = profile.hangarGlow || 'rgba(160,200,255,0.35)';

      const spriteInfo = npc.capitalSprite || (profile.spriteSrc ? getCapitalShipSprite(profile.spriteSrc) : null);
      if (!npc.capitalSprite && spriteInfo) {
        npc.capitalSprite = spriteInfo;
      }
      const useSprite = !!(spriteInfo && spriteInfo.ready && !spriteInfo.error);

      ctx.save();
      ctx.globalAlpha = npc.fade ?? 1;
      ctx.translate(screenPos.x, screenPos.y);

      const spriteRotation = Number.isFinite(profile.spriteRotation) ? profile.spriteRotation : 0;
      ctx.rotate((npc.angle || 0) + spriteRotation);

      const halfL = length * 0.5;
      const halfW = width * 0.5;

      // --- POPRAWKA: Dynamiczny promie≈Ñ, nigdy wiƒôkszy ni≈º sam statek ---
      // Zamiast sztywnych pixeli, bierzemy procent wymiaru.
      // To zapobiega "wykrƒôcaniu" siƒô kszta≈Çtu przy oddalaniu kamery.
      const radius = Math.min(width, length) * 0.15;

      let drawHullPath = null;

      const traceHullShape = (margin = 1.0) => {
        const mLen = length * margin;
        const mWid = width * margin;
        roundRect(ctx, -mLen / 2, -mWid / 2, mLen, mWid, radius);
      };

      if (useSprite) {
        const img = spriteInfo.image;
        const spriteScale = Number.isFinite(profile.spriteScale) ? profile.spriteScale : 1;
        const naturalW = spriteInfo.width || img.naturalWidth || 1;
        const naturalH = spriteInfo.height || img.naturalHeight || 1;

        // Logika skalowania
        const rawRotation = Number.isFinite(profile.spriteRotation) ? profile.spriteRotation : 0;
        const halfPi = Math.PI / 2;
        const approxSteps = Math.round(rawRotation / halfPi);
        const alignedToStep = Math.abs(rawRotation - approxSteps * halfPi) < 0.0001;
        const usesHeightForLength = alignedToStep && (Math.abs(approxSteps) % 2 === 1);

        const targetLength = length * spriteScale;
        const targetWidth = width * spriteScale;

        let scale;
        if (usesHeightForLength) {
          scale = targetLength / Math.max(1, naturalH);
        } else {
          scale = targetLength / Math.max(1, naturalW);
        }
        let drawW = naturalW * scale;
        let drawH = naturalH * scale;

        if (targetWidth > 0) {
          const crossSize = usesHeightForLength ? drawW : drawH;
          if (crossSize > targetWidth) {
            const adjust = targetWidth / crossSize;
            drawW *= adjust;
            drawH *= adjust;
          }
        }

        const offset = profile.spriteOffset || { x: 0, y: 0 };
        const sc = drawW / naturalW;
        ctx.drawImage(img, -drawW * 0.5 + (offset.x * sc), -drawH * 0.5 + (offset.y * sc), drawW, drawH);
      } else {
        // Proceduralny fallback (rysowanie prostokƒÖt√≥w)
        ctx.fillStyle = hullColor;
        drawHullPath = () => traceHullShape(1.0);
        drawHullPath();
        ctx.fill();

        // Detale rysujemy TYLKO je≈õli statek jest widoczny (wiƒôkszy ni≈º kropka)
        if (length > 4 && width > 4) {
          ctx.fillStyle = deckColor;
          roundRect(ctx, -halfL * 0.78, -halfW * 0.55, length * 0.82, width * 0.58, radius * 0.7);
          ctx.fill();

          ctx.fillStyle = hangarGlow;
          roundRect(ctx, -length * 0.18, -halfW * 0.45, length * 0.36, width * 0.9, width * 0.18);
          ctx.fill();

          ctx.fillStyle = accentColor;
          ctx.fillRect(-halfL * 0.2, -halfW * 0.05, length * 0.4, width * 0.1);
        }
      }

      // --- SILNIKI (tylko je≈õli statek jest wystarczajƒÖco du≈ºy) ---
      const engineOffsets = Array.isArray(profile.engineOffsets) ? profile.engineOffsets : null;
      if (engineOffsets && engineOffsets.length) {
        const speed = Math.hypot(npc.vx || 0, npc.vy || 0);
        const thrust = clamp(speed / Math.max(1, npc.maxSpeed || 1), 0, 1);

        // Optymalizacja: nie rysuj glowa silnik√≥w, je≈õli statek to < 2px na ekranie
        if (width > 2) {
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = 0.45 + thrust * 0.4;
          ctx.fillStyle = engineColor;
          const glowSize = profile.engineGlowSize || 0.26;
          for (const offset of engineOffsets) {
            const local = capitalLocalFromNormalized(offset, dims);
            ctx.beginPath();
            ctx.ellipse(local.x, local.y, width * glowSize * 0.45, width * glowSize * 0.75, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }
      }

      // --- EFEKT TRAFIENIA ---
      if (npc.hitFlash > 0) {
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = clamp(npc.hitFlash * 6, 0, 1);
        ctx.fillStyle = 'rgba(255,190,150,0.8)';

        if (drawHullPath) {
          drawHullPath();
          ctx.fill();
        } else {
          // Fallback kszta≈Çtu
          ctx.beginPath();
          traceHullShape(1.0);
          ctx.fill();
        }
        ctx.restore();
      }

      ctx.restore();
    }
    function drawNPCPretty(ctx, npc, s) {
      if (npc.hexGrid) {
        drawHexBody(ctx, npc, camera, worldToScreen);
        if (npc.hp < npc.maxHp) {
          const zoom = camera.zoom;
          const size = (npc.radius || 20) * zoom;
          const hpPct = Math.max(0, npc.hp / npc.maxHp);
          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.fillStyle = '#ef4444';
          ctx.fillRect(-size, -size - 10, size * 2, 4);
          ctx.fillStyle = '#22c55e';
          ctx.fillRect(-size, -size - 10, size * 2 * hpPct, 4);
          ctx.restore();
        }
        return;
      }

      if ((npc.type === 'destroyer' || npc.type === 'battleship' || npc.isCapitalShip) && !npc.hexGrid) {
        const sprite = getHullSpriteForNpc(npc) || (npc.capitalSprite && npc.capitalSprite.ready ? npc.capitalSprite : null);
        if (sprite && sprite.ready && !sprite.error) {
          initHexBody(npc, sprite.image);
          drawNPCPretty(ctx, npc, s);
          return;
        }
      }

      // 1. NAJPIERW sprawd≈∫ konkretne typy (Destroyer, Battleship, Frigate)
      // Dziƒôki temu u≈ºyjƒÖ one Twoich nowych sprite'√≥w z HULL_SPRITE_PATHS
      if (npc.type === 'destroyer') {
        drawDestroyer(ctx, npc, s);
        return;
      }
      if (npc.type === 'battleship') {
        drawBattleship(ctx, npc, s);
        return;
      }
      if (npc.type && (npc.type.includes('frigate') || npc.subType === 'laser')) {
        drawFrigateHull(ctx, npc, s);
        return;
      }

      // 2. DOPIERO POTEM sprawd≈∫ czy to og√≥lny Capital Ship (np. Carrier gracza)
      // Je≈õli to du≈ºy statek, kt√≥ry nie jest destroyerem/battleshipem, u≈ºyje systemu profili/sprite'√≥w capital
      if (npc.isCapitalShip) {
        const pixR = (npc.radius || 20) * camera.zoom;
        drawCapitalShipSprite(ctx, npc, s, pixR);
        return;
      }

      // 3. Domy≈õlny rysunek dla my≈õliwc√≥w (Fighter/Interceptor)
      const zoom = camera.zoom;
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(npc.angle);

      const isFighter = npc.fighter || npc.type === 'fighter' || npc.type === 'interceptor';

      // Kolor zale≈ºny od nastawienia
      ctx.fillStyle = npc.color || (npc.friendly ? '#7cff91' : '#ff5c7c');

      // Rysowanie tr√≥jkƒÖta (my≈õliwiec)
      const size = (npc.radius || 12) * zoom;
      if (isFighter && fighterSpriteState.ready && !fighterSpriteState.error) {
        const targetH = size * 2;
        const aspect = fighterSpriteState.width / fighterSpriteState.height;
        const targetW = targetH * (Number.isFinite(aspect) && aspect > 0 ? aspect : 1);
        ctx.drawImage(fighterSprite, -targetW / 2, -targetH / 2, targetW, targetH);
      } else {
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.lineTo(-size * 0.6, size * 0.7);
        ctx.lineTo(-size * 0.3, 0);
        ctx.lineTo(-size * 0.6, -size * 0.7);
        ctx.closePath();
        ctx.fill();

        // Obrys
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = 'rgba(0,0,0,0.4)';
        ctx.stroke();
      }

      // Pasek HP nad jednostkƒÖ
      if (npc.hp < npc.maxHp) {
        const hpPct = Math.max(0, npc.hp / npc.maxHp);
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(-size, -size - 6, size * 2, 3);
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(-size, -size - 6, size * 2 * hpPct, 3);
      }

      ctx.restore();
    }

    // --- CACHE DLA KORPUSU RAILGUNA (Optymalizacja) ---
    let railgunBodyCache = null;
    function getRailgunBodySprite() {
      if (railgunBodyCache) return railgunBodyCache;

      const s = 3.0; // Skala bazowa dla wysokiej jako≈õci
      const size = 120; // Rozmiar canvasa
      const c = document.createElement('canvas');
      c.width = size;
      c.height = size;
      const ctx = c.getContext('2d');

      ctx.translate(size / 2, size / 2);

      const housingW = 20 * s;
      const housingH = 24 * s;

      // Obudowa (Ciemny grafit)
      ctx.fillStyle = '#222222';
      ctx.beginPath();
      ctx.moveTo(8 * s, -6 * s);
      ctx.lineTo(0, -housingH / 2);
      ctx.lineTo(-housingW / 2, -housingH / 2);
      ctx.lineTo(-housingW / 1.5, 0);
      ctx.lineTo(-housingW / 2, housingH / 2);
      ctx.lineTo(0, housingH / 2);
      ctx.lineTo(8 * s, 6 * s);
      ctx.closePath();
      ctx.fill();

      // Wnƒôtrze (Ja≈õniejszy grafit)
      ctx.fillStyle = '#333333';
      ctx.beginPath();
      ctx.moveTo(-housingW / 2 + 2 * s, -housingH / 2 + 2 * s);
      ctx.lineTo(-2 * s, -housingH / 2 + 2 * s);
      ctx.lineTo(4 * s, -4 * s);
      ctx.lineTo(4 * s, 4 * s);
      ctx.lineTo(-2 * s, housingH / 2 - 2 * s);
      ctx.lineTo(-housingW / 2 + 2 * s, housingH / 2 - 2 * s);
      ctx.closePath();
      ctx.fill();

      // Detale (≈öwiat≈Ça/Z≈ÇƒÖcza)
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(-10 * s, -housingH / 2 + 4 * s, 4 * s, 1 * s);
      ctx.fillRect(-10 * s, housingH / 2 - 5 * s, 4 * s, 1 * s);

      // Pivot (≈örodek)
      ctx.beginPath();
      ctx.arc(0, 0, 1.5 * s, 0, Math.PI * 2);
      ctx.fill();

      railgunBodyCache = c;
      return c;
    }

    function render(alpha, frameDt) {
      canvas.style.cursor = 'default';
      //  cheats (np. nielimitowany warp)
      if (window.ApplyCheats) ApplyCheats();
      
      // Interpolacja stanu
      const interpPos = {
        x: prevState.pos.x + (ship.pos.x - prevState.pos.x) * alpha,
        y: prevState.pos.y + (ship.pos.y - prevState.pos.y) * alpha
      };
      const interpAngle = interpAngleShort(prevState.angle, ship.angle, alpha);
      const interpTurretAngle = interpAngleShort(prevState.turretAngle, ship.turret.angle, alpha);
      const interpTurretAngle2 = interpAngleShort(prevState.turretAngle2, ship.turret2.angle, alpha);
      const interpTurretAngle3 = interpAngleShort(prevState.turretAngle3, ship.turret3.angle, alpha);
      const interpTurretAngle4 = interpAngleShort(prevState.turretAngle4, ship.turret4.angle, alpha);
      const interpCIWSAngles = ship.ciws.map((c, i) => interpAngleShort(prevState.ciwsAngles[i], c.angle, alpha));

      // --- LOGIKA KAMERY (POPRAWIONA) ---
      // Przeniesiona do render(), aby u≈ºywaƒá interpPos i uniknƒÖƒá drga≈Ñ (jitter)
      
      if (camera.mode === 'ship' && !camera.transition) {
          // 1. Celujemy w wyg≈ÇadzonƒÖ pozycjƒô statku (interpPos)
          let targetX = interpPos.x;
          let targetY = interpPos.y;

          // 2. Efekt "Look Ahead" (Wy≈ÇƒÖczony podczas Warpa, ≈ºeby nie szarpa≈Ço)
          if (mouse.overCanvas && warp.state === 'idle') {
             const cx = W / 2;
             const cy = H / 2;
             const dx = mouse.x - cx;
             const dy = mouse.y - cy;
             
             // Czu≈Ço≈õƒá i max wychylenie
             const sensitivity = 0.55; 
             const maxPan = Math.min(W, H) * 0.45;

             const dist = Math.hypot(dx, dy);
             const angle = Math.atan2(dy, dx);
             const panDist = Math.min(dist * sensitivity, maxPan);
             
             // Dodajemy offset
             targetX += (Math.cos(angle) * panDist) / Math.max(0.1, camera.zoom);
             targetY += (Math.sin(angle) * panDist) / Math.max(0.1, camera.zoom);
          }

          // 3. Efekt hamowania grawitacyjnego (pozostawiony bez zmian)
          const brake = gravityBrakeCameraOffset();
          if (brake) {
             targetX += brake.x;
             targetY += brake.y;
          }

          // 4. P≈Çynne podƒÖ≈ºanie vs Hard Lock
          if (warp.state === 'active') {
              // FIX DR≈ªENIA: Podczas Warpu wy≈ÇƒÖczamy wyg≈Çadzanie.
              // Kamera musi byƒá idealnie "przyspawana" do pozycji statku,
              // inaczej przy prƒôdko≈õci 10k+ jednostek powstanie jitter.
              camera.x = targetX;
              camera.y = targetY;
          } else {
              // Normalny lot - u≈ºywamy p≈Çynnego podƒÖ≈ºania (lerp)
              // Zwiƒôkszamy lerpSpeed przy ≈Çadowaniu/hamowaniu dla lepszego czucia
              const isBusy = warp.state !== 'idle';
              const lerpSpeed = isBusy ? 15.0 : 5.0;

              const t = 1.0 - Math.exp(-lerpSpeed * frameDt);

              camera.x += (targetX - camera.x) * t;
              camera.y += (targetY - camera.y) * t;
          }
      }
      else if (camera.mode === 'focus') {
        const st = camera.focusStation;
        if (st) {
          camera.x = st.x;
          camera.y = st.y;
        } else {
          camera.clearFocus();
        }
      } else if (camera.mode === 'infrastructure') {
        const st = camera.focusStation;
        if (!st) {
          camera.clearFocus();
        }
      }

      const cam = { x: camera.x, y: camera.y, zoom: camera.zoom };
      if (!DevFlags.disableCameraShake && camera.shakeMag > 0) {
        const t = camera.shakeTime / camera.shakeDur;
        const mag = camera.shakeMag * Math.max(0, t);
        cam.x += (Math.random() * 2 - 1) * mag;
        cam.y += (Math.random() * 2 - 1) * mag;
      }

      overlayView.center.x = cam.x;
      overlayView.center.y = cam.y;
      overlayView.viewport.w = W;
      overlayView.viewport.h = H;
      overlayView.zoom = cam.zoom;

      // aktualizuj wy≈õwietlanie czasu
      gameTimeEl.textContent = formatGameTime(gameTime);
      updatePlayerStatusUI();
      updateFleetUI();
      updatePlanetRadar(ship, cam);

      // 1. Czy≈õcimy Canvas 2D do przezroczysto≈õci (≈ºeby ods≈Çoniƒá warstwƒô WebGL pod spodem)
      ctx.clearRect(0, 0, W, H);

      // (Opcjonalnie) Je≈õli spaceBg rysuje czarne t≈Ço, zakomentuj tƒô liniƒô:
      // spaceBg?.drawSpaceBg?.(ctx, cam);

      // 2. Aktualizacja i renderowanie planet 3D (na dolnym canvasie)
      if (window.updatePlanets3D) updatePlanets3D(frameDt);
      if (window.drawPlanets3D) {
        window.drawPlanets3D(ctx, cam);
      }
      if (warpBlackHoleFX) {
        configureWarpLensSource();
      }
      ensurePlanetStationsInit(stations);
      // najpierw zaktualizuj pozycje stacji 3D...
      if (window.updateStations3D) window.updateStations3D(stations);
      // ...a potem wyrenderuj overlay sceny 3D
      if (window.updateWorld3D) updateWorld3D(frameDt, vfxTime);

      // Gwiazdy (proceduralne kafelki na ca≈Çej mapie)
      //drawStars(cam);

      // scan waves
      for (const w of scanWaves) {
        const s = worldToScreen(w.x, w.y, cam);
        ctx.strokeStyle = 'rgba(120,200,255,0.18)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(s.x, s.y, w.r * camera.zoom, 0, Math.PI * 2); ctx.stroke();
      }

      ctx.globalCompositeOperation = 'source-over';
      ctx.imageSmoothingEnabled = true;
      if (window.drawStations3D) drawStations3D(ctx, cam, worldToScreen); // STACJE 3D NAD PLANETAMI (sprite per-stacja)
      if (window.drawWorld3D) drawWorld3D(ctx, cam, worldToScreen); // np. piracka stacja (spotlight)
      if (stationUI.editorMode && stationUI.station) {
        const infraState = ensureInfrastructureState(stationUI.station);
        if (infraState) drawInfrastructureGrid(ctx, cam, stationUI.station, infraState);
      }
      drawInfrastructureInstances(ctx, cam);
      drawPlanetLabels(ctx, cam);
      drawPlanetOrbitRings(ctx, cam);
      drawRangeRuler(ctx, cam);
      if (window.drawSunDirection) drawSunDirection(ctx, cam);

      // Warp gates
      for (const key in warpRoutes) {
        const route = warpRoutes[key];
        const perp = { x: -route.dir.y, y: route.dir.x };
        const w = 6 * camera.zoom;
        const s1 = worldToScreen(route.start.x, route.start.y, cam);
        const s2 = worldToScreen(route.end.x, route.end.y, cam);
        ctx.strokeStyle = '#88aaff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(s1.x - perp.x * w, s1.y - perp.y * w);
        ctx.lineTo(s1.x + perp.x * w, s1.y + perp.y * w);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(s2.x - perp.x * w, s2.y - perp.y * w);
        ctx.lineTo(s2.x + perp.x * w, s2.y + perp.y * w);
        ctx.stroke();
      }

      // Shockwaves (na warstwie ≈õwiata, pod HUD)
      for (const s of shockwaves) {
        const sw = worldToScreen(s.x, s.y, cam);
        ctx.beginPath();
        ctx.lineWidth = s.w * camera.zoom;
        ctx.strokeStyle = s.color + (1 - s.life / s.maxLife) + ')';
        ctx.arc(sw.x, sw.y, s.r * camera.zoom, 0, Math.PI * 2);
        ctx.stroke();
      }

      if (!window.USE_STATION_3D) {
        for (const st of stations) {
          const s = worldToScreen(st.x, st.y, cam);
          const visR = (st.baseR || st.r) * stationScaleFor(st);
          const rr = visR * camera.zoom;

          drawStationShadow(ctx, st, cam);
          drawStationVFX(ctx, st, s.x, s.y, rr, gameTime);

          for (let i = 0; i < st.ports.length; i++) {
            const pw = stationPortWorld(st, i);
            const ps = worldToScreen(pw.x, pw.y, cam);
            ctx.fillStyle = '#60a5fa';
            ctx.beginPath(); ctx.arc(ps.x, ps.y, 4 * camera.zoom, 0, Math.PI * 2); ctx.fill();
          }
          ctx.fillStyle = '#dfe7ff'; ctx.font = `${12 * camera.zoom}px monospace`;
          ctx.fillText('ST' + st.id, s.x - rr * 0.35, s.y + 4 * camera.zoom);
        }
      }

      if (mercMission && mercMission.weaponPlatforms) {
        for (const platform of mercMission.weaponPlatforms) {
          if (!platform || platform.removed) continue;
          const s = worldToScreen(platform.x, platform.y, cam);
          const size = platform.radius * 2 * camera.zoom;
          const baseAlpha = platform.destroyed ? Math.max(0, 1 - platform.deathTimer / 1.5) : 1;
          if (baseAlpha <= 0) continue;
          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.rotate(platform.rotation);
          ctx.globalAlpha = baseAlpha;
          ctx.drawImage(platform.canvas, -size / 2, -size / 2, size, size);
          if (platform.hitFlash > 0) {
            const flash = clamp(platform.hitFlash / 0.18, 0, 1);
            ctx.globalAlpha = flash * baseAlpha;
            const flashR = size * 0.34;
            ctx.fillStyle = 'rgba(255,215,150,0.6)';
            ctx.beginPath(); ctx.arc(0, 0, flashR, 0, Math.PI * 2); ctx.fill();
          }
          ctx.restore();

          if (platform.shield && !platform.destroyed && platform.shield.val > 0) {
            const frac = clamp(platform.shield.val / platform.shield.max, 0, 1);
            ctx.save();
            ctx.translate(s.x, s.y);
            ctx.globalAlpha = 0.45 + 0.35 * frac;
            ctx.lineWidth = Math.max(1.2, 2.4 * camera.zoom);
            ctx.strokeStyle = 'rgba(120,200,255,0.8)';
            ctx.beginPath(); ctx.arc(0, 0, size * 0.62, 0, Math.PI * 2); ctx.stroke();
            ctx.restore();
          }
        }
      }

      // Rysowanie wrak√≥w (hex-grid)
      for (const w of wrecks) {
        if (window.drawHexBody) {
          window.drawHexBody(ctx, w, camera, worldToScreen);
        }
      }

      // NPC
      const npcDrawList = [];
      for (const npc of npcs) {
        if (!npc || npc.dead) continue;
        npcDrawList.push(npc);
      }
      npcDrawList.sort((a, b) => (a.drawLayer || 0) - (b.drawLayer || 0));
      for (const npc of npcDrawList) {
        const s = worldToScreen(npc.x, npc.y, cam);
        drawNPCPretty(ctx, npc, s);
      }

      if (Selection.units.size) {
        ctx.save();
        ctx.strokeStyle = '#4a9eff';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.9;
        for (const unit of [...Selection.units]) {
          if (!unit || unit.dead) { Selection.units.delete(unit); continue; }
          const pos = unit.pos || unit;
          const baseR = unit.radius || unit.w || 30;
          const screen = worldToScreen(pos.x, pos.y, cam);
          ctx.beginPath();
          ctx.arc(screen.x, screen.y, Math.max(20, baseR + 12) * camera.zoom, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      if (PAUSED && Selection.active && Selection.rect) {
        const x0 = Math.min(Selection.rect.x0, Selection.rect.x1);
        const y0 = Math.min(Selection.rect.y0, Selection.rect.y1);
        const x1 = Math.max(Selection.rect.x0, Selection.rect.x1);
        const y1 = Math.max(Selection.rect.y0, Selection.rect.y1);
        const s0 = worldToScreen(x0, y0, cam);
        const s1 = worldToScreen(x1, y1, cam);
        ctx.save();
        ctx.strokeStyle = '#7aa8ff';
        ctx.globalAlpha = 0.8;
        ctx.lineWidth = 2;
        ctx.strokeRect(Math.min(s0.x, s1.x), Math.min(s0.y, s1.y), Math.abs(s1.x - s0.x), Math.abs(s1.y - s0.y));
        ctx.restore();
      }

      // === Warp Lens Pass (rysowany pod statkiem i tarczƒÖ) ===
      let warpLensShouldDraw = false;
      let warpLensOutputCanvas = null;

      if (warpBlackHoleFX) {
        const isWarpActive = (warp.state === 'active');
        const entryProgress = isWarpActive ? clamp(warp.entryProgress, 0, 1) : 0;
        const warpIntensity = isWarpActive ? smoothstep01(entryProgress) : 0;

        const lensThreshold = getWarpLensThreshold();
        const desiredLensMode = (warpIntensity >= lensThreshold) ? 'full' : 'background';
        if (desiredLensMode !== warpLensMode) {
          warpLensMode = desiredLensMode;
          warpLensSource = null;
        }
        if (!warpLensSource) {
          configureWarpLensSource();
        }

        const zoneAllowsWarpLens = zoneState.current?.wormholeVfx ?? false;
        const shouldRenderWarpLens = isWarpActive && warpIntensity > 0.001 && zoneAllowsWarpLens;
        warpBlackHoleFX.setEnabled(shouldRenderWarpLens && !!warpLensSource);

        if (shouldRenderWarpLens && warpLensSource) {
          const engineTail = ship.visual?.mainEngine?.y ?? (ship.h * 0.5);
          const tailDepthExtra = warpLensParam('tailDepthExtra');
          const warpDepth = engineTail + ship.h * tailDepthExtra;

          const tailOffset = rotate({ x: 0, y: warpDepth }, interpAngle);

          const s = {
            x: W / 2 + tailOffset.x * camera.zoom,
            y: H / 2 + tailOffset.y * camera.zoom
          };

          const radiusBase = warpLensParam('radiusBase');
          const radiusScale = warpLensParam('radiusScale');
          const massBase = warpLensParam('massBase');
          const massScale = warpLensParam('massScale');
          const softness = Math.min(1, Math.max(0, warpLensParam('softness')));
          const opacityBase = warpLensParam('opacityBase');
          const opacityScale = warpLensParam('opacityScale');

          const baseRadius = Math.max(0.01, radiusBase + radiusScale * warpIntensity);
          const referenceZoom = Math.max(0.0001, camera.defaultZoom || 1);
          const zoomFactor = camera.zoom / referenceZoom;
          const radius = Math.min(1, baseRadius * zoomFactor);

          const baseMass = Math.max(0, (massBase + massScale * warpIntensity) * warpIntensity);
          const mass = Math.min(0.6, baseMass * zoomFactor * zoomFactor);
          const opacity = Math.min(1, Math.max(0, (opacityBase + opacityScale * warpIntensity) * warpIntensity));

          const forwardStretchParam = warpLensParam('forwardStretch');
          const forwardStretchMajor = forwardStretchParam >= 1
            ? forwardStretchParam
            : 1 + (1 - forwardStretchParam);

          const lensStretchFactor = 1 + (forwardStretchMajor - 1) * warpIntensity;
          const lensAngle = ship.angle || 0;

          warpBlackHoleFX.render({
            centerX: s.x,
            centerY: s.y,
            mass,
            radius,
            softness,
            rotation: lensAngle,
            opacity,
            lensStretchForward: lensStretchFactor
          });

          let updated = false;
          if (typeof warpBlackHoleFX.updateOutputBuffer === 'function') {
            updated = warpBlackHoleFX.updateOutputBuffer();
          }

          warpLensOutputCanvas = (typeof warpBlackHoleFX.getOutputCanvas === 'function')
            ? warpBlackHoleFX.getOutputCanvas()
            : null;

          warpLensShouldDraw = !!(
            updated &&
            warpLensOutputCanvas &&
            warpLensOutputCanvas.width &&
            warpLensOutputCanvas.height
          );
        }
      }

      if (warpLensShouldDraw && warpLensOutputCanvas && warpLensOutputCanvas.width && warpLensOutputCanvas.height) {
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(
          warpLensOutputCanvas,
          0, 0, warpLensOutputCanvas.width, warpLensOutputCanvas.height,
          0, 0, canvas.width, canvas.height
        );
        ctx.restore();
      }

      // ======= STATEK =======
      const shipS = worldToScreen(interpPos.x, interpPos.y, cam);
      const spriteScale = ship.visual?.spriteScale || 1;
      const visualW = ship.w * spriteScale;
      const visualH = ship.h * spriteScale;
ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.save();
      ctx.translate(shipS.x, shipS.y);
      ctx.scale(camera.zoom, camera.zoom);
      ctx.rotate(interpAngle);

      // --- 1. OBLICZANIE ACTIVE THRUSTERS (Przeniesione na g√≥rƒô - FIX B≈ÅƒòDU) ---
      const activeThrusters = [];
      let overrides = null;

      if (ship.visual?.torqueThrusters?.length) {
        const thrusters = ship.visual.torqueThrusters;
        const strafeLeft = clamp(input.leftSide ?? 0, 0, 1);
        const strafeRight = clamp(input.rightSide ?? 0, 0, 1);
        const torqueInput = clamp(input.torque ?? 0, -1, 1);
        const torqueIntensity = Math.abs(torqueInput);
        let globalIntensity = 0;

        for (const thruster of thrusters) {
          const strafeIntensity = thruster.side === 'left' ? strafeLeft : strafeRight;
          let thrusterIntensity = strafeIntensity;

          if (torqueIntensity > 0) {
            const isTop = thruster.offset.y < 0;
            const isBottom = thruster.offset.y > 0;
            if (torqueInput < 0) {
              const shouldFire = (thruster.side === 'right' && isTop) || (thruster.side === 'left' && isBottom);
              if (shouldFire) thrusterIntensity = Math.max(thrusterIntensity, torqueIntensity);
            } else if (torqueInput > 0) {
              const shouldFire = (thruster.side === 'left' && isTop) || (thruster.side === 'right' && isBottom);
              if (shouldFire) thrusterIntensity = Math.max(thrusterIntensity, torqueIntensity);
            }
          }

          thrusterIntensity = clamp(thrusterIntensity, 0, 1);
          if (thrusterIntensity > 0) {
            activeThrusters.push({ thruster, intensity: thrusterIntensity });
            globalIntensity = Math.max(globalIntensity, thrusterIntensity);
          }
        }

        if (globalIntensity > 0) {
          overrides = {
            throttleOverride: globalIntensity,
            warpOverride: 0,
            boostOverride: 0,
            moveGlowOverride: 0
          };
        }
      }

      // --- 5. VFX SILNIK√ìW (Przeniesione na g√≥rƒô) ---
      // A. Boczne silniki (Strafe/Torque)
      if (activeThrusters.length) {
        for (const { thruster, intensity } of activeThrusters) {
          const tuneW = window.VFX_TUNE?.sideW ?? 1.0;
          const tuneL = window.VFX_TUNE?.sideL ?? 1.0;

          const widthPxMin = thruster.vfxWidthMin != null ? thruster.vfxWidthMin : spriteScale * 128 * 1.0;
          const widthPxMax = thruster.vfxWidthMax != null ? thruster.vfxWidthMax : spriteScale * 128 * 1.10;
          const lengthPxMin = thruster.vfxLengthMin != null ? thruster.vfxLengthMin : spriteScale * 256 * 0.2;
          const lengthPxMax = thruster.vfxLengthMax != null ? thruster.vfxLengthMax : spriteScale * 256 * 0.4;

          const widthPx = lerp(widthPxMin, widthPxMax, intensity);
          const lengthPx = lerp(lengthPxMin, lengthPxMax, intensity);

          const widthScale = Math.max(0.0001, (widthPx / 128) * tuneW);
          const lengthScale = Math.max(0.0001, (lengthPx / 256) * tuneL);
          const alpha = 0.55 + intensity * 0.35;

          drawNeedleEngineVfxLocal(thruster.offset, thruster.forward, {
            widthScale,
            lengthScale,
            yNudge: thruster.yNudge,
            alpha,
            overrides
          });
        }
      }

      // B. G≈Ç√≥wny silnik
      {
        const e = ship.engines.main;
        const visualOffset = e.visualOffset || e.offset;
        const forward = { x: 0, y: -1 };
        const spd = Math.hypot(ship.vel.x, ship.vel.y);
        const moveGlow = Math.min(spd / 900, 0.6) * 0.8;
        const throttle = Math.max(input.main || 0, moveGlow);

        const mainW = window.VFX_TUNE?.mainW ?? 1.0;
        const mainL = window.VFX_TUNE?.mainL ?? 1.0;

        const widen = (2.4 + 0.6 * throttle) * mainW;
        const lenBase = 1.0 * mainL;

        drawNeedleEngineVfxLocal(visualOffset, forward, {
          widthScale: widen,
          lengthScale: lenBase,
          yNudge: -68 * spriteScale,
          alpha: 1
        });
      }

      // --- 2. Rysowanie Warp Glow (≈Çadowanie) ---
      let warpGlowProgress = 0;
      if (warp.state === 'charging') {
        warpGlowProgress = clamp(warp.charge / warp.chargeTime, 0, 1);
      } else if (warp.state === 'active' && warp.entryProgress < 1) {
        warpGlowProgress = 1 - smoothstep01(warp.entryProgress);
      }
      if (warpGlowProgress > 0) {
        const chargeRadius = Math.max(visualW, visualH) * 0.7;
        drawWarpChargeEffectLocal(warpGlowProgress, chargeRadius, spriteScale);
      }

      // --- 3. Rysowanie KAD≈ÅUBA ---
      if (ship.hexGrid) {
        drawHexBodyLocal(ctx, ship);
        if (ship.hp < ship.maxHp) {
          const zoom = camera.zoom;
          const size = (ship.radius || 20); // UsunƒÖ≈Çem * zoom, bo ctx jest ju≈º wyskalowany w linii 2010
          const hpPct = Math.max(0, ship.hp / ship.maxHp);
          ctx.save();
          // Rysujemy lokalnie wzglƒôdem statku
          ctx.fillStyle = '#ef4444';
          ctx.fillRect(-size, -size - 10, size * 2, 4);
          ctx.fillStyle = '#22c55e';
          ctx.fillRect(-size, -size - 10, size * 2 * hpPct, 4);
          ctx.restore();
        }
        // Nie robimy return, ≈ºeby silniki i efekty (rysowane dalej) siƒô wykona≈Çy
      }
      else if (USE_SHIP_SPRITE && ship.spriteReady) {
        const scale = (ship.h / ship.spriteH) * spriteScale;
        const drawW = ship.spriteW * scale;
        const drawH = ship.spriteH * scale;

        ctx.save();
        ctx.globalAlpha = 0.33;
        ctx.drawImage(shipSprite, -drawW / 2 + 6, -drawH / 2 + 8, drawW, drawH);
        ctx.restore();

        ctx.drawImage(shipSprite, -drawW / 2, -drawH / 2, drawW, drawH);
      } else {
        // Fallback proceduralny (gdy brak sprite'a)
        ctx.fillStyle = 'rgba(3,8,18,0.8)';
        ctx.fillRect(-visualW / 2 + 6 * spriteScale, -visualH / 2 + 8 * spriteScale, visualW, visualH);
        const g = ctx.createLinearGradient(-visualW / 2, -visualH / 2, visualW / 2, visualH / 2);
        g.addColorStop(0, '#1d2740'); g.addColorStop(1, '#2d3b55');
        ctx.fillStyle = g;
        roundRect(ctx, -visualW / 2, -visualH / 2, visualW, visualH, 10 * spriteScale);
        ctx.fill();

        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.06)';
        ctx.lineWidth = 1.5;
        roundRect(ctx, -visualW / 2, -visualH / 2, visualW, visualH, 10 * spriteScale);
        ctx.stroke();
        ctx.globalAlpha = 0.25;
        ctx.beginPath();
        ctx.moveTo(-visualW * 0.35, -visualH * 0.20); ctx.lineTo(visualW * 0.35, -visualH * 0.20);
        ctx.moveTo(-visualW * 0.35, visualH * 0.20); ctx.lineTo(visualW * 0.35, visualH * 0.20);
        ctx.stroke();
        ctx.globalAlpha = 1;
        ctx.restore();

        ctx.fillStyle = '#a8d1ff';
        ctx.beginPath();
        ctx.ellipse(0, -6 * spriteScale, visualW * 0.22, visualH * 0.22, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        ctx.rotate(-interpAngle);
        const glare = ctx.createRadialGradient(0, -visualH * 0.18, 6 * spriteScale, 0, -visualH * 0.18, visualW * 0.5);
        glare.addColorStop(0, 'rgba(255,255,255,0.25)');
        glare.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.fillStyle = glare;
        ctx.beginPath();
        ctx.ellipse(0, -6 * spriteScale, visualW * 0.22, visualH * 0.22, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // --- 4. Rysowanie ELEMENT√ìW PROCEDURALNYCH (gdy brak sprite'a) ---
      if (!(USE_SHIP_SPRITE && ship.spriteReady)) {
        for (const pod of ship.pods) {
          ctx.save();
          ctx.translate(pod.offset.x, pod.offset.y);
          const pg = ctx.createLinearGradient(-pod.w / 2, -pod.h / 2, pod.w / 2, pod.h / 2);
          pg.addColorStop(0, '#1d2740'); pg.addColorStop(1, '#2d3b55');
          ctx.fillStyle = pg;
          roundRect(ctx, -pod.w / 2, -pod.h / 2, pod.w, pod.h, 6 * spriteScale);
          ctx.fill();
          ctx.restore();
        }

        const mainE = ship.engines.main;
        ctx.save();
        const mainVisual = mainE.visualOffset || mainE.offset;
        ctx.translate(mainVisual.x, mainVisual.y);
        ctx.fillStyle = '#2a3a56';
        roundRect(ctx, -14 * spriteScale, -9 * spriteScale, 28 * spriteScale, 18 * spriteScale, 6 * spriteScale);
        ctx.fill();
        ctx.save();
        ctx.globalAlpha = 0.8;
        ctx.shadowBlur = 20;
        ctx.shadowColor = 'rgba(150,200,255,0.9)';
        ctx.fillStyle = 'rgba(160,210,255,0.75)';
        roundRect(ctx, -8 * spriteScale, -6 * spriteScale, 16 * spriteScale, 12 * spriteScale, 4 * spriteScale);
        ctx.fill();
        ctx.restore();
        ctx.restore();

        for (const k of ['sideLeft', 'sideRight', 'torqueLeft', 'torqueRight']) {
          const e = ship.engines[k];
          ctx.save();
          const vis = e.visualOffset || e.offset;
          ctx.translate(vis.x, vis.y);
          ctx.fillStyle = '#2f3b57';
          roundRect(ctx, -6 * spriteScale, -6 * spriteScale, 12 * spriteScale, 12 * spriteScale, 3 * spriteScale);
          ctx.fill();
          ctx.restore();
        }

        // Dzia≈Çka boczne
        ctx.fillStyle = '#cbd6ff';
        for (const off of ship.sideGunsLeft) {
          ctx.save();
          ctx.translate(off.x, off.y);
          roundRect(ctx, -12 * spriteScale, -3 * spriteScale, 8 * spriteScale, 6 * spriteScale, 3 * spriteScale);
          ctx.fill();
          ctx.restore();
        }
        for (const off of ship.sideGunsRight) {
          ctx.save();
          ctx.translate(off.x, off.y);
          roundRect(ctx, 4 * spriteScale, -3 * spriteScale, 8 * spriteScale, 6 * spriteScale, 3 * spriteScale);
          ctx.fill();
          ctx.restore();
        }
      }

      // --- 6. WIE≈ªYCZKI I CIWS ---
      // CIWS
      const ciwsBase = 8 * spriteScale, ciwsBarrelLen = 12 * spriteScale, ciwsBarrelH = 4 * spriteScale;
      const activeCIWS = (Game.player.weapons?.[HP.AUX]?.length || 0);
      ship.ciws.forEach((c, i) => {
        if (i >= activeCIWS) return;
        const ang = interpCIWSAngles[i];
        const loadout = Game.player.weapons?.[HP.AUX]?.[i];
        const isLaser = loadout?.weapon?.id === 'laser_pd_mk1';
        const baseColor = isLaser ? '#7cc6ff' : '#b8bcc6';
        const barrelColor = isLaser ? '#e6f6ff' : '#d0d0d0';
        ctx.save();
        ctx.translate(c.offset.x, c.offset.y);
        ctx.rotate(ang - interpAngle);
        if (isLaser) {
          ctx.shadowColor = 'rgba(90,180,255,0.4)';
          ctx.shadowBlur = 8 * spriteScale;
        }
        ctx.fillStyle = baseColor;
        roundRect(ctx, -ciwsBase / 2, -ciwsBase / 2, ciwsBase, ciwsBase, 2); ctx.fill();
        ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(30,50,90,0.45)'; ctx.stroke();
        ctx.fillStyle = barrelColor;
        roundRect(ctx, ciwsBase / 2, -ciwsBarrelH / 2, ciwsBarrelLen, ciwsBarrelH, 2); ctx.fill(); ctx.stroke();
        ctx.restore();
      });

      // G≈Ç√≥wne wie≈ºyczki
      const baseW = 16 * spriteScale,
        baseH = 24 * spriteScale,
        barrelLen = Math.max(14 * spriteScale, Math.round(visualH * 0.16)) / 2,
        barrelH = 6 * spriteScale,
        gap = 10 * spriteScale;
      const turrets = [
        { t: ship.turret, ang: interpTurretAngle },
        { t: ship.turret2, ang: interpTurretAngle2 },
        { t: ship.turret3, ang: interpTurretAngle3 },
        { t: ship.turret4, ang: interpTurretAngle4 }
      ];
      const turretRefs = turrets.map(({ t }) => t);
      const mainWeaponLoadouts = Game.player.weapons?.[HP.MAIN] || [];
      mainWeaponLoadouts.forEach((loadout, index) => {
        const hpOffset = loadout?.hp?.pos;
        const turretIndex = hpOffset ? getNearestTurretIndex(hpOffset, turretRefs) : (index % turrets.length);
        const activeTurret = turrets[turretIndex] || turrets[0];
        const t = activeTurret.t;
        const ang = activeTurret.ang;
        const mountOffset = hpOffset || t.offset;
        ctx.save();
        ctx.translate(mountOffset.x, mountOffset.y);
        ctx.rotate(ang - interpAngle);

        // Pobieramy ID broni
        const weaponId = loadout?.weapon?.id;
        const behavior = getMainWeaponBehaviorForWeaponId(weaponId);

        // =========================================================
        // PRIORYTET 1: RAILGUN (MK1 / MK2) - ZAWSZE NOWY MODEL
        // =========================================================
        if (weaponId === 'railgun_mk2' || weaponId === 'railgun_mk1') {
          const s = spriteScale;

          // Pobierz recoil dla lewej i prawej lufy
          // (MK2 strzela naprzemiennie, wiƒôc warto≈õci bƒôdƒÖ r√≥≈ºne)
          const recoilL = (Array.isArray(t.recoil) ? t.recoil[0] : t.recoil) * s;
          const recoilR = (Array.isArray(t.recoil) ? t.recoil[1] : t.recoil) * s;

          const barrelLen = 40 * s;
          const barrelThick = 4 * s;
          const barrelOffset = 6 * s;

          // Rysowanie dynamicznych luf (proceduralnie, bo siƒô ruszajƒÖ)
          const drawBarrel = (offsetY, recoilVal) => {
            const startX = 4 * s - recoilVal;
            ctx.fillStyle = '#cccccc';
            ctx.fillRect(startX, offsetY - barrelThick / 2, barrelLen, barrelThick);
            // Detale lufy (paski)
            ctx.fillStyle = '#111111';
            for (let k = 1; k < 5; k++) ctx.fillRect(startX + k * 8 * s, offsetY - barrelThick / 2, 1 * s, barrelThick);
          };

          drawBarrel(-barrelOffset, recoilL); // Lewa
          drawBarrel(barrelOffset, recoilR);  // Prawa

          // Rysowanie statycznego korpusu z CACHE (jako obrazek)
          const bodySprite = getRailgunBodySprite();
          // Przeliczenie skali: w cache s=3.0, tutaj mamy 's'.
          // 120px to rozmiar cache.
          const scaleRatio = s / 3.0;
          const drawSize = 120 * scaleRatio;

          ctx.drawImage(bodySprite, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
        }

        // =========================================================
        // PRIORYTET 2: HEAVY AUTOCANNON (SPRITE SVG)
        // =========================================================
        else if (weaponId === 'heavy_autocannon' && heavyAutocannonSpriteReady) {
          const recoil = (Array.isArray(t.recoil) ? t.recoil[0] : t.recoil) * spriteScale;
          const naturalW = heavyAutocannonSprite.naturalWidth || 180;
          const naturalH = heavyAutocannonSprite.naturalHeight || 120;
          const scaleMul = spriteScale * 0.32;
          const drawW = naturalW * scaleMul;
          const drawH = naturalH * scaleMul;
          const pivotOffset = drawW * 0.52;
          const recoilOffset = recoil * 0.9;
          ctx.save();
          ctx.translate(-pivotOffset - recoilOffset, -drawH / 2);
          ctx.drawImage(heavyAutocannonSprite, 0, 0, drawW, drawH);
          ctx.restore();

          // Glow efekt dla autocannona
          const glowRadius = drawH * 0.34;
          const glowLength = drawW * 0.32;
          ctx.save();
          ctx.translate(drawW * 0.36 - recoil * 0.55, 0);
          const gradient = ctx.createRadialGradient(0, 0, glowRadius * 0.2, 0, 0, glowRadius);
          gradient.addColorStop(0, 'rgba(255,214,160,0.55)');
          gradient.addColorStop(1, 'rgba(255,166,70,0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.ellipse(0, 0, glowLength, glowRadius * 0.55, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          ctx.fillStyle = 'rgba(255,194,120,0.22)';
          ctx.beginPath();
          ctx.moveTo(drawW * 0.34 - recoil * 0.4, -drawH * 0.18);
          ctx.lineTo(drawW * 0.58 - recoil * 0.3, 0);
          ctx.lineTo(drawW * 0.34 - recoil * 0.4, drawH * 0.18);
          ctx.closePath();
          ctx.fill();
        }

        // =========================================================
        // PRIORYTET 3: RESZTA (GENERYCZNE FALLBACKI)
        // =========================================================
        else {
          const barrelsPerShot = Math.max(1, behavior.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot);
          const recoil = (Array.isArray(t.recoil) ? t.recoil[0] : t.recoil) * spriteScale;

          if (barrelsPerShot === 1) {
            // Rysowanie domy≈õlnej pojedynczej wie≈ºyczki (Armata style)
            const housingW = 20 * spriteScale;
            const housingH = 30 * spriteScale;
            ctx.fillStyle = '#7f8fb7';
            roundRect(ctx, -housingW / 2, -housingH / 2, housingW, housingH, 6 * spriteScale); ctx.fill();
            ctx.lineWidth = 1.4; ctx.strokeStyle = 'rgba(24,38,68,0.55)'; ctx.stroke();
            ctx.fillStyle = '#aebce0';
            roundRect(ctx, -housingW / 2 + 3 * spriteScale, -housingH / 2 + 4 * spriteScale, housingW - 6 * spriteScale, housingH - 8 * spriteScale, 5 * spriteScale); ctx.fill();
            ctx.fillStyle = 'rgba(255,180,110,0.8)';
            roundRect(ctx, -housingW / 2 + 2.5 * spriteScale, -2 * spriteScale, housingW * 0.42, 4 * spriteScale, 2 * spriteScale); ctx.fill();
            ctx.strokeStyle = 'rgba(24,38,68,0.55)';
            ctx.fillStyle = '#d9dde9';
            const barrelThickness = 8 * spriteScale;
            const barrelL = Math.max(20 * spriteScale, Math.round(visualH * 0.22));
            roundRect(ctx, 8 * spriteScale - recoil, -barrelThickness / 2, barrelL, barrelThickness, 3 * spriteScale); ctx.fill(); ctx.stroke();
            ctx.fillStyle = '#f0b97a';
            ctx.beginPath();
            ctx.moveTo(8 * spriteScale - recoil + barrelL, -barrelThickness / 2);
            ctx.lineTo(8 * spriteScale - recoil + barrelL + 6 * spriteScale, 0);
            ctx.lineTo(8 * spriteScale - recoil + barrelL, barrelThickness / 2);
            ctx.closePath();
            ctx.fill();
          } else {
            // Rysowanie domy≈õlnej podw√≥jnej wie≈ºyczki (Generyczna)
            const s = spriteScale * camera.zoom;
            const rVal = recoil * s; // Uproszczony recoil
            const housingW = 20 * s;
            const housingH = 24 * s;
            const barrelLen = 40 * s;
            const barrelThick = 4 * s;
            const barrelOffset = 6 * s;

            const drawBarrel = (offsetY) => {
              const startX = 4 * s - rVal;
              ctx.fillStyle = '#cccccc';
              ctx.fillRect(startX, offsetY - barrelThick / 2, barrelLen, barrelThick);
            };

            drawBarrel(-barrelOffset);
            drawBarrel(barrelOffset);

            ctx.fillStyle = '#555'; // Zwyk≈Çy szary dla generycznej
            ctx.beginPath();
            ctx.arc(0, 0, housingW / 1.5, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        ctx.restore();
      });
      ctx.restore(); // ship

      // === Projectile Pass ===
      for (const b of bullets) {
        drawBulletVisual(ctx, b, cam);
      }

      // === Hexlance Projectiles (Supercapital Weapon) ===
      const mWorldRender = { x: cam.x + (mouse.x - W / 2) / cam.zoom, y: cam.y + (mouse.y - H / 2) / cam.zoom };
      // FIX: Przekazujemy interpolowanƒÖ pozycjƒô i kƒÖt
      Superweapon.drawSuperweapon(ctx, cam, ship, worldToScreen, mWorldRender, { pos: interpPos, angle: interpAngle });

      // Rysowanie B≈Çyskawic (Lightning) - nad pociskami, pod UI
      ctx.save();
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.globalCompositeOperation = 'lighter';

      for (const p of lightningParticles) {
        const t = 1 - (p.age / p.maxLife);
        const s = worldToScreen(p.x, p.y, cam);

        if (s.x < -50 || s.x > W + 50 || s.y < -50 || s.y > H + 50) continue;

        ctx.strokeStyle = `rgba(180, 240, 255, ${t * 0.8})`;
        ctx.lineWidth = (1 + Math.random()) * camera.zoom;

        const len = p.size * t * 2.0 * camera.zoom;
        const ax = Math.cos(p.angle) * len;
        const ay = Math.sin(p.angle) * len;

        const x1 = s.x - ax * 0.5;
        const y1 = s.y - ay * 0.5;
        const x2 = s.x + ax * 0.5;
        const y2 = s.y + ay * 0.5;

        ctx.beginPath();
        ctx.moveTo(x1, y1);

        const segments = 3;
        for (let i = 1; i <= segments; i++) {
          const progress = i / segments;
          const tx = x1 + (x2 - x1) * progress;
          const ty = y1 + (y2 - y1) * progress;

          const noise = (Math.random() - 0.5) * p.size * 0.4 * t * camera.zoom;
          const px = -Math.sin(p.angle);
          const py = Math.cos(p.angle);

          if (i < segments) {
            ctx.lineTo(tx + px * noise, ty + py * noise);
          } else {
            ctx.lineTo(x2, y2);
          }
        }
        ctx.stroke();
      }
      ctx.restore();

      // === VFX Pass ===
      for (const p of particlePool) {
        if (!p.active || !p.beam) continue;
        const s1 = worldToScreen(p.start.x, p.start.y, cam);
        const s2 = worldToScreen(p.end.x, p.end.y, cam);
        const alphaFactor = clamp(1 - p.age / Math.max(p.life, 0.0001), 0, 1);
        const baseAlpha = (p.alpha != null) ? p.alpha : 1;
        const fade = (p.fadeWithLife === false) ? baseAlpha : baseAlpha * alphaFactor;
        if (fade <= 0) continue;
        const outerWidthMul = (p.outerWidthMul != null) ? p.outerWidthMul : 1.4;
        const innerWidthMul = (p.innerWidthMul != null) ? p.innerWidthMul : 0.6;
        const glowBlur = ((p.glowBlur != null) ? p.glowBlur : 30) * camera.zoom;
        const glowColor = p.glowColor || 'rgba(120,180,255,0.9)';
        const colorOuter = p.colorOuter || 'rgba(160,210,255,0.7)';
        const colorInner = p.colorInner || 'rgba(220,240,255,1.0)';

        ctx.save();
        ctx.globalAlpha = fade;
        ctx.lineCap = 'round';
        ctx.shadowBlur = glowBlur;
        ctx.shadowColor = glowColor;
        ctx.strokeStyle = colorOuter;
        ctx.lineWidth = p.width * camera.zoom * outerWidthMul;
        ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.globalAlpha = fade;
        ctx.lineCap = 'butt';
        ctx.strokeStyle = colorInner;
        ctx.lineWidth = p.width * camera.zoom * innerWidthMul;
        ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
        ctx.restore();
      }

      {
        ctx.save();

        let drawn = 0;
        for (const p of particlePool) {
          if (!p.active || p.flash || p.beam) continue;
          if (drawn >= MAX_PARTICLES_DRAW) break;
          drawn++;

          // Pomijanie czƒÖsteczek poza ekranem (Frustum culling)
          const s = worldToScreen(p.pos.x, p.pos.y, cam);
          if (s.x < -10 || s.x > W + 10 || s.y < -10 || s.y > H + 10) continue;

          const size = p.size * camera.zoom;
          if (size < 0.5) continue; // Nie rysuj sub-pikselowych ≈õmieci

          const t = 1 - p.age / p.life; // Alpha

          ctx.globalAlpha = clamp(t, 0, 1);
          ctx.fillStyle = p.color;

          if (size < 6) {
            // Dla ma≈Çych czƒÖsteczek rysujemy kwadrat (znacznie szybsze ni≈º arc)
            ctx.fillRect(s.x - size / 2, s.y - size / 2, size, size);
          } else {
            ctx.beginPath();
            ctx.arc(s.x, s.y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        ctx.restore(); // Przywr√≥ƒá stan raz na koniec
      }

      DestructorSystem.draw(ctx, cam, worldToScreen);

      // === Shield Pass ===
      for (const npc of npcDrawList) {
        if (!npc.shield) continue;
        drawShield(ctx, npc, cam);
      }
      if (ship.shield) {
        // FIX: Przekazujemy interpolowanƒÖ pozycjƒô do tarczy
        drawShield(ctx, ship, cam, interpPos);
      }

      // === UI / HUD Pass ===
      // Rysuj HUD na Canvasie TYLKO je≈õli nie jeste≈õmy w menu
      if (!isMainMenuVisible()) {
        hudRenderNav(ship, cam);
        for (const ping of radarPings) {
          const s = worldToScreen(ping.x, ping.y, cam);
          const t = ping.age / ping.life;
          ctx.strokeStyle = `rgba(120,200,255,${1 - t})`;
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(s.x, s.y, 40 * t * camera.zoom, 0, Math.PI * 2); ctx.stroke();
        }
      }

      if (scan.target && scan.targetType && mouse.overCanvas) {
        const obj = scan.target;
        const s = worldToScreen(obj.x, obj.y, cam);
        const base = (obj.radius || obj.r || 60);
        const outerExtra = scan.targetType === 'station' ? 28 : 14;
        const innerExtra = scan.targetType === 'station' ? 12 : 8;
        const outerR = (base + outerExtra) * camera.zoom;
        const innerR = Math.max(2, (base + innerExtra) * camera.zoom);
        const color = scan.targetType === 'station'
          ? 'rgba(143,181,255,0.95)'
          : (obj.friendly ? 'rgba(96,192,255,0.95)' : 'rgba(255,160,122,0.95)');

        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = Math.max(2, 2.5 * Math.sqrt(camera.zoom));
        ctx.shadowBlur = 18 * camera.zoom;
        ctx.shadowColor = color;
        ctx.globalAlpha = 0.9;
        ctx.beginPath(); ctx.arc(s.x, s.y, outerR, 0, Math.PI * 2); ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.globalAlpha = 0.55;
        ctx.setLineDash([6 * camera.zoom, 6 * camera.zoom]);
        ctx.beginPath(); ctx.arc(s.x, s.y, innerR, 0, Math.PI * 2); ctx.stroke();
        ctx.restore();

        if (scan.targetType === 'station' && !stationUI.open) {
          canvas.style.cursor = 'pointer';
        }
      }
      if (highlightedEnemies.length) {
        for (const obj of highlightedEnemies) {
          if (obj.dead) continue;
          const s = worldToScreen(obj.x, obj.y, cam);
          const rad = ((obj.radius || obj.r) + 12) * camera.zoom;
          ctx.strokeStyle = 'rgba(255,255,0,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI * 2); ctx.stroke();
        }
      }
      if (lockedTargets.length) {
        for (const obj of lockedTargets) {
          if (obj.dead) continue;
          const s = worldToScreen(obj.x, obj.y, cam);
          const rad = ((obj.radius || obj.r) + 14) * camera.zoom;
          ctx.strokeStyle = 'rgba(255,80,80,0.8)';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI * 2); ctx.stroke();
        }
      } else if (lockedTarget) {
        const obj = lockedTarget;
        const s = worldToScreen(obj.x, obj.y, cam);
        const rad = ((obj.radius || obj.r) + 14) * camera.zoom;
        ctx.strokeStyle = 'rgba(255,80,80,0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI * 2); ctx.stroke();
      }

      // scan arrows pointing to stations
      if (warp.state !== 'active') {
        const shieldR = Math.max(visualW, visualH) * 0.6;
        for (const a of scanArrows) {
          const st = a.target;
          const dx = st.x - ship.pos.x;
          const dy = st.y - ship.pos.y;
          const ang = Math.atan2(dy, dx);
          const baseR = shieldR + 10;
          const ax = ship.pos.x + Math.cos(ang) * baseR;
          const ay = ship.pos.y + Math.sin(ang) * baseR;
          const s = worldToScreen(ax, ay, cam);
          ctx.save();
          ctx.translate(s.x, s.y);
          ctx.rotate(ang);
          const size = 18 * camera.zoom;
          ctx.beginPath();
          ctx.fillStyle = 'rgba(120,200,255,0.9)';
          ctx.moveTo(0, -size * 0.5);
          ctx.lineTo(size, 0);
          ctx.lineTo(0, size * 0.5);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
          const tx = ship.pos.x + Math.cos(ang) * (baseR + 14);
          const ty = ship.pos.y + Math.sin(ang) * (baseR + 14);
          const ts = worldToScreen(tx, ty, cam);
          ctx.save();
          ctx.fillStyle = '#dfe7ff';
          ctx.font = `${12 * camera.zoom}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(`${Math.round(Math.hypot(dx, dy))}u`, ts.x, ts.y);
          ctx.restore();
        }
      }

      // --- ZOPTYMALIZOWANE RYSOWANIE FLASH (NA WIERZCHU) ---
      {
        ctx.save();

        let drawn = 0;
        for (const p of particlePool) {
          if (!p.active || !p.flash) continue;
          if (drawn >= MAX_PARTICLES_DRAW) break;
          drawn++;

          const s = worldToScreen(p.pos.x, p.pos.y, cam);
          // Cull offscreen
          if (s.x < -50 || s.x > W + 50 || s.y < -50 || s.y > H + 50) continue;

          const t = clamp(1 - p.age / p.life, 0, 1);
          const size = p.size * camera.zoom;

          // Glow (du≈ºe, s≈Çabe k√≥≈Çko)
          ctx.globalAlpha = t * 0.3;
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(s.x, s.y, size * 4, 0, Math.PI * 2);
          ctx.fill();

          // Core (ma≈Çe, jasne k√≥≈Çko)
          ctx.globalAlpha = t;
          ctx.beginPath();
          ctx.arc(s.x, s.y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      if (mercMission && mercMission.station) {
        const st = mercMission.station;
        const panelPadding = 24;
        const barW = 220;
        const barH = 10;
        let y = 36;
        const xRight = W - panelPadding;
        ctx.save();
        ctx.textAlign = 'right';
        ctx.fillStyle = '#ffd1d1';
        ctx.fillText('Piracka stacja', xRight, y);
        ctx.fillStyle = '#dfe7ff';
        y += 8;
        if (st.shield) {
          const shieldFrac = clamp(st.shield.val / st.shield.max, 0, 1);
          ctx.fillText(`Os≈Çony: ${Math.round(st.shield.val)}/${st.shield.max}`, xRight, y + 10);
          const bx = xRight - barW;
          ctx.strokeStyle = 'rgba(255,255,255,0.18)';
          ctx.strokeRect(bx - 1, y + 14, barW + 2, barH + 2);
          ctx.fillStyle = '#60a5fa';
          ctx.fillRect(bx, y + 15, barW * shieldFrac, barH);
          ctx.fillStyle = '#dfe7ff';
          y += 32;
        }
        const hullFrac = clamp(st.hp / st.maxHp, 0, 1);
        ctx.fillText(`Kad≈Çub: ${Math.round(st.hp)}/${st.maxHp}`, xRight, y + 10);
        const bx = xRight - barW;
        ctx.strokeStyle = 'rgba(255,255,255,0.18)';
        ctx.strokeRect(bx - 1, y + 14, barW + 2, barH + 2);
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(bx, y + 15, barW * hullFrac, barH);
        y += 32;
        const platforms = mercMission.weaponPlatforms || [];
        if (platforms.length) {
          ctx.fillStyle = '#ffd1d1';
          ctx.fillText('Platformy obronne', xRight, y);
          y += 8;
          for (const platform of platforms) {
            const label = platform.label || 'Platforma';
            const entryBx = xRight - barW;
            if (platform.shield && platform.shield.max > 0) {
              const shieldFrac = clamp(platform.shield.val / platform.shield.max, 0, 1);
              ctx.fillStyle = '#dfe7ff';
              ctx.fillText(`${label}: os≈Çony ${Math.round(platform.shield.val)}/${platform.shield.max}`, xRight, y + 10);
              ctx.strokeStyle = 'rgba(255,255,255,0.12)';
              ctx.strokeRect(entryBx - 1, y + 14, barW + 2, barH + 2);
              ctx.fillStyle = '#60a5fa';
              ctx.fillRect(entryBx, y + 15, barW * shieldFrac, barH);
              y += 26;
            }
            const hpFrac = (platform.maxHp > 0) ? clamp(Math.max(0, platform.hp) / platform.maxHp, 0, 1) : 0;
            ctx.fillStyle = '#dfe7ff';
            ctx.fillText(`${label}: kad≈Çub ${Math.max(0, Math.round(platform.hp))}/${platform.maxHp}`, xRight, y + 10);
            ctx.strokeStyle = 'rgba(255,255,255,0.12)';
            ctx.strokeRect(entryBx - 1, y + 14, barW + 2, barH + 2);
            ctx.fillStyle = platform.destroyed ? '#4b5563' : '#f97316';
            ctx.fillRect(entryBx, y + 15, barW * hpFrac, barH);
            y += 28;
          }
        }
        ctx.restore();
      }

      if (showMap) drawSectorMap();
      renderStationUI();
      renderOptions();
      renderMissionJournal();
      renderZoneMessages();
      renderMissionCompleteBanner();
      mouse.click = false;
    }

    function renderZoneMessages() {
      if (!zoneState.messages.length) return;

      ctx.save();
      ctx.resetTransform();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const baseY = 70;
      const lineH = 32;

      zoneState.messages.forEach((msg, i) => {
        const progress = msg.maxLife - msg.life;
        const fadeIn = clamp(progress / 0.35, 0, 1);
        const fadeOut = clamp(msg.life / 0.5, 0, 1);
        const alpha = Math.min(fadeIn, fadeOut);
        if (alpha <= 0) return;

        const fontSize = 22;
        const y = baseY + i * lineH;
        ctx.font = `600 ${fontSize}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 12;
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(12, 20, 36, 0.7)';
        ctx.fillStyle = '#e5ecff';
        ctx.globalAlpha = alpha;

        ctx.strokeText(msg.text, W / 2, y);
        ctx.fillText(msg.text, W / 2, y);
      });

      ctx.restore();
    }

    function renderMissionCompleteBanner() {
      if (!missionCompleteBanner.active) return;
      const alpha = missionCompleteBanner.alpha();
      if (alpha <= 0) return;

      ctx.save();
      ctx.resetTransform();
      ctx.translate(W / 2, H * 0.32);
      const scale = 1 + 0.08 * Math.sin(missionCompleteBanner.progress() * Math.PI);
      ctx.scale(scale, scale);
      ctx.globalAlpha = alpha;

      const fontSize = Math.round(Math.min(W, H) * 0.08);
      ctx.font = `700 ${fontSize}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(80,180,255,0.85)';
      ctx.shadowBlur = Math.max(14, fontSize * 0.2);
      ctx.lineJoin = 'round';

      const strokeWidth = Math.max(2, fontSize * 0.05);
      ctx.lineWidth = strokeWidth;
      ctx.strokeStyle = 'rgba(10,20,40,0.6)';
      ctx.strokeText(missionCompleteBanner.text, 0, 0);

      ctx.fillStyle = '#ffffff';
      ctx.fillText(missionCompleteBanner.text, 0, 0);

      ctx.restore();
    }

    function clampMapViewPosition(x, y) {
      const layout = mapView.layout;
      if (!layout) return { x, y };
      const minX = W - layout.mapW - layout.padding;
      const minY = H - layout.mapH - layout.padding;
      const maxX = layout.padding;
      const maxY = layout.padding;
      return {
        x: clamp(x, minX, maxX),
        y: clamp(y, minY, maxY),
      };
    }

    function syncMapViewLayout() {
      const padding = Math.max(28, Math.min(W, H) * 0.05);
      const baseScale = Math.min((W - padding * 2) / WORLD.w, (H - padding * 2) / WORLD.h);
      const scale = baseScale * mapView.zoom;
      const mapW = WORLD.w * scale;
      const mapH = WORLD.h * scale;
      mapView.layout = { padding, mapW, mapH };

      const clampPos = (value, content, view) => {
        if (content <= view - padding * 2) return (view - content) / 2;
        const min = view - content - padding;
        const max = padding;
        return clamp(value, min, max);
      };

      const targetX0 = clampPos(W / 2 - ship.pos.x * scale, mapW, W);
      const targetY0 = clampPos(H / 2 - ship.pos.y * scale, mapH, H);

      return { padding, scale, mapW, mapH, targetX0, targetY0 };
    }

    function drawSectorMap() {
      mapView.zoom += (mapView.targetZoom - mapView.zoom) * mapView.smoothness;

      const { padding, scale, mapW, mapH, targetX0, targetY0 } = syncMapViewLayout();

      if (mapView.viewX == null || mapView.viewY == null) {
        mapView.viewX = targetX0;
        mapView.viewY = targetY0;
      } else if (mapView.followShip) {
        mapView.viewX += (targetX0 - mapView.viewX) * 0.18;
        mapView.viewY += (targetY0 - mapView.viewY) * 0.18;
      }

      const clampedView = clampMapViewPosition(mapView.viewX, mapView.viewY);
      mapView.viewX = clampedView.x;
      mapView.viewY = clampedView.y;

      const toScreen = (x, y) => ({
        x: mapView.viewX + x * scale,
        y: mapView.viewY + y * scale,
      });

      ctx.save();
      ctx.resetTransform();

      const bg = ctx.createLinearGradient(0, 0, 0, H);
      bg.addColorStop(0, 'rgba(32, 74, 129, 0.95)');
      bg.addColorStop(0.55, 'rgba(10, 44, 86, 0.9)');
      bg.addColorStop(1, 'rgba(4, 18, 36, 0.92)');
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, W, H);

      const glow = ctx.createRadialGradient(W * 0.6, H * 0.34, Math.min(W, H) * 0.08, W * 0.4, H * 0.66, Math.max(W, H) * 0.9);
      glow.addColorStop(0, 'rgba(108, 227, 255, 0.35)');
      glow.addColorStop(0.45, 'rgba(78, 196, 255, 0.16)');
      glow.addColorStop(1, 'rgba(48, 168, 255, 0)');
      ctx.fillStyle = glow;
      ctx.fillRect(0, 0, W, H);

      ctx.save();
      ctx.globalAlpha = 0.8;
      const glass = ctx.createLinearGradient(0, padding, 0, H - padding);
      glass.addColorStop(0, 'rgba(255,255,255,0.08)');
      glass.addColorStop(0.5, 'rgba(255,255,255,0.02)');
      glass.addColorStop(1, 'rgba(255,255,255,0.07)');
      ctx.fillStyle = glass;
      ctx.fillRect(padding * 0.5, padding * 0.5, W - padding, H - padding);
      ctx.restore();

      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.lineWidth = 1;
      const gridStep = 4000;
      const startX = Math.floor(-mapView.viewX / (gridStep * scale)) * gridStep;
      const startY = Math.floor(-mapView.viewY / (gridStep * scale)) * gridStep;
      ctx.save();
      ctx.beginPath();
      for (let gx = startX; gx < WORLD.w; gx += gridStep) {
        const px = toScreen(gx, 0).x;
        if (px < padding || px > W - padding) continue;
        ctx.moveTo(px, padding);
        ctx.lineTo(px, H - padding);
      }
      for (let gy = startY; gy < WORLD.h; gy += gridStep) {
        const py = toScreen(0, gy).y;
        if (py < padding || py > H - padding) continue;
        ctx.moveTo(padding, py);
        ctx.lineTo(W - padding, py);
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.12)';
      ctx.stroke();
      ctx.restore();

      const frame = ctx.createLinearGradient(mapView.viewX, mapView.viewY, mapView.viewX, mapView.viewY + mapH);
      frame.addColorStop(0, 'rgba(132, 228, 255, 0.9)');
      frame.addColorStop(1, 'rgba(52, 142, 255, 0.8)');
      ctx.strokeStyle = frame;
      ctx.lineWidth = 2.5;
      ctx.shadowColor = 'rgba(80, 200, 255, 0.4)';
      ctx.shadowBlur = 14;
      ctx.strokeRect(mapView.viewX, mapView.viewY, mapW, mapH);
      ctx.shadowBlur = 0;

      const drawGlowDot = (pos, radius, fill, stroke) => {
        ctx.save();
        ctx.shadowColor = fill;
        ctx.shadowBlur = radius * 2;
        ctx.fillStyle = fill;
        ctx.strokeStyle = stroke || fill;
        ctx.lineWidth = Math.max(1.5, radius * 0.25);
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      };

      const sunPos = toScreen(SUN.x, SUN.y);
      const sunRadius = Math.max(10, 12 * mapView.zoom);
      drawGlowDot(sunPos, sunRadius, 'rgba(255, 200, 92, 0.9)', 'rgba(255, 243, 191, 0.9)');

      if (ASTEROID_BELT) {
        const cx = sunPos.x;
        const cy = sunPos.y;
        const outerRx = ASTEROID_BELT.outer * scale;
        const outerRy = ASTEROID_BELT.outer * scale;
        const innerRx = ASTEROID_BELT.inner * scale;
        const innerRy = ASTEROID_BELT.inner * scale;
        ctx.save();
        ctx.strokeStyle = 'rgba(168, 182, 204, 0.55)';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.7;
        ctx.beginPath(); ctx.ellipse(cx, cy, outerRx, outerRy, 0, 0, Math.PI * 2); ctx.stroke();
        ctx.beginPath(); ctx.ellipse(cx, cy, innerRx, innerRy, 0, 0, Math.PI * 2); ctx.stroke();
        ctx.restore();
      }

      const planetMarkerRadius = Math.max(8, 10 * Math.sqrt(mapView.zoom));
      const labelFont = Math.max(12, Math.round(Math.min(W, H) * 0.022));

      if (Array.isArray(planets) && planets.length) {
        ctx.save();

        ctx.fillStyle = '#a5ebff';
        for (const planet of planets) {
          const pos = toScreen(planet.x, planet.y);
          drawGlowDot(pos, planetMarkerRadius, 'rgba(140, 227, 255, 0.92)', 'rgba(214, 244, 255, 0.9)');
        }

        ctx.font = `600 ${labelFont}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.lineWidth = Math.max(2, labelFont * 0.14);
        ctx.strokeStyle = 'rgba(6, 10, 22, 0.85)';
        ctx.fillStyle = '#e8f7ff';

        for (const planet of planets) {
          const name = typeof planet.label === 'string' ? planet.label.trim() : '';
          if (!name) continue;
          const pos = toScreen(planet.x, planet.y);
          const labelY = pos.y + planetMarkerRadius + 8;
          ctx.strokeText(name, pos.x, labelY);
          ctx.fillText(name, pos.x, labelY);
        }

        ctx.restore();
      }

      ctx.save();
      ctx.fillStyle = '#9df0ff';
      ctx.strokeStyle = 'rgba(71, 191, 255, 0.65)';
      ctx.lineWidth = 2.4;
      for (const st of stations) {
        const pos = toScreen(st.x, st.y);
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }
      ctx.restore();

      if (mercMission?.station) {
        const piratePos = toScreen(mercMission.station.x, mercMission.station.y);
        const labelY = piratePos.y + planetMarkerRadius + 8;
        ctx.save();
        ctx.font = `600 ${labelFont}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.lineWidth = Math.max(2, labelFont * 0.14);
        ctx.strokeStyle = 'rgba(46, 4, 4, 0.85)';
        ctx.fillStyle = '#ffb3b3';
        ctx.strokeText('Pirate Station', piratePos.x, labelY);
        ctx.fillText('Pirate Station', piratePos.x, labelY);
        ctx.restore();
      }

      ctx.save();
      const shipPos = toScreen(ship.pos.x, ship.pos.y);
      const shipRadius = Math.max(7, 9 * Math.pow(mapView.zoom, 0.35));
      const angle = ship.angle || 0;
      ctx.translate(shipPos.x, shipPos.y);
      ctx.rotate(angle);
      ctx.fillStyle = '#e9fbff';
      ctx.strokeStyle = 'rgba(126, 233, 255, 0.95)';
      ctx.shadowColor = 'rgba(120, 230, 255, 0.6)';
      ctx.shadowBlur = 10;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(shipRadius * 1.6, 0);
      ctx.lineTo(-shipRadius * 0.9, shipRadius * 0.9);
      ctx.lineTo(-shipRadius * 0.9, -shipRadius * 0.9);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      ctx.strokeStyle = '#ff9cc2';
      ctx.lineWidth = 3.2;
      for (const m of MISSIONS.active) {
        if (m.status !== 'active' || !m.pos) continue;
        const pos = toScreen(m.pos.x, m.pos.y);
        const s = Math.max(9, 10 * Math.sqrt(mapView.zoom));
        ctx.beginPath();
        ctx.moveTo(pos.x - s, pos.y - s); ctx.lineTo(pos.x + s, pos.y + s);
        ctx.moveTo(pos.x - s, pos.y + s); ctx.lineTo(pos.x + s, pos.y - s);
        ctx.stroke();
      }

      ctx.save();
      const titleY = padding * 0.7;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.font = `700 ${Math.max(18, Math.min(W, H) * 0.03)}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
      ctx.fillStyle = '#f2f8ff';
      ctx.shadowColor = 'rgba(72, 192, 255, 0.75)';
      ctx.shadowBlur = 18;
      ctx.fillText('Mapa Sektora', padding, titleY);

      ctx.font = `500 ${Math.max(13, Math.min(W, H) * 0.018)}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(232, 241, 255, 0.85)';
      ctx.fillText('LPM ‚Äî przesuwanie ¬∑ Scroll ‚Äî powiƒôkszenie ¬∑ M ‚Äî zamknij', padding, titleY + 28);
      ctx.restore();

      ctx.restore();
    }

    // =============== Helpers (POPRAWIONE) ===============
    function roundRect(ctx, x, y, w, h, r) {
      // Zabezpieczenie: promie≈Ñ nie mo≈ºe byƒá wiƒôkszy ni≈º po≈Çowa kr√≥tszego boku
      if (w < 2 * r) r = w / 2;
      if (h < 2 * r) r = h / 2;
      if (r < 0) r = 0;

      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }


    function roundRectScreen(x, y, w, h, r) {
      roundRect(ctx, x, y, w, h, r);
    }

    function screenToWorld(sx, sy) {
      return { x: camera.x + (sx - W / 2) / camera.zoom, y: camera.y + (sy - H / 2) / camera.zoom };
    }

    // --- MINI UI HELPERS (HUD) ---
    let hudOffset = { x: 40, y: 46 };
    function hudBeginPanel(x = 24, y = 24, w = 450, h = 520) {
      ctx.save();
      ctx.resetTransform();
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(x, y, w, h);
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fillRect(x, y, w, 24);
      ctx.translate(x + 16, y + 46);
      hudOffset.x = x + 16;
      hudOffset.y = y + 46;
      ctx.fillStyle = '#E6F2FF';
      ctx.font = '16px monospace';
    }
    function hudEndPanel() { ctx.restore(); }
    function uiTitle(t) { ctx.font = '20px monospace'; ctx.fillText(t, 0, 0); ctx.translate(0, 28); ctx.font = '16px monospace'; }
    function section(t) { ctx.translate(0, 12); ctx.globalAlpha = 0.8; ctx.fillText('‚Äî ' + t, 0, 0); ctx.globalAlpha = 1; ctx.translate(0, 18); }
    function uiText(t) { ctx.fillText(t, 0, 0); ctx.translate(0, 18); }
    function hudTabs(names, active) {
      let x = 0, clicked = null;
      for (let i = 0; i < names.length; i++) {
        const key = names[i];
        const label = '[' + toTitleCaseFromKey(key) + ']';
        const w = ctx.measureText(label).width;
        const t = ctx.getTransform();
        const L = t.e + x, T = t.f - 14, R = L + w, B = T + 20;

        ctx.fillStyle = key === active ? '#fff' : '#a8c0ff';
        ctx.fillText(label, x, 0);

        const over = mouse.x > L && mouse.x < R && mouse.y > T && mouse.y < B;
        if (over) canvas.style.cursor = 'pointer';
        if (over && mouse.click) clicked = key;

        x += ctx.measureText(label + '  ').width;
      }
      ctx.translate(0, 28);
      ctx.fillStyle = '#E6F2FF';
      if (clicked) { stationUI.tab = clicked; mouse.click = false; }
    }

    // --- NOWA FUNKCJA UI DO WYBORU JAKO≈öCI ---
    function uiQualitySelector() {
      if (!window.Nebula) return;
      const cfg = window.Nebula.getConfig();
      const current = cfg.quality;
      const opts = ['2k', '4k', '8k'];

      ctx.fillText('Jako≈õƒá t≈Ça:', 0, 0);

      let x = 180;
      const y = -14;
      const w = 40;
      const h = 20;

      for (const opt of opts) {
        const isActive = (current === opt);

        // Rysowanie przycisku
        ctx.strokeStyle = isActive ? '#fff' : 'rgba(100,150,255,0.4)';
        ctx.fillStyle = isActive ? '#3b82f6' : 'rgba(10,20,40,0.5)';
        ctx.fillRect(x, y, w, h);
        ctx.strokeRect(x, y, w, h);

        // Tekst
        ctx.fillStyle = isActive ? '#fff' : '#8fb5ff';
        ctx.fillText(opt.toUpperCase(), x + 8, 0);

        // Obs≈Çuga myszy (Canvas Immediate Mode GUI)
        const t = ctx.getTransform();
        const L = t.e + x;
        const T = t.f + y;
        const R = L + w;
        const B = T + h;

        const over = mouse.x > L && mouse.x < R && mouse.y > T && mouse.y < B;
        if (over) {
          canvas.style.cursor = 'pointer';
          if (mouse.click) {
            window.Nebula.setQuality(opt);
            mouse.click = false; // "zjedz" klikniƒôcie
          }
        }

        x += w + 8; // odstƒôp
      }
      ctx.translate(0, 24); // nowa linia w panelu
    }

    function uiRowButton(label, btn) {
      ctx.fillText(label, 0, 0);
      const w = 96, h = 20, x = 320, y = -14;
      ctx.strokeStyle = '#cfe3ff'; ctx.strokeRect(x, y, w, h); ctx.fillText(btn, x + 10, 0);

      const t = ctx.getTransform();
      const L = t.e + x, T = t.f + y, R = L + w, B = T + h;
      const over = mouse.x > L && mouse.x < R && mouse.y > T && mouse.y < B;
      if (over) canvas.style.cursor = 'pointer';
      const clicked = over && mouse.click;

      ctx.translate(0, 22);
      if (clicked) mouse.click = false;
      return clicked;
    }
    function slider(label, min, max, step, obj, key) {
      ctx.fillText(`${label}: ${obj[key].toFixed(2)}`, 0, 0); ctx.translate(0, 18);
      // do prostoty ‚Äì klawiszami [ i ] zmieniasz ostatni slider; lub klik + ruch (opcjonalnie)
      // Mo≈ºesz podpiƒÖƒá realny input wed≈Çug swojej architektury.
    }
    function toast(t) { /* opcjonalnie dopisz do kolejki komunikat√≥w HUD */ }
    function applyShipStats(s) {
      ship.hull.max = Math.round(ship.hull.max * s.hp);
      ship.hull.val = Math.min(ship.hull.val, ship.hull.max);

      const speedMul = s.speed;
      ship.engines.main.maxThrust = Math.round(ship.engines.main.maxThrust * speedMul);
      ship.engines.sideLeft.maxThrust = Math.round(ship.engines.sideLeft.maxThrust * speedMul);
      ship.engines.sideRight.maxThrust = Math.round(ship.engines.sideRight.maxThrust * speedMul);
      ship.engines.torqueLeft.maxThrust = Math.round(ship.engines.torqueLeft.maxThrust * speedMul);
      ship.engines.torqueRight.maxThrust = Math.round(ship.engines.torqueRight.maxThrust * speedMul);

      ship.cargoCap = Math.round((ship.cargoCap || 20) * s.cargo);
    }

    function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }
    function limitSpeed(n, max) {
      const vx = n.vel ? n.vel.x : n.vx;
      const vy = n.vel ? n.vel.y : n.vy;
      const v = Math.hypot(vx, vy);
      if (v > max) {
        const s = max / v;
        if (n.vel) { n.vel.x *= s; n.vel.y *= s; }
        else { n.vx *= s; n.vy *= s; }
      }
    }
    function useRailPair(n, target) { /* sprawd≈∫ kƒÖt i cooldown, odpal pary */ }
    function useRocketsPair(n, target) { /* salwy */ }
    function useCIWSPair(n, target) { /* kr√≥tka seria */ }
    function maybeFireRockets(n, target) { /* warunkowo */ }
    Object.defineProperty(PirateSim, 'units', {
      get: function () {
        // Zwraca tablicƒô: [Gracz, ...Wszystkie ≈ºywe NPC]
        // Dziƒôki temu AI mo≈ºe iterowaƒá po 'sim.units' i szukaƒá cel√≥w
        return [ship, ...npcs.filter(n => !n.dead)];
      }
    });



    // 2. Pod≈ÇƒÖcz funkcjƒô strzelania AI do silnika gry
    // Kiedy AI wywo≈Ça spawnBullet, my przekierujemy to do adaptera, kt√≥ry doda pocisk do gry
    window.spawnBullet = function (sim, from, to, weapon) {
      if (window.spawnBulletAdapter) {
        window.spawnBulletAdapter(from, to, weapon);
      } else if (window.aiSpawnBullet) {
        window.aiSpawnBullet(sim, from, to, weapon);
      }
    };
    // NOWE: Funkcja do obs≈Çugi paska w UI gry
    function updateLiveBackgroundProgress(progress) {
      const el = document.getElementById('bg-gen-status');
      const txt = document.getElementById('bg-gen-percent');
      if (!el || !txt) return;

      if (progress < 1.0) {
        el.style.display = 'block';
        txt.textContent = Math.round(progress * 100) + '%';
      } else {
        el.style.display = 'none'; // Ukryj po zako≈Ñczeniu
      }
    }

    async function startGame() {
      if (gameStarted) return;

      // --- AUDIO START ---
      AudioSys.init();
      await Promise.all([
        AudioSys.loadSound('engine', '/sounds/engine/thruster_loop.wav'),
        AudioSys.loadSound('shieldHit', '/sounds/465540__steaq__sci-fi-shield-hit-wav.wav'),
        AudioSys.loadSound('specialTurret', '/sounds/weapons/specialturret.wav'),
        AudioSys.loadSound('sfx_hexlance', '/sounds/weapons/specialturret.wav'),
        AudioSys.loadSound('sfx_railgun', './sounds/weapons/Laser.wav')
      ]);

      if (typeof ship !== 'undefined') {
        ship.engineSound = AudioSys.createEngineLoop('engine');
      }
      // --- AUDIO END ---

      gameStarted = true;
      fadeOutMenuMusic();
      
      if (continueButton) continueButton.classList.remove('hidden');
      if (optionsButton) optionsButton.disabled = false;
      setMenuView('home');

      // 1. Rƒôcznie ukryj menu i upewnij siƒô, ≈ºe HUD jest SCHOWANY podczas ≈Çadowania
      if (mainMenuEl) mainMenuEl.classList.add('hidden');
      toggleGameUI(false);

      showLoadingOverlay(0, 'Przygotowanie ≈õwiata');
      initStars(true);
      setLoadingProgress(20, 'Inicjalizacja system√≥w');
      await nextFrame();

      initNPCs();
      setLoadingProgress(40, 'Symulacja tras NPC');
      await nextFrame();

      initFleet();
      setLoadingProgress(60, 'Kalibracja floty');
      await nextFrame();

      // Wstƒôpna symulacja fizyki
      for (let i = 0; i < 60; i++) npcStep(PHYS_DT);
      setLoadingProgress(80, 'Rozruch silnik√≥w');

      await waitForPlanetsReady();

      setLoadingProgress(100, 'Start!');
      await nextFrame();

      const firstFramePromise = new Promise(resolve => { firstFrameResolver = resolve; });
      lastTime = performance.now();
      acc = 0;
      vfxTime = 0;

      // Inicjalizacja system√≥w (ale bez pokazywania ich rƒôcznie, zrobi to toggleGameUI)
      initShieldSystem(W, H);

      requestAnimationFrame(loop);
      await firstFramePromise;

      // Ukryj loading overlay
      hideLoadingOverlay();

      // 2. TERAZ, gdy gra jest gotowa, u≈ºywamy hideMainMenu() logicznie, 
      // aby w≈ÇƒÖczyƒá HUD i odpauzowaƒá grƒô.
      hideMainMenu();

      console.log("[System] Gra uruchomiona.");
    }
    if (newGameButton) {
      newGameButton.addEventListener('click', () => {
        setMenuView('home');
        startGame();
      });
    }
    if (continueButton) {
      continueButton.addEventListener('click', () => {
        if (!gameStarted) return;
        hideMainMenu();
      });
    }
    if (loadGameButton) {
      loadGameButton.title = 'Wkr√≥tce dostƒôpne';
    }
    if (optionsButton) {
      optionsButton.title = 'Dostosuj jako≈õƒá t≈Ça';
      optionsButton.addEventListener('click', () => showMainMenu('options'));
    }
    if (optionsBackButton) {
      optionsBackButton.addEventListener('click', () => setMenuView('home'));
    }
    if (creditsButton) {
      creditsButton.title = 'Tw√≥rcy i dane projektu';
      creditsButton.addEventListener('click', () => showMainMenu('credits'));
    }
    if (creditsBackButton) {
      creditsBackButton.addEventListener('click', () => setMenuView('home'));
    }
    if (qualityButtons && qualityButtons.length) {
      qualityButtons.forEach(btn => {
        btn.addEventListener('click', () => setBackgroundQuality(btn.dataset.quality));
      });
      applyQualitySelection();
    }
    if (supportGuardBtn) {
      supportGuardBtn.addEventListener('click', () => setSupportOrder('guard', { force: true }));
    }
    if (supportEngageBtn) {
      supportEngageBtn.addEventListener('click', () => setSupportOrder('engage', { force: true }));
    }
    if (supportSpawnButtons && supportSpawnButtons.forEach) {
      supportSpawnButtons.forEach(btn => {
        const key = btn.dataset.supportSpawn;
        if (SUPPORT_CLICK_TYPES.has(key)) {
          btn.addEventListener('click', () => {
            if (btn.getAttribute('aria-disabled') === 'true') return;
            if (key === 'carrier_fighter') {
              const carrier = getFriendlyCarrierEntity();
              if (!carrier) return;
              spawnSupportShip('fighter', { anchor: carrier });
            } else {
              spawnSupportShip(key);
            }
            setSupportOrder('guard', { force: true });
          });
        } else if (isSupportDragKey(key)) {
          btn.addEventListener('mousedown', (event) => {
            if (event.button !== 0) return;
            if (btn.getAttribute('aria-disabled') === 'true') return;
            beginSupportDrag(key, btn);
          });
          btn.addEventListener('click', (event) => {
            event.preventDefault();
          });
        }
      });
    }
    window.addEventListener('mouseup', (event) => {
      if (endSupportDrag(event)) {
        event.preventDefault();
        event.stopPropagation();
      }
    }, true);
    if (energyShotBtn) {
      energyShotBtn.addEventListener('click', () => triggerEnergyShot());
    }

    // --- OBS≈ÅUGA JAKO≈öCI PLANET ---

    function updatePlanetQualityUI() {
      const current = window.OPTIONS.planetQuality || 'medium';
      document.querySelectorAll('[data-planet-q]').forEach(btn => {
        const isActive = (btn.dataset.planetQ === current);
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-pressed', isActive);
      });
    }

    document.querySelectorAll('[data-planet-q]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const quality = e.target.dataset.planetQ;
        if (window.OPTIONS) window.OPTIONS.planetQuality = quality;
        localStorage.setItem('sc_planet_quality', quality);
        updatePlanetQualityUI();
        console.log(`Zmieniono jako≈õƒá planet na: ${quality}`);
      });
    });

    window.addEventListener('DOMContentLoaded', () => {
      const saved = localStorage.getItem('sc_planet_quality');
      if (saved && window.OPTIONS) {
        window.OPTIONS.planetQuality = saved;
      }
      updatePlanetQualityUI();
    });

  </script>

  <script type="module">
    import { initDevTools } from './src/ui/devTools.js';

    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        initDevTools();
      }, 100);
    });
  </script>

</body>

</html>
