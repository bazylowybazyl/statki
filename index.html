<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Space Survivors — gwiazdy na całej mapie + duży silnik plazmowy</title>
<style>
  html,body{height:100%;margin:0;background:#030417;color:#dfe7ff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  #ui{position:absolute;left:12px;top:12px;z-index:20;background:rgba(8,10,20,0.6);padding:10px;border-radius:8px;backdrop-filter:blur(6px)}
  canvas{display:block;width:100vw;height:100vh}
  #game-root{position:relative;width:100vw;height:100vh;}
  #game-root>canvas{display:block;width:100%;height:100%;}
  #c { position: relative; z-index: 10; }
  /* nie obejmuj overlayu 3D */
  canvas:not(#c):not(.overlay3d) {
    pointer-events: none !important;
    position: absolute;
    inset: 0;
    z-index: 0;
  }
  .stat{font-family:monospace;font-size:13px}
  small{color:#a8b4d9}
  #loading{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:#030417;z-index:50;color:#dfe7ff;font-size:32px;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  .hidden{display:none !important;}
  .station-overlay{position:absolute;top:60px;right:40px;max-width:420px;max-height:80vh;overflow-y:auto;padding:16px;background:rgba(9,13,24,0.92);border:1px solid #1b2337;border-radius:12px;z-index:60;color:#dfe7ff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;backdrop-filter:blur(12px);box-shadow:0 18px 36px rgba(0,0,0,0.45);}
  .station-overlay h3{margin:0 0 12px 0;font-size:18px;letter-spacing:0.04em;text-transform:uppercase;color:#8fb5ff;}
  .station-overlay ul{list-style:none;padding:0;margin:0 0 12px 0;display:flex;gap:8px;}
  .station-overlay li{padding:6px 12px;border:1px solid #2a3a5a;border-radius:8px;background:#0a1020;cursor:pointer;color:#a8b4d9;font-size:14px;transition:background 0.2s,border-color 0.2s,color 0.2s;}
  .station-overlay li:hover{background:#131b2f;border-color:#3b4a6d;color:#e6f2ff;}
  .station-overlay li.active{background:#1f2c49;border-color:#3b82f6;color:#fff;}
  .station-tab.hidden{display:none;}
  .mechanic-toolbar{display:flex;align-items:center;gap:8px;margin-bottom:14px;}
  .mechanic-toolbar label{font-weight:600;letter-spacing:0.03em;color:#b8c9f3;}
  .mechanic-toolbar select{flex:1;background:#0b1224;color:#dfe7ff;border:1px solid #2a3a5a;border-radius:8px;padding:6px 10px;font-size:14px;}
  .hp-groups { display:grid; gap:12px; grid-template-columns: repeat(auto-fit,minmax(240px,1fr)); }
  .hp-group { background:#0b0f1a; border:1px solid #1b2337; border-radius:10px; padding:10px; }
  .hp-group h4 { margin:0 0 6px 0; font-weight:600; }
  .hp-item { display:flex; justify-content:space-between; align-items:center; padding:6px 8px; border-radius:8px; margin:6px 0; background:#121a2a; }
  .hp-item button { padding:4px 8px; border:1px solid #2a3a5a; background:#0a1020; border-radius:6px; cursor:pointer; color:#dfe7ff; }
  .hp-item button:hover{background:#18233c;}
  .hp-main   h4, .hp-main .hp-item   { outline:1px solid #3b82f6; }
  .hp-miss   h4, .hp-miss .hp-item   { outline:1px solid #10b981; }
  .hp-aux    h4, .hp-aux .hp-item    { outline:1px solid #f59e0b; }
  .hp-hangar h4, .hp-hangar .hp-item { outline:1px solid #a78bfa; }
  .hp-spec   h4, .hp-spec .hp-item   { outline:1px solid #ef4444; }
  .hover-info{position:absolute;top:120px;right:40px;min-width:220px;max-width:320px;background:rgba(9,13,24,0.88);border:1px solid rgba(91,116,178,0.45);border-radius:14px;padding:14px 18px;z-index:55;color:#e4ecff;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;pointer-events:none;backdrop-filter:blur(12px);box-shadow:0 14px 32px rgba(0,0,0,0.45);}
  .hover-info.hidden{display:none !important;}
  .hover-info .hover-title{font-size:16px;font-weight:600;letter-spacing:0.04em;margin:0 0 4px 0;}
  .hover-info .hover-subtitle{display:block;font-size:11px;letter-spacing:0.18em;text-transform:uppercase;color:#8fb5ff;margin-bottom:12px;}
  .hover-info .hover-section{font-size:11px;letter-spacing:0.12em;text-transform:uppercase;color:#94a9d6;margin-bottom:6px;}
  .hover-info .hover-tags{display:flex;flex-wrap:wrap;gap:6px;}
  .hover-info .hover-tag{padding:4px 10px;border-radius:999px;background:rgba(63,88,144,0.38);color:#dfe7ff;font-size:12px;}
  .hover-info .hover-line{font-size:13px;margin-bottom:6px;display:flex;align-items:center;gap:6px;}
  .hover-info .hover-line strong{font-weight:600;color:#8fb5ff;letter-spacing:0.05em;}
</style>
<style>
  /* Overlay 3D musi być nad głównym canvasem (#c) */
  canvas.overlay3d {
    position: absolute;
    inset: 0;
    pointer-events: none !important;
    z-index: 30 !important;
  }
</style>
</head>
<body>
  <div id="ui">
    <div><strong>Space Survivors — gwiazdy na całej mapie + duży silnik plazmowy</strong></div>
    <div class="stat">Czas gry: <span id="game-time">00:00</span></div>
    <div class="stat">W — ciąg (duży silnik plazmowy) · Q/E — strafe · A/D — obrót</div>
    <div class="stat">LPM — rail (A→B, A→B) · PPM — boczne rakiety · F — superbroń · SHIFT — warp · SPACJA — dopalacz</div>
    <div style="margin-top:6px"><small>Gwiazdy są proceduralne w całej galaktyce. Silnik: niebieski exhaust + krótki ślad przy ruchu.</small></div>
  </div>
<div id="game-root">
  <canvas id="c"></canvas>
</div>
<div id="loading">Ładowanie...</div>
<div id="mechanic-overlay" class="station-overlay hidden">
  <h3>Station Mechanic</h3>
  <ul>
    <li data-tab="mechanic">Mechanic</li>
  </ul>
  <div id="tab-mechanic" class="station-tab hidden">
    <div class="mechanic-toolbar">
      <label>Ship frame:</label>
      <select id="ship-frame-select"></select>
    </div>
    <div id="hp-groups" class="hp-groups"></div>
  </div>
</div>
<div id="hover-info" class="hover-info hidden">
  <div class="hover-title"></div>
  <span class="hover-subtitle"></span>
  <div class="hover-content"></div>
</div>
<script type="importmap">
{
  "imports": {
    "three": "./node_modules/three/build/three.module.js",
    "three/addons/": "./node_modules/three/examples/jsm/"
  }
}
</script>
<script type="module">
  import * as THREE from "three";
  import { EffectComposer }  from "three/addons/postprocessing/EffectComposer.js";
  import { RenderPass }      from "three/addons/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
  import { ShaderPass }      from "three/addons/postprocessing/ShaderPass.js";
  import { OutputPass }      from "three/addons/postprocessing/OutputPass.js";
  import { CopyShader }      from "three/addons/shaders/CopyShader.js";
  import { createShortNeedleExhaust, createWarpExhaustBlue } from "./Engineeffects.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { initWorld3D, attachPirateStation3D, dettachPirateStation3D, updateWorld3D, drawWorld3D } from "./src/3d/world3d.js";
  import { initStations3D, updateStations3D, detachPlanetStations3D, drawStations3D } from "./src/3d/stations3D.js";
  import { initOverlay } from "./src/effects3d/overlay.js";
  import { createRailgunExplosionFactory } from "./src/effects3d/railgunExplosion.js";
  import { createArmataImpactFactory } from "./src/effects3d/armataImpact.js";
  window.THREE = THREE;
  window.EffectComposer  = EffectComposer;
  window.RenderPass      = RenderPass;
  window.UnrealBloomPass = UnrealBloomPass;
  window.ShaderPass      = ShaderPass;
  window.OutputPass      = OutputPass;
  window.createShortNeedleExhaust = createShortNeedleExhaust;
  window.createWarpExhaustBlue = createWarpExhaustBlue;
  window.GLTFLoader = GLTFLoader;
  window.initWorld3D = initWorld3D;
  window.attachPirateStation3D = attachPirateStation3D;
  window.dettachPirateStation3D = dettachPirateStation3D;
  window.updateWorld3D = updateWorld3D;
  window.drawWorld3D = drawWorld3D;
  window.initStations3D = initStations3D;
  window.updateStations3D = updateStations3D;
  window.drawStations3D = drawStations3D;
  window.detachPlanetStations3D = detachPlanetStations3D;
  window.initOverlay3D = initOverlay;
  window.createRailgunExplosionFactory = createRailgunExplosionFactory;
  window.createArmataImpactFactory = createArmataImpactFactory;
  // Nie modyfikujemy namespace'u modułu THREE (jest niemodyfikowalny).
  // Jeśli coś potrzebuje CopyShader globalnie, wystawiamy go przez window:
  window.CopyShader = CopyShader;

</script>
<!-- przełącznik: aktywuj assetowy renderer planet (klasyczny skrypt, aby globalne API było gotowe zanim ruszy pętla gry) -->
<script type="module" src="planet3d.assets.js"></script>

<script>
// =============== Canvas & utils ===============
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth, H = canvas.height = innerHeight;

let mainScene3D = null;
let planetScene3D = null;
let planetStationsReady = false;

function asThreeScene(candidate){
  if (!candidate) return null;
  if (candidate.isScene) return candidate;
  if (candidate.scene && candidate.scene.isScene) return candidate.scene;
  if (candidate.scene3D && candidate.scene3D.isScene) return candidate.scene3D;
  if (candidate.planetScene && candidate.planetScene.isScene) return candidate.planetScene;
  if (candidate.sceneObject && candidate.sceneObject.isScene) return candidate.sceneObject;
  return null;
}

function findPlanetScene3D(){
  const directCandidates = [
    mainScene3D,
    planetScene3D,
    window.planetsScene3D,
    window.planetsScene,
    window.planetScene3D,
    window.PlanetScene3D,
    window.PlanetsScene3D,
    window.planets3DScene,
    window.planets3D
  ];
  for (const candidate of directCandidates){
    const scene = asThreeScene(candidate);
    if (scene) return scene;
  }
  const lazyCandidates = [
    typeof window.getPlanetsScene3D === 'function' ? window.getPlanetsScene3D() : null,
    typeof window.getPlanetScene3D === 'function' ? window.getPlanetScene3D() : null
  ];
  for (const candidate of lazyCandidates){
    const scene = asThreeScene(candidate);
    if (scene) return scene;
  }
  return null;
}

function ensurePlanetStationsInit(stationsList){
  if (typeof window.initStations3D !== 'function') return false;
  if (!Array.isArray(stationsList)) return false;
  if (!planetStationsReady) {
    window.initStations3D(null, stationsList);
    planetStationsReady = true;
  }
  return planetStationsReady;
}

function detachPlanetStationsIfNeeded(){
  if (typeof window.detachPlanetStations3D === 'function'){
    window.detachPlanetStations3D(planetScene3D);
  }
  planetScene3D = null;
  planetStationsReady = false;
}

window.addEventListener('beforeunload', detachPlanetStationsIfNeeded);

// Dev flags/tuning (persisted via devtools where available)
window.DevFlags = Object.assign({
  showRuler: false,
  unlimitedWarp: false,
  showSunDir: false,
  use3DPirateStation: true,
  usePlanetStations3D: true
}, window.DevFlags || {});

const DEFAULT_PLANET_SCALE = 3;
const DEFAULT_STATION_SCALE = 6;

window.DevTuning = Object.assign({
  pirateStationScale: DEFAULT_STATION_SCALE
}, window.DevTuning || {});

const DevFlags = window.DevFlags;
const DevTuning = window.DevTuning;
const Dev = window.Dev = window.Dev || {};
if (typeof Dev.station3DScale === 'number' && Number.isFinite(Dev.station3DScale)) {
  DevTuning.pirateStationScale = Dev.station3DScale;
} else {
  Dev.station3DScale = DevTuning.pirateStationScale;
}

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const add = (a,b)=>({x:a.x+b.x,y:a.y+b.y});
const mul = (v,s)=>({x:v.x*s,y:v.y*s});
const len = v=>Math.hypot(v.x,v.y);
const norm = v=>{ const L=len(v); return L?{x:v.x/L,y:v.y/L}:{x:0,y:0}; };
const smoothstep01 = t=>{ const x = clamp(t, 0, 1); return x*x*(3 - 2*x); };
function rotate(local,a){ const c=Math.cos(a), s=Math.sin(a); return {x: local.x*c - local.y*s, y: local.x*s + local.y*c}; }
function rotateInv(world,a){ return rotate(world, -a); }
function muzzlePosFor(entity, dir, extra = 8){
  const rad = (entity.radius != null) ? entity.radius : (entity.r != null ? entity.r : 12);
  return { x: entity.x + dir.x * (rad + extra), y: entity.y + dir.y * (rad + extra) };
}

function isPirateStation(st){
  if (!st) return false;
  const name = typeof st.name === 'string' ? st.name.toLowerCase() : '';
  return st.isPirate || st.type === 'pirate' || st.style === 'pirate' || name.includes('pir');
}

function stationScaleFor(st){
  const globalScale = Number.isFinite(Dev.station3DScale) ? Dev.station3DScale : 1.0;
  const pirateScale = Number.isFinite(DevTuning.pirateStationScale) ? DevTuning.pirateStationScale : globalScale;
  return isPirateStation(st) ? pirateScale : globalScale;
}

// === HARDPOINTS: enums ===
const HP = {
  MAIN: 'main',
  MISSILE: 'missile',
  AUX: 'aux',
  HANGAR: 'hangar',
  SPECIAL: 'special'
};

// === definicje broni ===
const WEAPONS = {
  railgun_mk1:  { id:'railgun_mk1',  type:HP.MAIN,    name:'Railgun Mk I',  dps:40, energy:6,  ammo:null },
  railgun_mk2:  { id:'railgun_mk2',  type:HP.MAIN,    name:'Railgun Mk II', dps:60, energy:8,  ammo:null },
  armata_mk1:   { id:'armata_mk1',   type:HP.MAIN,    name:'Armata Siege Cannon', damage:220, cooldown:1.8, energy:14, ammo:null },
  missile_rack: { id:'missile_rack', type:HP.MISSILE, name:'Missile Rack',  dps:0,  energy:2,  ammo:20 },
  ciws_mk1:     { id:'ciws_mk1',     type:HP.AUX,     name:'CIWS Mk I',     dps:12, energy:2,  ammo:null },
  laser_pd_mk1: { id:'laser_pd_mk1', type:HP.AUX,     name:'Helios PD Laser', dps:18, energy:3,  ammo:null },
  fighter_bay:  { id:'fighter_bay',  type:HP.HANGAR,  name:'Fighter Bay',   dps:0,  energy:5,  ammo:null },
  super_f:      { id:'super_f',      type:HP.SPECIAL, name:'Super Weapon',  dps:300,energy:20, ammo:null },
};

// === definicje statków / ram ===
const SHIPS = {
  atlas: {
    id:'atlas', name:'Atlas-class',
    spec: { [HP.MAIN]:4, [HP.MISSILE]:8, [HP.AUX]:8, [HP.HANGAR]:4, [HP.SPECIAL]:1 },
    genHardpoints(bounds){
      const hp = [];
      const w = bounds.w, h = bounds.h;
      placeLine(hp, HP.MAIN,    4, {x:-w*0.25,y:-h*0.48}, {x:w*0.25,y:-h*0.48});
      placeLine(hp, HP.MISSILE, 4, {x:-w*0.48,y:-h*0.15}, {x:-w*0.48,y:h*0.15});
      placeLine(hp, HP.MISSILE, 4, {x:w*0.48, y:-h*0.15}, {x:w*0.48, y:h*0.15});
      placeLine(hp, HP.AUX,     4, {x:-w*0.35,y:-h*0.35}, {x:-w*0.35,y:h*0.35});
      placeLine(hp, HP.AUX,     4, {x:w*0.35, y:-h*0.35}, {x:w*0.35, y:h*0.35});
      placeLine(hp, HP.HANGAR,  2, {x:-w*0.20,y:h*0.48},  {x:w*0.20, y:h*0.48});
      placeLine(hp, HP.HANGAR,  2, {x:-w*0.20,y:h*0.40},  {x:w*0.20, y:h*0.40});
      hp.push({id:uid(), type:HP.SPECIAL, pos:{x:0,y:0,rot:0}, mount:null, ammo:null, maxAmmo:null});
      return hp;
    }
  },
  corvus: {
    id:'corvus', name:'Corvus-class',
    spec: { [HP.MAIN]:2, [HP.MISSILE]:12, [HP.AUX]:4, [HP.HANGAR]:2, [HP.SPECIAL]:1 },
    genHardpoints(bounds){
      const hp=[]; const w=bounds.w, h=bounds.h;
      placeLine(hp, HP.MAIN, 2, {x:-w*0.2,y:-h*0.5}, {x:w*0.2,y:-h*0.5});
      placeLine(hp, HP.MISSILE,6,{x:-w*0.5,y:-h*0.25},{x:-w*0.5,y:h*0.25});
      placeLine(hp, HP.MISSILE,6,{x:w*0.5,y:-h*0.25},{x:w*0.5,y:h*0.25});
      placeLine(hp, HP.AUX,4,{x:0,y:-h*0.2},{x:0,y:h*0.2});
      placeLine(hp, HP.HANGAR,2,{x:-w*0.15,y:h*0.5},{x:w*0.15,y:h*0.5});
      hp.push({id:uid(), type:HP.SPECIAL, pos:{x:0,y:0,rot:0}, mount:null, ammo:null, maxAmmo:null});
      return hp;
    }
  }
};

function placeLine(out, type, count, a, b){
  for (let i=0;i<count;i++){
    const t = count===1 ? 0.5 : (i/(count-1));
    out.push({ id:uid(), type, pos:{ x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t, rot:0 }, mount:null, ammo:null, maxAmmo:null });
  }
}
function uid(){ return 'hp_'+Math.random().toString(36).slice(2,9); }

const Game = window.Game || (window.Game={});
Game.player = Game.player || {};
const defaultInventory = ['railgun_mk1','railgun_mk2','armata_mk1','missile_rack','ciws_mk1','laser_pd_mk1','fighter_bay','super_f'];
const existingInventory = Game.player.inventory ? Array.from(Game.player.inventory) : [];
Game.player.inventory = new Set([...existingInventory, ...defaultInventory]);
Game.player.shipFrame = Game.player.shipFrame || 'atlas';
Game.player.hardpoints = Game.player.hardpoints || [];
Game.player.weapons = Game.player.weapons || {};
Game.player.spriteW = Game.player.spriteW || 260;
Game.player.spriteH = Game.player.spriteH || 520;

let rocketAmmo = 0;
let rocketAmmoMax = 0;

function setHardpointMount(hp, weaponId, opts={}){
  if(!hp) return;
  const weapon = weaponId ? WEAPONS[weaponId] : null;
  const inventory = Game.player?.inventory;
  if(!weapon || (inventory && weaponId && !inventory.has(weaponId)) || weapon.type !== hp.type){
    hp.mount = null;
    hp.ammo = null;
    hp.maxAmmo = null;
    return;
  }
  hp.mount = weaponId;
  const baseMax = weapon.ammo != null ? weapon.ammo : null;
  hp.maxAmmo = opts.hasOwnProperty('maxAmmo') ? opts.maxAmmo : baseMax;
  if(weapon.ammo != null){
    const desiredAmmo = opts.hasOwnProperty('ammo') ? opts.ammo : weapon.ammo;
    hp.ammo = Math.max(0, desiredAmmo);
  } else {
    hp.ammo = null;
  }
}

function rebuildHardpointsForFrame(){
  const frame = SHIPS[Game.player.shipFrame];
  if(!frame) return;
  const spriteSize = { w: Game.player.spriteW || 260, h: Game.player.spriteH || 520 };
  Game.player.hardpoints = frame.genHardpoints(spriteSize);
  autoMountDefaults();
  syncWeaponSystems();
}

function autoMountDefaults(){
  mountFirstFree(HP.MAIN, 'railgun_mk2', 4);
  mountFirstFree(HP.MISSILE, 'missile_rack', 8);
  mountFirstFree(HP.AUX, 'ciws_mk1', 8);
  mountFirstFree(HP.HANGAR, 'fighter_bay', 4);
  mountFirstFree(HP.SPECIAL, 'super_f', 1);
}

function mountFirstFree(type, weaponId, howMany){
  if(!Game.player.inventory.has(weaponId)) return;
  for (const hp of Game.player.hardpoints){
    if (howMany<=0) break;
    if (hp.type===type && !hp.mount){
      setHardpointMount(hp, weaponId);
      howMany--;
    }
  }
}

function syncWeaponSystems(){
  const byType = {};
  for (const type of Object.values(HP)) byType[type] = [];
  for (const hp of Game.player.hardpoints){
    if (!hp.mount) continue;
    const weapon = WEAPONS[hp.mount];
    if(weapon) byType[hp.type].push({ hp, weapon });
  }
  Game.player.weapons = byType;
  rocketAmmoMax = missileAmmoCapacity();
  rocketAmmo = missileAmmoTotal();
  updateMainWeaponBehavior();
}

function getMainWeaponBehaviorForWeaponId(id){
  if(!id) return MAIN_WEAPON_BEHAVIOR.default;
  return MAIN_WEAPON_BEHAVIOR[id] || MAIN_WEAPON_BEHAVIOR.default;
}

function updateMainWeaponBehavior(){
  const mainWeapons = Game.player.weapons?.[HP.MAIN] || [];
  let behavior = MAIN_WEAPON_BEHAVIOR.default;
  if(mainWeapons.length){
    for(const loadout of mainWeapons){
      const id = loadout?.weapon?.id;
      const candidate = getMainWeaponBehaviorForWeaponId(id);
      if(!candidate) continue;
      if((candidate.cooldown ?? 0) > (behavior.cooldown ?? 0)){
        behavior = candidate;
      }
    }
  }
  rail.behaviorId = behavior.id || 'default';
  rail.cdMax = behavior.cooldown ?? MAIN_WEAPON_BEHAVIOR.default.cooldown;
  rail.shotGap = behavior.shotGap ?? MAIN_WEAPON_BEHAVIOR.default.shotGap;
  rail.burstGap = behavior.burstGap ?? MAIN_WEAPON_BEHAVIOR.default.burstGap;
  rail.burstsPerClick = behavior.burstsPerClick ?? MAIN_WEAPON_BEHAVIOR.default.burstsPerClick;
  rail.barrelsPerShot = behavior.barrelsPerShot ?? MAIN_WEAPON_BEHAVIOR.default.barrelsPerShot;
}

function missileAmmoTotal(){
  let total = 0;
  for (const hp of Game.player.hardpoints){
    if(hp.type===HP.MISSILE && hp.mount){
      if(typeof hp.ammo === 'number') total += hp.ammo;
    }
  }
  return total;
}

function missileAmmoCapacity(){
  let total = 0;
  for (const hp of Game.player.hardpoints){
    if(hp.type===HP.MISSILE && hp.mount){
      if(typeof hp.maxAmmo === 'number') total += hp.maxAmmo;
    }
  }
  return total;
}

function tryPreserveMounts(previous){
  if(!previous) return;
  const byType = new Map();
  for (const hp of previous){
    if(!hp.mount) continue;
    const entry = { weaponId: hp.mount, ammo: hp.ammo, maxAmmo: hp.maxAmmo };
    if(!byType.has(hp.type)) byType.set(hp.type, []);
    byType.get(hp.type).push(entry);
  }
  for (const hp of Game.player.hardpoints){
    const arr = byType.get(hp.type);
    if(arr && arr.length){
      const entry = arr.shift();
      setHardpointMount(hp, entry.weaponId, { ammo: entry.ammo, maxAmmo: entry.maxAmmo });
    }
  }
}

function saveLoadout(){
  try{
    localStorage.setItem('loadout', JSON.stringify({
      shipFrame: Game.player.shipFrame,
      hardpoints: Game.player.hardpoints.map(h=>({ id:h.id, type:h.type, mount:h.mount, ammo:h.ammo, maxAmmo:h.maxAmmo }))
    }));
  }catch(e){ console.warn('Loadout save error', e); }
}

function loadLoadout(){
  const raw = localStorage.getItem('loadout');
  if(!raw){ syncWeaponSystems(); return; }
  try{
    const data = JSON.parse(raw);
    if(data.shipFrame && SHIPS[data.shipFrame]){
      Game.player.shipFrame = data.shipFrame;
    }
    const frame = SHIPS[Game.player.shipFrame];
    if(frame){
      const spriteSize = { w: Game.player.spriteW || 260, h: Game.player.spriteH || 520 };
      const fresh = frame.genHardpoints(spriteSize);
      const savedByType = new Map();
      for(const saved of (data.hardpoints||[])){
        if(!saved.mount) continue;
        if(!savedByType.has(saved.type)) savedByType.set(saved.type, []);
        savedByType.get(saved.type).push(saved);
      }
      for(const hp of fresh){
        const arr = savedByType.get(hp.type);
        if(arr && arr.length){
          const saved = arr.shift();
          setHardpointMount(hp, saved.mount, { ammo: saved.ammo, maxAmmo: saved.maxAmmo });
        }
      }
      Game.player.hardpoints = fresh;
    }
  }catch(e){
    console.warn('Loadout parse error', e);
  }
  syncWeaponSystems();
  if(typeof renderMechanic === 'function') renderMechanic();
}

window.addEventListener('beforeunload', saveLoadout);

function drawHardpointGizmos(ctx, worldPos){
  if(!window.DEBUG_DRAW_HARDPOINTS) return;
  ctx.save();
  const screenX = (worldPos.x - ship.pos.x) * camera.zoom + W/2;
  const screenY = (worldPos.y - ship.pos.y) * camera.zoom + H/2;
  ctx.translate(screenX, screenY);
  for (const h of Game.player.hardpoints){
    ctx.beginPath();
    ctx.arc(h.pos.x*camera.zoom, h.pos.y*camera.zoom, 6, 0, Math.PI*2);
    ctx.strokeStyle = ({main:'#3b82f6', missile:'#10b981', aux:'#f59e0b', hangar:'#a78bfa', special:'#ef4444'})[h.type] || '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  ctx.restore();
}

// =============== Floating HUD state ===============
const HUD_SHOW_LEGACY = false; // stary HUD w lewym dolnym rogu – zostaw false

const HUD = {
  dmg: [],       // popupy obrażeń: {x,y,txt,color,vy,life,max}
  navArrows: [], // niebieskie strzałki po X: {x,y,age,life}
};

function hudSpawnDMG(x,y,amount,kind='npc'){
  const color = (kind==='player') ? '#f87171' : '#a7f3d0';
  HUD.dmg.push({ x, y, txt: Math.round(amount), color, vy: -14, life: 1.15, max: 1.15 });
}
function hudUpdateDMG(dt){
  for(const d of HUD.dmg){ d.y += d.vy*dt; d.life -= dt; }
  HUD.dmg = HUD.dmg.filter(d=>d.life>0);
}
function hudRenderDMG(cam){
  ctx.save();
  ctx.font = 'bold 13px system-ui,monospace';
  ctx.textAlign = 'center';
  for(const d of HUD.dmg){
    const s = worldToScreen(d.x, d.y, cam);
    ctx.globalAlpha = Math.max(0, d.life/d.max);
    ctx.fillStyle = d.color;
    ctx.fillText(d.txt, s.x, s.y);
  }
  ctx.restore();
}

function hudPingNpcStations(){
  // Niebieskie strzałki do stacji nie-misyjnych; gasną po 4s
  const targets = stations.filter(s=>!s.mission).slice(0, 8);
  HUD.navArrows = targets.map(s=>({ x:s.x, y:s.y, age:0, life:4.0 }));
}
function hudUpdateNav(dt){
  for(const p of HUD.navArrows) p.age += dt;
  HUD.navArrows = HUD.navArrows.filter(p=>p.age < p.life);
}

function drawArrowOnRing(cx, cy, R, ang, size, color){
  const x = cx + Math.cos(ang)*R, y = cy + Math.sin(ang)*R;
  ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(size, 0);
  ctx.lineTo(-size*0.6, size*0.6);
  ctx.lineTo(-size*0.2, 0);
  ctx.lineTo(-size*0.6, -size*0.6);
  ctx.closePath(); ctx.fill();
  ctx.restore();
}
function hudRenderNav(ship, cam){
  if(!HUD.navArrows.length) return;
  const s = worldToScreen(ship.pos.x, ship.pos.y, cam);
  const R = Math.max(ship.w, ship.h) * camera.zoom * 0.6 + 30;
  for(const p of HUD.navArrows){
    const ang = Math.atan2(p.y - ship.pos.y, p.x - ship.pos.x);
    const a = Math.max(0, 1 - p.age/p.life);
    ctx.save(); ctx.globalAlpha = 0.3 + 0.7*a;
    drawArrowOnRing(s.x, s.y, R, ang, 12, '#60a5fa');
    ctx.restore();
  }
}

function hudRenderFloatingBars(ship, cam){
  const center = worldToScreen(ship.pos.x, ship.pos.y, cam);
  const cx = center.x, cy = center.y;
  const R0 = Math.max(ship.w, ship.h) * camera.zoom * 0.8 + 32;

  // BOOST – pokazuj jako poziom paliwa dopalacza
  const boostFuelRatio = clamp(boost.fuel / boost.fuelMax, 0, 1);
  if (boostFuelRatio < 1 || (boost.state === 'active' && boost.fuel > 0)){
    ctx.save();
    ctx.strokeStyle = 'rgba(41,52,65,0.9)'; ctx.lineWidth = 8;
    ctx.beginPath(); ctx.arc(cx, cy, R0, -Math.PI/2, -Math.PI/2 + Math.PI*1.1); ctx.stroke();
    ctx.strokeStyle = '#60a5fa';
    ctx.beginPath(); ctx.arc(cx, cy, R0, -Math.PI/2, -Math.PI/2 + Math.PI*1.1*boostFuelRatio); ctx.stroke();
    ctx.fillStyle = '#bcd7ff'; ctx.font = '12px system-ui,monospace'; ctx.textAlign = 'center';
    ctx.fillText('BOOST', cx, cy - R0 - 10);
    ctx.restore();
  }

  // WARP – pokazuj przy charge/active
  if (warp.state === 'charging' || warp.state === 'active'){
    const t = (warp.state==='charging') ? Math.min(1, warp.charge/warp.chargeTime) : 1;
    const R1 = R0 + 16;
    ctx.save();
    ctx.strokeStyle = 'rgba(30,41,59,0.9)'; ctx.lineWidth = 8;
    ctx.beginPath(); ctx.arc(cx, cy, R1,  Math.PI/2,  Math.PI/2 - Math.PI*1.1, true); ctx.stroke();
    ctx.strokeStyle = '#7dd3fc';
    ctx.beginPath(); ctx.arc(cx, cy, R1,  Math.PI/2,  Math.PI/2 - Math.PI*1.1*t, true); ctx.stroke();
    ctx.fillStyle = '#d0f0ff'; ctx.font = '12px system-ui,monospace'; ctx.textAlign = 'center';
    ctx.fillText('WARP', cx, cy + R1 + 26);
    ctx.restore();
  }
}

// =============== Game time (1 min real = 1 h game) ===============
const TIME_SCALE = 60; // game seconds per real second
let gameTime = 0; // seconds
const gameTimeEl = document.getElementById('game-time');
function formatGameTime(sec){
  const t = Math.floor(sec);
  const h = Math.floor(t / 3600) % 24;
  const m = Math.floor((t % 3600) / 60);
  return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
}
function wrapAngle(a){ while(a>Math.PI) a-=2*Math.PI; while(a<-Math.PI) a+=2*Math.PI; return a; }
function interpAngleShort(prev,curr,t){ const d = wrapAngle(curr - prev); return wrapAngle(prev + d * t); }
function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function leadTarget(shooter, shooterVel, target, speed){
  const tx = target.x, ty = target.y;
  const tvx = target.vx || 0, tvy = target.vy || 0;
  const rx = tx - shooter.x, ry = ty - shooter.y;
  const rvx = tvx - shooterVel.x, rvy = tvy - shooterVel.y;
  const a = rvx*rvx + rvy*rvy - speed*speed;
  const b = 2*(rx*rvx + ry*rvy);
  const c = rx*rx + ry*ry;
  let t = 0;
  if(Math.abs(a) < 1e-6){
    if(Math.abs(b) > 1e-6) t = -c / b;
  } else {
    const disc = b*b - 4*a*c;
    if(disc >= 0){
      const sqrtDisc = Math.sqrt(disc);
      const t1 = (-b - sqrtDisc)/(2*a);
      const t2 = (-b + sqrtDisc)/(2*a);
      t = Math.min(t1, t2);
      if(t < 0) t = Math.max(t1, t2);
    }
  }
  if(!isFinite(t) || t < 0) t = 0;
  return { x: tx + tvx*t, y: ty + tvy*t };
}

// =============== World / camera ===============
const WORLD = { w: 240000, h: 160000 };
const camera = {
  zoom: 1.0,
  defaultZoom: 1.0,
  altZoom: 0.7,
  minZoom: 0.12,
  maxZoom: 3.2,
  wheelSpeed: 0.002,
  shakeMag: 0,
  shakeTime: 0,
  shakeDur: 0,
  addShake(mag, dur){ this.shakeMag = mag; this.shakeTime = dur; this.shakeDur = dur; }
};

// Model widoku overlayu (ortho nad światem 2D)
const overlayView = {
  center: { x: 0, y: 0 },
  viewport: { w: innerWidth, h: innerHeight },
  zoom: camera.zoom
};

// Bezpieczna, odroczona inicjalizacja overlayu 3D
let overlay3D = null;

window.addEventListener('resize', ()=>{
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  resizeOverlay3D();
  initStars(true);
});

function startOverlay3D() {
  const init = window.initOverlay3D;
  const railFactory = window.createRailgunExplosionFactory;
  const armataFactory = window.createArmataImpactFactory;
  const host = document.getElementById('game-root');

  // Musimy mieć: API z modułu + host z DOM + overlayView z tego skryptu
  if (!init || !railFactory || !host || typeof overlayView === 'undefined') return false;

  const ov = init({ host, getView: () => overlayView });
  overlay3D = ov;
  window.overlay3D = ov;
  window.makeRailgunExplosion = railFactory(ov.scene);
  if (armataFactory) {
    window.makeArmataImpact = armataFactory(ov.scene);
  }
  resizeOverlay3D();
  return true;
}

// Moduły <script type="module"> wykonują się po parsowaniu DOM, więc
// DOMContentLoaded zwykle wystarczy. Dla pewności dodajemy krótki polling.
window.addEventListener('DOMContentLoaded', () => {
  if (startOverlay3D()) return;
  let tries = 0;
  const maxTries = 120; // ~2 sekundy przy 60 FPS
  (function poll() {
    if (startOverlay3D() || tries++ > maxTries) return;
    requestAnimationFrame(poll);
  })();
});

// Helper do spawnu eksplozji 3D
function triggerRailgunExplosion3D(x, y, size = ship.h * 0.22){
  if (overlay3D && window.makeRailgunExplosion) {
    const fx = window.makeRailgunExplosion({ x, y, size });
    overlay3D.spawn(fx);
  }
}

function triggerArmataImpact3D(x, y, size = ship.h * 0.3){
  if (overlay3D && window.makeArmataImpact) {
    const fx = window.makeArmataImpact({ x, y, size });
    overlay3D.spawn(fx);
  }
}

// Resize: utrzymuj rozmiar overlayu = okna
function resizeOverlay3D(){
  overlayView.viewport.w = innerWidth;
  overlayView.viewport.h = innerHeight;
  if (overlay3D) overlay3D.resize();
}

resizeOverlay3D();

// =============== Ship ===============
const ship = {
  w:100, h:300, mass:140,
  pos:{x:WORLD.w/2, y:WORLD.h/2}, vel:{x:0,y:0},
  angle:0, angVel:0, inertia:null,
  linearDamping:0.9, angularDamping:1.6,
  engines:{},
  turret:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
           recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  turret2:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
            recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  turret3:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
            recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  turret4:{ angle:0, angVel:0, maxSpeed:1.8, maxAccel:8.0, damping:2.0,
            recoil:0, recoilMax:12, recoilRecover:48, recoilKick:14, offset:{x:0,y:0} },
  shield:{ max:15000, val:120, regenRate:100, regenDelay:2, regenTimer:0 },
  hull:{ max:10000, val:1000 },
  special:{ cooldown:10, cooldownTimer:0 },
  input:{ thrustX:0, thrustY:0, aimX:0, aimY:0 }
};
ship.inertia = (1/12) * ship.mass * ((ship.w*ship.w)+(ship.h*ship.h));
const SHIP_SPRITE_SCALE = 1.22;
const SHIP_VISUAL_BASE = {
  turretTop:    { x: 38.18587785469991, y: -52.448366304887465 },
  turretBottom: { x: 42.60145666564039, y:  43.668730035791256 },
  engineY: 119.44796580188681
};
overlayView.center.x = ship.pos.x;
overlayView.center.y = ship.pos.y;
(function configureShip(){
  const hw = ship.w/2, hh = ship.h/2;
  ship.visual = {
    spriteScale: SHIP_SPRITE_SCALE,
    turretTop: {
      x: SHIP_VISUAL_BASE.turretTop.x * SHIP_SPRITE_SCALE,
      y: SHIP_VISUAL_BASE.turretTop.y * SHIP_SPRITE_SCALE
    },
    turretBottom: {
      x: SHIP_VISUAL_BASE.turretBottom.x * SHIP_SPRITE_SCALE,
      y: SHIP_VISUAL_BASE.turretBottom.y * SHIP_SPRITE_SCALE
    },
    mainEngine: {
      x: 0,
      y: Math.round(SHIP_VISUAL_BASE.engineY * SHIP_SPRITE_SCALE)
    }
  };

  // Silniki — fizyczne offsety pozostają takie jak wcześniej
  ship.engines.main = {
    offset: { x: 0, y: Math.round(hh-8) },
    visualOffset: { x: 0, y: ship.visual.mainEngine.y },
    maxThrust: 12800
  };

  const sidePhysX = Math.round(hw-8);
  const sideVisualX = Math.round((hw-8) * ship.visual.spriteScale);
  ship.engines.sideLeft  =  { offset:{x:-sidePhysX, y: 0}, visualOffset:{x:-sideVisualX, y:0}, maxThrust:3000 };
  ship.engines.sideRight =  { offset:{x: sidePhysX, y: 0}, visualOffset:{x: sideVisualX, y:0}, maxThrust:3000 };

  const torquePhysY = Math.round(hh-8);
  const torqueVisualY = Math.round((hh-8) * ship.visual.spriteScale);
  ship.engines.torqueLeft  =  { offset:{x:0,y:-torquePhysY}, visualOffset:{x:0,y:-torqueVisualY}, maxThrust:3000 };
  ship.engines.torqueRight =  { offset:{x:0,y: torquePhysY}, visualOffset:{x:0,y: torqueVisualY}, maxThrust:3000 };

  ship.sideGunsLeft = []; ship.sideGunsRight = [];
  const gunsPer = 8, inset = 6 * ship.visual.spriteScale, margin = 12 * ship.visual.spriteScale;
  const visualHH = hh * ship.visual.spriteScale;
  const visualHW = hw * ship.visual.spriteScale;
  for(let i=0;i<gunsPer;i++){
    const t = gunsPer===1?0.5:(i/(gunsPer-1));
    const yLocal = -visualHH + margin + t * ((visualHH - margin) - (-visualHH + margin));
    ship.sideGunsLeft.push({ x: -Math.round(visualHW - inset), y: Math.round(yLocal) });
    ship.sideGunsRight.push({ x:  Math.round(visualHW - inset), y: Math.round(yLocal) });
  }

  const podW = Math.round(30 * ship.visual.spriteScale);
  const podH = Math.round(60 * ship.visual.spriteScale);
  const bottomTurret = ship.visual.turretBottom;
  const topTurret = ship.visual.turretTop;
  ship.pods = [
    { offset:{ x: -bottomTurret.x, y:  bottomTurret.y }, w: podW, h: podH },
    { offset:{ x:  bottomTurret.x, y:  bottomTurret.y }, w: podW, h: podH },
    { offset:{ x: -topTurret.x,    y:  topTurret.y },    w: podW, h: podH },
    { offset:{ x:  topTurret.x,    y:  topTurret.y },    w: podW, h: podH }
  ];
  ship.turret.offset  = { x: -bottomTurret.x, y:  bottomTurret.y };
  ship.turret2.offset = { x:  bottomTurret.x, y:  bottomTurret.y };
  ship.turret3.offset = { x: -topTurret.x,    y:  topTurret.y };
  ship.turret4.offset = { x:  topTurret.x,    y:  topTurret.y };

  const ciwsOff = 20 * ship.visual.spriteScale;
  ship.ciws = [
    { offset:{ x:-ciwsOff, y:-ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x:0,         y:-ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x: ciwsOff, y:-ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x:-ciwsOff, y:0 },        angle:0, angVel:0, cd:0 },
    { offset:{ x: ciwsOff, y:0 },        angle:0, angVel:0, cd:0 },
    { offset:{ x:-ciwsOff, y: ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x:0,         y: ciwsOff }, angle:0, angVel:0, cd:0 },
    { offset:{ x: ciwsOff, y: ciwsOff }, angle:0, angVel:0, cd:0 }
  ];
  ship.nextFighterPod = 0;
  ship.nextFighterOrbit = 0;
})();

// === Ship sprite ===
const USE_SHIP_SPRITE = true;
const shipSprite = new Image();
ship.spriteReady = false;
shipSprite.onload = () => {
  ship.spriteReady = true;
  ship.spriteW = shipSprite.naturalWidth;
  ship.spriteH = shipSprite.naturalHeight;
  Game.player.spriteW = ship.spriteW;
  Game.player.spriteH = ship.spriteH;
  const prev = Game.player.hardpoints.map(h=>({ type:h.type, mount:h.mount, ammo:h.ammo, maxAmmo:h.maxAmmo }));
  rebuildHardpointsForFrame();
  tryPreserveMounts(prev);
  syncWeaponSystems();
  if(typeof renderMechanic === 'function') renderMechanic();
  saveLoadout();
};
shipSprite.src = "assets/capital_ship_rect_v1.png"; // <- ścieżka do pliku

// =============== Proceduralne gwiazdy na CAŁEJ MAPIE ===============
// Generujemy je "na żądanie" w kafelkach 1024×1024 z deterministycznym seedem.
// Dzięki temu gwiazdy są wszędzie, ale pamięć i CPU trzymamy w ryzach.
const STAR_CELL = 1024;
const starCells = new Map(); // key "ix,iy" -> {stars:[...] , lastSeen: frameId}
let frameId = 0;

function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
function key(ix,iy){ return ix+','+iy; }

function generateCell(ix,iy){
  const seed = ((ix*73856093) ^ (iy*19349663) ^ 0x9e3779b9) >>> 0;
  const rnd = mulberry32(seed);
  const count = 14 + Math.floor(rnd()*10); // 14–23 gwiazdy na komórkę
  const stars = [];
  for(let i=0;i<count;i++){
    const x = ix*STAR_CELL + rnd()*STAR_CELL;
    const y = iy*STAR_CELL + rnd()*STAR_CELL;
    const size = 0.7 + rnd()*2.1;
    const bright = 0.35 + rnd()*0.65;
    stars.push({x,y,size,bright});
  }
  const obj = { stars, lastSeen: frameId };
  starCells.set(key(ix,iy), obj);
  return obj;
}
function getCell(ix,iy){
  const k = key(ix,iy);
  let c = starCells.get(k);
  if(!c) c = generateCell(ix,iy);
  c.lastSeen = frameId;
  return c;
}
function pruneStarCells(){
  // Trzymajmy ~ 600 ostatnio widzianych komórek (wystarczy z zapasem)
  if(starCells.size <= 600) return;
  // Proste LRU: wyrzucamy najstarsze
  const arr = Array.from(starCells.entries());
  arr.sort((a,b)=>a[1].lastSeen - b[1].lastSeen);
  const toDrop = arr.slice(0, Math.max(0, arr.length - 600));
  for(const [k] of toDrop) starCells.delete(k);
}
function initStars(reset=false){
  if(reset){ starCells.clear(); }
}

// =============== Słońce, planety i stacje ===============
const SUN = { x: WORLD.w/2, y: WORLD.h/2, r: 1000,
  color: {
    core:  '#ffe88a',   // jasno-żółty rdzeń
    mid:   '#ffbe3b',   // pomarańcz-żółć
    rim:   '#ff8c1a'    // ciepła krawędź tarczy
  },
  corona: {
    rays: 72,           // ile „igieł”
    jitter: 0.35,       // nieregularność
    length: 0.85,       // długość korony w promieniach R
    pulse: 0.22,        // amplituda pulsu
    haze:  2.8          // rozmiar miękkiej poświaty (×R)
  },
  seed: 93731
};
window.SUN = SUN;

// --- tryb: REALNY UKŁAD SŁONECZNY (domyślnie włączony) ---
const solarParams = new URLSearchParams(location.search);
const USE_SOLAR = solarParams.has('solar') ? solarParams.get('solar') !== '0' : true; // można też sterować paramem URL ?solar=1

function makeSolarPlanets(){
  // Skala: 1 AU ≈ 3000 jednostek świata (Neptun ~ 90k)
  const AU = 3000;
  window.BASE_ORBIT = AU;
  const MIN_SUN_GAP = 600;
  const MIN_PLANET_GAP = 800;
  const INNER_PLANET_COUNT = 4;
  const INNER_EXTRA_ORBIT = 600;
  const INNER_EXTRA_SUN_GAP = 600;
  const INNER_EXTRA_PLANET_GAP = 600;
  const rand = () => Math.random() * Math.PI * 2;
  const defs = [
    { id:'mercury', name:'mercury', baseR:  44, orbitAU: 0.39 },
    { id:'venus',   name:'venus',   baseR:  60, orbitAU: 0.72 },
    { id:'earth',   name:'earth',   baseR: 129, orbitAU: 1.00 },
    { id:'mars',    name:'mars',    baseR: 191, orbitAU: 1.52 },
    { id:'jupiter', name:'jupiter', baseR: 400, orbitAU: 5.20 },
    { id:'saturn',  name:'saturn',  baseR: 180, orbitAU: 9.58 },
    { id:'uranus',  name:'uranus',  baseR: 108, orbitAU:19.20 },
    { id:'neptune', name:'neptune', baseR: 104, orbitAU:30.00 },
    // { id:'pluto',   name:'pluto',   baseR:  30, orbitAU:39.50 },
  ];

  let minOrbitEdge = SUN.r;
  return defs.map((def, index) => {
    const effectiveR = def.baseR * DEFAULT_PLANET_SCALE;
    const baseOrbit = def.orbitAU * AU;
    const isInner = index < INNER_PLANET_COUNT;
    const extraOrbit = isInner ? INNER_EXTRA_ORBIT : 0;
    const sunGap = SUN.r + effectiveR + MIN_SUN_GAP + (isInner ? INNER_EXTRA_SUN_GAP : 0);
    const neighborGap = minOrbitEdge + effectiveR + MIN_PLANET_GAP + (isInner ? INNER_EXTRA_PLANET_GAP : 0);
    const orbitRadius = Math.max(
      baseOrbit + extraOrbit,
      sunGap,
      neighborGap
    );

    minOrbitEdge = orbitRadius + effectiveR;

    return {
      id: def.id,
      name: def.name,
      baseR: def.baseR,
      r: effectiveR,
      orbitRadius,
      angle: rand(),
      speed: 0
    };
  });
}

// jeśli kiedyś będziemy chcieli wrócić do starych zasad, zostawiamy helper:
function makeProceduralPlanets(){
  // stary kod może zostać, ale domyślnie nieużywany
  const PLANET_TYPES = {
    TERRAN: 'terran',
    VOLCANIC: 'volcanic',
    FROZEN: 'frozen',
    GAS: 'gas',
    BARREN: 'barren'
  };
  const NUM_PLANETS = 7;
  const TYPES = [
    PLANET_TYPES.VOLCANIC,
    PLANET_TYPES.VOLCANIC,
    PLANET_TYPES.TERRAN,
    PLANET_TYPES.TERRAN,
    PLANET_TYPES.BARREN,
    PLANET_TYPES.GAS,
    PLANET_TYPES.FROZEN
  ];
  const BASE_ORBIT = 7000;
  window.BASE_ORBIT = BASE_ORBIT;
  const list = [];
  for (let i = 0; i < NUM_PLANETS; i++) {
    const orbitRadius = BASE_ORBIT * (i + 1);
    const angle = Math.random() * Math.PI * 2;
    const au = i + 1;
    const periodHours = 24 * 365 * Math.pow(au, 1.5);
    const speed = (2 * Math.PI) / (periodHours * 3600);
    const r = (48 + Math.floor(Math.random() * 36)) * 3;
    list.push({ id: i, orbitRadius, angle, speed, r, type: TYPES[i], x: 0, y: 0 });
  }
  return list;
}

const PLANET_DATA = USE_SOLAR ? makeSolarPlanets() : makeProceduralPlanets();

function formatPlanetLabel(planet, index){
  if (typeof planet.label === 'string' && planet.label.trim().length) {
    return planet.label.trim();
  }
  const candidates = [];
  if (typeof planet.name === 'string') candidates.push(planet.name);
  if (typeof planet.id === 'string') candidates.push(planet.id);
  if (typeof planet.type === 'string') candidates.push(planet.type);

  for (const raw of candidates) {
    if (!raw) continue;
    const pretty = raw
      .replace(/[_-]+/g, ' ')
      .trim()
      .replace(/\b\w/g, ch => ch.toUpperCase());
    if (pretty) return pretty;
  }
  return `Planet ${index + 1}`;
}

// wylicz pozycje
let planets = PLANET_DATA.map((p, index) => {
  if (p.baseR == null) p.baseR = p.r;
  if (p.r == null && p.baseR != null) {
    p.r = p.baseR * DEFAULT_PLANET_SCALE;
  }
  p.x = SUN.x + Math.cos(p.angle) * p.orbitRadius;
  p.y = SUN.y + Math.sin(p.angle) * p.orbitRadius;
  p.label = formatPlanetLabel(p, index);
  return p;
});
window.planets = planets;

const ASTEROID_BELT = (() => {
  const innerPlanet = planets[3];
  const outerPlanet = planets[4];
  if (innerPlanet && outerPlanet && innerPlanet.orbitRadius && outerPlanet.orbitRadius) {
    const r1 = innerPlanet.orbitRadius;
    const r2 = outerPlanet.orbitRadius;
    const inner = r1 + 0.25 * (r2 - r1);
    const outer = r1 + 0.55 * (r2 - r1);
    return { inner, outer, mid: (inner + outer) / 2 };
  }
  return null;
})();

const STATION_STYLES = ['ringGate','hexHub','triRing','solarPetals','shipyard','tradeSpindle'];

let stations = planets.map(pl => {
  const orbitRadius = pl.r + 300;
  const angle = Math.random() * Math.PI * 2;
  const periodHours = 12; // stacja okrąża planetę w 12h
  const speed = (2 * Math.PI) / (periodHours * 3600);
  const x = pl.x + Math.cos(angle) * orbitRadius;
  const y = pl.y + Math.sin(angle) * orbitRadius;
  const r = 120;
  const portOffset = r + 40;
  const gateOffset = 220;
  const warpGate = { x: x + gateOffset, y, offset: { x: gateOffset, y: 0 } };
  const ports = [
    {x: portOffset, y: 0},
    {x: 0, y: portOffset},
    {x: -portOffset, y: 0},
    {x: 0, y: -portOffset}
  ];
  const style = STATION_STYLES[Math.floor(Math.random()*STATION_STYLES.length)];
  return {
    id: pl.id,
    planet: pl,
    orbitRadius,
    angle,
    speed,
    r,
    baseR: r,
    x,
    y,
    ports,
    style,
    warpGate
  };
});
window.stations = stations;
window.USE_STATION_3D = true;
if (window.__setStation3DScale) {
  window.__lastStationScale = 1;
  if (window.Dev && typeof Dev.station3DScale === 'number') {
    __setStation3DScale(Dev.station3DScale);
  }
}

// oznacz stacje wewnątrz pasa asteroid
(() => {
  if (ASTEROID_BELT) {
    const beltRadius = ASTEROID_BELT.mid;
    for (const st of stations) st.inner = st.orbitRadius < beltRadius;
  } else {
    for (const st of stations) st.inner = true;
  }
})();

// Warp routes between stations
let warpRoutes = {};
function initWarpRoutes(){
  warpRoutes = {};
  for(const from of stations){
    for(const to of stations){
      if(from.id === to.id) continue;
      if(from.inner !== to.inner) continue;
      const sx = from.warpGate?.x ?? from.x;
      const sy = from.warpGate?.y ?? from.y;
      const ex = to.warpGate?.x ?? to.x;
      const ey = to.warpGate?.y ?? to.y;
      const dx = ex - sx;
      const dy = ey - sy;
      const dist = Math.hypot(dx, dy) || 1;
      warpRoutes[from.id + '-' + to.id] = {
        from: from.id,
        to: to.id,
        fromRef: from,
        toRef: to,
        start: { x: sx, y: sy, queues: [[], []] },
        end: { x: ex, y: ey },
        dir: { x: dx / dist, y: dy / dist },
        length: dist
      };
    }
  }
}
function getWarpRoute(fromId, toId){ return warpRoutes[fromId + '-' + toId]; }
initWarpRoutes();

let npcs = [];

function stationLaunchPose(station, idx){
  const dirs = [
    { x: 1, y: 0 },
    { x:-1, y: 0 },
    { x: 0, y: 1 },
    { x: 0, y:-1 }
  ];
  const dir = dirs[idx % dirs.length];
  const offset = (station.r || 40) + 50;
  const launchSpeed = 120;
  return {
    x: station.x + dir.x * offset,
    y: station.y + dir.y * offset,
    vx: dir.x * launchSpeed,
    vy: dir.y * launchSpeed
  };
}
const MISSION_NPCS = [];
let mercMission = null;
const missionCompleteBanner = {
  active: false,
  text: '',
  timer: 0,
  duration: 5,
  fadeIn: 0.75,
  fadeOut: 1.25,
  trigger(text){
    this.text = text;
    this.timer = 0;
    this.active = true;
  },
  update(dt){
    if(!this.active) return;
    this.timer += dt;
    if(this.timer >= this.duration){
      this.active = false;
      this.timer = 0;
    }
  },
  alpha(){
    if(!this.active) return 0;
    const { timer, duration, fadeIn, fadeOut } = this;
    if(timer < fadeIn){
      const t = clamp(timer / fadeIn, 0, 1);
      return 1 - Math.pow(1 - t, 3);
    }
    if(timer > duration - fadeOut){
      const t = clamp((duration - timer) / fadeOut, 0, 1);
      return t * t * t;
    }
    return 1;
  },
  progress(){
    if(!this.active) return 0;
    return clamp(this.timer / Math.max(0.0001, this.duration), 0, 1);
  }
};

// === Missions / Journal ===
const MISSIONS = {
  active: [],   // {id, title, type, stationId?, pos:{x,y}, status:'active'|'completed'}
  show: false
};

function spawnMissionFighter(pos){
  const n = makeNPCBase(pos, { hp: 120, accel: 90, maxSpeed: 540, turn: 4.0, radius: 22 });
  n.type = 'pirate';
  n.color = '#ff5533';
  n.isPirate = true;
  n.ai = function(dt){
    chaseEvadeAI(n, ship, { strafe:true });
  };
  n.mission = true;
  npcs.push(n);
}

function makeNPCBase(pos, stats){
  return {
    x: pos.x, y: pos.y,
    vx: 0, vy: 0,
    angle: 0,
    hp: stats.hp || 100,
    maxHp: stats.hp || 100,
    accel: stats.accel || 0,
    maxSpeed: stats.maxSpeed || 0,
    turn: stats.turn || 0,
    radius: stats.radius || 20,
    dead: false,
    ai: null,
    weapons: {}
  };
}

function makeRailgun(cfg){ return { ...cfg }; }
function makeRocketPod(cfg){ return { ...cfg }; }
function makeGatling(cfg){ return { ...cfg }; }
function useRailPair(){/* stub */}
function useRocketsPair(){/* stub */}
function useCIWSPair(){/* stub */}
function maybeFireRockets(){/* stub */}

function spawnInterceptor(pos){
  const n = makeNPCBase(pos, { hp: 160, accel: 90, maxSpeed: 540, turn: 4.0, radius: 22 });
  n.type = 'interceptor';
  n.ai = function(dt){
    chaseEvadeAI(n, ship, { strafe:true, dodgeRails:true, rocketBurst:false });
  };
  MISSION_NPCS.push(n);
}

function spawnDestroyer(pos){
  const n = makeNPCBase(pos, { hp: 1200, accel: 40, maxSpeed: 260, turn: 1.2, radius: 60 });
  n.type = 'destroyer';
  n.weapons = {
    railL: makeRailgun({ dmg: 85, cooldown: 0.85, spread: 0.004 }),
    railR: makeRailgun({ dmg: 85, cooldown: 0.85, spread: 0.004 }),
    rocketL: makeRocketPod({ salvo: 3, cooldown: 2.8 }),
    rocketR: makeRocketPod({ salvo: 3, cooldown: 2.8 })
  };
  n.ai = function(dt){
    battleshipAI(n, ship);
    useRailPair(n, ship);
    useRocketsPair(n, ship);
  };
  MISSION_NPCS.push(n);
}

function spawnFrigate(pos){
  const n = makeNPCBase(pos, { hp: 650, accel: 60, maxSpeed: 360, turn: 2.0, radius: 44 });
  n.type = 'frigate';
  armPirate(n, 'mid'); // AI i uzbrojenie jak w piratach
  MISSION_NPCS.push(n);
}

function spawnGunship(pos){
  const n = makeNPCBase(pos, { hp: 520, accel: 60, maxSpeed: 360, turn: 2.4, radius: 40 });
  n.type = 'gunship';
  n.weapons = {
    ciwsL: makeGatling({ dps: 65, heat: 0.3 }),
    ciwsR: makeGatling({ dps: 65, heat: 0.3 }),
    rockets: makeRocketPod({ salvo: 2, cooldown: 3.2 })
  };
  n.ai = function(dt){
    dogfightAI(n, ship);
    useCIWSPair(n, ship);
    maybeFireRockets(n, ship);
  };
  MISSION_NPCS.push(n);
}
const TRAFFIC_WEIGHTS = {
  mercury: { civilian: 0.02, convoy: 0.25 },
  venus:   { civilian: 0.03, convoy: 0.25 },
  earth:   { civilian: 1.80, convoy: 0.50 },
  mars:    { civilian: 1.60, convoy: 0.55 },
  default: { civilian: 0.40, convoy: 0.40 }
};

function trafficWeightFor(station, kind){
  const table = TRAFFIC_WEIGHTS[station.id] || TRAFFIC_WEIGHTS.default;
  if(kind === 'convoy') return table.convoy ?? TRAFFIC_WEIGHTS.default.convoy;
  if(kind === 'civilian') return table.civilian ?? TRAFFIC_WEIGHTS.default.civilian;
  if(kind && typeof table[kind] === 'number') return table[kind];
  return table.civilian ?? TRAFFIC_WEIGHTS.default.civilian;
}

function weightedPickStation(kind, scope){
  let pool;
  if(Array.isArray(scope)){
    pool = scope.slice();
  }else if(scope === 'inner' || scope === 'outer'){
    const match = scope === 'inner';
    pool = stations.filter(s => s.inner === match);
  }else if(typeof scope === 'boolean'){
    pool = stations.filter(s => s.inner === scope);
  }else{
    pool = stations.slice();
  }
  if(!pool.length) return null;
  let total = 0;
  const weighted = pool.map(st => {
    const w = Math.max(0, trafficWeightFor(st, kind));
    total += w;
    return { st, w };
  });
  if(total <= 0){
    return pool[Math.floor(Math.random()*pool.length)];
  }
  let r = Math.random() * total;
  for(const { st, w } of weighted){
    r -= w;
    if(r <= 0) return st;
  }
  return weighted[weighted.length - 1].st;
}

function preferEarthMarsRoute(stationId){
  return (stationId === 'earth' || stationId === 'mars') && Math.random() < 0.7;
}

function pickNextStation(startStationId, type){
  const start = stations.find(s=>s.id===startStationId) || stations[0];
  if(!start) return startStationId;
  if(preferEarthMarsRoute(start.id)){
    return start.id === 'earth' ? 'mars' : 'earth';
  }
  const isCivil = type && (type.startsWith('civilian') || type.startsWith('freighter'));
  const sameSphere = stations.filter(s => s.inner === start.inner && s.id !== start.id);
  const otherSphere = stations.filter(s => s.inner !== start.inner);
  let pool = sameSphere.length ? sameSphere : stations.filter(s => s.id !== start.id);
  if(isCivil && otherSphere.length && Math.random() < 0.35){
    pool = otherSphere;
  }
  let target = weightedPickStation(isCivil ? 'civilian' : null, pool);
  if(!target || target.id === start.id){
    const fallbackPool = pool.length ? pool : stations.filter(s => s.id !== start.id);
    if(fallbackPool.length){
      return fallbackPool[Math.floor(Math.random()*fallbackPool.length)].id;
    }
    return startStationId;
  }
  return target.id;
}
const NPC_TYPES = {
  'freighter-small':  { radius:10, speed:60, hp:100, color:'#8ab4d6', weapon:null },
  'freighter-medium': { radius:15, speed:55, hp:150, color:'#769cb8', weapon:null },
  'freighter-large':  { radius:25, speed:50, hp:200, color:'#5d829c', weapon:null },
  'freighter-capital':{ radius:48, speed:45, hp:400, color:'#45667d', weapon:null },
  'police':           { radius:24, speed:100, hp:200, color:'#44aaff', weapon:'railgun' },
  'civilian-small':   { radius:6, speed:100, hp:10, color:'#cccccc', weapon:null },
  'civilian-large':   { radius:12, speed:80, hp:50, color:'#bbbbbb', weapon:null },
  'guard':            { radius:20, speed:95, hp:100, color:'#ff9933', weapon:'gun' },
  'mercenary':        { radius:25, speed:95, hp:100, color:'#ff6633', weapon:'gun' }
};
function initNPCs(){
  npcs = [];
  let npcId = 0, groupCounter = 0;
  const desiredCount = 1000;
  const ESCORT_RADIUS = 80;
  function spawnNPC(type, start, targetId, group, opts = {}){
    if(npcs.length >= desiredCount) return null;
    const cfg = NPC_TYPES[type];
    const startPort = Math.floor(Math.random()*start.ports.length);
    const spawnPos = stationPortWorld(start, startPort);
    let x = spawnPos.x + (Math.random()-0.5)*10;
    let y = spawnPos.y + (Math.random()-0.5)*10;
    let vx = 0, vy = 0;
    if(opts.launch){
      const pose = stationLaunchPose(start, opts.launchIndex || 0);
      x = pose.x;
      y = pose.y;
      vx = pose.vx;
      vy = pose.vy;
    }
    const target = stations.find(s=>s.id===targetId);
    const dockPort = target ? Math.floor(Math.random()*target.ports.length) : 0;
    const route = (target && start.inner === target.inner) ? getWarpRoute(start.id, targetId) : null;
    const npc = { id:npcId++, type, group,
      x, y,
      vx, vy, angle:Math.random()*Math.PI*2,
      target: targetId, speed:cfg.speed, radius:cfg.radius,
      hp:cfg.hp, maxHp:cfg.hp, color:cfg.color, weapon:cfg.weapon,
      dead:false, respawnTimer:0, fade:1, docking:false, lastStation:start.id,
      leader:null, orbitAngle:0, orbitRadius:0,
      warpRoute: route,
      phase: route?'toGate':'direct',
      lane: route?Math.floor(Math.random()*2):0,
      dockPort };
    npcs.push(npc);
    return npc;
  }
  function spawnFreighterEscortGroup(fType, escortMin, escortMax, sphere){
    const cand = stations.filter(s=>s.inner === (sphere==='inner'));
    if (!cand.length) return;
    const start = weightedPickStation('convoy', cand);
    if(!start) return;
    const targetId = pickNextStation(start.id, fType);
    const group = groupCounter++;
    const launchBase = npcId;
    const leader = spawnNPC(fType, start, targetId, group, { launch: true, launchIndex: launchBase });
    if(!leader) return;
    const target = stations.find(s=>s.id===targetId);
    if(!target || start.inner !== target.inner) return;
    const escortCount = escortMin + Math.floor(Math.random()*(escortMax-escortMin+1));
    for(let i=0;i<escortCount;i++){
      const eType = Math.random()<0.5?'guard':'mercenary';
      const angle = (i / escortCount) * Math.PI * 2;
      const escort = spawnNPC(eType, start, targetId, group, { launch: true, launchIndex: launchBase + i + 1 });
      if(!escort) continue;
      escort.leader = leader.id;
      escort.orbitAngle = angle;
      escort.orbitRadius = leader.radius + ESCORT_RADIUS;
      escort.x = leader.x + Math.cos(angle) * escort.orbitRadius;
      escort.y = leader.y + Math.sin(angle) * escort.orbitRadius;
      escort.vx = 0;
      escort.vy = 0;
    }
  }
  function spawnCivilianGroup(min, max, sphere){
    const cand = stations.filter(s=>s.inner === (sphere==='inner'));
    if (!cand.length) return;
    const start = weightedPickStation('civilian', cand);
    if(!start) return;
    const targetId = pickNextStation(start.id, 'civilian-small');
    const group = groupCounter++;
    const launchBase = npcId;
    spawnNPC('freighter-small', start, targetId, group, { launch: true, launchIndex: launchBase });
    const count = min + Math.floor(Math.random()*(max-min+1));
    for(let i=0;i<count;i++){
      const type = Math.random()<0.5?'civilian-small':'civilian-large';
      spawnNPC(type, start, targetId, group, { launch: true, launchIndex: launchBase + i + 1 });
    }
  }
  function spawnPolicePatrol(min, max, sphere){
    const cand = stations.filter(s=>s.inner === (sphere==='inner'));
    if (!cand.length) return;
    const start = weightedPickStation(null, cand);
    if(!start) return;
    const targetId = pickNextStation(start.id, 'police');
    const group = groupCounter++;
    const count = min + Math.floor(Math.random()*(max-min+1));
    const launchBase = npcId;
    for(let i=0;i<count;i++){
      spawnNPC('police', start, targetId, group, { launch: true, launchIndex: launchBase + i });
    }
  }
  let attempts = 0;
  while(npcs.length < desiredCount && attempts < desiredCount * 10){
    attempts++;
    spawnFreighterEscortGroup('freighter-small',0,0,'inner');
    spawnFreighterEscortGroup('freighter-small',0,0,'outer');
    spawnFreighterEscortGroup('freighter-medium',0,0,'inner');
    spawnFreighterEscortGroup('freighter-medium',0,0,'outer');
    spawnFreighterEscortGroup('freighter-large',0,0,'inner');
    spawnFreighterEscortGroup('freighter-large',0,0,'outer');
    spawnFreighterEscortGroup('freighter-capital',0,0,'inner');
    spawnFreighterEscortGroup('freighter-capital',0,0,'outer');
    spawnCivilianGroup(1,2,'inner');
    spawnCivilianGroup(1,2,'outer');
    spawnCivilianGroup(1,2,'inner');
    spawnCivilianGroup(1,2,'outer');
    spawnPolicePatrol(1,2,'inner');
    spawnPolicePatrol(1,2,'outer');
  }
}
// Ensure Three.js modules are loaded before initializing 3D objects
window.addEventListener('DOMContentLoaded', () => {
  const planetInitResult = initPlanets3D(planets, SUN);
  const sceneFromInit = asThreeScene(planetInitResult);
  if (sceneFromInit) {
    planetScene3D = sceneFromInit;
  }
  // overlay main scene
  let overlayScene = null;
  if (typeof window.initWorld3D === 'function') {
    const res = initWorld3D();
    const candidate = asThreeScene(res?.scene || res);
    if (candidate) {
      mainScene3D = candidate;
      overlayScene = candidate;
    } else if (res?.scene) {
      mainScene3D = res.scene;
      overlayScene = res.scene;
    }
  }
  // stacje – własna warstwa 3D (ortho), bez world3D
  if (typeof window.initStations3D === 'function') {
    window.initStations3D(null, stations);
    planetScene3D = overlayScene;
    planetStationsReady = true;
  }
  if (!planetStationsReady && !ensurePlanetStationsInit(stations)) {
    let tries = 0;
    const maxTries = 240;
    (function poll(){
      if (ensurePlanetStationsInit(stations) || tries++ > maxTries) return;
      requestAnimationFrame(poll);
    })();
  }
});

// =============== Bullets & effects ===============
const bullets = [];
const particles = [];
const shockwaves = [];
const MAX_PARTICLES = 8000;          // twardy sufit (dobry balans)
const MAX_PARTICLES_DRAW = 4500;     // ile maks. rysujemy na ekranie

function pushParticleSafe(p){
  if (particles.length < MAX_PARTICLES) particles.push(p);
}

function spawnParticle(pos, vel, life, color, size, flash){
  pushParticleSafe({
    pos:{...pos}, vel:{...vel}, life, age:0,
    color: color||'#ffb677', size: size||2, flash: !!flash
  });
}
function spawnExplosionPlasma(x,y,scale=1){
  const count = Math.round(22 * scale);
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 120 + Math.random()*260 * scale;
    spawnParticle({x,y}, {x:Math.cos(a)*s, y:Math.sin(a)*s}, 0.45 + Math.random()*0.5, '#7CFF7C', 2 + Math.random()*3, true);
  }
}
function spawnRailHitEffect(x,y,scale=1){
  // Tylko 3D (skalowane parametrem efektu)
  triggerRailgunExplosion3D(x, y, ship.h * 0.22 * scale);
}

function spawnArmataHitEffect(x, y, scale = 1){
  triggerArmataImpact3D(x, y, ship.h * 0.3 * scale);
  const count = Math.round(28 * scale);
  for(let i=0;i<count;i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 200 + Math.random() * 280;
    const color = (Math.random() < 0.45) ? '#ffd2a0' : '#ff9f58';
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.22 + Math.random() * 0.18,
      color,
      2.2 + Math.random() * 2.6,
      true
    );
  }
  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.12, '#fff2d0', 7.5 * scale, true);
  spawnShockwave(x, y, { r: 14 * scale, maxR: 120 * scale, w: 3.2 * scale, maxLife: 0.42, color: 'rgba(255,170,90,' });
}

function spawnRailMuzzle(pos, dir, baseVel, scale = 1){
  spawnParticle({ x: pos.x, y: pos.y }, { x: 0, y: 0 }, 0.1, '#bfe7ff', 6 * scale, true);
  const angle = Math.atan2(dir.y, dir.x);
  for(let i = 0; i < 5; i++){
    const aa = angle + (Math.random() - 0.5) * 0.14;
    const speed = 220 + Math.random() * 60;
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 6 * scale, y: pos.y + Math.sin(aa) * 6 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.2, y: Math.sin(aa) * speed + baseVel.y * 0.2 },
      0.12,
      '#bfe7ff',
      1.6 * scale,
      true
    );
  }
}

function spawnArmataMuzzle(pos, dir, baseVel, scale = 1){
  const angle = Math.atan2(dir.y, dir.x);
  spawnParticle(
    { x: pos.x, y: pos.y },
    { x: dir.x * 160 + baseVel.x * 0.12, y: dir.y * 160 + baseVel.y * 0.12 },
    0.16,
    '#ffd6a0',
    9 * scale,
    true
  );
  for(let i = 0; i < 10; i++){
    const spread = (Math.random() - 0.5) * 0.38;
    const aa = angle + spread;
    const speed = 260 + Math.random() * 140;
    const size = 2.6 + Math.random() * 2.8;
    const life = 0.16 + Math.random() * 0.14;
    const color = (Math.random() < 0.5) ? '#ffbe7a' : '#ffcfa0';
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 8 * scale, y: pos.y + Math.sin(aa) * 8 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.18, y: Math.sin(aa) * speed + baseVel.y * 0.18 },
      life,
      color,
      size * scale,
      true
    );
  }
  for(let i = 0; i < 4; i++){
    const aa = angle + (Math.random() - 0.5) * 0.25;
    const speed = 120 + Math.random() * 60;
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 4 * scale, y: pos.y + Math.sin(aa) * 4 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.08, y: Math.sin(aa) * speed + baseVel.y * 0.08 },
      0.3 + Math.random() * 0.18,
      '#d76926',
      1.8 * scale,
      false
    );
  }
  spawnShockwave(pos.x, pos.y, { r: 10 * scale, maxR: 80 * scale, w: 2.6 * scale, maxLife: 0.3, color: 'rgba(255,170,90,' });
}
function spawnDefaultHit(x,y,scale=1){
  for(let i=0;i<14*scale;i++){
    const a = Math.random()*Math.PI*2;
    const s = 80 + Math.random()*160 * scale;
    spawnParticle({x,y}, {x:Math.cos(a)*s, y:Math.sin(a)*s}, 0.24 + Math.random()*0.36, '#ffb36b', 1 + Math.random()*2, true);
  }
  spawnParticle({x,y}, {x:0,y:0}, 0.08, '#ffffff', 4 * scale, true);
}

function spawnShockwave(x, y, opts = {}){
  shockwaves.push({
    x, y,
    r: opts.r || 20,
    maxR: opts.maxR || 800,
    w: opts.w || 8,
    life: 0,
    maxLife: opts.maxLife || 0.6,
    color: opts.color || 'rgba(180,200,255,'
  });
}

// =============== Station UI ===============
let stationUI = {
  open:false,
  tab:'upgrades',
  station:null,
  cursorOver:false,
  hoverId:null,
  x:(W-450)/2,
  y:(H-520)/2,
  w:450,
  h:520,
  dragging:false,
  dragDX:0,
  dragDY:0
};

const OPTIONS = {
  vfx: { colorTempK: 8000, bloomGain: 1.1 },
  audio: { master: 0.8, sfx: 1.0, music: 0.7 },
  controls: { mouseSensitivity: 1.0 } // bez odwracania osi
};
let OPTIONS_OPEN = false;

function stationUnderCursor(){
  const world = screenToWorld(mouse.x, mouse.y);
  for(const s of stations){
    const d = Math.hypot(world.x - s.x, world.y - s.y);
    if(d < (s.r||120)) return s;
  }
  return null;
}

function openStationUI(station){
  if(!station) return;
  stationUI.open = true;
  stationUI.station = station;
  stationUI.tab = 'upgrades';
  stationUI.x = (W - stationUI.w) / 2;
  stationUI.y = (H - stationUI.h) / 2;
  stationUI.dragging = false;
  mouse.left = false;
  mouse.right = false;
}

const hoverInfoState = {
  el: document.getElementById('hover-info'),
  title: document.querySelector('#hover-info .hover-title'),
  subtitle: document.querySelector('#hover-info .hover-subtitle'),
  content: document.querySelector('#hover-info .hover-content'),
  type: null,
  target: null
};

function toTitleCaseFromKey(value){
  return String(value || '')
    .split(/[-_\s]+/g)
    .filter(Boolean)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

function availableStationTabs(station){
  if (Array.isArray(station?.tabs) && station.tabs.length) {
    return station.tabs.map(toTitleCaseFromKey);
  }
  return ['Upgrades', 'Trade', 'Cantina', 'Hangar', 'Mechanic'];
}

function formatNpcName(npc){
  if(!npc) return '';
  if(typeof npc.name === 'string' && npc.name.trim()) return npc.name;
  if(typeof npc.callsign === 'string' && npc.callsign.trim()) return npc.callsign;
  if(npc.type) return toTitleCaseFromKey(npc.type);
  if(npc.id != null) return `Jednostka #${npc.id}`;
  return 'Jednostka';
}

function formatShieldValue(entity){
  const shield = entity?.shield;
  if(shield && typeof shield.val === 'number' && typeof shield.max === 'number'){
    return `${Math.max(0, Math.round(shield.val))}/${Math.max(0, Math.round(shield.max))}`;
  }
  return 'Brak';
}

function formatWeaponName(weapon){
  if(!weapon) return 'Brak';
  if(typeof weapon === 'string') return toTitleCaseFromKey(weapon);
  if(weapon.name) return toTitleCaseFromKey(weapon.name);
  return 'Brak';
}

function hideHoverInfo(){
  const { el, content } = hoverInfoState;
  if(!el) return;
  if(content) content.innerHTML = '';
  if(!el.classList.contains('hidden')) el.classList.add('hidden');
  hoverInfoState.type = null;
  hoverInfoState.target = null;
}

function updateHoverInfo(target, type){
  const { el, title, subtitle, content } = hoverInfoState;
  if(!el) return;
  if(!target || !type){
    hideHoverInfo();
    return;
  }
  hoverInfoState.type = type;
  hoverInfoState.target = target;
  el.classList.remove('hidden');
  if(content) content.innerHTML = '';

  if(type === 'station'){
    if(title) title.textContent = target.name || (target.id ? `Stacja ${String(target.id).toUpperCase()}` : 'Stacja');
    if(subtitle) subtitle.textContent = 'STACJA ORBITALNA';
    if(content){
      const section = document.createElement('div');
      section.className = 'hover-section';
      section.textContent = 'Zakładki';
      content.appendChild(section);

      const tags = document.createElement('div');
      tags.className = 'hover-tags';
      for(const tab of availableStationTabs(target)){
        const span = document.createElement('span');
        span.className = 'hover-tag';
        span.textContent = tab;
        tags.appendChild(span);
      }
      content.appendChild(tags);
    }
  } else if(type === 'npc'){
    if(title) title.textContent = formatNpcName(target);
    if(subtitle) subtitle.textContent = target.friendly ? 'SOJUSZNIK' : 'CELE NPC';
    if(content){
      const lines = [
        { label:'HP', value: `${Math.max(0, Math.round(target.hp ?? 0))}/${Math.max(0, Math.round(target.maxHp ?? target.hp ?? 0))}` },
        { label:'Tarcza', value: formatShieldValue(target) },
        { label:'Broń', value: formatWeaponName(target.weapon) }
      ];
      for(const line of lines){
        const row = document.createElement('div');
        row.className = 'hover-line';
        const strong = document.createElement('strong');
        strong.textContent = `${line.label}:`;
        const span = document.createElement('span');
        span.textContent = line.value;
        row.appendChild(strong);
        row.appendChild(span);
        content.appendChild(row);
      }
    }
  }
}

window.addEventListener('keydown', (e)=>{
  if(stationUI.open){
    if(e.code==='Escape'){ stationUI.open=false; stationUI.station=null; stationUI.dragging=false; }
    if(e.code==='Digit1') stationUI.tab='upgrades';
    if(e.code==='Digit2') stationUI.tab='trade';
    if(e.code==='Digit3') stationUI.tab='cantina';
    if(e.code==='Digit4') stationUI.tab='hangar';
    if(e.code==='Digit5') stationUI.tab='mechanic';
  }
});

window.addEventListener('keydown', (e)=>{
  if(e.code==='KeyO' && !stationUI.open){ OPTIONS_OPEN = !OPTIONS_OPEN; }
});

function renderStationUI(){
  if(!stationUI.open){
    setMechanicUIVisible(false);
    return;
  }
  setMechanicUIVisible(stationUI.tab==='mechanic');
  hudBeginPanel(stationUI.x, stationUI.y, stationUI.w, stationUI.h);
  hudTabs(['upgrades','trade','cantina','hangar','mechanic'], stationUI.tab);
  if(stationUI.tab==='upgrades') renderUpgradesTab();
  if(stationUI.tab==='trade')    renderTradeTab();
  if(stationUI.tab==='cantina')  renderCantinaTab();
  if(stationUI.tab==='hangar')   renderHangarTab();
  if(stationUI.tab==='mechanic') renderMechanicTab();
  hudEndPanel();
}

function setMechanicUIVisible(visible){
  const overlay = document.getElementById('mechanic-overlay');
  if(!overlay) return;
  const panel = document.getElementById('tab-mechanic');
  const tabBtn = overlay.querySelector('li[data-tab="mechanic"]');
  const active = !!visible;
  overlay.classList.toggle('hidden', !active);
  if(panel) panel.classList.toggle('hidden', !active);
  if(tabBtn) tabBtn.classList.toggle('active', active);
}

function renderMechanicTab(){
  uiTitle('Mechanic');
  uiText('Zarządzaj hardpointami i uzbrojeniem w panelu obok.');
}

function initMechanicUI(){
  const overlay = document.getElementById('mechanic-overlay');
  if(!overlay) return;
  const tabBtn = overlay.querySelector('li[data-tab="mechanic"]');
  if(tabBtn){
    tabBtn.addEventListener('click', ()=>{
      stationUI.open = true;
      stationUI.tab = 'mechanic';
      setMechanicUIVisible(true);
    });
  }
  const sel = document.getElementById('ship-frame-select');
  if(sel){
    sel.innerHTML = Object.values(SHIPS).map(s=>
      `<option value="${s.id}" ${Game.player.shipFrame===s.id?'selected':''}>${s.name}</option>`
    ).join('');
    sel.value = Game.player.shipFrame;
    sel.onchange = () => {
      Game.player.shipFrame = sel.value;
      const prev = Game.player.hardpoints.map(h=>({ type:h.type, mount:h.mount, ammo:h.ammo, maxAmmo:h.maxAmmo }));
      rebuildHardpointsForFrame();
      tryPreserveMounts(prev);
      syncWeaponSystems();
      renderMechanic();
      saveLoadout();
    };
  }
  renderMechanic();
  setMechanicUIVisible(false);
}

function renderMechanic(){
  const root = document.getElementById('hp-groups');
  if(!root) return;
  const groups = {
    [HP.MAIN]:    { title:'Broń główna', css:'hp-main' },
    [HP.MISSILE]: { title:'Rakiety', css:'hp-miss' },
    [HP.AUX]:     { title:'Broń dodatkowa', css:'hp-aux' },
    [HP.HANGAR]:  { title:'Hangary', css:'hp-hangar' },
    [HP.SPECIAL]: { title:'Broń specjalna', css:'hp-spec' },
  };
  const listByType = {};
  for (const t of Object.values(HP)) listByType[t] = [];
  for (const hp of Game.player.hardpoints) listByType[hp.type].push(hp);
  root.innerHTML = Object.entries(groups).map(([type, meta])=>{
    const slots = listByType[type];
    const items = slots.map((hp,idx)=>{
      const weaponName = hp.mount ? (WEAPONS[hp.mount]?.name || hp.mount) : '— empty —';
      return `<div class="hp-item">
        <span>#${idx+1} &nbsp; ${weaponName}</span>
        <button data-hp="${hp.id}">Change</button>
      </div>`;
    }).join('');
    const content = items || '<div class="hp-item"><span>Brak slotów</span></div>';
    return `<div class="hp-group ${meta.css}">
      <h4>${meta.title} (${slots.length})</h4>
      ${content}
    </div>`;
  }).join('');
  root.querySelectorAll('button[data-hp]').forEach(btn=>{
    btn.onclick = ()=> openWeaponPicker(btn.getAttribute('data-hp'));
  });
  const sel = document.getElementById('ship-frame-select');
  if(sel && sel.value !== Game.player.shipFrame){
    sel.value = Game.player.shipFrame;
  }
}

function openWeaponPicker(hpId){
  const hp = Game.player.hardpoints.find(h=>h.id===hpId);
  if(!hp) return;
  const available = Object.values(WEAPONS).filter(w=>w.type===hp.type && Game.player.inventory.has(w.id));
  if(!available.length){
    alert('Brak dostępnych broni dla tego slotu.');
    return;
  }
  const choice = prompt('Choose weapon:\n' + available.map((w,i)=>`${i+1}. ${w.name}`).join('\n'));
  if(choice === null) return;
  const idx = Number.parseInt(choice, 10) - 1;
  if(!Number.isInteger(idx) || idx < 0 || idx >= available.length) return;
  const weapon = available[idx];
  setHardpointMount(hp, weapon.id);
  if(weapon.ammo != null){ hp.ammo = weapon.ammo; hp.maxAmmo = weapon.ammo; }
  syncWeaponSystems();
  renderMechanic();
  saveLoadout();
}

// --- Zakładki ---
const PLAYER = { credits: 1200, cargo: {}, shipId: 'starter' };
const BLUEPRINTS = {
  upgrades: [
    { id:'rail_cooler', name:'Chłodzenie raila', cost:600, apply(){ rail.heatCap *= 1.25; rail.coolRate *= 1.15; } },
    { id:'boost_core',  name:'Wzmocniony boost', cost:700, apply(){
      boost.extraThrustMul *= 1.15;
      boost.consumeRate *= 0.9;
      boost.handlingMultiplier *= 1.05;
    } },
    { id:'agility',     name:'Zwrotność +',      cost:500, apply(){
      ship.angularDamping *= 0.9;
      ship.engines.torqueLeft.maxThrust  = Math.round(ship.engines.torqueLeft.maxThrust * 1.12);
      ship.engines.torqueRight.maxThrust = Math.round(ship.engines.torqueRight.maxThrust * 1.12);
    } },
  ],
  ships: [
    { id:'scout', name:'Scout', cost:2500, stats:{ hp:0.8, speed:1.3, cargo:0.6 } },
    { id:'frigate', name:'Fregata', cost:4200, stats:{ hp:1.6, speed:0.85, cargo:1.4 } },
  ],
};

function renderUpgradesTab(){
  uiTitle('Ulepszenia statku');
  for(const u of BLUEPRINTS.upgrades){
    if(uiRowButton(`${u.name} — ${u.cost} cr`, 'Kup')){
      if(PLAYER.credits>=u.cost){ PLAYER.credits-=u.cost; u.apply(); toast('Zainstalowano: '+u.name); }
      else toast('Za mało kredytów');
    }
  }
}
const MARKET = { // ceny przykładowe
  buy:{ ruda: 22, paliwo: 15, żywność: 8 },
  sell:{ ruda: 18, paliwo: 12, żywność: 6 }
};
function renderTradeTab(){
  uiTitle('Handel towarami');
  for(const [k,price] of Object.entries(MARKET.buy)){
    if(uiRowButton(`${k} — kup: ${price} cr`, 'Kup')){
      if(PLAYER.credits>=price){ PLAYER.credits-=price; PLAYER.cargo[k]=(PLAYER.cargo[k]||0)+1; }
    }
  }
  for(const [k,price] of Object.entries(MARKET.sell)){
    if(uiRowButton(`${k} — sprzedaj: ${price} cr`, 'Sprzedaj')){
      if((PLAYER.cargo[k]||0)>0){ PLAYER.cargo[k]-=1; PLAYER.credits+=price; }
    }
  }
}
function renderCantinaTab(){
  uiTitle('Kantyna');
  section('Misje najemnik');
  if(uiRowButton('Najemnik: piracka stacja', 'Przyjmij')){
    startMercenaryMission();
  }
  section('Misje żołnierz');
  if(uiRowButton('Wojna o terytorium (punkt kontrolny)', 'Dołącz')){
    startTerritoryWarMission();
  }
}
function renderHangarTab(){
  uiTitle('Hangar');

  const damageFrac = 1 - (ship.hull.val / ship.hull.max);
  const damagePct = Math.ceil(damageFrac * 100);
  const cost = Math.ceil(damageFrac * 600);

  if(uiRowButton(`Napraw kadłub (${damagePct}% uszk.)`, 'Napraw')){
    if(PLAYER.credits >= cost){
      PLAYER.credits -= cost;
      ship.hull.val = ship.hull.max;
      toast('Naprawiono kadłub.');
    } else {
      toast('Za mało kredytów');
    }
  }
  section('Nowe statki');
  for(const s of BLUEPRINTS.ships){
    if(uiRowButton(`${s.name} — ${s.cost} cr`, 'Kup')){
      if(PLAYER.credits>=s.cost){ PLAYER.credits-=s.cost; PLAYER.shipId=s.id; applyShipStats(s.stats); toast('Zakupiono: '+s.name); }
      else toast('Za mało kredytów');
    }
  }
}

initMechanicUI();
function startMercenaryMission(){
  if(mercMission) { toast('Misja już aktywna. Wciśnij J aby zobaczyć dziennik.'); return; }

  const beltRadius = ASTEROID_BELT
    ? ASTEROID_BELT.mid
    : (planets[3] && planets[4])
      ? (planets[3].orbitRadius + planets[4].orbitRadius) / 2
      : Math.max(12000, planets[planets.length - 1]?.orbitRadius || 0);
  const angle = Math.random() * Math.PI * 2;
  const x = SUN.x + Math.cos(angle) * beltRadius;
  const y = SUN.y + Math.sin(angle) * beltRadius;

  const r = 220;
  const portOffset = r + 60;
  const ports = [
    {x: portOffset, y: 0},
    {x: 0, y: portOffset},
    {x: -portOffset, y: 0},
    {x: 0, y: -portOffset}
  ];

  const station = {
    id: 'PIR',
    x, y, r,
    baseR: r,
    isPirate: true,
    hp: 10000, maxHp: 10000,
    static: true, mission: true,
    ports,
    style: STATION_STYLES[Math.floor(Math.random()*STATION_STYLES.length)],
    shield: {
      max: 9000,
      val: 9000,
      regenRate: 650,
      regenDelay: 4.5,
      regenTimer: 0
    },
    // --- UZBROJENIE ---
    weapons: {
      rails: Array.from({length:6}, (_,i)=>({
        offsetAngle: i * (Math.PI*2/6),
        cd: 0,
        cdMax: 1.0 + Math.random()*0.5
      })),
      rockets: [
        { offsetAngle:  Math.PI/3, cd:0, cdMax: 3.0 },
        { offsetAngle: -Math.PI/3, cd:0, cdMax: 3.0 }
      ]
    }
  };

  stations.push(station);
  if (typeof window.attachPirateStation3D === 'function') {
    if (!mainScene3D && typeof window.initWorld3D === 'function') {
      const res = initWorld3D();
      mainScene3D = res?.scene || mainScene3D;
    }
    window.attachPirateStation3D(mainScene3D, station);
  }
  mercMission = {
    station,
    npcsSpawned:false,
    // --- SWARM control ---
    swarm: {
      active:false,
      maxAlive: 200,     // <- zwiększony limit
      timer: 0,
      baseInterval: 1.0  // skraca się wraz z utratą HP stacji
    }
  };

  mercMission.guards = [];
  for (let i = 0; i < 6; i++)
    mercMission.guards.push( spawnStationGuard(station, 'interceptor', i * (Math.PI*2/6)) );
  for (let i = 0; i < 2; i++)
    mercMission.guards.push( spawnStationGuard(station, 'frigate', i * Math.PI) );

  // Zapis do dziennika + koordy do markera mapy
  const exists = MISSIONS.active.find(m => m.id === 'merc_pirate_station' && m.status === 'active');
  if(!exists){
    MISSIONS.active.push({
      id: 'merc_pirate_station',
      title: 'Najemnik: piracka stacja',
      type: 'mercenary',
      stationId: station.id,
      pos: { x, y },
      status: 'active'
    });
  }

  toast('Misja najemnik rozpoczęta. Wciśnij M aby otworzyć mapę — cel oznaczony X. Dziennik: J.');
}
function startTerritoryWarMission(){ toast('Dołączono do wojny terytorialnej'); }

function renderOptions(){
  if(!OPTIONS_OPEN) return;
  hudBeginPanel();
  uiTitle('Opcje');
  slider('VFX: temperatura (K)', 1000, 20000, 500, OPTIONS.vfx, 'colorTempK');
  slider('VFX: bloom', 0.2, 2.5, 0.05, OPTIONS.vfx, 'bloomGain');
  slider('Audio: master', 0, 1, 0.05, OPTIONS.audio, 'master');
  slider('Audio: SFX', 0, 1, 0.05, OPTIONS.audio, 'sfx');
  slider('Audio: muzyka', 0, 1, 0.05, OPTIONS.audio, 'music');
  slider('Mysz: czułość', 0.3, 2.0, 0.05, OPTIONS.controls, 'mouseSensitivity');
  // brak opcji odwrócenia osi zgodnie z prośbą
  hudEndPanel();
}

function renderMissionJournal(){
  if(!MISSIONS.show) return;
  const w = 420, h = 260;
  const x = (W - w)/2, y = 60;
  hudBeginPanel(x, y, w, h);
  uiTitle('Dziennik misji [J]');
  if(MISSIONS.active.length === 0){
    uiText('Brak przyjętych misji.');
  } else {
    for(const m of MISSIONS.active){
      const status = m.status === 'active' ? 'AKTYWNA' : 'ZAKOŃCZONA';
      uiText(`${m.title} — ${status}`);
    }
  }
  hudEndPanel();
}

function spawnLaserBeam(start, end, width, opts={}){
  pushParticleSafe({
    beam:true,
    start:{...start},
    end:{...end},
    width,
    age:0,
    life: (opts && opts.life != null) ? opts.life : 0.12,
    colorOuter: opts?.colorOuter,
    colorInner: opts?.colorInner,
    glowColor: opts?.glowColor,
    glowBlur: opts?.glowBlur,
    outerWidthMul: opts?.outerWidthMul,
    innerWidthMul: opts?.innerWidthMul,
    alpha: opts?.alpha,
    fadeWithLife: opts?.fadeWithLife
  });
}

// =============== Input ===============
const input = { main:0, leftSide:0, rightSide:0, torque:0 };
const keys = {};
let showMap = false;
let PAUSED = false;
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(e.code==='Space'){ e.preventDefault(); }
  if(e.code==='ShiftLeft' || e.code==='ShiftRight'){ e.preventDefault(); }
  const k = e.key.toLowerCase();
  keys[k] = true;
  if(k === 'm') showMap = !showMap;
  if(k === 'j') MISSIONS.show = !MISSIONS.show;
  if(e.key === ' '){
    e.preventDefault();
    if(boost.fuel>0){ boost.state='active'; }
  }
  if(k === 'x'){ triggerScanWave(); hudPingNpcStations(); }
  if (k === 'z') {
    if(!(Game.player.weapons?.[HP.HANGAR]?.length)) { toast('Brak dostępnych hangarów.'); return; }
    if (SQUAD.order === 'idle' || SQUAD.list.length === 0) {
      // start + ESKORTA
      SQUAD.list = [];
      for (let i = 0; i < FIGHTERS_PER_LAUNCH; i++) {
        const f = spawnFighter();
        f.formIndex = i;              // <- indeks w formacji
        SQUAD.list.push(f);
      }
      SQUAD.order = 'escort';
      SQUAD.targets = [];
      toast('Myśliwce: ESKORTA');
    } else if (SQUAD.order === 'escort') {
      SQUAD.targets = pickSquadTargets();
      SQUAD.order = 'attack';
      toast(SQUAD.targets.length ? 'Myśliwce: ATAK' : 'Myśliwce: ATAK (brak oznaczeń — wybiorą najbliższych)');
    } else if (SQUAD.order === 'attack') {
      SQUAD.order = 'return';
      toast('Myśliwce: POWRÓT');
    } else if (SQUAD.order === 'return') {
      SQUAD.order = 'escort';
      SQUAD.targets = [];
      toast('Myśliwce: ESKORTA');
    }
  }
  if(k === 'r'){
    if(highlightedEnemies.length){
      lockedTargets = highlightedEnemies.filter(n=>!n.dead)
        .sort((a,b)=>Math.hypot(a.x-ship.pos.x,a.y-ship.pos.y) - Math.hypot(b.x-ship.pos.x,b.y-ship.pos.y));
      highlightTimer = 0;
      highlightedEnemies = [];
    } else {
      lockedTarget = scan.scanned || null;
    }
  }
  updateInput();
});
window.addEventListener('keyup', e=>{
  const k = e.key.toLowerCase();
  keys[k] = false;
  if(e.key === ' ' && boost.state==='active'){ boost.state='idle'; }
  updateInput();
});
function updateInput(){
  input.main = keys['w']?1:0;
  input.leftSide  = keys['q']?1:0;
  input.rightSide = keys['e']?1:0;
  let torque = 0; if(keys['a']) torque -= 1; if(keys['d']) torque += 1; input.torque = torque;
  if(keys['f']) tryFireSpecial();
}

// targeting / scanning
const SCAN_RANGE = 10000;
const SCAN_VFX_SPEED = 4000;
const SCAN_ARROW_LIFE = 1.5;
const scan = { target:null, scanned:null, targetType:null };
let lockedTarget = null;
let lockedTargets = [];
let highlightedEnemies = [];
let highlightTimer = 0;
const HIGHLIGHT_TIME = 3;
const HIGHLIGHT_RANGE = 2000;
const radarPings = [];
const scanWaves = [];
const scanArrows = [];
const NPC_DESPAWN_RADIUS = 20000;
function spawnRadarPing(x,y){ radarPings.push({x,y,age:0,life:1}); }
function triggerScanWave(){
  const wave = {x:ship.pos.x,y:ship.pos.y,r:0,speed:SCAN_VFX_SPEED,max:SCAN_RANGE,hit:new Set()};
  scanWaves.push(wave);
  scanArrows.length = 0;
 // Merge of branches:
  // 1) codex/add-various-npc-types-and-groups → prefer enemies that have weapons
  // 2) main → only highlight those within HIGHLIGHT_RANGE
  const inRange = (n) => Math.hypot(n.x - ship.pos.x, n.y - ship.pos.y) <= HIGHLIGHT_RANGE;
  const armed = npcs.filter(n => !n.dead && n.weapon && inRange(n));
  highlightedEnemies = armed.length ? armed : npcs.filter(n => !n.dead && inRange(n));
  highlightTimer = HIGHLIGHT_TIME;
  for(const st of stations){
    const dist = Math.hypot(st.x - ship.pos.x, st.y - ship.pos.y);
    spawnRadarPing(st.x, st.y);
    if(dist <= SCAN_RANGE){
      scanArrows.push({target:st,age:0,life:SCAN_ARROW_LIFE});
      wave.hit.add(st);
    }
  }
}

const mouse = { x: W/2, y: H/2, left:false, right:false, click:false, overCanvas:false };
canvas.addEventListener('mousemove', e=>{
  mouse.x = e.clientX; mouse.y = e.clientY;
  mouse.overCanvas = true;
  if(stationUI.open && stationUI.dragging){
    stationUI.x = mouse.x - stationUI.dragDX;
    stationUI.y = mouse.y - stationUI.dragDY;
  }
});
canvas.addEventListener('mouseenter', ()=>{
  mouse.overCanvas = true;
});
canvas.addEventListener('mouseleave', ()=>{
  mouse.overCanvas = false;
  mouse.left = false;
  mouse.right = false;
  mouse.click = false;
  scan.target = null;
  scan.scanned = null;
  scan.targetType = null;
  hideHoverInfo();
});
canvas.addEventListener('mousedown', e=>{
  if(e.button===0){
    if(stationUI.open){
      const inX = mouse.x >= stationUI.x && mouse.x <= stationUI.x + stationUI.w;
      const inY = mouse.y >= stationUI.y && mouse.y <= stationUI.y + stationUI.h;
      if(inX && inY && mouse.y <= stationUI.y + 24){
        stationUI.dragging = true;
        stationUI.dragDX = mouse.x - stationUI.x;
        stationUI.dragDY = mouse.y - stationUI.y;
      }
      return;
    }
    mouse.left=true;
    if(scan.targetType === 'station' && mouse.overCanvas){
      return;
    }
    if(!stationUI.open && !warp.isBusy()) triggerRailVolley();
  }
  if(e.button===2){
    e.preventDefault();
    if(stationUI.open) return;
    mouse.right=true;
    if(!stationUI.open && !warp.isBusy()){
      const mouseWorld = { x: ship.pos.x + (mouse.x - W/2)/camera.zoom, y: ship.pos.y + (mouse.y - H/2)/camera.zoom };
      const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
      const side = (local.x >= 0) ? 'right' : 'left';
      fireRocket(side);
      rocketCooldown = ROCKET_FIRE_INTERVAL;
    }
  }
  if(e.button===1){ e.preventDefault(); camera.zoom = Math.abs(camera.zoom - camera.defaultZoom) < 0.03 ? camera.altZoom : camera.defaultZoom; }
});
canvas.addEventListener('mouseup', e=>{
  if(e.button===0){
    const wasDragging = stationUI.dragging;
    if(stationUI.dragging){
      stationUI.dragging=false;
    }
    if(stationUI.open){
      if(!wasDragging){
        mouse.click=true;
      }
      return;
    }
    mouse.left=false;
    if(!wasDragging){
      mouse.click=true;
    }
  }
  if(e.button===2){
    if(stationUI.open) return;
    mouse.right=false;
  }
});
canvas.addEventListener('contextmenu', e=>e.preventDefault());
canvas.addEventListener('wheel', e=>{
  if (stationUI.open) return;
  e.preventDefault();
  const f = 1 - e.deltaY * camera.wheelSpeed;
  camera.zoom = clamp(camera.zoom * f, camera.minZoom, camera.maxZoom);
}, {passive:false});

const GAMEPAD = { enabled:true, dead:0.15, last:{} };

function applyGamepad(){
  const pads = navigator.getGamepads?.() || [];
  const p = pads[0];
  if(!p) return;
  const ax = (v)=> (Math.abs(v)<GAMEPAD.dead?0:v);
  const lx = ax(p.axes[0]||0), ly = ax(p.axes[1]||0);
  const rx = ax(p.axes[2]||0), ry = ax(p.axes[3]||0);
  // ruch/rotacja
  ship.input.thrustX = lx;
  ship.input.thrustY = ly*-1; // bez odwracania osi (standard)
  ship.input.aimX = rx;
  ship.input.aimY = ry*-1;
  input.main = Math.max(0, ship.input.thrustY);
  input.torque = ship.input.thrustX;
  input.leftSide = 0;
  input.rightSide = 0;
  // przyciski
  const btn = (i)=>!!(p.buttons[i]&&p.buttons[i].pressed);
  if(btn(0)) triggerRailVolley();      // A / Cross
  if(btn(1)) fireRocket();             // B / Circle
  if(btn(2)){
    if(boost.fuel>0) boost.state='active';
  } else if(boost.state==='active' && !keys[' ']){
    boost.state='idle';
  }
  if(btn(3)) attemptWarp();            // Y / Triangle
  if(btn(9)) PAUSED = !PAUSED;         // START
}

// =============== Side rockets ===============
const ROCKET_FIRE_INTERVAL = 0.11;
let rocketCooldown = 0;
let nextRocketIndexLeft = 0, nextRocketIndexRight = 0;
const SIDE_BULLET_SPEED = 760, SIDE_BULLET_DAMAGE = 20;
const SIDE_PLASMA_EXPLODE_RADIUS = 48;
const SIDE_ROCKET_TURN_RATE = 6;
const SIDE_ROCKET_HOMING_DELAY = 0.25;
const SPECIAL_COOLDOWN = 10; ship.special.cooldownTimer = 0;
const SPECIAL_DAMAGE = 1500;

function consumeMissileAmmo(side){
  const entries = (Game.player.weapons?.[HP.MISSILE] || []).map(e=>e.hp);
  if(!entries.length) return false;
  const available = entries.filter(hp => hp.mount && (hp.ammo === null || hp.ammo > 0));
  if(!available.length) return false;
  let preferred = null;
  if(side === 'left'){
    preferred = available.find(hp => (hp.pos?.x || 0) <= 0);
  } else if(side === 'right'){
    preferred = available.find(hp => (hp.pos?.x || 0) >= 0);
  }
  const target = preferred || available[0];
  if(typeof target.ammo === 'number'){
    target.ammo = Math.max(0, target.ammo - 1);
  }
  rocketAmmo = missileAmmoTotal();
  saveLoadout();
  return true;
}

function fireRocket(side){
  if(!(Game.player.weapons?.[HP.MISSILE]?.length)) return;
  if(rocketAmmoMax > 0 && rocketAmmo <= 0) return;
  const guns = side === 'left' ? ship.sideGunsLeft : ship.sideGunsRight;
  const idx = side === 'left' ? nextRocketIndexLeft : nextRocketIndexRight;
  const gunOff = guns[idx % guns.length];
  const target = (lockedTarget && !lockedTarget.dead) ? lockedTarget : null;
  if(!consumeMissileAmmo(side)) return;
  fireSideGunAtOffset(gunOff, side, target);
  if(side === 'left') nextRocketIndexLeft = (idx + 1) % guns.length;
  else nextRocketIndexRight = (idx + 1) % guns.length;
}

function fireSideGunAtOffset(gunOff, side, target=null){
  const gunWorld = add(ship.pos, rotate(gunOff, ship.angle));
  const dl = side === 'left' ? -1 : 1;
  const dir = rotate({x:dl, y:0}, ship.angle);
  bullets.push({ x: gunWorld.x, y: gunWorld.y, px: gunWorld.x, py: gunWorld.y,
    vx: dir.x*SIDE_BULLET_SPEED + ship.vel.x, vy: dir.y*SIDE_BULLET_SPEED + ship.vel.y,
    life:2.4, r:5, owner:'player', damage:SIDE_BULLET_DAMAGE, penetration:0, type:'rocket',
    explodeRadius: SIDE_PLASMA_EXPLODE_RADIUS, homingDelay: SIDE_ROCKET_HOMING_DELAY, target,
    source: ship, spawnGrace: 0.08 });
  spawnParticle({x:gunWorld.x, y:gunWorld.y}, {x:dir.x*120 + ship.vel.x*0.1, y:dir.y*120 + ship.vel.y*0.1}, 0.14, '#b4ffb4', 3.2, true);
  for(let k=0;k<6;k++){
    const aa = Math.atan2(dir.y, dir.x) + (Math.random()-0.5)*0.9;
    spawnParticle({x:gunWorld.x + Math.cos(aa)*6, y:gunWorld.y + Math.sin(aa)*6}, {x:Math.cos(aa)*160, y:Math.sin(aa)*160}, 0.14 + Math.random()*0.06, '#a8ff9a', 1.1, true);
  }
}

// =============== Fighters ===============
const FIGHTER_ORBIT_RADIUS = 200;  // były zbyt blisko
const FIGHTER_ORBIT_SPEED = 1.8;
const FIGHTER_ATTACK_RANGE = 1000;
const FIGHTERS_PER_LAUNCH = 10;
const FIGHTER_ACCEL = 720;
const FIGHTER_MAX_SPEED = 1020;
const FIGHTER_TURN_RATE = 7.2;
const FIGHTER_DRAG_COEFF = 2.6;
const FIGHTER_ESCORT_POSITION_GAIN = 3.0;
const FIGHTER_ESCORT_FOLLOW_GAIN = 7.5;

// Bliska eskorta - lokalne offsety względem kadłuba (w pikselach)
const FIGHTER_FORMATION = [
  {x:-150, y:-120}, {x:150, y:-120},
  {x:-190, y:-70},  {x:190, y:-70},
  {x:-190, y:-10},  {x:190, y:-10},
  {x:-150, y: 60},  {x:150, y: 60},
  {x:-100, y:-180}, {x:100, y:-180}
];

function fighterAI(dt){
  // lekkie tłumienie
  const drag = Math.exp(-3 * dt);
  this.vx *= drag; this.vy *= drag;

  // helpery
  const limit = (e, vmax)=>{ const s = Math.hypot(e.vx, e.vy); if(s>vmax){ const k=vmax/s; e.vx*=k; e.vy*=k; } };
  const faceAndThrust = (tx, ty, accelMul=1.0)=>{
    const desired = Math.atan2(ty - this.y, tx - this.x);
    const current = Math.atan2(this.vy, this.vx);
    const diff = wrapAngle(desired - current);
    const turn = clamp(diff, -this.turn*dt, this.turn*dt);
    const ang = current + turn;
    this.vx += Math.cos(ang) * this.accel * accelMul * dt;
    this.vy += Math.sin(ang) * this.accel * accelMul * dt;
    // VFX silników
    for (const e of this.engines){
      const off = rotate(e, ang + Math.PI);
      spawnParticle({x:this.x + off.x, y:this.y + off.y},
                    {x:this.vx - Math.cos(ang)*80, y:this.vy - Math.sin(ang)*80},
                    0.10, this.friendly ? '#cfe7ff' : '#ffc9c0', 0.8);
    }
    return ang;
  };
  const canGunsFire = (target)=>{
    const dx = target.x - this.x, dy = target.y - this.y;
    const dist = Math.hypot(dx, dy);
    const facing = Math.atan2(this.vy, this.vx);
    const aim = Math.atan2(dy, dx);
    const align = Math.abs(wrapAngle(aim - facing));
    const closing = (this.vx*dx + this.vy*dy) > 0; // lecimy w stronę celu
    const MIN = 260, MAX = 820, ALIGN_OK = 0.28; // ~16°
    return (dist >= MIN && dist <= MAX && align < ALIGN_OK && closing);
  };

  // === POWRÓT DO STATKU (despawn) ===
  if (SQUAD.order === 'return'){
    // bardziej „miękka” nawigacja + większy promień dokowania
    const dx = ship.pos.x - this.x, dy = ship.pos.y - this.y;
    const d  = Math.hypot(dx, dy) || 1;
    const ang = faceAndThrust(ship.pos.x, ship.pos.y, 1.0);

    // dopasowanie prędkości kiedy blisko – silniejsze niż było
    if (d < 260){
      this.vx += (ship.vel.x - this.vx) * Math.min(1, 8*dt);
      this.vy += (ship.vel.y - this.vy) * Math.min(1, 8*dt);
    }
    limit(this, this.maxSpeed);

    // fallback timer: jak utkną — wymuś dokowanie
    this._retT = (this._retT||0) + dt;

    const DOCK_R = 70; // było ~40
    if (d < DOCK_R || (this._retT > 8 && d < 300)){
      this.dead = true;
      const i = SQUAD.list.indexOf(this);
      if (i !== -1) SQUAD.list.splice(i, 1);
      if (SQUAD.list.length === 0){
        SQUAD.order = 'idle';
        SQUAD.targets = [];
        toast('Myśliwce: ZADOKOWANE');
      }
    }
    return;
  }

  // === ATAK: nalot (ingress -> pass -> egress) ===
  if (SQUAD.order === 'attack'){
    // wybór celu (jak wcześniej)
    let target = null;
    if (SQUAD.targets.length){
      const idx = Math.max(0, SQUAD.list.indexOf(this));
      const t = SQUAD.targets[idx % SQUAD.targets.length];
      if (t && !t.dead) target = t;
    }
    if (!target){
      let best=null, bd=Infinity;
      for (const n of npcs){
        if (n.dead || n.friendly) continue;
        const d = Math.hypot(n.x - this.x, n.y - this.y);
        if (d < bd){ bd = d; best = n; }
      }
      target = best;
    }
    if (!target){ SQUAD.order = 'escort'; return; }

    // inicjalizacja stanu „pass”
    if (!this._pass || this._pass.targetId !== target.id){
      this._pass = {
        phase: 'ingress',   // ingress | attack | egress
        t: 0,
        targetId: target.id,
        egressT: 0,
      };
      this.ciwsCd = 0; this.missileCd = 0; // bez natychmiastowego strzału
    }
    this._pass.t += dt;

    // metryki względem celu
    const dx = target.x - this.x, dy = target.y - this.y;
    const dist = Math.hypot(dx, dy) || 1;
    const lead = leadTarget({x:this.x,y:this.y},{x:this.vx||0,y:this.vy||0}, target, Math.max(300, this.maxSpeed*0.9));

    if (this._pass.phase === 'ingress'){
      // zbliż się do punktu wyprzedzenia, bez ognia
      faceAndThrust(lead.x, lead.y, 1.0);
      limit(this, this.maxSpeed);
      // warunki otwarcia ognia: w zasięgu + wyrównanie
      const facing = Math.atan2(this.vy, this.vx);
      const aim = Math.atan2(dy, dx);
      const align = Math.abs(wrapAngle(aim - facing));
      const APPROACH = 900, ALIGN_OK = 0.35;
      if (dist < APPROACH && align < ALIGN_OK){
        this._pass.phase = 'attack';
        this._pass.t = 0;
      }
      return;
    }

    if (this._pass.phase === 'attack'){
      // krótka prosta z ogniem (nalot)
      const ang = faceAndThrust(lead.x, lead.y, 1.0);
      limit(this, this.maxSpeed);

      // Strzelaj tylko w „oknie”
      if (canGunsFire(target)){
        this.ciwsCd = Math.max(0, this.ciwsCd - dt);
        this.missileCd = Math.max(0, this.missileCd - dt);
        const dir = {x:Math.cos(ang), y:Math.sin(ang)};
        if (this.ciwsCd === 0){
          bullets.push({
            x:this.x + dir.x*8, y:this.y + dir.y*8,
            vx: dir.x*CIWS_BULLET_SPEED + this.vx,
            vy: dir.y*CIWS_BULLET_SPEED + this.vy,
            life:1.2, r:2, owner:'player', damage:CIWS_DAMAGE, type:'ciws'
          });
          this.ciwsCd = CIWS_FIRE_INTERVAL;
        }
        if (this.missiles>0 && this.missileCd === 0){
          bullets.push({
            x:this.x + dir.x*8, y:this.y + dir.y*8,
            vx: dir.x*SIDE_BULLET_SPEED + this.vx,
            vy: dir.y*SIDE_BULLET_SPEED + this.vy,
            life:2.4, r:5, owner:'player', damage:SIDE_BULLET_DAMAGE,
            penetration:0, type:'rocket',
            explodeRadius: SIDE_PLASMA_EXPLODE_RADIUS,
            homingDelay: SIDE_ROCKET_HOMING_DELAY,
            target
          });
          this.missiles--; this.missileCd = 1.5;
        }
      }

      // warunki zakończenia przelotu
      const passed = (this.vx*dx + this.vy*dy) < 0; // minęliśmy cel
      if (this._pass.t > 1.6 || dist < 180 || passed){
        this._pass.phase = 'egress';
        this._pass.egressT = 0;
      }
      return;
    }

    if (this._pass.phase === 'egress'){
      // odejście po przelocie – odskocz od celu
      this._pass.egressT += dt;
      const awayX = this.x - dx, awayY = this.y - dy; // kierunek od celu
      faceAndThrust(awayX, awayY, 0.9);
      limit(this, this.maxSpeed);
      if (this._pass.egressT > 0.9){
        this._pass.phase = 'ingress';
        this._pass.t = 0;
      }
      return;
    }
  }

  // === ESKORTA (domyślnie) ===
  const local = FIGHTER_FORMATION[this.formIndex % FIGHTER_FORMATION.length] || {x:-140, y:-90};
  const off = rotate(local, ship.angle);
  const anchor = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };

  const to = { x: anchor.x - this.x, y: anchor.y - this.y };
  const desiredVel = { x: ship.vel.x + to.x * 2.2, y: ship.vel.y + to.y * 2.2 };
  const spd = Math.hypot(desiredVel.x, desiredVel.y);
  const vmax = this.maxSpeed * 0.95;
  if (spd > vmax){ const s = vmax/spd; desiredVel.x*=s; desiredVel.y*=s; }
  this.vx += (desiredVel.x - this.vx) * Math.min(1, 5.5*dt);
  this.vy += (desiredVel.y - this.vy) * Math.min(1, 5.5*dt);

  const ang = Math.atan2(this.vy, this.vx);
  for(const e of this.engines){
    const eo = rotate(e, ang + Math.PI);
    spawnParticle({x:this.x + eo.x, y:this.y + eo.y},
                  {x:this.vx - Math.cos(ang)*60, y:this.vy - Math.sin(ang)*60},
                  0.08, '#cfe7ff', 0.7);
  }
}
// === PIRATE AI (strzela jak myśliwce) + SPAWN SWARM ===
function armPirate(n, tier='light'){
  n.friendly = false;
  n.mission  = true;
  n.color    = '#ff5533';
  n.isPirate = true;
  n.ciwsCd   = 0;
  n.missileCd= 0;
  n.missiles = (tier==='heavy') ? 4 : (tier==='mid' ? 3 : 2);
  n.ai = function(dt){ pirateAI(n, dt); };
  return n;
}

function pirateAI(n, dt){
  const drag = Math.exp(-0.9 * dt);
  n.vx *= drag; n.vy *= drag;

  const st = mercMission && mercMission.station;
  const dShip = Math.hypot(ship.pos.x - n.x, ship.pos.y - n.y);
  const dSt   = st ? Math.hypot(st.x - n.x, st.y - n.y) : Infinity;
  const leashR = st ? (st.r + 3500) : 3500;

  let targetPos;
  if (st && dSt > leashR && dShip > 2000){
    targetPos = { x: st.x, y: st.y };
  } else {
    targetPos = leadTarget(
      {x:n.x, y:n.y},
      {x:n.vx||0, y:n.vy||0},
      {x:ship.pos.x, y:ship.pos.y, vx:ship.vel.x, vy:ship.vel.y},
      Math.max(300, n.maxSpeed*0.9)
    );
  }

  const desired = Math.atan2(targetPos.y - n.y, targetPos.x - n.x);
  const diff = wrapAngle(desired - n.angle);
  const turn = clamp(diff, -n.turn*dt, n.turn*dt);
  n.angle = wrapAngle(n.angle + turn);

  n.vx += Math.cos(n.angle) * n.accel * dt;
  n.vy += Math.sin(n.angle) * n.accel * dt;
  const side = (Math.random()<0.5?-1:1);
  const angS = n.angle + side * Math.PI/2;
  n.vx += Math.cos(angS) * n.accel * 0.008;
  n.vy += Math.sin(angS) * n.accel * 0.008;

  if (dShip < 280){ n.vx -= n.vx * 0.65 * dt; n.vy -= n.vy * 0.65 * dt; }

  limitSpeed(n, n.maxSpeed);

  const ang = Math.atan2(n.vy, n.vx);
  spawnParticle({x:n.x - Math.cos(ang)*6, y:n.y - Math.sin(ang)*6},
                {x:n.vx - Math.cos(ang)*80, y:n.vy - Math.sin(ang)*80},
                0.08, '#ffc9c0', 0.8);

  n.ciwsCd    = Math.max(0, n.ciwsCd - dt);
  n.missileCd = Math.max(0, n.missileCd - dt);

  const dir = {x:Math.cos(n.angle), y:Math.sin(n.angle)};

  if(n.ciwsCd===0 && dShip < 900){
    const m = muzzlePosFor(n, dir, 10);
    bullets.push({
      x:m.x, y:m.y,
      vx: dir.x*CIWS_BULLET_SPEED + (n.vx||0),
      vy: dir.y*CIWS_BULLET_SPEED + (n.vy||0),
      life:1.2, r:2, owner:'npc', damage:CIWS_DAMAGE, type:'ciws',
      source:n, spawnGrace:0.1
    });
    n.ciwsCd = CIWS_FIRE_INTERVAL;
  }

  if(n.missiles>0 && n.missileCd===0 && dShip < 1400){
    const m = muzzlePosFor(n, dir, 14);
    bullets.push({
      x:m.x, y:m.y, px:m.x, py:m.y,
      vx: dir.x*SIDE_BULLET_SPEED + (n.vx||0),
      vy: dir.y*SIDE_BULLET_SPEED + (n.vy||0),
      life:2.4, r:5, owner:'npc', damage:SIDE_BULLET_DAMAGE, penetration:0,
      type:'rocket', explodeRadius:SIDE_PLASMA_EXPLODE_RADIUS,
      homingDelay:SIDE_ROCKET_HOMING_DELAY,
      source:n, spawnGrace:0.12
    });
    n.missiles--; n.missileCd = 1.8;
  }
}

function guardAI(n, dt){
  const st = n.home;
  if(!st){ n.ai = (dt)=>pirateAI(n,dt); return; }

  const playerNear = Math.hypot(ship.pos.x - st.x, ship.pos.y - st.y) < 1600;
  const shieldDamaged = st.shield && st.shield.val < st.shield.max;
  const underAttack = (mercMission && mercMission.swarm && mercMission.swarm.active) || (st.hp < st.maxHp) || shieldDamaged;

  if(playerNear || underAttack){
    n.guard = false;
    n.ai = (dt)=>pirateAI(n, dt);
    return;
  }

  const w = 0.6; // rad/s
  n.orbitAngle = (n.orbitAngle + w*dt) % (Math.PI*2);
  const target = { x: st.x + Math.cos(n.orbitAngle)*n.orbitRadius,
                   y: st.y + Math.sin(n.orbitAngle)*n.orbitRadius };
  steerToward(n, target.x, target.y, dt, n.accel*0.8, n.turn*0.8);
  const drag = Math.exp(-0.8*dt);
  n.vx *= drag; n.vy *= drag;
}

function spawnStationGuard(st, kind, angle){
  const orbitR = st.r + 180;
  const pos = { x: st.x + Math.cos(angle)*orbitR, y: st.y + Math.sin(angle)*orbitR };
  const n = spawnPirate(kind, st);
  n.x = pos.x; n.y = pos.y; n.vx = 0; n.vy = 0;
  n.guard = true; n.home = st; n.orbitAngle = angle; n.orbitRadius = orbitR;
  n.ai = (dt)=>guardAI(n, dt);
  return n;
}

// uniwersalne spawnowanie pirata przy stacji (swarm)
function spawnPirate(kind, station){
  const a = Math.random()*Math.PI*2;
  const r = station.r + 32;
  const pos = { x: station.x + Math.cos(a)*r, y: station.y + Math.sin(a)*r };
  let n;
  if(kind==='interceptor'){
    n = makeNPCBase(pos, { hp: 160, accel: 110,  maxSpeed: 640, turn: 5.2, radius: 22 });
    armPirate(n, 'light');
  } else if(kind==='frigate'){
    // nowa fregata (mid)
    n = makeNPCBase(pos, { hp: 650, accel: 80,  maxSpeed: 430, turn: 2.6, radius: 44 });
    armPirate(n, 'mid');
  } else { // 'destroyer'
    n = makeNPCBase(pos, { hp: 1200, accel: 60, maxSpeed: 320, turn: 1.8, radius: 60 });
    armPirate(n, 'heavy');
  }
  n.type = kind;
  npcs.push(n);
  return n;
}

// === FIGHTER SQUAD STATE ===
const SQUAD = {
  order: 'idle',       // 'idle' | 'escort' | 'attack' | 'return'
  list: [],            // referencje do obiektów fighterów w npcs
  targets: [],         // wybrane cele przy rozkazie "attack"
};

function pickSquadTargets() {
  const aliveLocked = lockedTargets.filter(t => !t.dead);
  if (aliveLocked.length) return aliveLocked;
  if (lockedTarget && !lockedTarget.dead) return [lockedTarget];
  // fallback: brak oznaczeń → będzie wybór najbliższego w AI
  return [];
}

function spawnFighter(){
  const pod = ship.pods[ship.nextFighterPod % ship.pods.length];
  ship.nextFighterPod = (ship.nextFighterPod + 1) % ship.pods.length;
  const off = rotate(pod.offset, ship.angle);
  const orbit = ship.nextFighterOrbit;
  ship.nextFighterOrbit = (ship.nextFighterOrbit + Math.PI*2 / FIGHTERS_PER_LAUNCH) % (Math.PI*2);

  const f = {
    x: ship.pos.x + off.x,
    y: ship.pos.y + off.y,
    vx: ship.vel.x,
    vy: ship.vel.y,
    accel: FIGHTER_ACCEL,
    maxSpeed: FIGHTER_MAX_SPEED,
    turn: FIGHTER_TURN_RATE,
    radius:12, hp:40, maxHp:40, color:'#9edfff', fade:1,
    ai: fighterAI, mission:true, friendly:true,
    fighter: true,
    ciwsCd:0, missileCd:0, missiles:2,
    engines:[{x:-3,y:8},{x:3,y:8}],
    // orbita (fallback) — ciaśniej:
    orbitAngle: orbit,
    orbitRadius: FIGHTER_ORBIT_RADIUS,
    orbitSpeed: FIGHTER_ORBIT_SPEED,
    // formacja:
    formIndex: SQUAD.list.length || 0
  };
  npcs.push(f);
  return f; // ← ważne
}

// =============== Rail (2 lufy: serie A→B, A→B) ===============
const RAIL_SPEED = 2600, RAIL_PEN = 3, RAIL_DAMAGE = 60;
const ARMATA_SPLASH_RADIUS = 140;
const ARMATA_SPLASH_FALLOFF_MIN = 0.2;
const BASE_MAIN_BEHAVIOR = {
  id: 'default',
  cooldown: 0.38,
  burstsPerClick: 2,
  shotGap: 0.07,
  burstGap: 0.18,
  recoilKick: 14,
  recoilMax: 12,
  barrelsPerShot: 2,
  muzzleFx: spawnRailMuzzle,
  hitFx: spawnRailHitEffect,
  projectile: {
    type: 'rail',
    speed: RAIL_SPEED,
    life: 2.0,
    radius: 4,
    penetration: RAIL_PEN,
    effectScale: 1.0,
  },
};

function createMainWeaponBehavior(overrides = {}) {
  const projectileOverrides = overrides.projectile || {};
  const behavior = {
    ...BASE_MAIN_BEHAVIOR,
    ...overrides,
    projectile: {
      ...BASE_MAIN_BEHAVIOR.projectile,
      ...projectileOverrides,
    },
    muzzleFx: overrides.muzzleFx || BASE_MAIN_BEHAVIOR.muzzleFx,
    hitFx: overrides.hitFx || BASE_MAIN_BEHAVIOR.hitFx,
  };
  behavior.id = overrides.id || behavior.id;
  behavior.barrelsPerShot = overrides.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot;
  return behavior;
}

const MAIN_WEAPON_BEHAVIOR = {
  default: createMainWeaponBehavior(),
  railgun_mk2: createMainWeaponBehavior({ id: 'railgun_mk2' }),
  armata_mk1: createMainWeaponBehavior({
    id: 'armata_mk1',
    cooldown: 1.8,
    burstsPerClick: 1,
    shotGap: 0,
    burstGap: 0.32,
    recoilKick: 20,
    recoilMax: 18,
    barrelsPerShot: 1,
    muzzleFx: spawnArmataMuzzle,
    hitFx: spawnArmataHitEffect,
    projectile: {
      type: 'armata',
      speed: RAIL_SPEED * 0.78,
      life: 2.6,
      radius: 6,
      penetration: 0,
      explodeRadius: ARMATA_SPLASH_RADIUS,
      effectScale: 1.4,
    },
  }),
};
MAIN_WEAPON_BEHAVIOR.railgun_mk1 = MAIN_WEAPON_BEHAVIOR.default;

const rail = {
  cd: [0, 0],
  cdMax: MAIN_WEAPON_BEHAVIOR.default.cooldown,
  shotGap: MAIN_WEAPON_BEHAVIOR.default.shotGap,
  burstGap: MAIN_WEAPON_BEHAVIOR.default.burstGap,
  burstsPerClick: MAIN_WEAPON_BEHAVIOR.default.burstsPerClick,
  barrelsPerShot: MAIN_WEAPON_BEHAVIOR.default.barrelsPerShot,
  queue: [],
  nextStart: 0,
  behaviorId: MAIN_WEAPON_BEHAVIOR.default.id,
};
let railTimer = 0;

rebuildHardpointsForFrame();
loadLoadout();

function triggerRailVolley(){
  if(!(Game.player.weapons?.[HP.MAIN]?.length)) return;
  if(rail.queue.length) return;
  const start = rail.nextStart; rail.nextStart ^= 1;
  const barrels = Math.max(1, rail.barrelsPerShot || 2);
  const orderPair = barrels === 1 ? [0] : [start, 1 - start];
  for(let b=0;b<rail.burstsPerClick;b++){
    const baseDelay = b * (orderPair.length * rail.shotGap + rail.burstGap);
    for(let idx = 0; idx < orderPair.length; idx++){
      rail.queue.push({ timer: baseDelay + idx * rail.shotGap, barrel: orderPair[idx] });
    }
  }
}
function fireRailBarrel(barIndex){
  const mainWeapons = Game.player.weapons?.[HP.MAIN] || [];
  if(!mainWeapons.length) return;
  const spriteScale = ship.visual?.spriteScale || 1;
  const forwardLen = Math.min((ship.h * spriteScale) * 0.40, 52 * spriteScale); // było 0.36 i 46
  const gap = 10 * spriteScale;
  const turrets = [ship.turret, ship.turret2, ship.turret3, ship.turret4];
  const activeCount = Math.min(mainWeapons.length, turrets.length);
  let maxCooldown = 0;
  for(let i=0;i<activeCount;i++){
    const t = turrets[i];
    const weaponData = mainWeapons[i]?.weapon;
    const behavior = getMainWeaponBehaviorForWeaponId(weaponData?.id);
    const projectile = behavior.projectile || BASE_MAIN_BEHAVIOR.projectile;
    const barrelsPerShot = Math.max(1, behavior.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot);
    const normalizedIndex = Math.min(barIndex, barrelsPerShot - 1);
    const offsetFrac = barrelsPerShot === 1 ? 0 : (normalizedIndex / (barrelsPerShot - 1) - 0.5) * 2;
    const lateralOffset = (gap * 0.5) * offsetFrac;
    const damage = weaponData?.damage ?? weaponData?.dps ?? RAIL_DAMAGE;
    const a = t.angle;
    const f = {x:Math.cos(a), y:Math.sin(a)};
    const p = {x:-Math.sin(a), y:Math.cos(a)};
    const off = rotate(t.offset, ship.angle);
    const px = ship.pos.x + off.x + f.x * forwardLen + p.x * lateralOffset;
    const py = ship.pos.y + off.y + f.y * forwardLen + p.y * lateralOffset;
    bullets.push({
      x: px,
      y: py,
      vx: f.x * (projectile.speed ?? RAIL_SPEED) + ship.vel.x,
      vy: f.y * (projectile.speed ?? RAIL_SPEED) + ship.vel.y,
      life: projectile.life ?? 2.0,
      r: projectile.radius ?? 4,
      owner: 'player',
      damage,
      penetration: (projectile.penetration != null) ? projectile.penetration : RAIL_PEN,
      type: projectile.type || 'rail',
      weaponId: weaponData?.id,
      effectScale: projectile.effectScale ?? 1.0,
      explodeRadius: projectile.explodeRadius,
    });
    const recoilKick = behavior.recoilKick ?? t.recoilKick;
    const recoilMax = behavior.recoilMax ?? t.recoilMax;
    t.recoil = Math.min(t.recoil + recoilKick, recoilMax);
    const muzzleFx = behavior.muzzleFx || spawnRailMuzzle;
    muzzleFx({ x: px, y: py }, f, ship.vel, projectile.effectScale ?? 1.0);
    maxCooldown = Math.max(maxCooldown, behavior.cooldown ?? rail.cdMax);
  }
  rail.cd[barIndex] = maxCooldown || rail.cdMax;
}

// =============== CIWS (point-defence) ===============
const CIWS_FIRE_INTERVAL = 0.06;
const CIWS_BULLET_SPEED = 900;
const CIWS_DAMAGE = 8;
const CIWS_RANGE = 600;

const LASER_PD_FIRE_INTERVAL = 0.18;
const LASER_PD_DAMAGE = 16;
const LASER_PD_RANGE = 620;
const LASER_PD_BEAM_WIDTH = 6;

function ciwsStep(dt){
  const auxWeapons = Game.player.weapons?.[HP.AUX] || [];
  for(let i=0;i<ship.ciws.length;i++){
    if(i >= auxWeapons.length) break;
    const loadout = auxWeapons[i];
    if(!loadout || !loadout.weapon) continue;
    const weaponId = loadout.weapon.id;
    const isLaser = weaponId === 'laser_pd_mk1';
    const gun = ship.ciws[i];
    gun.cd = Math.max(0, gun.cd - dt);
    const off = rotate(gun.offset, ship.angle);
    const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
    const baseVel = { x: ship.vel.x - ship.angVel * off.y, y: ship.vel.y + ship.angVel * off.x };
    const range = isLaser ? LASER_PD_RANGE : CIWS_RANGE;
    let target = null; let dist = range;
    for(const npc of npcs){
      if(npc.dead || npc.friendly || !npc.isPirate) continue;
      const d = Math.hypot(npc.x - base.x, npc.y - base.y);
      if(d < dist){ dist = d; target = npc; }
    }
    if(!target) continue;

    const aimPoint = isLaser ? { x: target.x, y: target.y }
                             : leadTarget(base, baseVel, target, CIWS_BULLET_SPEED);
    const desired = Math.atan2(aimPoint.y - base.y, aimPoint.x - base.x);
    let diff = wrapAngle(desired - gun.angle);
    const aimStrength = isLaser ? 9 : 8;
    const maxVel = isLaser ? 6.5 : 6;
    let desiredVel = clamp(diff * aimStrength, -maxVel, maxVel);
    const velDelta = desiredVel - gun.angVel;
    const maxDelta = 40 * dt;
    gun.angVel += clamp(velDelta, -maxDelta, maxDelta);
    gun.angVel *= Math.exp(-8 * dt);
    gun.angVel = clamp(gun.angVel, -maxVel, maxVel);
    gun.angle = wrapAngle(gun.angle + gun.angVel * dt);

    const aimTolerance = isLaser ? 0.1 : 0.15;
    if(Math.abs(diff) >= aimTolerance || gun.cd > 0) continue;

    if(isLaser){
      firePointDefenseLaser(gun, base, baseVel, target);
    } else {
      fireCIWSGun(gun, base, baseVel);
    }
  }
}

function fireCIWSGun(gun, base, baseVel){
  const dir = { x: Math.cos(gun.angle), y: Math.sin(gun.angle) };
  const px = base.x + dir.x * 6;
  const py = base.y + dir.y * 6;
  bullets.push({
    x:px,
    y:py,
    vx: dir.x*CIWS_BULLET_SPEED + baseVel.x,
    vy: dir.y*CIWS_BULLET_SPEED + baseVel.y,
    life:1.2,
    r:2,
    owner:'player',
    damage:CIWS_DAMAGE,
    type:'ciws'
  });
  spawnParticle(
    {x:px, y:py},
    {x:dir.x*120 + baseVel.x*0.1, y:dir.y*120 + baseVel.y*0.1},
    0.06,
    '#ffdf9e',
    2.0,
    true
  );
  gun.cd = CIWS_FIRE_INTERVAL;
}

function firePointDefenseLaser(gun, base, baseVel, target){
  const dir = { x: Math.cos(gun.angle), y: Math.sin(gun.angle) };
  const muzzle = { x: base.x + dir.x * 6, y: base.y + dir.y * 6 };
  const toTarget = { x: target.x - muzzle.x, y: target.y - muzzle.y };
  const distance = clamp(Math.hypot(toTarget.x, toTarget.y), 0, LASER_PD_RANGE);
  const beamEnd = { x: muzzle.x + dir.x * distance, y: muzzle.y + dir.y * distance };

  spawnLaserBeam(muzzle, beamEnd, LASER_PD_BEAM_WIDTH, {
    life: 0.09,
    colorOuter: 'rgba(110,200,255,0.9)',
    colorInner: 'rgba(250,255,255,1.0)',
    glowColor: 'rgba(90,180,255,0.95)',
    glowBlur: 22,
    outerWidthMul: 1.05,
    innerWidthMul: 0.45
  });
  spawnPointDefenseLaserMuzzle(muzzle, dir, baseVel);
  spawnPointDefenseLaserHit(beamEnd.x, beamEnd.y);
  applyDamageToNPC(target, LASER_PD_DAMAGE, 'laser_pd');
  gun.cd = LASER_PD_FIRE_INTERVAL;
}

function spawnPointDefenseLaserMuzzle(pos, dir, baseVel){
  const tangential = { x: -dir.y, y: dir.x };
  for(let i=0;i<3;i++){
    const spread = (Math.random()-0.5) * 0.6;
    const vel = {
      x: dir.x * (220 + Math.random()*80) + tangential.x * spread * 80 + baseVel.x * 0.1,
      y: dir.y * (220 + Math.random()*80) + tangential.y * spread * 80 + baseVel.y * 0.1
    };
    spawnParticle(
      { x: pos.x, y: pos.y },
      vel,
      0.08 + Math.random()*0.05,
      '#8fe4ff',
      2.2 + Math.random()*0.8,
      true
    );
  }
}

function spawnPointDefenseLaserHit(x, y){
  for(let i=0;i<12;i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 160 + Math.random() * 200;
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.16 + Math.random()*0.14,
      '#78d9ff',
      1.4 + Math.random()*1.6,
      true
    );
  }
  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.05, '#ffffff', 4.4, true);
  spawnShockwave(x, y, { r: 5, maxR: 70, w: 2.4, maxLife: 0.35, color: 'rgba(110,200,255,' });
}

// =============== Specjal & dmg ===============
function tryFireSpecial(){
  if(!(Game.player.weapons?.[HP.SPECIAL]?.length)) return;
  if(ship.special.cooldownTimer>0) return;
  ship.special.cooldownTimer = SPECIAL_COOLDOWN;
  const dir = rotate({x:0,y:-1}, ship.angle);
  const start = add(ship.pos, rotate({x:0, y:-ship.h/2}, ship.angle));
  const length = 2000;
  const end = { x: start.x + dir.x*length, y: start.y + dir.y*length };
  const width = ship.w;
  const npcsInRange = npcs.filter(npc => !npc.dead && Math.hypot(npc.x - start.x, npc.y - start.y) < length + npc.radius);
  let hits = 0;
  const HIT_CAP = 80; // wystarczająco dużo, by czuć „miotłę”, ale bez zgonu CPU
  for (const npc of npcsInRange){
    if (hits >= HIT_CAP) break;
    const vx = npc.x - start.x, vy = npc.y - start.y;
    const proj = vx*dir.x + vy*dir.y;
    if (proj < 0 || proj > length) continue;
    const perp = Math.abs(vx*dir.y - vy*dir.x);
    if (perp <= npc.radius + width*0.5){
      applyDamageToNPC(npc, SPECIAL_DAMAGE, 'none');
      if ((hits & 1) === 0) spawnParticle({x:npc.x, y:npc.y}, {x:0,y:0}, 0.10, '#9ccfff', 5, true);
      hits++;
    }
  }
  spawnLaserBeam(start, end, width);
  for(let i=0;i<8;i++){
    const t = i/7;
    const px = start.x + dir.x*length*t + (Math.random()-0.5)*width*0.3;
    const py = start.y + dir.y*length*t + (Math.random()-0.5)*width*0.3;
    spawnParticle({x:px, y:py}, {x:(Math.random()-0.5)*120, y:(Math.random()-0.5)*120}, 0.2, '#9ccfff', 2.5, true);
  }
}
function applyDamageToPlayer(amount){
  if(ship.shield.val>0){ const s = Math.min(ship.shield.val, amount); ship.shield.val -= s; amount -= s; ship.shield.regenTimer = ship.shield.regenDelay; }
  if(amount>0) ship.hull.val = Math.max(0, ship.hull.val - amount);
  hudSpawnDMG(ship.pos.x, ship.pos.y - ship.h*0.4, amount, 'player');
}
function applyDamageToNPC(npc, dmg, cause='default'){
  if(npc.dead) return;
  npc.hitFlash = 0.12;
  npc.damageHue = (npc.damageHue || 0) + dmg;
  npc.hp -= dmg;
  hudSpawnDMG(npc.x, npc.y - (npc.radius||20)*0.8, dmg, 'npc');
  if(npc.hp<=0){
    npc.dead = true; npc.respawnTimer = 3 + Math.random()*6;
    if(cause === 'plasma'){ spawnExplosionPlasma(npc.x, npc.y, 1.2); }
    else if(cause === 'default'){ spawnDefaultHit(npc.x, npc.y, 1.2); }
  }
}

function applyDamageToStation(station, amount){
  let dmg = amount || 0;
  if(dmg <= 0) return 0;
  if(station.shield){
    station.shield.regenTimer = station.shield.regenDelay;
    const absorbed = Math.min(station.shield.val, dmg);
    station.shield.val -= absorbed;
    dmg -= absorbed;
  }
  if(dmg > 0){
    station.hp = Math.max(0, station.hp - dmg);
  }
  return dmg;
}

// =============== Collisions & particles ===============
function bulletsAndCollisionsStep(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.px = b.x; b.py = b.y;
    b.x += b.vx * dt; b.y += b.vy * dt;
    b.life -= dt;
    b.age = (b.age || 0) + dt; // krótki „grace” po wystrzale

    if(b.type === 'plasma' || b.type === 'rocket'){
      const trailVel = { x: -b.vx*0.02 + (Math.random()-0.5)*10, y: -b.vy*0.02 + (Math.random()-0.5)*10 };
      spawnParticle({x:b.x + (Math.random()-0.5)*3, y:b.y + (Math.random()-0.5)*3}, trailVel, 0.28, '#8cff8c', 1.0, false);
      if(b.type === 'rocket'){
        if(b.homingDelay > 0){
          b.homingDelay -= dt;
        } else {
          // HOMING: NPC -> gracz, player -> cele (NPC)
          let target = null;

          if (b.owner !== 'player') {
            // rakiety piratów zawsze gonią gracza
            target = { x: ship.pos.x, y: ship.pos.y };
          } else if (b.target && !b.target.dead) {
            target = { x: b.target.x, y: b.target.y };
          } else if (lockedTargets.length){
            let dist = Infinity, chosen = null;
            for(const t of lockedTargets){
              if(t.dead) continue;
              const d = Math.hypot(t.x - b.x, t.y - b.y);
              if(d < dist){ dist = d; chosen = t; }
            }
            if(chosen) target = { x: chosen.x, y: chosen.y };
          } else if (lockedTarget && !lockedTarget.dead){
            target = { x: lockedTarget.x, y: lockedTarget.y };
          } else {
            let dist = Infinity;
            for(const npc of npcs){
              if(npc.dead) continue;
              // graczowe rakiety nie strzelają w sojusznicze (friendly) cele
              if (b.owner==='player' && npc.friendly) continue;
              const d = Math.hypot(npc.x - b.x, npc.y - b.y);
              if(d < dist){ dist = d; target = {x:npc.x, y:npc.y}; }
            }
            if(!target){
              target = { x: ship.pos.x + (mouse.x - W/2)/camera.zoom,
                         y: ship.pos.y + (mouse.y - H/2)/camera.zoom };
            }
          }

          const speed = Math.hypot(b.vx, b.vy);
          const dir = norm({x:target.x - b.x, y:target.y - b.y});
          const current = Math.atan2(b.vy, b.vx);
          const desired = Math.atan2(dir.y, dir.x);
          const diff = wrapAngle(desired - current);
          const maxTurn = SIDE_ROCKET_TURN_RATE * dt;
          const turn = Math.abs(diff) < maxTurn ? diff : Math.sign(diff) * maxTurn;
          const newAng = current + turn;
          b.vx = Math.cos(newAng) * speed;
          b.vy = Math.sin(newAng) * speed;
        }
      }
    }

    if(b.life <= 0){ bullets.splice(i,1); continue; }

    // hit NPC (z pominięciem własnego źródła w czasie grace)
    let hitNPC = null;
    for (const npc of npcs){
      if (npc.dead) continue;
      if (b.owner === 'player' && npc.friendly) continue;
      if (b.source && b.source === npc && b.age < (b.spawnGrace || 0)) continue;
      const d = Math.hypot(npc.x - b.x, npc.y - b.y);
      if (d < npc.radius + b.r){ hitNPC = npc; break; }
    }

    if(hitNPC){
      if(b.type === 'plasma' || b.type === 'rocket'){
        const ex = b.x, ey = b.y;
        spawnExplosionPlasma(ex, ey, 1.0);
        for(const npc of npcs){
          if(npc.dead || (b.owner==='player' && npc.friendly)) continue;
          const d2 = Math.hypot(npc.x - ex, npc.y - ey);
          if(d2 <= b.explodeRadius + npc.radius){
            const falloff = 1 - (d2 / (b.explodeRadius + npc.radius));
            applyDamageToNPC(npc, Math.round(b.damage * (0.9 * falloff + 0.1)), 'plasma');
          }
        }
        bullets.splice(i,1);
        continue;
      } else if(b.type === 'armata'){
        applyDamageToNPC(hitNPC, b.damage, 'armata');
        spawnArmataHitEffect(b.x, b.y, b.effectScale || 1.0);
        const radius = b.explodeRadius ?? ARMATA_SPLASH_RADIUS;
        if(radius > 0){
          for (const npc of npcs){
            if (npc === hitNPC || npc.dead) continue;
            if (b.owner === 'player' && npc.friendly) continue;
            const d2 = Math.hypot(npc.x - b.x, npc.y - b.y);
            if (d2 <= radius + npc.radius){
              const falloff = 1 - Math.min(1, d2 / (radius + npc.radius));
              const scaled = Math.max(ARMATA_SPLASH_FALLOFF_MIN, falloff);
              const splashDmg = Math.round(b.damage * 0.6 * scaled);
              if (splashDmg > 0){
                applyDamageToNPC(npc, splashDmg, 'armata');
              }
            }
          }
        }
        bullets.splice(i,1);
        continue;
      } else if(b.type === 'rail'){
        applyDamageToNPC(hitNPC, b.damage, 'rail');
        spawnRailHitEffect(b.x, b.y, 1.0);
        b.penetration = (b.penetration !== undefined) ? b.penetration - 1 : (RAIL_PEN - 1);
        if(b.penetration <= 0){ bullets.splice(i,1); }
        continue;
      } else {
        applyDamageToNPC(hitNPC, b.damage, 'default');
        spawnDefaultHit(b.x, b.y, 1.0);
        bullets.splice(i,1);
        continue;
      }
    }

    // hit mission station
    for(const st of stations){
      if(!st.hp) continue;
      if (b.source && b.source === st && b.age < (b.spawnGrace || 0)) continue;
      const d = Math.hypot(st.x - b.x, st.y - b.y);
      if(d < st.r + b.r){
        applyDamageToStation(st, b.damage || 0);
        if(mercMission && mercMission.station === st && !mercMission.swarm.active){
          mercMission.swarm.active = true; // start „swarm”
        }
        if(st.hp <= 0){
          if(mercMission && mercMission.station === st){
            PLAYER.credits += 10000;
            stations.splice(stations.indexOf(st),1);
            if (typeof window.dettachPirateStation3D === 'function') {
              window.dettachPirateStation3D(mainScene3D);
            }
            mercMission = null;

            const m = MISSIONS.active.find(mm => mm.id === 'merc_pirate_station' && mm.status === 'active');
            if(m) m.status = 'completed';

            missionCompleteBanner.trigger('misja zakończona');
            toast('Misja zakończona: +10000 cr');
          }
        }
        if(b.type === 'armata'){
          spawnArmataHitEffect(b.x, b.y, b.effectScale || 1.0);
        } else if(b.type === 'rail'){
          spawnRailHitEffect(b.x, b.y, 1.0);
        } else {
          spawnExplosionPlasma(b.x, b.y, 1.0);
        }
        bullets.splice(i,1);
        break;
      }
    }

    // hit player
    if(b.owner !== 'player'){
      const hitR = Math.max(ship.w, ship.h) * 0.45;
      const d = Math.hypot(ship.pos.x - b.x, ship.pos.y - b.y);
      if(d < hitR + b.r){
        applyDamageToPlayer(b.damage);
        spawnDefaultHit(b.x, b.y, 1.0);
        bullets.splice(i,1);
        continue;
      }
    }
  }

  // particles
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.age += dt; if(p.age >= p.life){ particles.splice(i,1); continue; }
    if(p.beam) continue;
    p.vel.x *= 0.98; p.vel.y *= 0.98; p.vel.y += 8*dt;
    p.pos.x += p.vel.x*dt; p.pos.y += p.vel.y*dt;
  }
}

// =============== NPC movement/shooting ===============
let npcFireTimer = 0;
function npcShootingStep(dt){
  npcFireTimer -= dt;
  if(npcFireTimer <= 0){
    npcFireTimer = 0.45 + Math.random()*0.8;
    const candidates = npcs.filter(n=>!n.dead && n.weapon && !n.friendly && Math.hypot(n.x-ship.pos.x, n.y-ship.pos.y) < 900);
    if(candidates.length){
      const shooter = candidates[Math.floor(Math.random()*candidates.length)];
      const dir = norm({x: ship.pos.x - shooter.x, y: ship.pos.y - shooter.y});
      const bx = shooter.x + dir.x*(shooter.radius+6), by = shooter.y + dir.y*(shooter.radius+6);
      if(shooter.weapon === 'railgun'){
        bullets.push({ x:bx, y:by, vx: dir.x*600 + shooter.vx, vy: dir.y*600 + shooter.vy, life: 2.0, r:4, owner:'npc', damage:40, type:'rail', penetration:1 });
      } else {
        bullets.push({ x:bx, y:by, vx: dir.x*220 + shooter.vx, vy: dir.y*220 + shooter.vy, life: 4, r:3, owner:'npc', damage:12 });
      }
    }
  }
}
function npcStep(dt){
  const DESPAWN_RADIUS_SQ = NPC_DESPAWN_RADIUS * NPC_DESPAWN_RADIUS;
  for(const npc of npcs){
    if (npc.hitFlash) npc.hitFlash = Math.max(0, npc.hitFlash - dt);
    if(!npc.mission){
      const dx = npc.x - ship.pos.x;
      const dy = npc.y - ship.pos.y;
      if(dx*dx + dy*dy > DESPAWN_RADIUS_SQ){
        npc.dead = true;
        npc.respawnTimer = 5;
        continue;
      }
    }
    if(npc.mission){
      if(npc.dead) continue;
      if(npc.ai) npc.ai(dt);
      if (npc.fighter) { const drag = Math.exp(-3*dt); npc.vx *= drag; npc.vy *= drag; }
      npc.x += (npc.vx||0)*dt;
      npc.y += (npc.vy||0)*dt;
      npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
      continue;
    }
    if(npc.dead){
      npc.respawnTimer -= dt;
      if(npc.respawnTimer<=0){
        const base = stations.find(s=>s.id===npc.lastStation) || stations[0];
        const group = stations.filter(s=>s.inner === base.inner);
        const start = group[Math.floor(Math.random()*group.length)];
        const targetId = pickNextStation(start.id, npc.type);
        const startPort = Math.floor(Math.random()*start.ports.length);
        const spawnPos = stationPortWorld(start, startPort);
        npc.x = spawnPos.x;
        npc.y = spawnPos.y;
        npc.vx = 0; npc.vy = 0;
        npc.hp = npc.maxHp; npc.dead=false; npc.target = targetId; npc.fade = 1; npc.docking=false; npc.lastStation=start.id;
        const target = stations.find(s=>s.id===targetId);
        npc.dockPort = target ? Math.floor(Math.random()*target.ports.length) : 0;
        if(target && start.inner === target.inner){
          const route = getWarpRoute(start.id, targetId);
          if(route){ npc.warpRoute = route; npc.phase = 'toGate'; npc.lane = Math.floor(Math.random()*2); }
          else { npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0; }
        } else {
          npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0;
        }
      }
      continue;
    }
    if(npc.docking){
      const st = stations.find(s=>s.id===npc.lastStation);
      if(st){
        const portPos = stationPortWorld(st, npc.dockPort || 0);
        npc.x = portPos.x; npc.y = portPos.y;
      }
      npc.fade -= dt / 0.6;
      if(npc.fade <= 0 && st){
        const targetId = pickNextStation(npc.lastStation, npc.type);
        const startPort = Math.floor(Math.random()*st.ports.length);
        const spawnPos = stationPortWorld(st, startPort);
        npc.x = spawnPos.x;
        npc.y = spawnPos.y;
        npc.vx = 0; npc.vy = 0;
        npc.target = targetId; npc.fade = 1; npc.docking=false; npc.lastStation=st.id;
        const target = stations.find(s=>s.id===targetId);
        npc.dockPort = target ? Math.floor(Math.random()*target.ports.length) : 0;
        if(target && st.inner === target.inner){
          const route = getWarpRoute(st.id, targetId);
          if(route){ npc.warpRoute = route; npc.phase = 'toGate'; npc.lane = Math.floor(Math.random()*2); }
          else { npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0; }
        } else {
          npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0;
        }
      }
      continue;
    }
    if(npc.phase === 'warping'){
      npc.x += npc.vx*dt; npc.y += npc.vy*dt;
      npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
      const route = npc.warpRoute;
      const traveled = (npc.x - route.start.x) * route.dir.x + (npc.y - route.start.y) * route.dir.y;
      if(traveled >= route.length){
        npc.phase = 'toStation';
        npc.x = route.end.x; npc.y = route.end.y;
      }
      continue;
    }
    if(npc.phase === 'toGate'){
      const gate = npc.warpRoute.start;
      const start = stations.find(s=>s.id===npc.lastStation);
      const gv = { x: gate.x - start.x, y: gate.y - start.y };
      const gd = Math.hypot(gv.x, gv.y) || 1;
      const dirToGate = { x: gv.x/gd, y: gv.y/gd };
      const perp = { x: -dirToGate.y, y: dirToGate.x };
      const laneOffset = npc.lane ? 20 : -20;
      const gatePos = { x: gate.x + perp.x*laneOffset, y: gate.y + perp.y*laneOffset };
      const queue = gate.queues[npc.lane];
      let idx = queue.indexOf(npc);
      if(idx === -1){ queue.push(npc); idx = queue.length-1; }
      const spacing = 30;
      const targetPos = {
        x: gatePos.x - dirToGate.x * idx * spacing,
        y: gatePos.y - dirToGate.y * idx * spacing
      };
      const distGate = Math.hypot(npc.x - gatePos.x, npc.y - gatePos.y);
      if(idx === 0 && distGate < 5){
        queue.shift();
        npc.phase = 'warping';
        npc.vx = npc.warpRoute.dir.x * 4000;
        npc.vy = npc.warpRoute.dir.y * 4000;
        npc.x = gatePos.x;
        npc.y = gatePos.y;
        continue;
      }
      const to = { x: targetPos.x - npc.x, y: targetPos.y - npc.y };
      const d = Math.hypot(to.x, to.y);
      if(d < 1){
        npc.vx = 0; npc.vy = 0;
        continue;
      }
      const dir = { x: to.x/d, y: to.y/d };
      const desiredV = { x: dir.x*npc.speed, y: dir.y*npc.speed };
      npc.vx += (desiredV.x - (npc.vx||0)) * clamp(1.5*dt,0,1);
      npc.vy += (desiredV.y - (npc.vy||0)) * clamp(1.5*dt,0,1);
      npc.x += npc.vx*dt; npc.y += npc.vy*dt; npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
      continue;
    }
    let targetPos, st = null;
    if(npc.leader != null){
      const leader = npcs.find(n=>n.id===npc.leader && !n.dead);
      if(leader){
        targetPos = {
          x: leader.x + Math.cos(npc.orbitAngle) * npc.orbitRadius,
          y: leader.y + Math.sin(npc.orbitAngle) * npc.orbitRadius
        };
      } else {
        npc.leader = null;
      }
    }
    if(!targetPos){
      st = stations.find(s=>s.id===npc.target);
      if(!st){
        npc.target = pickNextStation(npc.lastStation, npc.type);
        const start = stations.find(s=>s.id===npc.lastStation);
        const target = stations.find(s=>s.id===npc.target);
        if(start && target && start.inner === target.inner){
          const route = getWarpRoute(start.id, npc.target);
          if(route){
            npc.warpRoute = route;
            npc.phase = 'toGate';
            npc.lane = Math.floor(Math.random()*2);
          } else {
            npc.warpRoute = null;
            npc.phase = 'direct';
            npc.lane = 0;
          }
        } else {
          npc.warpRoute = null;
          npc.phase = 'direct';
          npc.lane = 0;
        }
        continue;
      }
      if(npc.phase === 'toStation' || npc.phase === 'direct'){
        targetPos = stationPortWorld(st, npc.dockPort || 0);
      } else {
        targetPos = { x: st.x, y: st.y };
      }
    }
    const to = { x: targetPos.x - npc.x, y: targetPos.y - npc.y };
    const d = Math.hypot(to.x,to.y);
    const dir = d?{x:to.x/d,y:to.y/d}:{x:0,y:0};
    const desiredSpeed = npc.leader != null ? npc.speed : npc.speed * (d < 120 ? (d/120) : 1);
    const desiredV = { x: dir.x*desiredSpeed, y: dir.y*desiredSpeed };
    npc.vx += (desiredV.x - (npc.vx||0)) * clamp(1.5*dt,0,1);
    npc.vy += (desiredV.y - (npc.vy||0)) * clamp(1.5*dt,0,1);
    const toP = { x: ship.pos.x - npc.x, y: ship.pos.y - npc.y }; const dp = Math.hypot(toP.x,toP.y);
    if(dp < 120){ npc.vx -= (toP.x/dp) * 40*dt; npc.vy -= (toP.y/dp) * 40*dt; }
    npc.x += npc.vx*dt; npc.y += npc.vy*dt; npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
    const portPos = st ? stationPortWorld(st, npc.dockPort || 0) : null;
    const distToStation = portPos ? Math.hypot(portPos.x - npc.x, portPos.y - npc.y) : Infinity;
    if(npc.leader == null && st && distToStation < 20){
      npc.docking = true;
      npc.x = portPos.x; npc.y = portPos.y;
      npc.vx = 0; npc.vy = 0;
      npc.lastStation = st.id;
    }
  }
}

function pirateMissionStep(dt){
  if(!mercMission) return;
  const st = mercMission.station;
  if(!st) return;

  // --- Stacja strzela ---
  if(st.hp > 0 && st.weapons){
    // railguny
    for(const g of st.weapons.rails){
      g.cd = Math.max(0, g.cd - dt);
      if(g.cd===0){
        const mount = { x: st.x + Math.cos(g.offsetAngle)*st.r, y: st.y + Math.sin(g.offsetAngle)*st.r };
        const d = Math.hypot(ship.pos.x - mount.x, ship.pos.y - mount.y);
        if(d < 2200){ // zasięg
          const aim = Math.atan2(ship.pos.y - mount.y, ship.pos.x - mount.x);
          const dir = {x:Math.cos(aim), y:Math.sin(aim)};
          const muzzle = muzzlePosFor(st, dir, 14);
          bullets.push({
            x:muzzle.x, y:muzzle.y,
            vx: dir.x*(RAIL_SPEED*0.9), vy: dir.y*(RAIL_SPEED*0.9),
            life:2.0, r:4, owner:'npc', damage:60, type:'rail', penetration:2,
            source: st, spawnGrace: 0.08
          });
          spawnParticle({x:muzzle.x,y:muzzle.y}, {x:0,y:0}, 0.10, '#bfe7ff', 6, true);
          g.cd = g.cdMax;
        }
      }
    }
    // rakiety
    for(const r of st.weapons.rockets){
      r.cd = Math.max(0, r.cd - dt);
      if(r.cd===0){
        const mount = { x: st.x + Math.cos(r.offsetAngle)*st.r, y: st.y + Math.sin(r.offsetAngle)*st.r };
        const d = Math.hypot(ship.pos.x - mount.x, ship.pos.y - mount.y);
        if(d < 2600){
          const aim = Math.atan2(ship.pos.y - mount.y, ship.pos.x - mount.x);
          const dir = {x:Math.cos(aim), y:Math.sin(aim)};
          const muzzleR = muzzlePosFor(st, dir, 16);
          bullets.push({
            x:muzzleR.x, y:muzzleR.y, px:muzzleR.x, py:muzzleR.y,
            vx: dir.x*SIDE_BULLET_SPEED, vy: dir.y*SIDE_BULLET_SPEED,
            life:2.6, r:5, owner:'npc', damage:SIDE_BULLET_DAMAGE,
            type:'rocket', explodeRadius:SIDE_PLASMA_EXPLODE_RADIUS,
            homingDelay:SIDE_ROCKET_HOMING_DELAY,
            source: st, spawnGrace: 0.12
          });
          r.cd = r.cdMax;
        }
      }
    }
  }

  // --- SWARM spawnowanie falowo ---
  const swarm = mercMission.swarm;
  if(!swarm) return;
  if(!swarm.active) return;

  // ilu piratów żyje
  const alive = npcs.reduce((a,n)=>a + (n.mission && !n.friendly && !n.dead ? 1:0), 0);
  const hpFrac = Math.max(0, st.hp / st.maxHp);
  // im mniej HP, tym szybciej i więcej
  const interval = Math.max(0.35, swarm.baseInterval - (1 - hpFrac)*0.6);
  const batch = (hpFrac>0.66)?2 : (hpFrac>0.33)?4 : 6;

  swarm.timer -= dt;
  if(swarm.timer <= 0 && alive < swarm.maxAlive){
    const toSpawn = Math.min(batch, swarm.maxAlive - alive);
    for(let i=0;i<toSpawn;i++){
      const roll = Math.random();
      const kind = (roll<0.5)?'interceptor' : (roll<0.8)?'frigate' : 'destroyer';
      spawnPirate(kind, st);
    }
    swarm.timer = interval;
  }
}

// =============== Warp (jak wcześniej) ===============
const warp = {
  state:'idle', // idle | charging | active
  charge:0, chargeTime:0.8,
  orientTolerance: Math.PI/30,
  speed:3800,
  fuelMax:6, fuel:6, consumeRate:1.0, regenRate:0.5,
  dir:{x:0,y:0},
  turnRate: Math.PI / 5, // maksymalna prędkość skrętu w rad/s podczas warpa
  alignRate: Math.PI / 2.5, // szybkość zgrywania kadłuba do kierunku lotu
  entryProgress:0,
  entryDuration:0.9,
  entryBaseSpeed:0,
  isBusy(){ return this.state!=='idle'; }
};

function exitWarp(){
  spawnShockwave(ship.pos.x, ship.pos.y, { maxR: 1200, maxLife: 0.7 });
  camera.addShake(18, 0.22);
  warp.entryProgress = 0;
}

const boost = {
  state:'idle',
  fuelMax:15, fuel:15,
  regenRate:0.7,
  consumeRate:1.5,
  extraThrustMul:0.8,
  handlingMultiplier:1.35,
  dampingFactor:0.55,
  angularDampingFactor:0.65,
  effectTime:0, effectDuration:0.25, effectDir:{x:0,y:-1}
};

function attemptWarp(){
  if (warp.state === 'idle' && (DevFlags.unlimitedWarp || warp.fuel > 0)) {
    warp.state = 'charging';
    warp.charge = 0;
    return;
  }
  if (warp.state === 'charging') {
    warp.state = 'idle';
    warp.charge = 0;
    return;
  }
  if (warp.state === 'active') {
    warp.state = 'idle';
    exitWarp();
  }
}

window.addEventListener('keydown', (e)=>{
  if(e.key.toLowerCase() === 'shift'){
    if(warp.state==='idle' && (DevFlags.unlimitedWarp || warp.fuel>0)){
      warp.state='charging';
      warp.charge=0;
    }
  }
});
window.addEventListener('keyup', (e)=>{
  if(e.key.toLowerCase() === 'shift'){
    if(warp.state==='charging'){ warp.state='idle'; warp.charge=0; }
    else if(warp.state==='active'){ warp.state='idle'; exitWarp(); }
  }
});
function engageWarp(dir){
  const ndir = norm(dir);
  warp.dir.x = ndir.x;
  warp.dir.y = ndir.y;
  ship.angle = Math.atan2(ndir.y, ndir.x) + Math.PI/2;
  ship.angVel = 0;
  warp.state='active';
  warp.entryProgress = 0;
  warp.entryBaseSpeed = Math.hypot(ship.vel.x, ship.vel.y);
  if (DevFlags.unlimitedWarp) {
    warp.fuel = warp.fuelMax;
  }
  spawnParticle({x:ship.pos.x, y:ship.pos.y}, {x:0,y:0}, 0.14, '#bfe7ff', 8, true);
  for(let i=0;i<18;i++){
    const a = Math.random()*Math.PI*2;
    spawnParticle({x:ship.pos.x, y:ship.pos.y}, {x:Math.cos(a)*320, y:Math.sin(a)*320}, 0.18+Math.random()*0.18, '#cce6ff', 1.4, false);
  }
}

// =============== Fizyk ===============
function physicsStep(dt){
  // czas gry
  gameTime = (gameTime + dt * TIME_SCALE) % (24*3600);
  // aktualizacja orbit planet i stacji
  for(const pl of planets){
    pl.angle += pl.speed * dt * TIME_SCALE;
    const R = pl.devOrbitOverrideR ?? pl.orbitRadius ?? pl.orbit?.radius ?? pl.orbitR ?? BASE_ORBIT;
    if ('orbitRadius' in pl) pl.orbitRadius = R;
    if (pl.orbit && 'radius' in pl.orbit) pl.orbit.radius = R;
    if ('orbitR' in pl) pl.orbitR = R;
    pl.x = SUN.x + Math.cos(pl.angle) * R;
    pl.y = SUN.y + Math.sin(pl.angle) * R;
  }
  for(const st of stations){
    if(st.static) continue;
    st.angle += st.speed * dt * TIME_SCALE;
    st.x = st.planet.x + Math.cos(st.angle) * st.orbitRadius;
    st.y = st.planet.y + Math.sin(st.angle) * st.orbitRadius;
  }
  for(const st of stations){
    if(!st.warpGate) continue;
    const off = st.warpGate.offset;
    const ox = off && typeof off.x === 'number' ? off.x : 0;
    const oy = off && typeof off.y === 'number' ? off.y : 0;
    st.warpGate.x = st.x + ox;
    st.warpGate.y = st.y + oy;
  }
  for(const key in warpRoutes){
    const route = warpRoutes[key];
    if(!route) continue;
    const from = route.fromRef;
    const to = route.toRef;
    if(!from || !to) continue;
    const sx = from.warpGate?.x ?? from.x;
    const sy = from.warpGate?.y ?? from.y;
    const ex = to.warpGate?.x ?? to.x;
    const ey = to.warpGate?.y ?? to.y;
    route.start.x = sx;
    route.start.y = sy;
    route.end.x = ex;
    route.end.y = ey;
    const dx = ex - sx;
    const dy = ey - sy;
    const dist = Math.hypot(dx, dy) || 1;
    route.dir.x = dx / dist;
    route.dir.y = dy / dist;
    route.length = dist;
  }
  for(const st of stations){
    if(!st.shield) continue;
    if(st.shield.regenTimer > 0){
      st.shield.regenTimer = Math.max(0, st.shield.regenTimer - dt);
    } else {
      st.shield.val = clamp(st.shield.val + st.shield.regenRate * dt, 0, st.shield.max);
    }
  }
  for (const st of stations) {
    if (st.baseR == null) st.baseR = st.r;
    const scale = stationScaleFor(st);
    st.r = (st.baseR || st.r) * scale;
  }
  // regen paliwa gdy nie warpuje
  if(warp.state!=='active'){
    warp.fuel = clamp(warp.fuel + warp.regenRate*dt, 0, warp.fuelMax);
    if(DevFlags.unlimitedWarp) warp.fuel = warp.fuelMax;
    warp.entryProgress = 0;
  }
  let boostActive = boost.state === 'active';
  if(boost.state === 'active'){
    boost.fuel = clamp(boost.fuel - boost.consumeRate*dt, 0, boost.fuelMax);
    if(boost.fuel <= 0){
      boost.state = 'idle';
      boostActive = false;
    } else {
      boostActive = true;
    }
  } else {
    boostActive = false;
    if(boost.effectTime <= 0){
      boost.fuel = clamp(boost.fuel + boost.regenRate*dt, 0, boost.fuelMax);
    }
  }
  if(!boostActive && boost.effectTime>0) boost.effectTime = Math.max(0, boost.effectTime - dt);

  // rail queue/cd
  rail.cd[0] = Math.max(0, rail.cd[0]-dt);
  rail.cd[1] = Math.max(0, rail.cd[1]-dt);
  const requiredBarrels = Math.max(1, rail.barrelsPerShot || 2);
  const secondaryReady = requiredBarrels < 2 || rail.cd[1] <= 0;
  if (!stationUI.open && mouse.left  && rail.queue.length===0 && rail.cd[0]<=0 && secondaryReady && !warp.isBusy()) { triggerRailVolley(); }
  for(const q of rail.queue) q.timer -= dt;
  let firedSomething = true;
  while(firedSomething){
    firedSomething = false;
    for(let i=0;i<rail.queue.length;i++){
      const q = rail.queue[i];
      if(q.timer <= 0 && rail.cd[q.barrel] <= 0 && !warp.isBusy()){
        fireRailBarrel(q.barrel);
        rail.queue.splice(i,1);
        firedSomething = true;
        break;
      }
    }
  }
  railTimer = (requiredBarrels > 1) ? Math.min(rail.cd[0], rail.cd[1]) : rail.cd[0];

  ship.special.cooldownTimer = Math.max(0, ship.special.cooldownTimer - dt);
  if(ship.shield.regenTimer > 0) ship.shield.regenTimer -= dt;
  else ship.shield.val = clamp(ship.shield.val + ship.shield.regenRate * dt, 0, ship.shield.max);
  rocketCooldown = Math.max(0, rocketCooldown - dt);
  // mouse world position
  const mouseWorld = { x: ship.pos.x + (mouse.x - W/2)/camera.zoom, y: ship.pos.y + (mouse.y - H/2)/camera.zoom };
  const hasMissilesEquipped = (Game.player.weapons?.[HP.MISSILE]?.length || 0) > 0;
  if (!stationUI.open && mouse.right && !warp.isBusy() && hasMissilesEquipped && (rocketAmmoMax === 0 || rocketAmmo > 0) && rocketCooldown<=0) {
    const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
    const side = (local.x >= 0) ? 'right' : 'left';
    fireRocket(side);
    rocketCooldown = ROCKET_FIRE_INTERVAL;
  }

  // hover scanning
  let hover = null;
  let hoverType = null;
  if(mouse.overCanvas){
    let bestDistSq = Infinity;
    const npcMargin = 20;
    for(const npc of npcs){
      if(npc.dead) continue;
      const radius = (npc.radius || 0) + npcMargin;
      const dx = npc.x - mouseWorld.x;
      const dy = npc.y - mouseWorld.y;
      const distSq = dx*dx + dy*dy;
      if(distSq <= radius*radius && distSq < bestDistSq){
        bestDistSq = distSq;
        hover = npc;
        hoverType = 'npc';
      }
    }
    const stationMargin = 24;
    for(const st of stations){
      const baseR = ((st.r ?? st.baseR) || 120) + stationMargin;
      const dx = st.x - mouseWorld.x;
      const dy = st.y - mouseWorld.y;
      const distSq = dx*dx + dy*dy;
      if(distSq <= baseR*baseR && distSq < bestDistSq){
        bestDistSq = distSq;
        hover = st;
        hoverType = 'station';
      }
    }
  }

  if(hover){
    scan.target = hover;
    scan.targetType = hoverType;
    scan.scanned = hover;
    updateHoverInfo(hover, hoverType);
    if(!stationUI.open && mouse.click && hoverType === 'station'){
      openStationUI(hover);
      mouse.click = false;
    }
  } else {
    if(scan.target || scan.scanned || scan.targetType){
      scan.target = null;
      scan.scanned = null;
      scan.targetType = null;
    }
    hideHoverInfo();
  }
  if(lockedTarget && lockedTarget.dead) lockedTarget = null;
  lockedTargets = lockedTargets.filter(t=>!t.dead);
  if(highlightTimer > 0){
    highlightTimer -= dt;
    if(highlightTimer <= 0){ highlightTimer = 0; highlightedEnemies = []; }
  }

  // update radar pings
  for(let i=radarPings.length-1;i>=0;i--){
    const p = radarPings[i];
    p.age += dt; if(p.age>p.life) radarPings.splice(i,1);
  }
  // update scan waves
  for(let i=scanWaves.length-1;i>=0;i--){
    const w = scanWaves[i];
    w.r += w.speed*dt;
    for(const npc of npcs){
      if(npc.dead) continue;
      if(!w.hit.has(npc) && Math.hypot(npc.x-w.x, npc.y-w.y) <= w.r){ w.hit.add(npc); spawnRadarPing(npc.x,npc.y); }
    }
    for(const st of stations){
      if(!w.hit.has(st) && Math.hypot(st.x-w.x, st.y-w.y) <= w.r){ w.hit.add(st); spawnRadarPing(st.x,st.y); }
    }
    if(w.r > w.max) scanWaves.splice(i,1);
  }

  // update scan arrows
  for(let i=scanArrows.length-1;i>=0;i--){
    const a = scanArrows[i];
    if(warp.state !== 'active') a.age += dt;
    if(a.age > a.life) scanArrows.splice(i,1);
  }

  // turret aim (poza warp active)
  if(warp.state!=='active'){
    for(const t of [ship.turret, ship.turret2, ship.turret3, ship.turret4]){
      const off = rotate(t.offset, ship.angle);
      const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
      const aimPos = (lockedTarget && !lockedTarget.dead)
        ? leadTarget(base, ship.vel, lockedTarget, RAIL_SPEED)
        : mouseWorld;
      let diffT = wrapAngle(Math.atan2(aimPos.y - base.y, aimPos.x - base.x) - t.angle);
      let desiredVel = clamp(diffT * 6.5, -t.maxSpeed, t.maxSpeed);
      const velDelta = desiredVel - t.angVel;
      const maxDelta = t.maxAccel * dt;
      t.angVel += clamp(velDelta, -maxDelta, maxDelta);
      t.angVel *= Math.exp(-t.damping * dt);
      t.angVel = clamp(t.angVel, -t.maxSpeed, t.maxSpeed);
      t.angle = wrapAngle(t.angle + t.angVel * dt);
    }
  }
  for(const t of [ship.turret, ship.turret2, ship.turret3, ship.turret4]){
    t.recoil = Math.max(0, t.recoil - t.recoilRecover * dt);
  }

  // siły
  let totalF = {x:0,y:0}, totalTorque = 0;
  const forwardLocal = {x:0, y:-1};

  if(warp.state==='active'){
    const turnInput = clamp(input.torque, -1, 1);
    if(Math.abs(turnInput) > 1e-3){
      const currentAngle = Math.atan2(warp.dir.y, warp.dir.x);
      const maxTurn = warp.turnRate * dt;
      const delta = clamp(turnInput * warp.turnRate * dt, -maxTurn, maxTurn);
      const newAngle = currentAngle + delta;
      warp.dir.x = Math.cos(newAngle);
      warp.dir.y = Math.sin(newAngle);
    }
    const desiredBodyAngle = Math.atan2(warp.dir.y, warp.dir.x) + Math.PI/2;
    const diffBody = wrapAngle(desiredBodyAngle - ship.angle);
    const maxAlign = warp.alignRate * dt;
    ship.angle = wrapAngle(ship.angle + clamp(diffBody, -maxAlign, maxAlign));
    ship.angVel = 0;

    warp.entryProgress = Math.min(1, warp.entryProgress + dt / Math.max(0.001, warp.entryDuration));
    const entryEase = smoothstep01(warp.entryProgress);
    const targetSpeed = warp.entryBaseSpeed + (warp.speed - warp.entryBaseSpeed) * entryEase;
    const targetV = { x: warp.dir.x*targetSpeed, y: warp.dir.y*targetSpeed };
    ship.vel.x += (targetV.x - ship.vel.x) * clamp(6*dt,0,1);
    ship.vel.y += (targetV.y - ship.vel.y) * clamp(6*dt,0,1);
    if(!DevFlags.unlimitedWarp){
      warp.fuel = Math.max(0, warp.fuel - warp.consumeRate*dt);
      if(warp.fuel<=0){ warp.state='idle'; exitWarp(); }
    } else {
      warp.fuel = warp.fuelMax;
    }
  }
  else if(warp.state==='charging'){
    const dirToMouse = norm({x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y});
    const desiredBodyAngle = Math.atan2(dirToMouse.y, dirToMouse.x) + Math.PI/2;
    const kp = 5.5, maxSpin=2.5, accel=8.0;
    const diffB = wrapAngle(desiredBodyAngle - ship.angle);
    const desiredSpin = clamp(diffB * kp, -maxSpin, maxSpin);
    const delta = clamp(desiredSpin - ship.angVel, -accel*dt, accel*dt);
    ship.angVel += delta;
    if(warp.charge < warp.chargeTime) warp.charge += dt;
    if(warp.charge >= warp.chargeTime && Math.abs(diffB) <= warp.orientTolerance && (DevFlags.unlimitedWarp || warp.fuel>0)){
      engageWarp(dirToMouse);
    }
  }
  else {
    const handlingMul = boostActive ? boost.handlingMultiplier : 1;
    const forwardWorld = rotate(forwardLocal, ship.angle);

    if(boostActive){
      boost.effectTime = boost.effectDuration;
      boost.effectDir = {x: forwardWorld.x, y: forwardWorld.y};
    }

    // GŁÓWNY DUŻY SILNIK — ciąg do przodu
    if(input.main>0){
      const e = ship.engines.main;
      const wo = rotate(e.offset, ship.angle);
      const wf = forwardWorld;
      let thrust = e.maxThrust * input.main;
      if(boostActive){
        thrust *= (1 + boost.extraThrustMul);
      }
      totalF.x += wf.x * thrust; totalF.y += wf.y * thrust;
      totalTorque += (wo.x * (wf.y * thrust) - wo.y * (wf.x * thrust));
    }
    // mały krótki ślad przy poruszaniu (bez gazu)
    const spd = len(ship.vel);
    if(spd > 60){
      const e = ship.engines.main;
      const wo = rotate(e.offset, ship.angle);
      const backDir = norm({x:-ship.vel.x, y:-ship.vel.y});
      spawnParticle({x: ship.pos.x + wo.x, y: ship.pos.y + wo.y},
                    {x: backDir.x*50 + (Math.random()-0.5)*20, y: backDir.y*50 + (Math.random()-0.5)*20},
                    0.18, '#bfe7ff', 1.2, false);
    }

    // boczne i moment
    if(input.leftSide>0){
      const e = ship.engines.sideLeft;
      const thrust = e.maxThrust * input.leftSide * handlingMul;
      const wo = rotate(e.offset, ship.angle);
      const lateral = rotate({x:1,y:0}, ship.angle);
      const worldForce = {x: lateral.x * thrust, y: lateral.y * thrust};
      totalF.x += worldForce.x; totalF.y += worldForce.y;
      totalTorque += (wo.x * worldForce.y - wo.y * worldForce.x);
      spawnParticle(add(ship.pos, wo), add(ship.vel, mul(worldForce,-0.002)), 0.30, '#cfe7ff', 1.0);
    }
    if(input.rightSide>0){
      const e = ship.engines.sideRight;
      const thrust = e.maxThrust * input.rightSide * handlingMul;
      const wo = rotate(e.offset, ship.angle);
      const lateral = rotate({x:-1,y:0}, ship.angle);
      const worldForce = {x: lateral.x * thrust, y: lateral.y * thrust};
      totalF.x += worldForce.x; totalF.y += worldForce.y;
      totalTorque += (wo.x * worldForce.y - wo.y * worldForce.x);
      spawnParticle(add(ship.pos, wo), add(ship.vel, mul(worldForce,-0.002)), 0.30, '#cfe7ff', 1.0);
    }
    if(input.torque !== 0){
      const sign = Math.sign(input.torque);
      const left = ship.engines.torqueLeft; const right = ship.engines.torqueRight;
      const thrust = left.maxThrust * Math.abs(input.torque) * handlingMul;
      const o1 = rotate(left.offset, ship.angle), o2 = rotate(right.offset, ship.angle);
      const lateral1 = rotate({x:1,y:0}, ship.angle), lateral2 = rotate({x:-1,y:0}, ship.angle);
      const f1 = mul(lateral1, thrust * sign), f2 = mul(lateral2, thrust * sign);
      totalF.x += f1.x + f2.x; totalF.y += f1.y + f2.y;
      totalTorque += (o1.x * f1.y - o1.y * f1.x) + (o2.x * f2.y - o2.y * f2.x);
      spawnParticle(add(ship.pos, o1), add(ship.vel, mul(f1,-0.002)), 0.22, '#cfe7ff',1.0);
      spawnParticle(add(ship.pos, o2), add(ship.vel, mul(f2,-0.002)), 0.22, '#cfe7ff',1.0);
    }
  }

  // integracja ruchu
  const ax = totalF.x / ship.mass, ay = totalF.y / ship.mass;
  ship.vel.x += ax*dt; ship.vel.y += ay*dt;
  const linDamp = Math.exp(-ship.linearDamping * (boostActive ? boost.dampingFactor : 1) * dt);
  if(warp.state!=='active'){ ship.vel.x *= linDamp; ship.vel.y *= linDamp; }
  ship.pos.x += ship.vel.x*dt; ship.pos.y += ship.vel.y*dt;

  // granice
  const margin = 50;
  ship.pos.x = clamp(ship.pos.x, margin, WORLD.w - margin);
  ship.pos.y = clamp(ship.pos.y, margin, WORLD.h - margin);

  // obrót
  const angAcc = totalTorque / ship.inertia;
  ship.angVel += angAcc*dt;
  ship.angVel *= Math.exp(-ship.angularDamping * (boostActive ? boost.angularDampingFactor : 1) * dt);
  ship.angle += ship.angVel*dt;

  npcStep(dt);
  pirateMissionStep(dt);
  ciwsStep(dt);
  bulletsAndCollisionsStep(dt);
  npcShootingStep(dt);
  hudUpdateDMG(dt);
  hudUpdateNav(dt);
}

// ======= Efekty VFX =======
let _engineVFX = null;
let _engineVFXLoading = false;

function getEngineVFX() {
  if (_engineVFX) return _engineVFX;

  if (typeof THREE === "undefined") return null;

  // 1) Upewnij się, że mamy konstruktory efektów
  if (typeof window.createShortNeedleExhaust !== "function") {
    if (!_engineVFXLoading) {
      _engineVFXLoading = true;
      import("./Engineeffects.js").then(mod => {
        window.createShortNeedleExhaust = mod.createShortNeedleExhaust;
        window.createWarpExhaustBlue   = mod.createWarpExhaustBlue;
      }).catch(err => console.warn("Engineeffects.js failed to load", err))
        .finally(() => { _engineVFXLoading = false; });
    }
    return null;
  }

  // 2) Offscreen canvas i scena
  const canvas = document.createElement("canvas");
  // więcej miejsca, żeby ogon nie był ścinany
  canvas.width = 128;
  canvas.height = 256;
  const ctx2d = canvas.getContext("2d");

  const scene = new THREE.Scene();
  scene.background = null;

  const camera = new THREE.OrthographicCamera(-64, 64, 64, -192, -1000, 1000);
  camera.position.z = 10;
  camera.lookAt(0, 0, 0);

  const exhaust = window.createShortNeedleExhaust();
  exhaust.group.position.y = 0; // zero — unikamy clipu przy obrocie
  scene.add(exhaust.group);

  // 3) Renderer: użyj współdzielonego jeśli jest, w przeciwnym razie lokalnego
  let localRenderer = null;
  function pickRenderer(w, h) {
    if (typeof window.getSharedRenderer === "function") {
      const r = window.getSharedRenderer(w, h);
      return r || null;
    }
    if (!localRenderer) {
      localRenderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
        premultipliedAlpha: true,
        preserveDrawingBuffer: true
      });
      localRenderer.setPixelRatio(1);
    }
    // dopasuj rozmiar jeśli się zmienił
    const d = localRenderer.getSize(new THREE.Vector2());
    if (d.x !== w || d.y !== h) localRenderer.setSize(w, h, false);
    return localRenderer;
  }

  function resetRendererForVFX(renderer, width, height) {
    if (!renderer) return;
    if (typeof renderer.setRenderTarget === 'function') renderer.setRenderTarget(null);
    if (typeof renderer.setPixelRatio === 'function') renderer.setPixelRatio(1);
    if (typeof renderer.setSize === 'function') renderer.setSize(width, height, false);
    if (typeof renderer.setViewport === 'function') renderer.setViewport(0, 0, width, height);
    if (renderer.state && typeof renderer.state.reset === 'function') renderer.state.reset();
    if (typeof renderer.setScissorTest === 'function') renderer.setScissorTest(false);
    if (typeof renderer.setClearColor === 'function') renderer.setClearColor(0x000000, 0);
    if (typeof renderer.clear === 'function') renderer.clear(true, true, false);
  }

  _engineVFX = {
    canvas, ctx2d, camera, scene, exhaust,
    render(time) {
      const r = pickRenderer(canvas.width, canvas.height);
      if (!r) return;
      // pełny reset i przezroczyste czyszczenie
      resetRendererForVFX(r, canvas.width, canvas.height);

      // dynamiczny throttle
      const spd = Math.hypot(ship.vel.x, ship.vel.y);
      const moveGlow = Math.min(spd / 900, 0.6);
      const thrust = input.main > 0 ? input.main : 0;
      const boostAmp = (boost.effectDuration > 0)
        ? clamp(boost.effectTime / boost.effectDuration, 0, 1)
        : 0;
      const warpActiveAmp = (warp.state === 'active') ? smoothstep01(warp.entryProgress) : 0;
      const warpChargeAmp = (warp.state === 'charging')
        ? smoothstep01(Math.min(1, warp.charge/warp.chargeTime)) * 0.6
        : 0;
      const warpAmp  = Math.max(warpActiveAmp, warpChargeAmp);
      const throttle = Math.max(thrust, moveGlow * 0.8);

      exhaust.setThrottle(throttle);
      exhaust.setWarpBoost(Math.max(boostAmp, warpAmp));
      // Możesz dopasować temperaturę i bloom z poziomu opcji (D3):
      exhaust.setColorTemp(OPTIONS.vfx.colorTempK);
      exhaust.setBloomGain(OPTIONS.vfx.bloomGain);

      exhaust.update(time);
      r.render(scene, camera);

      // skopiuj do 2D
      ctx2d.clearRect(0, 0, canvas.width, canvas.height);
      ctx2d.drawImage(r.domElement, 0, 0, canvas.width, canvas.height);
    }
  };

  return _engineVFX;
}

// Prosty fallback 2D — żeby ZAWSZE coś było widać, gdy evfx==null
function drawEngineFallback2D() {
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  const g = ctx.createLinearGradient(0, 0, 0, 90);
  g.addColorStop(0, 'rgba(170,210,255,0.55)');
  g.addColorStop(1, 'rgba(170,210,255,0)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(-14, 0);
  ctx.quadraticCurveTo(0, 70, 14, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawPhotonBeamLocal(alpha){
  const L = 200;
  ctx.save();
  ctx.lineCap = 'round';
  ctx.shadowBlur = 28;
  ctx.shadowColor = `rgba(230,250,255,${0.95 * alpha})`;
  ctx.strokeStyle = `rgba(255,255,255,${0.95 * alpha})`;
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, -L * 0.96);
  ctx.stroke();
  ctx.restore();

  const g = ctx.createLinearGradient(0, 0, 0, -L);
  g.addColorStop(0, `rgba(160,210,255,${0.25 * alpha})`);
  g.addColorStop(1, `rgba(160,210,255,0)`);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(-50, 0);
  ctx.quadraticCurveTo(0, -L * 0.5, 0, -L);
  ctx.quadraticCurveTo(0, -L * 0.5, 50, 0);
  ctx.closePath();
  ctx.fill();

  for (let i = 0; i < 4; i++) {
    const phase = ((vfxTime * 0.8) + i * 0.25) % 1;
    const y = -phase * L;
    const r = 20 + 40 * (1 - phase);
    ctx.strokeStyle = `rgba(200,240,255,${(1 - phase) * alpha})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, y, r, 0, Math.PI * 2);
    ctx.stroke();
  }

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.shadowBlur = 19.2;
  ctx.shadowColor = '#fff';
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(0, 0, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawWarpChargeEffectLocal(progress, radius, spriteScale){
  if(progress <= 0) return;
  const eased = smoothstep01(progress);
  const baseAlpha = 0.3 + 0.5 * eased;
  const glowR = radius * (0.65 + 0.25 * eased);
  const ringR = radius * (0.9 + 0.35 * eased);
  const lineBase = (6 + 22 * eased) * spriteScale;
  const arcLine = (10 + 18 * eased) * spriteScale;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';

  const glow = ctx.createRadialGradient(0, 0, glowR * 0.35, 0, 0, glowR);
  glow.addColorStop(0, `rgba(186,232,255,${baseAlpha})`);
  glow.addColorStop(1, 'rgba(125,211,252,0)');
  ctx.fillStyle = glow;
  ctx.beginPath(); ctx.arc(0, 0, glowR, 0, Math.PI * 2); ctx.fill();

  ctx.lineWidth = lineBase;
  ctx.strokeStyle = `rgba(125,211,252,${0.35 + 0.4 * eased})`;
  ctx.beginPath(); ctx.arc(0, 0, ringR, 0, Math.PI * 2); ctx.stroke();

  const segments = 4;
  const arcLen = Math.PI * (0.22 + 0.4 * eased);
  ctx.lineWidth = arcLine;
  ctx.strokeStyle = `rgba(206,244,255,${0.45 + 0.45 * eased})`;
  for(let i=0;i<segments;i++){
    const offset = (vfxTime * 1.4 + i / segments) * Math.PI * 2;
    ctx.beginPath();
    ctx.arc(0, 0, ringR, offset, offset + arcLen);
    ctx.stroke();
  }

  ctx.restore();
}

function drawMainEngineVfxLocal(localPos, forward, widen = 1.5, yNudge = -68) {
  ctx.save();
  // przechodzimy w lokal statku
  ctx.translate(localPos.x, localPos.y);
  // dopasowanie szerokości do kadłuba
  ctx.scale(widen, 1);
  // igła w dół statku (dysza na dole) — oś Y płomienia w dół
  ctx.rotate(Math.atan2(forward.y, forward.x) + Math.PI/2);
  ctx.globalCompositeOperation = 'lighter';

  const evfx = getEngineVFX();
  if (evfx) {
    evfx.render(vfxTime);
    const w = evfx.canvas.width, h = evfx.canvas.height;
    ctx.drawImage(evfx.canvas, -w / 2, yNudge, w, h);
  }
  ctx.restore();
}

function drawBoostBeam(pos, dir, cam, alpha){ const s=worldToScreen(pos.x,pos.y,cam); ctx.save(); ctx.translate(s.x,s.y); ctx.scale(camera.zoom,camera.zoom); ctx.rotate(Math.atan2(-dir.x, dir.y)); ctx.globalCompositeOperation='lighter'; drawPhotonBeamLocal(alpha); ctx.restore(); }

// =============== Main loop ===============
let lastTime = performance.now();
const PHYS_DT = 1/120;
let acc = 0;
let vfxTime = 0;
let prevState = null;
function saveState(){ prevState = { pos:{...ship.pos}, angle: ship.angle, turretAngle: ship.turret.angle, turretAngle2: ship.turret2.angle, turretAngle3: ship.turret3.angle, turretAngle4: ship.turret4.angle, ciwsAngles: ship.ciws.map(c=>c.angle) }; }
saveState();
function loop(now){
  const frame = Math.min(0.033, (now - lastTime)/1000);
  lastTime = now;
  applyGamepad();
  if(PAUSED){ requestAnimationFrame(loop); return; }
  acc += frame;
  vfxTime += frame;
  saveState();
  let steps = 0;
  while(acc >= PHYS_DT && steps < 10){
    physicsStep(PHYS_DT);
    acc -= PHYS_DT; steps++;
  }
  const alpha = acc / PHYS_DT;
  frameId++;
  missionCompleteBanner.update(frame);
  // Shockwaves
  for(let i=shockwaves.length-1;i>=0;i--){
    const s = shockwaves[i];
    s.life += frame;
    const k = Math.min(1, s.life/s.maxLife);
    s.r = s.maxR * k;
    s.w = Math.max(1, (1-k) * (s.maxR*0.06));
    if(s.life >= s.maxLife) shockwaves.splice(i,1);
  }
  if(camera.shakeTime > 0){
    camera.shakeTime -= frame;
    if(camera.shakeTime <= 0) camera.shakeMag = 0;
  }
  render(alpha, frame);
  if (overlay3D) {
    overlay3D.tick(frame);
  }
  requestAnimationFrame(loop);
}

// =============== Render ===============
function worldToScreen(wx,wy,cam){ return { x: (wx - cam.x)*camera.zoom + W/2, y: (wy - cam.y)*camera.zoom + H/2 }; }

function stationPortWorld(st, idx){
  const off = st.ports[idx % st.ports.length];
  return { x: st.x + off.x, y: st.y + off.y };
}

function glowCircle(ctx, x, y, r, color){
  ctx.save();
  ctx.shadowColor = color;
  ctx.shadowBlur = r*0.5;
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawSunWithCorona(ctx, cam, t) {
  const s = worldToScreen(SUN.x, SUN.y, cam);
  const R = SUN.r * camera.zoom;

  ctx.save();
  ctx.translate(s.x, s.y);

  // --- miękka poświata daleko w tle (nebula-like) ---
  ctx.globalCompositeOperation = 'lighter';
  const hazeR = R * SUN.corona.haze;
  const gH = ctx.createRadialGradient(0,0, R*0.6, 0,0, hazeR);
  gH.addColorStop(0, 'rgba(255,220,120,0.25)');
  gH.addColorStop(1, 'rgba(50,80,140,0.00)');
  ctx.fillStyle = gH;
  ctx.beginPath(); ctx.arc(0,0,hazeR,0,Math.PI*2); ctx.fill();

  // --- korona: promieniste igły z lekkim szumem i pulsem ---
  const rays = SUN.corona.rays | 0;
  const baseLen = R * (1.0 + SUN.corona.length);
  const pulse = 1 + SUN.corona.pulse * Math.sin(t*1.6);
  const jitterAmp = SUN.corona.jitter;

  // deterministyczny „szum” bez biblioteki
  function n1(i, k=1) {
    const x = Math.sin((i*374761.0 + SUN.seed*1.123 + k)*0.0000131) * 43758.5453;
    return x - Math.floor(x);
  }

  ctx.beginPath();
  for (let i=0;i<rays;i++){
    const a = (i / rays) * Math.PI*2;
    const w = (Math.PI*2 / rays) * (0.6 + n1(i,2)*0.6);  // szerokość klina
    const j = (n1(i) - 0.5) * 2 * jitterAmp;
    const len = baseLen * (0.82 + 0.18*n1(i,3)) * pulse;
    const r1 = R * (1.02 + 0.03*n1(i,4));
    const r2 = len * (1 + j);

    const aL = a - w*0.5, aR = a + w*0.5;
    // mały klin (trójkąt) – od krawędzi tarczy na zewnątrz
    ctx.moveTo(Math.cos(aL)*r1, Math.sin(aL)*r1);
    ctx.lineTo(Math.cos(a)*r2,  Math.sin(a)*r2);
    ctx.lineTo(Math.cos(aR)*r1, Math.sin(aR)*r1);
  }
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,210,120,0.25)';
  ctx.shadowColor = 'rgba(255,235,170,0.9)';
  ctx.shadowBlur = Math.max(6, R*0.22);
  ctx.fill();

  // --- obwód korony (fresnel) ---
  const fresR = R * (1.2 + 0.06*Math.sin(t*1.1));
  const gF = ctx.createRadialGradient(0,0, fresR*0.7, 0,0, fresR);
  gF.addColorStop(0, 'rgba(255,240,180,0)');
  gF.addColorStop(1, 'rgba(255,235,170,0.32)');
  ctx.fillStyle = gF;
  ctx.beginPath(); ctx.arc(0,0, fresR, 0, Math.PI*2); ctx.fill();

  // --- tarcza gwiazdy (żółta z „rimem”) ---
  const g = ctx.createRadialGradient(0,0, R*0.1, 0,0, R);
  g.addColorStop(0, SUN.color.core);
  g.addColorStop(0.55, SUN.color.mid);
  g.addColorStop(1, SUN.color.rim);
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.fill();

  // delikatne „plamy” (granulacja) — kilka półprzezroczystych kół
  ctx.globalCompositeOperation = 'multiply';
  ctx.fillStyle = 'rgba(200,90,0,0.06)';
  for(let i=0;i<8;i++){
    const a = (i*0.79 + t*0.15) % (Math.PI*2);
    const rr = R*(0.12 + 0.15*n1(i,5));
    const d  = R*(0.15 + 0.55*n1(i,6));
    ctx.beginPath();
    ctx.arc(Math.cos(a)*d, Math.sin(a)*d, rr, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.restore();
}

function drawStationShadow(ctx, st, cam){
  const s = worldToScreen(st.x, st.y, cam);
  const toSun = { x: (SUN.x - st.x), y: (SUN.y - st.y) };
  const ang = Math.atan2(toSun.y, toSun.x) + Math.PI; // cień „od” Słońca
  const scale = stationScaleFor(st);
  const base = (st.baseR || st.r || 120) * scale;
  const off  = base * 1.2 * cam.zoom;
  const w = base * 1.6 * cam.zoom;
  const h = base * 0.7 * cam.zoom;

  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.rotate(ang);
  const g = ctx.createRadialGradient(off, 0, 0, off, 0, w);
  g.addColorStop(0.00, 'rgba(0,0,0,0.35)');
  g.addColorStop(1.00, 'rgba(0,0,0,0.00)');
  ctx.globalCompositeOperation = 'multiply';
  ctx.beginPath();
  ctx.ellipse(off, 0, w, h, 0, 0, Math.PI*2);
  ctx.fillStyle = g;
  ctx.fill();
  ctx.restore();
}

function drawStationVFX(ctx, st, x, y, r, t){
  ctx.save();
  ctx.translate(x, y);
  switch(st.style){
    case 'ringGate':
      ctx.strokeStyle = '#273447';
      ctx.lineWidth = Math.max(1, r*0.2);
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
      ctx.save(); ctx.rotate(t*0.6);
      for(let i=0;i<6;i++){ ctx.rotate(Math.PI/3); glowCircle(ctx, r*0.6, 0, r*0.12, '#6dd6ff'); }
      ctx.restore();
      glowCircle(ctx,0,0,r*0.3,'#6dd6ff');
      break;
    case 'hexHub':
      ctx.strokeStyle = '#273447';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<6;i++){ const a=i*Math.PI/3; const px=Math.cos(a)*r*0.6; const py=Math.sin(a)*r*0.6; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); }
      ctx.closePath(); ctx.stroke();
      break;
    case 'triRing':
      ctx.strokeStyle = '#273447'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0,0,r*0.9,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,r*0.6,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,r*0.3,0,Math.PI*2); ctx.stroke();
      break;
    case 'solarPetals':
      ctx.save(); ctx.rotate(t*0.5);
      for(let i=0;i<8;i++){ ctx.rotate(Math.PI/4); ctx.fillStyle='#274a7d'; ctx.fillRect(r*0.3,-r*0.1,r*0.4,r*0.2); }
      ctx.restore();
      glowCircle(ctx,0,0,r*0.25,'#8fd0ff');
      break;
    case 'shipyard':
      ctx.save();
      for(let i=0;i<4;i++){ ctx.rotate(Math.PI/2); ctx.fillStyle='#344a74'; ctx.fillRect(r*0.2,-r*0.05,r*0.8,r*0.1); }
      ctx.restore();
      break;
    case 'tradeSpindle':
      ctx.fillStyle='#3b517d'; ctx.fillRect(-r*0.1,-r,r*0.2,r*2);
      for(let i=-3;i<=3;i++){ ctx.fillStyle='#6ea0ff'; ctx.fillRect(r*0.3, i*r*0.2 - r*0.05, r*0.3, r*0.1); ctx.fillRect(-r*0.6, i*r*0.2 - r*0.05, r*0.3, r*0.1); }
      break;
    default:
      ctx.fillStyle = '#273447';
      ctx.beginPath(); ctx.arc(0,0,r*0.6,0,Math.PI*2); ctx.fill();
      break;
  }

  if(st.shield && st.shield.val > 0){
    const frac = clamp(st.shield.val / st.shield.max, 0, 1);
    const pulse = (Math.sin(t * 1.6) + 1) * 0.5;
    const shieldR = r * (1.18 + 0.04 * pulse);
    const fresnel = ctx.createRadialGradient(0, 0, shieldR * 0.72, 0, 0, shieldR);
    fresnel.addColorStop(0, 'rgba(120,200,255,0)');
    fresnel.addColorStop(1, `rgba(120,200,255,${0.22 + 0.25 * frac})`);
    ctx.save();
    ctx.fillStyle = fresnel;
    ctx.globalAlpha = 0.45 + 0.25 * pulse * frac;
    ctx.beginPath(); ctx.arc(0,0, shieldR, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.lineWidth = Math.max(3, r * 0.08);
    ctx.strokeStyle = `rgba(120,200,255,${0.32 + 0.4 * frac})`;
    ctx.beginPath(); ctx.arc(0,0, shieldR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  ctx.restore();
  ctx.strokeStyle = 'rgba(175,210,255,0.12)';
  ctx.lineWidth = Math.max(1, 2);
  ctx.beginPath(); ctx.arc(x, y, r*1.05, 0, Math.PI*2); ctx.stroke();
}

function drawPlanetLabels(ctx, cam){
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  const fontSize = Math.round(clamp(18 * camera.zoom, 12, 30));
  ctx.font = `600 ${fontSize}px Inter,system-ui,monospace`;
  ctx.lineJoin = 'round';
  for(const pl of planets){
    if(!pl || !pl.label) continue;
    const screen = worldToScreen(pl.x, pl.y, cam);
    if(screen.x < -160 || screen.x > W + 160 || screen.y < -160 || screen.y > H + 160) continue;
    const offset = ((pl.r || 0) + 40) * camera.zoom;
    const y = screen.y - offset;
    ctx.save();
    ctx.shadowColor = 'rgba(12, 22, 42, 0.7)';
    ctx.shadowBlur = fontSize * 0.4;
    ctx.lineWidth = Math.max(2, fontSize * 0.18);
    ctx.strokeStyle = 'rgba(10, 20, 36, 0.85)';
    ctx.fillStyle = 'rgba(223, 231, 255, 0.95)';
    ctx.strokeText(pl.label, screen.x, y);
    ctx.fillText(pl.label, screen.x, y);
    ctx.restore();
  }
  ctx.restore();
}

function drawStars(cam){
  // jak daleko poza ekran ładować komórki
  const marginW = (W/2)/camera.zoom + 2000;
  const marginH = (H/2)/camera.zoom + 2000;
  const minX = Math.floor((cam.x - marginW)/STAR_CELL);
  const maxX = Math.floor((cam.x + marginW)/STAR_CELL);
  const minY = Math.floor((cam.y - marginH)/STAR_CELL);
  const maxY = Math.floor((cam.y + marginH)/STAR_CELL);

  for(let iy=minY; iy<=maxY; iy++){
    for(let ix=minX; ix<=maxX; ix++){
      const cell = getCell(ix,iy);
      for(const s of cell.stars){
        const sx = (s.x - cam.x) * camera.zoom + W/2;
        const sy = (s.y - cam.y) * camera.zoom + H/2;
        if(sx < -50 || sx > W+50 || sy < -50 || sy > H+50) continue;

        if(warp.state==='active'){
          // Smugi przy warp
          const entry = smoothstep01(warp.entryProgress);
          const L = 24 * (0.25 + 0.75*entry) * (1 + 1.2*(warp.fuel/warp.fuelMax));
          const dx = -warp.dir.x * L, dy = -warp.dir.y * L;
          ctx.strokeStyle = 'rgba(200,220,255,0.35)';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(sx+dx, sy+dy); ctx.lineTo(sx, sy); ctx.stroke();
        } else {
          ctx.globalAlpha = s.bright;
          ctx.fillStyle = '#ffffff';
          const sz = Math.max(0.6, s.size * (0.8 + 0.2*Math.random()));
          ctx.fillRect(Math.round(sx), Math.round(sy), Math.ceil(sz), Math.ceil(sz));
          ctx.globalAlpha = 1;
        }
      }
    }
  }
  pruneStarCells();
}

function drawRangeRuler(ctx, cam){
  if (!DevFlags.showRuler) return;

  const cx = W / 2;
  const cy = H / 2;
  const zoom = cam?.zoom ?? camera.zoom ?? 1;

  ctx.save();
  ctx.globalAlpha = 0.5;
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#6db6ff';

  const step = 500;
  const maxWorldR = Math.min(W, H) / zoom * 0.5 * 0.95;

  for (let r = step; r < maxWorldR; r += step) {
    const rr = r * zoom;
    ctx.beginPath();
    ctx.arc(cx, cy, rr, 0, Math.PI * 2);
    ctx.stroke();

    if (r % 1000 === 0) {
      ctx.fillStyle = '#cfe6ff';
      ctx.font = '11px monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${r}`, cx + rr + 4, cy);
    }
  }

  ctx.globalAlpha = 0.25;
  const axisR = maxWorldR * zoom;
  ctx.beginPath(); ctx.moveTo(cx - axisR, cy); ctx.lineTo(cx + axisR, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, cy - axisR); ctx.lineTo(cx, cy + axisR); ctx.stroke();

  ctx.restore();
}

const npcSpriteCache = new Map();

function getNPCSprite(npc){
  const key = npc.type + '|' + npc.radius + '|' + (npc.friendly?1:0);
  if (npcSpriteCache.has(key)) return npcSpriteCache.get(key);

  if (npc.radius <= 8) {
    const can = document.createElement('canvas');
    const size = Math.ceil(npc.radius*2 + 10);
    can.width = can.height = size * 2;
    const g = can.getContext('2d');
    g.translate(can.width/2, can.height/2); g.scale(2,2);

    const r = npc.radius;
    // kadłub: klin
    g.fillStyle = npc.friendly ? '#b7ccf7' : '#ffb7a8';
    g.beginPath(); g.moveTo(r*0.9,0); g.lineTo(-r*0.7,-r*0.55); g.lineTo(-r*0.7,r*0.55); g.closePath(); g.fill();
    // mostek
    g.fillStyle = '#e6f2ff';
    g.fillRect(-r*0.15, -r*0.22, r*0.35, r*0.44);
    // dysze
    g.globalCompositeOperation='lighter';
    g.fillStyle = npc.friendly ? 'rgba(150,200,255,0.9)' : 'rgba(255,170,130,0.9)';
    g.beginPath(); g.ellipse(-r*0.7, -r*0.25, 1.8, 2.6, 0, 0, Math.PI*2); g.fill();
    g.beginPath(); g.ellipse(-r*0.7,  r*0.25, 1.8, 2.6, 0, 0, Math.PI*2); g.fill();

    npcSpriteCache.set(key, can);
    return can;
  }

  const size = Math.ceil(npc.radius*2 + 16);
  const can = document.createElement('canvas');
  can.width = can.height = size * 2;              // hi-res dla ładnego obrotu
  const g = can.getContext('2d');
  g.translate(can.width/2, can.height/2);
  g.scale(2,2);                                   // hi-res skala

  const w = npc.radius*2, h = npc.radius*1.6;
  const r = Math.min(10, npc.radius*0.4);

  // baza: gradient „metal”
  const grad = g.createLinearGradient(-w/2,-h/2, w/2,h/2);
  grad.addColorStop(0, '#1e2a46');
  grad.addColorStop(1, '#30425f');
  g.fillStyle = grad;
  roundRect(g, -w/2, -h/2, w, h, r); g.fill();
  g.lineWidth = 1.5; g.strokeStyle = 'rgba(255,255,255,0.06)'; g.stroke();

  // pasek frakcji (piraci – czerwony, sojusznicy – niebieski)
  g.globalAlpha = 0.85;
  g.fillStyle = npc.friendly ? '#60a5fa' : '#ff6b57';
  g.fillRect(-w*0.45, -h*0.12, w*0.90, h*0.24);
  g.globalAlpha = 1;

  // nos/skrzydła zależne od typu
  if (npc.type === 'interceptor' || npc.radius <= 24){
    g.fillStyle = '#9fb3d9';
    g.beginPath(); g.moveTo(w*0.55,0); g.lineTo(-w*0.25,-h*0.45); g.lineTo(-w*0.25,h*0.45); g.closePath(); g.fill();
  } else {
    g.fillStyle = '#2a3754';
    g.fillRect(-w*0.65,-h*0.55, w*0.4, h*0.25);
    g.fillRect(-w*0.65, h*0.30, w*0.4, h*0.25);
    g.fillStyle = '#bcd7ff';                       // mostek
    g.fillRect(-w*0.1, -h*0.15, w*0.22, h*0.30);
  }

  // okna
  g.fillStyle = '#cfe7ff';
  const win = Math.max(3, Math.round(npc.radius/6));
  for (let i=0;i<win;i++){
    const yy = -h*0.25 + i*(h*0.5)/(win-1 || 1);
    g.fillRect(w*0.05, yy, 3, 2);
  }

  // dysze
  g.fillStyle = '#2c3a58';
  const noz = Math.max(2, Math.round(npc.radius/10));
  for(let i=0;i<noz;i++){
    const t = noz===1 ? 0 : (i/(noz-1) - 0.5);
    roundRect(g, -w*0.55, t*h*0.6 - 3, 8, 6, 2); g.fill();
  }

  npcSpriteCache.set(key, can);
  return can;
}

function drawNPCPretty(ctx, npc, screenPos){
  const pixR = npc.radius * camera.zoom;
  if (pixR < 9) {
    ctx.save();
    ctx.globalAlpha = npc.fade ?? 1;
    ctx.translate(screenPos.x, screenPos.y);
    ctx.rotate(npc.angle);
    // „shuttle”: klin + 2 silniczki
    ctx.fillStyle = npc.friendly ? '#bfd8ff' : '#ffc7bd';
    ctx.beginPath();
    ctx.moveTo( pixR, 0);
    ctx.lineTo(-pixR*0.7, -pixR*0.6);
    ctx.lineTo(-pixR*0.7,  pixR*0.6);
    ctx.closePath(); ctx.fill();
    // dysze
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = npc.friendly ? 'rgba(150,200,255,0.9)' : 'rgba(255,160,120,0.9)';
    ctx.beginPath(); ctx.ellipse(-pixR*0.7, -pixR*0.25, 2, 3, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(-pixR*0.7,  pixR*0.25, 2, 3, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    return;
  }

  ctx.save();
  ctx.globalAlpha = npc.fade ?? 1;
  ctx.translate(screenPos.x, screenPos.y);
  ctx.rotate(npc.angle);

  const sprite = getNPCSprite(npc);
  const drawSize = Math.ceil(npc.radius*2 + 16) * camera.zoom;
  ctx.drawImage(sprite, -drawSize/2, -drawSize/2, drawSize, drawSize);

  // glow z dysz (moc rośnie wraz z prędkością)
  const sp = Math.hypot(npc.vx||0, npc.vy||0);
  const thrust = Math.min(1, sp / (npc.maxSpeed || 1));
  if (thrust > 0.05){
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.shadowBlur = 14*camera.zoom;
    ctx.shadowColor = npc.friendly ? 'rgba(120,200,255,0.9)' : 'rgba(255,160,120,0.95)';
    ctx.fillStyle   = npc.friendly ? 'rgba(160,210,255,0.7)' : 'rgba(255,180,130,0.8)';
    ctx.beginPath();
    ctx.ellipse(-npc.radius*0.9*camera.zoom, 0, 9*camera.zoom*(0.8+thrust), 20*camera.zoom*(0.8+thrust), 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // „hit-flash” (ekranowa poświata)
  if (npc.hitFlash > 0){
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = npc.hitFlash;
    ctx.drawImage(sprite, -drawSize/2, -drawSize/2, drawSize, drawSize);
    ctx.globalCompositeOperation = 'source-over';
  }

  // pasek HP
  const hpw = (npc.hp / npc.maxHp) * (npc.radius*2*camera.zoom);
  ctx.fillStyle = '#ff6b6b';
  ctx.fillRect(-npc.radius*camera.zoom, -npc.radius*camera.zoom - 8*camera.zoom, hpw, 4*camera.zoom);

  ctx.restore();
}

function render(alpha, frameDt){
  canvas.style.cursor = 'default';
  // DevTools cheats (np. nielimitowany warp)
  if (window.devtoolsApplyCheats) devtoolsApplyCheats();
  // Interpolacja stanu
  const interpPos = {
    x: prevState.pos.x + (ship.pos.x - prevState.pos.x) * alpha,
    y: prevState.pos.y + (ship.pos.y - prevState.pos.y) * alpha
  };
  const interpAngle = prevState.angle*(1-alpha) + ship.angle*alpha;
  const interpTurretAngle = interpAngleShort(prevState.turretAngle, ship.turret.angle, alpha);
  const interpTurretAngle2 = interpAngleShort(prevState.turretAngle2, ship.turret2.angle, alpha);
  const interpTurretAngle3 = interpAngleShort(prevState.turretAngle3, ship.turret3.angle, alpha);
  const interpTurretAngle4 = interpAngleShort(prevState.turretAngle4, ship.turret4.angle, alpha);
  const interpCIWSAngles = ship.ciws.map((c,i)=>interpAngleShort(prevState.ciwsAngles[i], c.angle, alpha));

  // Kamera
  const cam = { x: interpPos.x, y: interpPos.y, zoom: camera.zoom };
  if(camera.shakeMag > 0){
    const t = camera.shakeTime / camera.shakeDur;
    const mag = camera.shakeMag * Math.max(0, t);
    cam.x += (Math.random()*2 - 1) * mag;
    cam.y += (Math.random()*2 - 1) * mag;
  }

  overlayView.center.x = cam.x;
  overlayView.center.y = cam.y;
  overlayView.viewport.w = W;
  overlayView.viewport.h = H;
  overlayView.zoom = cam.zoom;

  // aktualizuj wyświetlanie czasu
  gameTimeEl.textContent = formatGameTime(gameTime);

  // Czyścimy ekran
  ctx.clearRect(0,0,W,H);
  ensurePlanetStationsInit(stations);
  if (window.updatePlanets3D) updatePlanets3D(frameDt);
  // najpierw zaktualizuj pozycje stacji 3D...
  if (window.updateStations3D) window.updateStations3D(stations);
  // ...a potem wyrenderuj overlay sceny 3D
  if (window.updateWorld3D) updateWorld3D(frameDt, vfxTime);

  // Gwiazdy (proceduralne kafelki na całej mapie)
  drawStars(cam);

  // ★ SŁOŃCE Z KORONĄ
  drawSunWithCorona(ctx, cam, vfxTime);

  // scan waves
  for(const w of scanWaves){
    const s = worldToScreen(w.x, w.y, cam);
    ctx.strokeStyle = 'rgba(120,200,255,0.18)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, w.r * camera.zoom, 0, Math.PI*2); ctx.stroke();
  }

  ctx.globalCompositeOperation = 'source-over';
  ctx.imageSmoothingEnabled = true;
  if (window.drawPlanets3D)   drawPlanets3D(ctx, cam);      // planety
  if (window.drawStations3D)  drawStations3D(ctx, cam, worldToScreen); // STACJE 3D NAD PLANETAMI (sprite per-stacja)
  if (window.drawWorld3D)     drawWorld3D(ctx, cam, worldToScreen); // np. piracka stacja (spotlight)
  drawPlanetLabels(ctx, cam);
  drawRangeRuler(ctx, cam);
  if (window.drawSunDirection) drawSunDirection(ctx, cam);

  // Warp gates
  for(const key in warpRoutes){
    const route = warpRoutes[key];
    const perp = { x: -route.dir.y, y: route.dir.x };
    const w = 6*camera.zoom;
    const s1 = worldToScreen(route.start.x, route.start.y, cam);
    const s2 = worldToScreen(route.end.x, route.end.y, cam);
    ctx.strokeStyle = '#88aaff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(s1.x - perp.x*w, s1.y - perp.y*w);
    ctx.lineTo(s1.x + perp.x*w, s1.y + perp.y*w);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(s2.x - perp.x*w, s2.y - perp.y*w);
    ctx.lineTo(s2.x + perp.x*w, s2.y + perp.y*w);
    ctx.stroke();
  }

  // Shockwaves (na warstwie świata, pod HUD)
  for(const s of shockwaves){
    const sw = worldToScreen(s.x, s.y, cam);
    ctx.beginPath();
    ctx.lineWidth = s.w * camera.zoom;
    ctx.strokeStyle = s.color + (1 - s.life/s.maxLife) + ')';
    ctx.arc(sw.x, sw.y, s.r * camera.zoom, 0, Math.PI*2);
    ctx.stroke();
  }

  if (!window.USE_STATION_3D) {
    for (const st of stations){
      const s = worldToScreen(st.x, st.y, cam);
      const visR = (st.baseR || st.r) * stationScaleFor(st);
      const rr = visR * camera.zoom;

      drawStationShadow(ctx, st, cam);
      drawStationVFX(ctx, st, s.x, s.y, rr, gameTime);

      for (let i=0;i<st.ports.length;i++){
        const pw = stationPortWorld(st, i);
        const ps = worldToScreen(pw.x, pw.y, cam);
        ctx.fillStyle = '#60a5fa';
        ctx.beginPath(); ctx.arc(ps.x, ps.y, 4*camera.zoom, 0, Math.PI*2); ctx.fill();
      }
      ctx.fillStyle = '#dfe7ff'; ctx.font = `${12*camera.zoom}px monospace`;
      ctx.fillText('ST'+st.id, s.x - rr*0.35, s.y + 4*camera.zoom);
    }
  }

  // Laser beams
  for(const p of particles){
    if(!p.beam) continue;
    const s1 = worldToScreen(p.start.x, p.start.y, cam);
    const s2 = worldToScreen(p.end.x, p.end.y, cam);
    const alphaFactor = clamp(1 - p.age/Math.max(p.life, 0.0001), 0, 1);
    const baseAlpha = (p.alpha != null) ? p.alpha : 1;
    const fade = (p.fadeWithLife === false) ? baseAlpha : baseAlpha * alphaFactor;
    if(fade <= 0) continue;
    const outerWidthMul = (p.outerWidthMul != null) ? p.outerWidthMul : 1.4;
    const innerWidthMul = (p.innerWidthMul != null) ? p.innerWidthMul : 0.6;
    const glowBlur = ((p.glowBlur != null) ? p.glowBlur : 30) * camera.zoom;
    const glowColor = p.glowColor || 'rgba(120,180,255,0.9)';
    const colorOuter = p.colorOuter || 'rgba(160,210,255,0.7)';
    const colorInner = p.colorInner || 'rgba(220,240,255,1.0)';

    ctx.save();
    ctx.globalAlpha = fade;
    ctx.lineCap = 'round';
    ctx.shadowBlur = glowBlur;
    ctx.shadowColor = glowColor;
    ctx.strokeStyle = colorOuter;
    ctx.lineWidth = p.width * camera.zoom * outerWidthMul;
    ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = fade;
    ctx.lineCap = 'butt';
    ctx.strokeStyle = colorInner;
    ctx.lineWidth = p.width * camera.zoom * innerWidthMul;
    ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    ctx.restore();
  }

  // Pociski
  for(const b of bullets){
    const s = worldToScreen(b.x, b.y, cam);
    if(b.type === 'rail'){
      const a = Math.atan2(b.vy, b.vx);
      const lenPx = 28 * camera.zoom;
      const dx = Math.cos(a) * (lenPx*0.5);
      const dy = Math.sin(a) * (lenPx*0.5);

      // glow
      ctx.save();
      ctx.lineCap = 'round';
      ctx.shadowBlur = 20 * camera.zoom;
      ctx.shadowColor = 'rgba(140,200,255,0.9)';
      ctx.strokeStyle = 'rgba(160,210,255,0.6)';
      ctx.lineWidth = 12 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx, s.y - dy); ctx.lineTo(s.x + dx, s.y + dy); ctx.stroke();
      ctx.restore();

      // rdzeń
      ctx.lineCap = 'round';
      ctx.strokeStyle = 'rgba(240,255,255,1.0)';
      ctx.lineWidth = 4 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx*0.4, s.y - dy*0.4); ctx.lineTo(s.x + dx*0.9, s.y + dy*0.9); ctx.stroke();
      ctx.lineCap = 'butt';
    } else if(b.type === 'armata'){
      const a = Math.atan2(b.vy, b.vx);
      const lenPx = 36 * camera.zoom;
      const dx = Math.cos(a) * (lenPx * 0.6);
      const dy = Math.sin(a) * (lenPx * 0.6);

      ctx.save();
      ctx.lineCap = 'round';
      ctx.shadowBlur = 30 * camera.zoom;
      ctx.shadowColor = 'rgba(255,170,90,0.95)';
      ctx.strokeStyle = 'rgba(255,190,120,0.75)';
      ctx.lineWidth = 16 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx, s.y - dy); ctx.lineTo(s.x + dx, s.y + dy); ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.lineCap = 'round';
      ctx.strokeStyle = 'rgba(255,240,210,1.0)';
      ctx.lineWidth = 6 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx*0.3, s.y - dy*0.3); ctx.lineTo(s.x + dx*1.1, s.y + dy*1.1); ctx.stroke();
      ctx.restore();
    } else if(b.type === 'plasma'){
      const sp = worldToScreen(b.px, b.py, cam);
      ctx.save();
      ctx.lineCap = 'round';
      ctx.shadowBlur = 20 * camera.zoom;
      ctx.shadowColor = 'rgba(100,255,120,0.85)';
      ctx.strokeStyle = 'rgba(80,240,120,0.55)';
      ctx.lineWidth = 8 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(sp.x, sp.y); ctx.lineTo(s.x, s.y); ctx.stroke();
      ctx.restore();
      ctx.beginPath(); ctx.fillStyle = '#9eff9a';
      ctx.arc(s.x, s.y, Math.max(2, b.r*camera.zoom*0.8), 0, Math.PI*2); ctx.fill();
    } else {
      ctx.beginPath(); ctx.fillStyle = '#ffd86b';
      ctx.arc(s.x, s.y, Math.max(1.5, b.r*camera.zoom), 0, Math.PI*2); ctx.fill();
    }
  }

  // NPC
  for(const npc of npcs){
    if(npc.dead) continue;
    const s = worldToScreen(npc.x, npc.y, cam);
    drawNPCPretty(ctx, npc, s);
  }

  hudRenderNav(ship, cam);
  hudRenderDMG(cam);
  hudRenderFloatingBars(ship, cam);

  // radar pings
  for(const ping of radarPings){
    const s = worldToScreen(ping.x, ping.y, cam);
    const t = ping.age/ping.life;
    ctx.strokeStyle = `rgba(120,200,255,${1-t})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, 40 * t * camera.zoom, 0, Math.PI*2); ctx.stroke();
  }

  // scan indicator and lock
  if(scan.target && scan.targetType && mouse.overCanvas){
    const obj = scan.target;
    const s = worldToScreen(obj.x, obj.y, cam);
    const base = (obj.radius || obj.r || 60);
    const outerExtra = scan.targetType === 'station' ? 28 : 14;
    const innerExtra = scan.targetType === 'station' ? 12 : 8;
    const outerR = (base + outerExtra) * camera.zoom;
    const innerR = Math.max(2, (base + innerExtra) * camera.zoom);
    const color = scan.targetType === 'station'
      ? 'rgba(143,181,255,0.95)'
      : (obj.friendly ? 'rgba(96,192,255,0.95)' : 'rgba(255,160,122,0.95)');

    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(2, 2.5 * Math.sqrt(camera.zoom));
    ctx.shadowBlur = 18 * camera.zoom;
    ctx.shadowColor = color;
    ctx.globalAlpha = 0.9;
    ctx.beginPath(); ctx.arc(s.x, s.y, outerR, 0, Math.PI*2); ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.55;
    ctx.setLineDash([6 * camera.zoom, 6 * camera.zoom]);
    ctx.beginPath(); ctx.arc(s.x, s.y, innerR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();

    if(scan.targetType === 'station' && !stationUI.open){
      canvas.style.cursor = 'pointer';
    }
  }
  if(highlightedEnemies.length){
    for(const obj of highlightedEnemies){
      if(obj.dead) continue;
      const s = worldToScreen(obj.x, obj.y, cam);
      const rad = ((obj.radius||obj.r) + 12) * camera.zoom;
      ctx.strokeStyle = 'rgba(255,255,0,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
    }
  }
  if(lockedTargets.length){
    for(const obj of lockedTargets){
      if(obj.dead) continue;
      const s = worldToScreen(obj.x, obj.y, cam);
      const rad = ((obj.radius||obj.r) + 14) * camera.zoom;
      ctx.strokeStyle = 'rgba(255,80,80,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
    }
  } else if(lockedTarget){
    const obj = lockedTarget;
    const s = worldToScreen(obj.x, obj.y, cam);
    const rad = ((obj.radius||obj.r) + 14) * camera.zoom;
    ctx.strokeStyle = 'rgba(255,80,80,0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
  }

  // Particles (za statkiem) — zwykłe
  {
    let drawn = 0;
    for (let i = particles.length - 1; i >= 0 && drawn < MAX_PARTICLES_DRAW; i--){
      const p = particles[i];
      if (p.flash || p.beam) continue;
      drawn++;
      const s = worldToScreen(p.pos.x, p.pos.y, cam);
      const t = clamp(1 - p.age/p.life, 0, 1);
      ctx.globalAlpha = t;
      ctx.beginPath(); ctx.fillStyle = p.color;
      ctx.arc(s.x, s.y, p.size * camera.zoom, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Efekt dopalacza
  const boostAlpha = (boost.effectDuration > 0)
    ? clamp(boost.effectTime / boost.effectDuration, 0, 1)
    : 0;
  if(boostAlpha>0){
    const e = ship.engines.main;
    const mainVisual = e.visualOffset || e.offset;
    const origin = add(interpPos, rotate(mainVisual, interpAngle));
    drawBoostBeam(origin, boost.effectDir, cam, boostAlpha);
  }

  // ======= STATEK =======
  const shipS = worldToScreen(interpPos.x, interpPos.y, cam);
  const spriteScale = ship.visual?.spriteScale || 1;
  const visualW = ship.w * spriteScale;
  const visualH = ship.h * spriteScale;
  ctx.save(); ctx.translate(shipS.x, shipS.y); ctx.scale(camera.zoom, camera.zoom); ctx.rotate(interpAngle);

  let warpGlowProgress = 0;
  if(warp.state === 'charging'){
    warpGlowProgress = clamp(warp.charge / warp.chargeTime, 0, 1);
  } else if(warp.state === 'active' && warp.entryProgress < 1){
    warpGlowProgress = 1 - smoothstep01(warp.entryProgress);
  }
  if(warpGlowProgress > 0){
    const chargeRadius = Math.max(visualW, visualH) * 0.7;
    drawWarpChargeEffectLocal(warpGlowProgress, chargeRadius, spriteScale);
  }

  // --- KADŁUB: sprite lub fallback ---
  if (USE_SHIP_SPRITE && ship.spriteReady) {
    const scale = (ship.h / ship.spriteH) * spriteScale;
    const drawW = ship.spriteW * scale;
    const drawH = ship.spriteH * scale;

    ctx.save();
    ctx.globalAlpha = 0.33;
    ctx.filter = 'blur(2px)';
    ctx.drawImage(shipSprite, -drawW/2 + 6, -drawH/2 + 8, drawW, drawH);
    ctx.restore();

    ctx.drawImage(shipSprite, -drawW/2, -drawH/2, drawW, drawH);
  } else {
    ctx.fillStyle = 'rgba(3,8,18,0.8)';
    ctx.fillRect(-visualW/2 + 6*spriteScale, -visualH/2 + 8*spriteScale, visualW, visualH);
    const g = ctx.createLinearGradient(-visualW/2, -visualH/2, visualW/2, visualH/2);
    g.addColorStop(0, '#1d2740'); g.addColorStop(1, '#2d3b55');
    ctx.fillStyle = g;
    roundRect(ctx, -visualW/2, -visualH/2, visualW, visualH, 10 * spriteScale);
    ctx.fill();

    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1.5;
    roundRect(ctx, -visualW/2, -visualH/2, visualW, visualH, 10 * spriteScale);
    ctx.stroke();
    ctx.globalAlpha = 0.25;
    ctx.beginPath();
    ctx.moveTo(-visualW*0.35, -visualH*0.20); ctx.lineTo(visualW*0.35, -visualH*0.20);
    ctx.moveTo(-visualW*0.35,  visualH*0.20); ctx.lineTo(visualW*0.35,  visualH*0.20);
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();

    ctx.fillStyle = '#a8d1ff';
    ctx.beginPath();
    ctx.ellipse(0, -6*spriteScale, visualW*0.22, visualH*0.22, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.save();
    ctx.rotate(-interpAngle);
    const glare = ctx.createRadialGradient(0, -visualH*0.18, 6*spriteScale, 0, -visualH*0.18, visualW*0.5);
    glare.addColorStop(0, 'rgba(255,255,255,0.25)');
    glare.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = glare;
    ctx.beginPath();
    ctx.ellipse(0, -6*spriteScale, visualW*0.22, visualH*0.22, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  if (!(USE_SHIP_SPRITE && ship.spriteReady)) {
    for (const pod of ship.pods) {
      ctx.save();
      ctx.translate(pod.offset.x, pod.offset.y);
      const pg = ctx.createLinearGradient(-pod.w/2, -pod.h/2, pod.w/2, pod.h/2);
      pg.addColorStop(0, '#1d2740'); pg.addColorStop(1, '#2d3b55');
      ctx.fillStyle = pg;
      roundRect(ctx, -pod.w/2, -pod.h/2, pod.w, pod.h, 6 * spriteScale);
      ctx.fill();
      ctx.restore();
    }

    const mainE = ship.engines.main;
    ctx.save();
    const mainVisual = mainE.visualOffset || mainE.offset;
    ctx.translate(mainVisual.x, mainVisual.y);
    ctx.fillStyle = '#2a3a56';
    roundRect(ctx, -14*spriteScale, -9*spriteScale, 28*spriteScale, 18*spriteScale, 6*spriteScale);
    ctx.fill();
    ctx.save();
    ctx.globalAlpha = 0.8;
    ctx.shadowBlur = 20;
    ctx.shadowColor = 'rgba(150,200,255,0.9)';
    ctx.fillStyle = 'rgba(160,210,255,0.75)';
    roundRect(ctx, -8*spriteScale, -6*spriteScale, 16*spriteScale, 12*spriteScale, 4*spriteScale);
    ctx.fill();
    ctx.restore();
    ctx.restore();

    for (const k of ['sideLeft','sideRight','torqueLeft','torqueRight']) {
      const e = ship.engines[k];
      ctx.save();
      const vis = e.visualOffset || e.offset;
      ctx.translate(vis.x, vis.y);
      ctx.fillStyle = '#2f3b57';
      roundRect(ctx, -6*spriteScale, -6*spriteScale, 12*spriteScale, 12*spriteScale, 3*spriteScale);
      ctx.fill();
      ctx.restore();
    }

    ctx.fillStyle = '#cbd6ff';
    for (const off of ship.sideGunsLeft) {
      ctx.save();
      ctx.translate(off.x, off.y);
      roundRect(ctx, -12*spriteScale, -3*spriteScale, 8*spriteScale, 6*spriteScale, 3*spriteScale);
      ctx.fill();
      ctx.restore();
    }
    for (const off of ship.sideGunsRight) {
      ctx.save();
      ctx.translate(off.x, off.y);
      roundRect(ctx, 4*spriteScale, -3*spriteScale, 8*spriteScale, 6*spriteScale, 3*spriteScale);
      ctx.fill();
      ctx.restore();
    }
  }

  // VFX głównego silnika – pod tarczą, wyrasta z dyszy
  {
    const e = ship.engines.main;
    const visualOffset = e.visualOffset || e.offset;
    const forward = { x: 0, y: -1 }; // lokalny "w dół statku"
    // szerokość zależna od gazu/ruchu
    const spd = Math.hypot(ship.vel.x, ship.vel.y);
    const moveGlow = Math.min(spd / 900, 0.6) * 0.8;
    const throttle = Math.max(input.main || 0, moveGlow);
    const widen = 2.4 + 0.6 * throttle; // 1.2..1.8
    drawMainEngineVfxLocal(visualOffset, forward, widen, -68 * spriteScale);
  }

  // status circle (hull/shield/speed/rockets) behind shield
  {
    const hullFrac = ship.hull.val / ship.hull.max;
    const shieldFrac = ship.shield.val / ship.shield.max;
    const r = Math.max(visualW, visualH) * 0.6;
    ctx.save();
    ctx.rotate(-interpAngle);
    ctx.lineWidth = 4;
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 - Math.PI,true); ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 + Math.PI,false); ctx.stroke();
    ctx.strokeStyle = '#ef4444';
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 - Math.PI*hullFrac,true); ctx.stroke();
    ctx.strokeStyle = '#3b82f6';
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 + Math.PI*shieldFrac,false); ctx.stroke();
    ctx.fillStyle = '#dfe7ff';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const speed = Math.round(Math.hypot(ship.vel.x, ship.vel.y));
    ctx.fillText(`${speed}`, 0, -r - 8);
    if(rocketAmmoMax > 0 && rocketAmmo < rocketAmmoMax) ctx.fillText(`${rocketAmmo}`, 0, r + 8);
    ctx.restore();
  }

  // tarcza
  const sp = ship.shield.val / ship.shield.max;
  if(sp > 0.005){
    const rr = Math.max(visualW, visualH) * 0.62;
    ctx.save();
    const fresnel = ctx.createRadialGradient(0,0, rr*0.78, 0,0, rr);
    fresnel.addColorStop(0, 'rgba(120,200,255,0)');
    fresnel.addColorStop(1, `rgba(120,200,255,${0.18 + 0.4*sp})`);
    ctx.fillStyle = fresnel;
    ctx.beginPath(); ctx.arc(0,0, rr, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    ctx.beginPath(); ctx.strokeStyle = `rgba(120,200,255,${0.18 + 0.4*sp})`;
    ctx.lineWidth = 3; ctx.arc(0,0, Math.max(visualW,visualH)*0.6, 0, Math.PI*2); ctx.stroke();
  }

  // CIWS turrets
  const ciwsBase = 8 * spriteScale, ciwsBarrelLen = 12 * spriteScale, ciwsBarrelH = 4 * spriteScale;
  const activeCIWS = (Game.player.weapons?.[HP.AUX]?.length || 0);
  ship.ciws.forEach((c,i)=>{
    if(i >= activeCIWS) return;
    const ang = interpCIWSAngles[i];
    const loadout = Game.player.weapons?.[HP.AUX]?.[i];
    const isLaser = loadout?.weapon?.id === 'laser_pd_mk1';
    const baseColor = isLaser ? '#7cc6ff' : '#b8bcc6';
    const barrelColor = isLaser ? '#e6f6ff' : '#d0d0d0';
    ctx.save();
    ctx.translate(c.offset.x, c.offset.y);
    ctx.rotate(ang - interpAngle);
    if(isLaser){
      ctx.shadowColor = 'rgba(90,180,255,0.4)';
      ctx.shadowBlur = 8 * spriteScale;
    }
    ctx.fillStyle = baseColor;
    roundRect(ctx, -ciwsBase/2, -ciwsBase/2, ciwsBase, ciwsBase, 2); ctx.fill();
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(30,50,90,0.45)'; ctx.stroke();
    ctx.fillStyle = barrelColor;
    roundRect(ctx, ciwsBase/2, -ciwsBarrelH/2, ciwsBarrelLen, ciwsBarrelH, 2); ctx.fill(); ctx.stroke();
    ctx.restore();
  });

  // wieżyczki podwójne z recoilem
  const baseW = 16 * spriteScale,
        baseH = 24 * spriteScale,
        barrelLen = Math.max(14 * spriteScale, Math.round(visualH * 0.16)) / 2,
        barrelH = 6 * spriteScale,
        gap = 10 * spriteScale; // trochę dłuższe
  const turrets = [
    { t: ship.turret,  ang: interpTurretAngle },
    { t: ship.turret2, ang: interpTurretAngle2 },
    { t: ship.turret3, ang: interpTurretAngle3 },
    { t: ship.turret4, ang: interpTurretAngle4 }
  ];
  const mainWeaponLoadouts = Game.player.weapons?.[HP.MAIN] || [];
  turrets.forEach(({ t, ang }, index) => {
    ctx.save();
    ctx.translate(t.offset.x, t.offset.y);
    ctx.rotate(ang - interpAngle);
    const recoil = t.recoil * spriteScale;
    const loadout = mainWeaponLoadouts[index];
    const behavior = getMainWeaponBehaviorForWeaponId(loadout?.weapon?.id);
    const barrelsPerShot = Math.max(1, behavior.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot);

    if(barrelsPerShot === 1){
      const housingW = 20 * spriteScale;
      const housingH = 30 * spriteScale;
      const barrelL = Math.max(20 * spriteScale, Math.round(visualH * 0.22));
      const barrelThickness = 8 * spriteScale;
      ctx.fillStyle = '#7f8fb7';
      roundRect(ctx, -housingW/2, -housingH/2, housingW, housingH, 6 * spriteScale); ctx.fill();
      ctx.lineWidth = 1.4; ctx.strokeStyle = 'rgba(24,38,68,0.55)'; ctx.stroke();
      ctx.fillStyle = '#aebce0';
      roundRect(ctx, -housingW/2 + 3 * spriteScale, -housingH/2 + 4 * spriteScale, housingW - 6 * spriteScale, housingH - 8 * spriteScale, 5 * spriteScale); ctx.fill();
      ctx.fillStyle = 'rgba(255,180,110,0.8)';
      roundRect(ctx, -housingW/2 + 2.5 * spriteScale, -2 * spriteScale, housingW * 0.42, 4 * spriteScale, 2 * spriteScale); ctx.fill();
      ctx.strokeStyle = 'rgba(24,38,68,0.55)';
      ctx.fillStyle = '#d9dde9';
      roundRect(ctx, 8 * spriteScale - recoil, -barrelThickness/2, barrelL, barrelThickness, 3 * spriteScale); ctx.fill(); ctx.stroke();
      ctx.fillStyle = '#f0b97a';
      ctx.beginPath();
      ctx.moveTo(8 * spriteScale - recoil + barrelL, -barrelThickness/2);
      ctx.lineTo(8 * spriteScale - recoil + barrelL + 6 * spriteScale, 0);
      ctx.lineTo(8 * spriteScale - recoil + barrelL, barrelThickness/2);
      ctx.closePath();
      ctx.fill();
    } else {
      ctx.fillStyle = '#9ab7ff'; roundRect(ctx, -baseW/2, -baseH/2, baseW, baseH, 5 * spriteScale); ctx.fill();
      ctx.lineWidth = 1.2; ctx.strokeStyle = 'rgba(30,50,90,0.45)'; ctx.stroke();
      ctx.fillStyle = '#c0c0c0';
      roundRect(ctx, 6*spriteScale - recoil, -gap/2 - barrelH/2, barrelLen, barrelH, 3 * spriteScale); ctx.fill(); ctx.stroke();
      roundRect(ctx, 6*spriteScale - recoil,  gap/2 - barrelH/2, barrelLen, barrelH, 3 * spriteScale); ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  });
  ctx.restore(); // ship

  // scan arrows pointing to stations
  if(warp.state !== 'active'){
    const shieldR = Math.max(visualW, visualH) * 0.6;
    for(const a of scanArrows){
      const st = a.target;
      const dx = st.x - ship.pos.x;
      const dy = st.y - ship.pos.y;
      const ang = Math.atan2(dy, dx);
      const baseR = shieldR + 10;
      const ax = ship.pos.x + Math.cos(ang) * baseR;
      const ay = ship.pos.y + Math.sin(ang) * baseR;
      const s = worldToScreen(ax, ay, cam);
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(ang);
      const size = 18 * camera.zoom;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(120,200,255,0.9)';
      ctx.moveTo(0, -size*0.5);
      ctx.lineTo(size, 0);
      ctx.lineTo(0, size*0.5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      const tx = ship.pos.x + Math.cos(ang) * (baseR + 14);
      const ty = ship.pos.y + Math.sin(ang) * (baseR + 14);
      const ts = worldToScreen(tx, ty, cam);
      ctx.save();
      ctx.fillStyle = '#dfe7ff';
      ctx.font = `${12*camera.zoom}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${Math.round(Math.hypot(dx,dy))}u`, ts.x, ts.y);
      ctx.restore();
    }
  }

  // mercenary mission arrow towards pirate station
  if(mercMission && mercMission.station){
    const st = mercMission.station;
    const dx = st.x - ship.pos.x;
    const dy = st.y - ship.pos.y;
    const dist = Math.hypot(dx, dy);
    if(dist > 1){
      const ang = Math.atan2(dy, dx);
      const shipScreen = worldToScreen(ship.pos.x, ship.pos.y, cam);
      const distScreen = dist * camera.zoom;
      const maxRadius = Math.max(160, Math.min(W, H) * 0.5 - 60);
      const baseMinRadius = (visualH * 0.5 + 80) * camera.zoom;
      const minRadius = Math.min(baseMinRadius, maxRadius);
      let arrowRadius = distScreen;
      arrowRadius = Math.max(arrowRadius, minRadius);
      arrowRadius = Math.min(arrowRadius, maxRadius);
      const ax = shipScreen.x + Math.cos(ang) * arrowRadius;
      const ay = shipScreen.y + Math.sin(ang) * arrowRadius;

        // shrink + auto-hide when close to station
        const HIDE_DIST = st.r + 600; // znikaj przy podejściu
        if (dist > HIDE_DIST) {
          const baseArrowLength = (ship.h / camera.zoom) * 0.45;
          const arrowLength = clamp(baseArrowLength, 18, 42);
          const arrowWidth = arrowLength * 0.26;
          const strokeW = clamp(2.5 / camera.zoom, 1.2, 5);

          ctx.save();
          ctx.translate(ax, ay);
          ctx.rotate(ang);
          ctx.beginPath();
          ctx.moveTo(arrowLength * 0.5, 0);
          ctx.lineTo(-arrowLength * 0.5, -arrowWidth * 0.5);
          ctx.lineTo(-arrowLength * 0.5, arrowWidth * 0.5);
          ctx.closePath();
          ctx.fillStyle = 'rgba(255,90,90,0.92)';
          ctx.shadowColor = 'rgba(255,120,120,0.6)';
          ctx.shadowBlur = 14;
          ctx.fill();
          ctx.lineWidth = strokeW;
          ctx.strokeStyle = 'rgba(10,0,0,0.55)';
          ctx.stroke();
          ctx.restore();

          const labelDist = arrowLength * 0.45;
          const labelX = ax + Math.cos(ang) * labelDist;
          const labelY = ay + Math.sin(ang) * labelDist;
          const fontSize = Math.round(clamp(16 / camera.zoom, 10, 26));
          ctx.save();
          ctx.fillStyle = '#ffd1d1';
          ctx.font = `bold ${fontSize}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText('PIRACKA STACJA', labelX, labelY - 6);
          ctx.textBaseline = 'top';
          ctx.fillText(`${Math.round(dist)} u`, labelX, labelY + 6);
          ctx.restore();
        }
    }
  }

  // Particles typu "flash" na samym wierzchu
  {
    let drawn = 0;
    for (let i = particles.length - 1; i >= 0 && drawn < MAX_PARTICLES_DRAW; i--){
      const p = particles[i];
      if (!p.flash) continue;
      drawn++;
      const s = worldToScreen(p.pos.x, p.pos.y, cam);
      const t = clamp(1 - p.age/p.life, 0, 1);
      ctx.globalAlpha = t;
      ctx.save();
      ctx.shadowBlur = 20 * camera.zoom * (p.size/2);
      let shadowColor = p.color;
      if(p.color === '#bfe7ff') shadowColor = 'rgba(120,200,255,0.9)';
      if(p.color === '#ffd8c4') shadowColor = 'rgba(255,180,120,0.9)';
      if(p.color === '#7CFF7C' || p.color === '#a8ff9a') shadowColor = 'rgba(120,255,140,0.95)';
      if(p.color === '#ffffff') shadowColor = 'rgba(255,255,255,0.95)';
      ctx.shadowColor = shadowColor;
      ctx.beginPath(); ctx.fillStyle = p.color;
      ctx.arc(s.x, s.y, (p.size * 3) * camera.zoom, 0, Math.PI*2); ctx.fill();
      ctx.restore();
      ctx.beginPath(); ctx.fillStyle = p.color;
      ctx.arc(s.x, s.y, p.size * camera.zoom, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  if (HUD_SHOW_LEGACY) {
    // HUD
    ctx.fillStyle = '#dfe7ff'; ctx.font = '12px monospace';
    ctx.fillText(`HP: ${Math.round(ship.hull.val)}/${ship.hull.max}`, 12, H-100);
    ctx.fillText(`Shield: ${Math.round(ship.shield.val)}/${ship.shield.max}`, 12, H-84);
    const warpText = warp.state==='active' ? `ACTIVE`
                    : warp.state==='charging' ? `CHARGING ${(Math.min(1,warp.charge/warp.chargeTime)*100).toFixed(0)}%`
                    : 'READY';
    ctx.fillText(`Warp: ${warpText}`, 12, H-68);
    const fw = 200, fh = 10, ffrac = warp.fuel/warp.fuelMax;
    ctx.strokeStyle = 'rgba(255,255,255,0.14)'; ctx.strokeRect(12-1, H-52-fh, fw+2, fh+2);
    ctx.fillStyle = '#60a5fa'; ctx.fillRect(12, H-52-fh, fw*ffrac, fh);
    ctx.fillStyle = '#dfe7ff'; ctx.fillText(`${warp.fuel.toFixed(1)}s / ${warp.fuelMax}s`, 12 + fw + 8, H-42-fh);
    const boosting = boost.state==='active' && boost.fuel > 0;
    const fullyCharged = boost.fuel >= boost.fuelMax - 0.01;
    const boostText = boosting ? 'ACTIVE' : (fullyCharged ? 'READY' : 'REFILLING');
    ctx.fillText(`Boost: ${boostText} (${boost.fuel.toFixed(1)}/${boost.fuelMax})`, 12, H-44);
    const railTimerHUD = (Math.max(1, rail.barrelsPerShot || 2) > 1)
      ? Math.min(rail.cd[0], rail.cd[1])
      : rail.cd[0];
    ctx.fillText(`Rail: ${railTimerHUD>0?railTimerHUD.toFixed(2)+'s':'READY'}  Special: ${ship.special.cooldownTimer>0?ship.special.cooldownTimer.toFixed(1)+'s':'READY'}`, 12, H-28);

    // rocket ammo
    const bw = 160, bh = 10;
    const ammoFrac = rocketAmmoMax > 0 ? rocketAmmo / rocketAmmoMax : 0;
    ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.strokeRect(12-1, H-12-bh-12, bw+2, bh+2);
    ctx.fillStyle = '#3b82f6'; ctx.fillRect(12, H-12-bh-12, bw*ammoFrac, bh);
    ctx.fillStyle = '#dfe7ff'; ctx.fillText(`Rockets: ${rocketAmmo}`, 12 + bw + 8, H-12-bh-6-12);
  }

  if(mercMission && mercMission.station){
    const st = mercMission.station;
    const panelPadding = 24;
    const barW = 220;
    const barH = 10;
    let y = 36;
    const xRight = W - panelPadding;
    ctx.save();
    ctx.textAlign = 'right';
    ctx.fillStyle = '#ffd1d1';
    ctx.fillText('Piracka stacja', xRight, y);
    ctx.fillStyle = '#dfe7ff';
    y += 8;
    if(st.shield){
      const shieldFrac = clamp(st.shield.val / st.shield.max, 0, 1);
      ctx.fillText(`Osłony: ${Math.round(st.shield.val)}/${st.shield.max}`, xRight, y + 10);
      const bx = xRight - barW;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.strokeRect(bx - 1, y + 14, barW + 2, barH + 2);
      ctx.fillStyle = '#60a5fa';
      ctx.fillRect(bx, y + 15, barW * shieldFrac, barH);
      ctx.fillStyle = '#dfe7ff';
      y += 32;
    }
    const hullFrac = clamp(st.hp / st.maxHp, 0, 1);
    ctx.fillText(`Kadłub: ${Math.round(st.hp)}/${st.maxHp}`, xRight, y + 10);
    const bx = xRight - barW;
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.strokeRect(bx - 1, y + 14, barW + 2, barH + 2);
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(bx, y + 15, barW * hullFrac, barH);
    ctx.restore();
  }

  if(showMap) drawSectorMap();
  renderStationUI();
  renderOptions();
  renderMissionJournal();
  renderMissionCompleteBanner();
  mouse.click=false;
}

function renderMissionCompleteBanner(){
  if(!missionCompleteBanner.active) return;
  const alpha = missionCompleteBanner.alpha();
  if(alpha <= 0) return;

  ctx.save();
  ctx.resetTransform();
  ctx.translate(W/2, H*0.32);
  const scale = 1 + 0.08 * Math.sin(missionCompleteBanner.progress() * Math.PI);
  ctx.scale(scale, scale);
  ctx.globalAlpha = alpha;

  const fontSize = Math.round(Math.min(W, H) * 0.08);
  ctx.font = `700 ${fontSize}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = 'rgba(80,180,255,0.85)';
  ctx.shadowBlur = Math.max(14, fontSize * 0.2);
  ctx.lineJoin = 'round';

  const strokeWidth = Math.max(2, fontSize * 0.05);
  ctx.lineWidth = strokeWidth;
  ctx.strokeStyle = 'rgba(10,20,40,0.6)';
  ctx.strokeText(missionCompleteBanner.text, 0, 0);

  ctx.fillStyle = '#ffffff';
  ctx.fillText(missionCompleteBanner.text, 0, 0);

  ctx.restore();
}

function drawSectorMap(){
  const mapW = 600;
  const mapH = Math.round(mapW * WORLD.h / WORLD.w);
  const x0 = (W - mapW) / 2;
  const y0 = (H - mapH) / 2;
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = 'rgba(26,26,26,0.8)';
  ctx.fillRect(x0, y0, mapW, mapH);
  ctx.strokeStyle = '#dfe7ff';
  ctx.lineWidth = 2;
  ctx.strokeRect(x0, y0, mapW, mapH);
  const sx = mapW / WORLD.w;
  const sy = mapH / WORLD.h;

  ctx.fillStyle = '#ffd966';
  ctx.beginPath();
  ctx.arc(x0 + SUN.x * sx, y0 + SUN.y * sy, 6, 0, Math.PI*2);
  ctx.fill();

  if (ASTEROID_BELT) {
    const cx = x0 + SUN.x * sx;
    const cy = y0 + SUN.y * sy;
    const outerRx = ASTEROID_BELT.outer * sx;
    const outerRy = ASTEROID_BELT.outer * sy;
    const innerRx = ASTEROID_BELT.inner * sx;
    const innerRy = ASTEROID_BELT.inner * sy;
    ctx.save();
    ctx.fillStyle = 'rgba(168, 182, 204, 0.18)';
    ctx.beginPath();
    ctx.ellipse(cx, cy, outerRx, outerRy, 0, 0, Math.PI*2);
    ctx.ellipse(cx, cy, innerRx, innerRy, 0, 0, Math.PI*2);
    ctx.fill('evenodd');
    ctx.strokeStyle = 'rgba(168, 182, 204, 0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.ellipse(cx, cy, outerRx, outerRy, 0, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(cx, cy, innerRx, innerRy, 0, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  if (Array.isArray(planets) && planets.length) {
    ctx.save();

    const markerRadius = 6;
    ctx.fillStyle = '#7dd3fc';
    for (const planet of planets) {
      const px = x0 + planet.x * sx;
      const py = y0 + planet.y * sy;
      ctx.beginPath();
      ctx.arc(px, py, markerRadius, 0, Math.PI * 2);
      ctx.fill();
    }

    const labelFont = Math.max(12, Math.round(mapW * 0.028));
    ctx.font = `600 ${labelFont}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.lineWidth = Math.max(1.5, labelFont * 0.12);
    ctx.strokeStyle = 'rgba(10, 16, 34, 0.85)';
    ctx.fillStyle = '#f8fafc';

    for (const planet of planets) {
      const name = typeof planet.label === 'string' ? planet.label.trim() : '';
      if (!name) continue;
      const px = x0 + planet.x * sx;
      const py = y0 + planet.y * sy;
      const labelY = py + markerRadius + 6;
      ctx.strokeText(name, px, labelY);
      ctx.fillText(name, px, labelY);
    }

    ctx.restore();
  }

  ctx.fillStyle = '#60a5fa';
  for(const st of stations){
    ctx.beginPath();
    ctx.arc(x0 + st.x * sx, y0 + st.y * sy, 4, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.fillStyle = '#ffffff';
  ctx.beginPath();
  ctx.arc(x0 + ship.pos.x * sx, y0 + ship.pos.y * sy, 4, 0, Math.PI*2);
  ctx.fill();

  // Markery misji (X) dla aktywnych z pozycją
  ctx.strokeStyle = '#ff4d4d';
  ctx.lineWidth = 3;
  for(const m of MISSIONS.active){
    if(m.status !== 'active' || !m.pos) continue;
    const px = x0 + m.pos.x * sx;
    const py = y0 + m.pos.y * sy;
    const s = 8;
    ctx.beginPath();
    ctx.moveTo(px - s, py - s); ctx.lineTo(px + s, py + s);
    ctx.moveTo(px - s, py + s); ctx.lineTo(px + s, py - s);
    ctx.stroke();
  }

  ctx.restore();
}

// =============== Helpers ===============
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
function roundRectScreen(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

function screenToWorld(sx, sy){
  return { x: ship.pos.x + (sx - W/2)/camera.zoom, y: ship.pos.y + (sy - H/2)/camera.zoom };
}

// --- MINI UI HELPERS (HUD) ---
let hudOffset = {x:40, y:46};
function hudBeginPanel(x=24, y=24, w=450, h=520){
  ctx.save();
  ctx.resetTransform();
  ctx.fillStyle='rgba(0,0,0,0.55)';
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle='rgba(255,255,255,0.08)';
  ctx.fillRect(x, y, w, 24);
  ctx.translate(x+16, y+46);
  hudOffset.x = x+16;
  hudOffset.y = y+46;
  ctx.fillStyle='#E6F2FF';
  ctx.font='16px monospace';
}
function hudEndPanel(){ ctx.restore(); }
function uiTitle(t){ ctx.font='20px monospace'; ctx.fillText(t,0,0); ctx.translate(0,28); ctx.font='16px monospace'; }
function section(t){ ctx.translate(0,12); ctx.globalAlpha=0.8; ctx.fillText('— '+t,0,0); ctx.globalAlpha=1; ctx.translate(0,18); }
function uiText(t){ ctx.fillText(t,0,0); ctx.translate(0,18); }
function hudTabs(names, active){
  let x = 0, clicked = null;
  for (let i = 0; i < names.length; i++) {
    const label = '[' + names[i] + ']';
    const w = ctx.measureText(label).width;
    const t = ctx.getTransform();
    const L = t.e + x, T = t.f - 14, R = L + w, B = T + 20;

    ctx.fillStyle = names[i]===active ? '#fff' : '#a8c0ff';
    ctx.fillText(label, x, 0);

    const over = mouse.x>L && mouse.x<R && mouse.y>T && mouse.y<B;
    if (over) canvas.style.cursor = 'pointer';
    if (over && mouse.click) clicked = names[i];

    x += ctx.measureText(label+'  ').width;
  }
  ctx.translate(0, 28);
  ctx.fillStyle = '#E6F2FF';
  if (clicked){ stationUI.tab = clicked; mouse.click = false; }
}
function uiRowButton(label, btn){
  ctx.fillText(label, 0, 0);
  const w=96,h=20,x=320,y=-14;
  ctx.strokeStyle='#cfe3ff'; ctx.strokeRect(x,y,w,h); ctx.fillText(btn, x+10, 0);

  const t = ctx.getTransform();
  const L=t.e+x, T=t.f+y, R=L+w, B=T+h;
  const over = mouse.x>L && mouse.x<R && mouse.y>T && mouse.y<B;
  if (over) canvas.style.cursor = 'pointer';
  const clicked = over && mouse.click;

  ctx.translate(0,22);
  if (clicked) mouse.click = false;
  return clicked;
}
function slider(label, min,max, step, obj, key){
  ctx.fillText(`${label}: ${obj[key].toFixed(2)}`,0,0); ctx.translate(0,18);
  // do prostoty – klawiszami [ i ] zmieniasz ostatni slider; lub klik + ruch (opcjonalnie)
  // Możesz podpiąć realny input według swojej architektury.
}
function toast(t){ /* opcjonalnie dopisz do kolejki komunikatów HUD */ }
function applyShipStats(s){
  ship.hull.max = Math.round(ship.hull.max * s.hp);
  ship.hull.val = Math.min(ship.hull.val, ship.hull.max);

  const speedMul = s.speed;
  ship.engines.main.maxThrust      = Math.round(ship.engines.main.maxThrust * speedMul);
  ship.engines.sideLeft.maxThrust  = Math.round(ship.engines.sideLeft.maxThrust * speedMul);
  ship.engines.sideRight.maxThrust = Math.round(ship.engines.sideRight.maxThrust * speedMul);
  ship.engines.torqueLeft.maxThrust  = Math.round(ship.engines.torqueLeft.maxThrust * speedMul);
  ship.engines.torqueRight.maxThrust = Math.round(ship.engines.torqueRight.maxThrust * speedMul);

  ship.cargoCap = Math.round((ship.cargoCap || 20) * s.cargo);
}

function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1, y2-y1); }
function limitSpeed(n, max){
  const vx = n.vel ? n.vel.x : n.vx;
  const vy = n.vel ? n.vel.y : n.vy;
  const v = Math.hypot(vx, vy);
  if(v>max){
    const s = max/v;
    if(n.vel){ n.vel.x*=s; n.vel.y*=s; }
    else { n.vx*=s; n.vy*=s; }
  }
}
function steerToward(n, tx, ty, dt, accel = n.accel, turnRate = n.turn) {
  const desired = Math.atan2(ty - n.y, tx - n.x);
  const diff = wrapAngle(desired - n.angle);
  const turn = clamp(diff, -turnRate * dt, turnRate * dt);
  n.angle = wrapAngle(n.angle + turn);
  n.vx += Math.cos(n.angle) * accel * dt;
  n.vy += Math.sin(n.angle) * accel * dt;
  limitSpeed(n, n.maxSpeed);
}

function chaseEvadeAI(n, target, opts = {}) {
  steerToward(n, target.pos.x, target.pos.y, 0.016);

  if (opts.strafe) {
    const side = (Math.random() < 0.5 ? -1 : 1);
    const ang = n.angle + side * Math.PI / 2;
    n.vx += Math.cos(ang) * n.accel * 0.004;
    n.vy += Math.sin(ang) * n.accel * 0.004;
  }
}

function dogfightAI(n, target) {
  chaseEvadeAI(n, target, { strafe: true });
}

function battleshipAI(n, target) {
  const d = Math.hypot(target.pos.x - n.x, target.pos.y - n.y);
  if (d < 600) {
    const ang = Math.atan2(n.y - target.pos.y, n.x - target.pos.x);
    n.vx += Math.cos(ang) * n.accel * 0.016;
    n.vy += Math.sin(ang) * n.accel * 0.016;
    limitSpeed(n, n.maxSpeed);
  } else {
    chaseEvadeAI(n, target);
  }
}
function useRailPair(n, target){ /* sprawdź kąt i cooldown, odpal pary */ }
function useRocketsPair(n, target){ /* salwy */ }
function useCIWSPair(n, target){ /* krótka seria */ }
function maybeFireRockets(n, target){ /* warunkowo */ }

// init
const loadingEl = document.getElementById('loading');
function startGame(){
  initStars(true);
  initNPCs();
  for(let i=0;i<120;i++) npcStep(PHYS_DT);
  loadingEl.style.display = 'none';
  lastTime = performance.now();
  requestAnimationFrame(loop);
  console.log('Gwiazdy: proceduralne kafelki 1024px na całej mapie. Silnik: warkocz jonowy, dopalacz: wiązka fotonów.');
}
setTimeout(startGame, 500);

(function wireDevTools(){
  const saveLS = () => { window.__devtoolsSaveLS?.(); };
  const elUnlimited = document.getElementById('dt-unlimited-warp');
  const elRuler     = document.getElementById('dt-show-ruler');
  const elScale     = document.getElementById('dt-pirate-scale');
  const elScaleVal  = document.getElementById('dt-pirate-scale-value');
  const elStation3DScale = document.getElementById('dt-station3d-scale');
  const elStation3DScaleVal = document.getElementById('dt-station3d-scale-value');
  const elPlanet3D  = document.getElementById('dt-use-planet-stations');
  const elPir3D     = document.getElementById('dt-use-3d-pirate');
  const elSunDir    = document.getElementById('dt-show-sundir');

  if (elUnlimited) {
    elUnlimited.checked = !!DevFlags.unlimitedWarp;
    elUnlimited.addEventListener('change', e => {
      DevFlags.unlimitedWarp = e.target.checked;
      if (DevFlags.unlimitedWarp) warp.fuel = warp.fuelMax;
      const legacyUnlimited = document.getElementById('toggleUnlimitedWarp');
      if (legacyUnlimited) legacyUnlimited.checked = DevFlags.unlimitedWarp;
    });
  }
  if (elRuler) {
    elRuler.checked = !!DevFlags.showRuler;
    elRuler.addEventListener('change', e => {
      DevFlags.showRuler = e.target.checked;
      const legacyRuler = document.getElementById('toggleRuler');
      if (legacyRuler) legacyRuler.checked = DevFlags.showRuler;
    });
  }

  if (elSunDir) {
    elSunDir.checked = !!(window.DevFlags && DevFlags.showSunDir);
    elSunDir.addEventListener('change', e => {
      if (!window.DevFlags) window.DevFlags = {};
      DevFlags.showSunDir = !!e.target.checked;
      if (typeof scheduleRebuild3D === 'function') scheduleRebuild3D();
      saveLS();
    });
  }

  const applyScale = () => {
    if (!elScale) return;
    const v = parseFloat(elScale.value);
    DevTuning.pirateStationScale = isFinite(v) ? v : 1.0;
    if (window.DevConfig) {
      window.DevConfig.pirateScale = DevTuning.pirateStationScale;
    }
    const legacyScale = document.getElementById('pirScale');
    if (legacyScale) legacyScale.value = String(DevTuning.pirateStationScale);
    const legacyScaleVal = document.getElementById('pirScaleVal');
    if (legacyScaleVal) legacyScaleVal.textContent = '×' + DevTuning.pirateStationScale.toFixed(2);
    if (elScaleVal) elScaleVal.textContent = DevTuning.pirateStationScale.toFixed(2);
  };

  const applyStation3DScale = (inputValue) => {
    const parsed = Number(inputValue);
    const value = Number.isFinite(parsed) ? parsed : 1;
    DevTuning.pirateStationScale = value;
    Dev.station3DScale = value;
    if (window.DevConfig) {
      window.DevConfig.station3DScale = value;
    }
    if (window.USE_STATION_3D && typeof window.__setStation3DScale === 'function') {
      __setStation3DScale(value);
    }
    if (elStation3DScaleVal) elStation3DScaleVal.textContent = value.toFixed(2);
    const legacy = document.getElementById('station3DScale');
    const legacyVal = document.getElementById('station3DScaleVal');
    if (legacy) legacy.value = String(value);
    if (legacyVal) legacyVal.textContent = '×' + value.toFixed(2);
  };

  // Ustaw wartość z DevConfig (jeśli jest) i natychmiast zastosuj na starcie
  if (elStation3DScale) {
    const initial =
      (window.DevConfig && Number.isFinite(DevConfig.station3DScale) && DevConfig.station3DScale) ||
      (Number.isFinite(+elStation3DScale.value) ? +elStation3DScale.value : 1);
    elStation3DScale.value = String(initial);
    applyStation3DScale(initial);
    if (typeof scheduleRebuild3D === 'function') scheduleRebuild3D();
  }

  if (elScale) {
    if (!isFinite(parseFloat(elScale.value))) {
      elScale.value = String(DevTuning.pirateStationScale);
    }
    elScale.addEventListener('input', applyScale);
    elScale.addEventListener('change', applyScale);
    applyScale();
  } else if (elScaleVal) {
    elScaleVal.textContent = DevTuning.pirateStationScale.toFixed(2);
  }

  if (elStation3DScale) {
    if (!isFinite(parseFloat(elStation3DScale.value))) {
      elStation3DScale.value = String(DevTuning.pirateStationScale);
    }
    applyStation3DScale(elStation3DScale.value);
    elStation3DScale.addEventListener('input', e => applyStation3DScale(e.target.value));
    elStation3DScale.addEventListener('change', e => applyStation3DScale(e.target.value));
  } else if (elStation3DScaleVal) {
    elStation3DScaleVal.textContent = DevTuning.pirateStationScale.toFixed(2);
  }

  if (elPlanet3D) {
    const stored = typeof DevFlags.usePlanetStations3D === 'boolean'
      ? DevFlags.usePlanetStations3D
      : window.USE_PLANET_STATIONS_3D !== false;
    const enabled = stored !== false;
    DevFlags.usePlanetStations3D = enabled;
    window.USE_PLANET_STATIONS_3D = enabled;
    elPlanet3D.checked = enabled;
    elPlanet3D.addEventListener('change', (e) => {
      const value = !!e.target.checked;
      DevFlags.usePlanetStations3D = value;
      window.USE_PLANET_STATIONS_3D = value;
      if (Array.isArray(window.stations) && typeof window.updateStations3D === 'function') {
        window.updateStations3D(window.stations);
      }
      saveLS();
    });
  }

  if (elPir3D){
    if (typeof DevFlags.use3DPirateStation === 'boolean') {
      window.USE_STATION_3D = DevFlags.use3DPirateStation;
    }
    elPir3D.checked = window.USE_STATION_3D !== false;
    elPir3D.addEventListener('change', e=>{
      if (!window.DevFlags) window.DevFlags = {};
      DevFlags.use3DPirateStation = e.target.checked;
      window.USE_STATION_3D = e.target.checked;
      if (window.USE_STATION_3D && window.__setStation3DScale && typeof Dev.station3DScale === 'number') {
        __setStation3DScale(Dev.station3DScale);
      }
    });
  }
})();
</script>

<!-- === DEVTOOLS (F10) =================================================== -->
<style>
  #devtools{position:fixed; right:16px; top:16px; width:340px; max-height:80vh;
    overflow:auto; padding:14px; border-radius:12px; background:rgba(10,14,25,.92);
    border:1px solid #1b2337; color:#dfe7ff; z-index:1000; font-family:Inter, system-ui, Segoe UI, Roboto, Arial; display:none}
  #devtools h3{margin:0 0 8px 0; font-size:16px; letter-spacing:.04em; text-transform:uppercase; color:#8fb5ff}
  #devtools .group{margin:12px 0; padding:10px; background:#0b0f1a; border:1px solid #1b2337; border-radius:10px}
  #devtools .row{display:flex; align-items:center; gap:8px; margin:6px 0}
  #devtools .row label{flex:1}
  #devtools input[type=range]{width:180px}
  #devtools .val{min-width:64px; text-align:right; font-variant-numeric: tabular-nums}
  #devtools .small{opacity:.7; font-size:12px}
  #devtools .pill{display:inline-block; padding:2px 8px; border:1px solid #2a3a5a; border-radius:999px; background:#0a1020}
  #devtools textarea{width:100%; height:90px; background:#0b1224; color:#dfe7ff; border:1px solid #2a3a5a; border-radius:8px; padding:8px}
  #devtools .muted{color:#9fb0d8}
  #devtools .dt-row{display:flex; gap:8px; margin-top:6px}
  #devtools .dt-col{display:flex; flex-direction:column}
  #devtools .dt-stack{display:flex; flex-direction:column}
  #devtools .dt-btn{padding:4px 8px; border:1px solid #2a3a5a; border-radius:8px; background:#0a1020; color:#dfe7ff; cursor:pointer}
  #devtools .dt-btn:hover{background:#18233c}
  #devtools .dt-label{font-size:12px; font-weight:600; letter-spacing:.04em; text-transform:uppercase; color:#9fb0d8}
</style>

<div id="devtools">
  <h3>DevTools</h3>

  <div class="group">
    <div class="row"><strong>Wszechświat</strong></div>
    <div class="row">
      <label>Słońce – promień (R)</label>
      <input id="sunR" type="range" min="50" max="1500" step="1">
      <div class="val" id="sunRVal"></div>
    </div>
    <div class="row">
      <label>Planety – skala globalna (×)</label>
      <input id="planetScaleAll" type="range" min="0.5" max="3" step="0.01">
      <div class="val" id="planetScaleAllVal"></div>
    </div>
  </div>

  <div class="group" id="planetsGroup">
    <div class="row"><strong>Planety (R)</strong> <span class="small muted">(per-planeta)</span></div>
    <!-- Tu JS doda po 1 wierszu na planetę -->
  </div>

  <!-- === Dystanse od Słońca (AU → promień orbity) ======================== -->
  <div class="group" id="distancesGroup">
    <div class="row">
      <strong>Dystanse od Słońca</strong>
      <span class="small muted">(AU → promień orbity)</span>
    </div>
    <!-- Wiersze z suwakami będą dodane przez buildDistancesUI() -->
  </div>

  <div class="group">
    <div class="row"><strong>Stacje</strong></div>
    <div class="row">
      <label>Skala stacji pirackiej (×)</label>
      <input id="pirScale" type="range" min="0.4" max="12" step="0.01">
      <div class="val" id="pirScaleVal"></div>
    </div>
    <div class="row">
      <label>Skala stacji 3D (×)</label>
      <input id="station3DScale" type="range" min="0.2" max="12.0" step="0.05" value="6.0">
      <div class="val" id="station3DScaleVal"></div>
    </div>
    <div class="row">
      <label>Stacja 3D – rozmiar sprite (px)</label>
      <input id="stationSpritePx" type="number" min="64" max="4096" step="32" value="512" style="width:96px;">
    </div>
    <div class="dt-row">
      <div class="dt-col">
        <div class="dt-label" style="margin-top:6px;">Skala per stacja</div>
        <div id="dt-stations-per-scale" class="dt-stack" style="gap:6px;"></div>
        <button id="dt-reset-station-scales" class="dt-btn" style="margin-top:6px;">Reset per stacja</button>
      </div>
    </div>
    <label style="display:flex;gap:6px;align-items:center;margin-top:8px">
      <input id="dt-use-planet-stations" type="checkbox" />
      Planet Stations 3D (overlay)
    </label>
    <label style="display:flex;gap:6px;align-items:center;margin-top:8px">
      <input id="dt-use-3d-pirate" type="checkbox" />
      3D Pirate Station (hide 2D)
    </label>
  </div>

  <div class="group" id="stationsFramesGroup">
    <div class="row"><strong>Stacje (kadr per stacja)</strong></div>
    <!-- Wiersze z suwakami per stacja będą dodane dynamicznie przez buildStationFramesUI() -->
  </div>

  <div class="group">
    <div class="row">
      <label><input id="toggleRuler" type="checkbox"> Miarka (okręgi dystansu) <span class="pill">F11</span></label>
    </div>
    <div class="row">
      <label><input id="toggleUnlimitedWarp" type="checkbox"> Nielimitowany warp <span class="pill">F9</span></label>
    </div>
    <div class="row">
      <label><input id="dt-show-sundir" type="checkbox"> Pokaż kierunek słońca</label>
    </div>
  </div>

  <div class="group">
    <div class="row"><strong>Konfiguracja</strong></div>
    <div class="row">
      <button id="btnCopy">Kopiuj aktualną konfigurację</button>
      <button id="btnReset" style="margin-left:auto">Reset</button>
    </div>
    <div class="row"><textarea id="cfgOut" readonly></textarea></div>
    <div class="small muted">Skopiuj JSON i wklej do kodu (np. stałe R), gdy chcesz utrwalić w repo.</div>
  </div>

  <div class="small muted">F10 — pokaż/ukryj panel</div>
</div>
<!-- ====================================================================== -->

<script>
(function(){
  // === Wczytaj podstawowe obiekty gry (muszą już istnieć globalnie): SUN, planets, initPlanets3D ===
  // Zakładamy: let SUN = {...}, let planets = [...]; render pętla już działa.

  // ---- Stan & persistencja ------------------------------------------------
  const DevConfig = {
    sunR: null,                 // liczba — promień Słońca (SUN.r)
    planetRById: {},            // { [id or name]: R }
    planetOrbitAUById: {},      // { [id or name]: AU }
    planetScaleAll: DEFAULT_PLANET_SCALE,          // mnożnik globalny ×R
    pirateScale: DEFAULT_STATION_SCALE,           // mnożnik rysowania stacji pirackiej
    station3DScale: DEFAULT_STATION_SCALE,        // mnożnik nakładki 3D
    stationSpriteSize: 512,
    stationSpriteFrame: 1.25,
    stationSpriteFrameById: {},
    stationScaleById: {},
  };
  const DevFlags = window.DevFlags;
  window.DevConfig = DevConfig;

  // ---- Elementy UI --------------------------------------------------------
  const el = (id)=>document.getElementById(id);
  const ui = {
    root: el('devtools'),
    sunR: el('sunR'), sunRVal: el('sunRVal'),
    planetScaleAll: el('planetScaleAll'), planetScaleAllVal: el('planetScaleAllVal'),
    pirScale: el('pirScale'), pirScaleVal: el('pirScaleVal'),
    station3DScale: el('station3DScale'), station3DScaleVal: el('station3DScaleVal'),
    stationSpritePx: el('stationSpritePx'),
    stationsFramesGroup: el('stationsFramesGroup'),
    planetsGroup: el('planetsGroup'),
    distancesGroup: el('distancesGroup'),
    cbRuler: el('toggleRuler'),
    cbUnlimited: el('toggleUnlimitedWarp'),
    cbSunDir: el('dt-show-sundir'),
    cbPlanetStations3D: el('dt-use-planet-stations'),
    cbPirate3D: el('dt-use-3d-pirate'),
    btnCopy: el('btnCopy'), btnReset: el('btnReset'),
    cfgOut: el('cfgOut')
  };

  // ---- Inicjalne odczyty z gry -------------------------------------------
  function bootstrapFromGame(){
    const sun = window.SUN;
    if (DevConfig.sunR == null && sun) DevConfig.sunR = sun.r;
    // domyślne per-planeta (key = name lub id)
    const planetList = Array.isArray(window.planets) ? window.planets : [];
    for (const p of planetList) {
      const key = (p.name || p.id || String(p.index)||'').toString().toLowerCase();
      const baseR = p.baseR ?? p.r;
      if (baseR != null && !DevConfig.planetRById[key]) DevConfig.planetRById[key] = baseR;
    }
  }

  function stationKey(st) {
    if (!st) return null;
    if (st.id != null) return String(st.id).toLowerCase();
    if (st.name) return String(st.name).toLowerCase();
    return null;
  }

  // ---- Persistencja -------------------------------------------------------
  function loadLS(){
    try {
      const cfg = JSON.parse(localStorage.getItem('devConfig')||'null');
      const flags = JSON.parse(localStorage.getItem('devFlags')||'null');
      if (cfg && typeof cfg==='object'){
        Object.assign(DevConfig, cfg);
        if (typeof DevConfig.pirateScale === 'number') {
          DevTuning.pirateStationScale = DevConfig.pirateScale;
        }
        if (typeof DevConfig.station3DScale === 'number') {
          Dev.station3DScale = DevConfig.station3DScale;
        }
      }
      if (flags && typeof flags==='object'){
        Object.assign(DevFlags, flags);
      }
    } catch {}
    if (typeof DevFlags.usePlanetStations3D !== 'boolean') {
      DevFlags.usePlanetStations3D = true;
    }
    if (typeof window !== 'undefined') {
      window.USE_PLANET_STATIONS_3D = DevFlags.usePlanetStations3D !== false;
    }
    if (!DevConfig.planetOrbitAUById || typeof DevConfig.planetOrbitAUById !== 'object') {
      DevConfig.planetOrbitAUById = {};
    }
    if (typeof DevConfig.planetScaleAll !== 'number') {
      DevConfig.planetScaleAll = DEFAULT_PLANET_SCALE;
    }
    if (typeof DevConfig.pirateScale !== 'number') {
      DevConfig.pirateScale = DevTuning.pirateStationScale;
    }
    if (typeof DevConfig.station3DScale !== 'number') {
      DevConfig.station3DScale = Dev.station3DScale;
    }
    if (typeof DevConfig.stationSpriteSize !== 'number') {
      let saved = NaN;
      try {
        saved = Number(localStorage.getItem('stationSpriteSize'));
      } catch {}
      DevConfig.stationSpriteSize = Number.isFinite(saved) ? saved : 512;
    }
    if (typeof DevConfig.stationSpriteFrame !== 'number') {
      let saved = NaN;
      try {
        saved = Number(localStorage.getItem('stationSpriteFrame'));
      } catch {}
      DevConfig.stationSpriteFrame = Number.isFinite(saved) ? saved : 1.25;
    }
    if (!DevConfig.stationSpriteFrameById || typeof DevConfig.stationSpriteFrameById !== 'object') {
      try {
        DevConfig.stationSpriteFrameById = JSON.parse(localStorage.getItem('stationSpriteFrameById') || '{}') || {};
      } catch {
        DevConfig.stationSpriteFrameById = {};
      }
    }
    if (!DevConfig.stationScaleById || typeof DevConfig.stationScaleById !== 'object') {
      DevConfig.stationScaleById = {};
    }
    if (window.__setStation3DScale && window.USE_STATION_3D) {
      window.__lastStationScale = 1;
      __setStation3DScale(Dev.station3DScale);
    }
  }
  function saveLS(){
    localStorage.setItem('devConfig', JSON.stringify(DevConfig));
    localStorage.setItem('devFlags', JSON.stringify(DevFlags));
  }
  window.__devtoolsSaveLS = saveLS;

  // ---- Rebuild 3D (throttle) ---------------------------------------------
  let rebuildTimer = null;
  function scheduleRebuild3D(){
    if (rebuildTimer) cancelAnimationFrame(rebuildTimer);
    rebuildTimer = requestAnimationFrame(()=> {
      // aktualizujemy struktury gry na podstawie DevConfig
      SUN.r = DevConfig.sunR|0;
      const scaleAll = +DevConfig.planetScaleAll || DEFAULT_PLANET_SCALE;
      for (const p of planets) {
        const key = (p.name || p.id || String(p.index)||'').toString().toLowerCase();
        const base = DevConfig.planetRById[key] ?? p.baseR ?? p.r;
        if (base != null) {
          p.baseR = base;
          p.r = Math.max(1, Math.round(base * scaleAll));
        }
      }
      // Odbudowa warstwy 3D
      if (typeof initPlanets3D === 'function') initPlanets3D(planets, SUN);
    });
  }

  // ---- Rysowanie miarki ---------------------------------------------------
  window.drawRangeRings = function drawRangeRings(ctx, cam){
    drawRangeRuler(ctx, cam);
  };

  function drawSunDirection(ctx, cam){
    if (!DevFlags.showSunDir) return;
    const planets = Array.isArray(window.planets) ? window.planets : null;
    const sun = (window.SUN || SUN);
    if (!planets || !sun) return;

    const camX = cam?.x ?? 0;
    const camY = cam?.y ?? 0;
    const zoom = cam?.zoom ?? 1;
    const halfW = canvas.width / 2;
    const halfH = canvas.height / 2;

    ctx.save();
    ctx.strokeStyle = '#66c2ff';
    ctx.fillStyle = '#cfe3ff';
    ctx.lineWidth = Math.max(1, 2 * zoom);
    ctx.font = `${Math.max(10, Math.round(12 * zoom))}px monospace`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';

    const dash = Math.max(6, 12 * zoom);
    const labelOffset = 6 * zoom;
    const arrowSize = Math.max(8, 14 * zoom);

    for (const planet of planets) {
      if (!planet || typeof planet.x !== 'number' || typeof planet.y !== 'number') continue;

      const dx = (sun.x ?? 0) - planet.x;
      const dy = (sun.y ?? 0) - planet.y;
      const dist = Math.hypot(dx, dy);
      if (!isFinite(dist) || dist <= 0.0001) continue;

      const ux = dx / dist;
      const uy = dy / dist;

      const sx = (planet.x - camX) * zoom + halfW;
      const sy = (planet.y - camY) * zoom + halfH;

      const segWorld = Math.min(Math.max(dist * 0.25, 80), 240);
      const len = segWorld * zoom;
      const ex = sx + ux * len;
      const ey = sy + uy * len;

      ctx.setLineDash([dash, dash]);
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(ex, ey);
      ctx.stroke();

      ctx.setLineDash([]);

      const ang = Math.atan2(uy, ux);
      ctx.beginPath();
      ctx.moveTo(ex, ey);
      ctx.lineTo(ex - Math.cos(ang - 0.4) * arrowSize, ey - Math.sin(ang - 0.4) * arrowSize);
      ctx.lineTo(ex - Math.cos(ang + 0.4) * arrowSize, ey - Math.sin(ang + 0.4) * arrowSize);
      ctx.closePath();
      ctx.fillStyle = '#66c2ff';
      ctx.fill();

      ctx.fillStyle = '#cfe3ff';
      ctx.fillText('Sun →', ex + labelOffset, ey - labelOffset);
    }

    ctx.restore();
  }
  window.drawSunDirection = drawSunDirection;

  // ---- Cheat: unlimited warp ---------------------------------------------
  window.devtoolsApplyCheats = function devtoolsApplyCheats(){
    if (!DevFlags.unlimitedWarp) return;
    const s = window.ship;
    if (s && s.warp){
      if ('cooldown' in s.warp) s.warp.cooldown = 0;
      if ('charge'   in s.warp) s.warp.charge   = s.warp.chargeMax ?? s.warp.maxCharge ?? 1;
      if ('energy'   in s.warp) s.warp.energy   = s.warp.energyMax ?? s.warp.maxEnergy ?? 1;
    }
    if (typeof window.warpCooldown === 'number') window.warpCooldown = 0;
    if (typeof window.warpEnergy === 'number' && typeof window.warpEnergyMax === 'number'){
      window.warpEnergy = window.warpEnergyMax;
    }
  };

  // ---- Hook na stację piracką (rysowanie) --------------------------------
  // W drawStation*(...) gdzie skalujesz sprite/canvas po st.r — zamień na:
  //   const R = st.r * (st.style==='pirate' || st.name?.toLowerCase().includes('pir') ? DevConfig.pirateScale : 1);
  // Jeśli jest osobna funkcja wyliczająca promień — użyj jej (patrz Krok 4: „diff”).

  // ---- UI init ------------------------------------------------------------
  function buildPlanetsUI(){
    // wyczyść stare
    ui.planetsGroup.querySelectorAll('.row.p').forEach(n=>n.remove());
    // dołóż po 1 wierszu per planeta
    for (const p of planets){
      const key = (p.name || p.id || String(p.index)||'').toString().toLowerCase();
      const row = document.createElement('div');
      row.className = 'row p';
      row.innerHTML = `
        <label>${p.name||('Planet '+(p.id??''))}</label>
        <input data-k="${key}" class="plR" type="range" min="20" max="400" step="1">
        <div class="val" id="val_${key}"></div>
      `;
      ui.planetsGroup.appendChild(row);
    }
    // podpinki
    ui.planetsGroup.querySelectorAll('input.plR').forEach(inp=>{
      const k = inp.dataset.k;
      inp.value = DevConfig.planetRById[k] ?? 100;
      el('val_'+k).textContent = inp.value;
      inp.addEventListener('input', ()=>{
        DevConfig.planetRById[k] = +inp.value;
        el('val_'+k).textContent = inp.value;
        saveLS(); scheduleRebuild3D(); reflectToCfg();
      });
    });
  }

  function reflectToUI(){
    DevConfig.pirateScale = DevTuning.pirateStationScale;
    DevConfig.station3DScale = Dev.station3DScale;
    ui.sunR.value = DevConfig.sunR|0; ui.sunRVal.textContent = ui.sunR.value;
    ui.planetScaleAll.value = DevConfig.planetScaleAll; ui.planetScaleAllVal.textContent = '×'+(+DevConfig.planetScaleAll).toFixed(2);
    ui.pirScale.value = DevConfig.pirateScale; ui.pirScaleVal.textContent = '×'+(+DevConfig.pirateScale).toFixed(2);
    if (ui.station3DScale) {
      ui.station3DScale.value = DevConfig.station3DScale;
      if (ui.station3DScaleVal) ui.station3DScaleVal.textContent = '×'+(+DevConfig.station3DScale).toFixed(2);
    }
    if (ui.stationSpritePx) ui.stationSpritePx.value = DevConfig.stationSpriteSize|0;
    ui.cbRuler.checked = DevFlags.showRuler;
    ui.cbUnlimited.checked = DevFlags.unlimitedWarp;
    if (ui.cbSunDir) ui.cbSunDir.checked = DevFlags.showSunDir;
    if (ui.cbPlanetStations3D) ui.cbPlanetStations3D.checked = DevFlags.usePlanetStations3D !== false;
    if (ui.cbPirate3D) ui.cbPirate3D.checked = DevFlags.use3DPirateStation;
  }
  function reflectToCfg(){
    const out = {
      sunR: DevConfig.sunR|0,
      planetRById: DevConfig.planetRById,
      planetScaleAll: +DevConfig.planetScaleAll,
      pirateScale: +DevConfig.pirateScale,
      station3DScale: +DevConfig.station3DScale,
      stationSpriteSize: +DevConfig.stationSpriteSize,
      stationSpriteFrame: +DevConfig.stationSpriteFrame,
      stationSpriteFrameById: DevConfig.stationSpriteFrameById,
      planetOrbitAUById: collectAUForExport(),
      stationScaleById: DevConfig.stationScaleById
    };
    ui.cfgOut.value = JSON.stringify(out, null, 2);
  }
  window.__devtoolsReflectToCfg = reflectToCfg;

  function fmtU(worldDist){
    if (typeof worldDist !== 'number' || !Number.isFinite(worldDist)) return '?';
    const abs = Math.abs(worldDist);
    if (abs >= 100000) return worldDist.toFixed(0);
    if (abs >= 10000)  return worldDist.toFixed(1);
    if (abs >= 1000)   return worldDist.toFixed(1);
    if (abs >= 100)    return worldDist.toFixed(2);
    if (abs >= 1)      return worldDist.toFixed(2);
    if (abs >= 0.01)   return worldDist.toFixed(2);
    return worldDist.toExponential(2).replace('+', '');
  }
  function keyFor(p){
    return (p.name || p.id || String(p.index) || '').toString().toLowerCase();
  }
  function formatAUValue(worldDist){
    if (typeof BASE_ORBIT !== 'number' || BASE_ORBIT <= 0) return 0;
    return worldDist / BASE_ORBIT;
  }
  function collectAUForExport(){
    const map = {};
    if (!Array.isArray(window.planets) || !window.SUN) return map;
    const sun = window.SUN;
    const sx = +sun.x || 0, sy = +sun.y || 0;
    for (const p of window.planets){
      const k = keyFor(p);
      let au = DevConfig.planetOrbitAUById?.[k];
      if (!(au > 0)) {
        const dWorld = Math.hypot((p.x||0)-sx, (p.y||0)-sy);
        au = formatAUValue(dWorld);
      }
      map[k] = +(+au).toFixed(2);
    }
    return map;
  }
  function buildStationFramesUI() {
    const root = ui.stationsFramesGroup;
    if (!root) return;
    root.querySelectorAll('.row.sf').forEach(n => n.remove());

    const list = Array.isArray(window.stations) ? window.stations : [];
    for (const st of list) {
      const name = st?.name || `Stacja ${st?.id ?? ''}`;
      const key = stationKey(st);
      if (!key) continue;
      const isPirate = (String(st?.style || '').toLowerCase() === 'pirate') ||
        /pir(?:ate)?/i.test(String(st?.name || '')) ||
        st?.isPirate === true;
      if (isPirate) continue;

      const row = document.createElement('div');
      row.className = 'row sf';
      row.style.alignItems = 'center';
      const initial = Number(DevConfig.stationSpriteFrameById[key]);
      const value = Number.isFinite(initial) ? initial : (Number(DevConfig.stationSpriteFrame) || 1.25);
      const safeValue = Math.max(0.1, Math.min(3.0, value));
      row.innerHTML = `
      <label style="min-width:140px">${name}</label>
      <input class="sfSlider" data-k="${key}" type="range" min="0.1" max="3.0" step="0.01" value="${safeValue}">
      <input class="sfNum" data-k="${key}" type="number" min="0.1" max="3.0" step="0.01" value="${safeValue}"
             style="width:72px; margin-left:8px">
      <span class="val" style="min-width:60px; text-align:right">×${(+safeValue).toFixed(2)}</span>
    `;
      root.appendChild(row);

      const slider = row.querySelector('input.sfSlider');
      const num = row.querySelector('input.sfNum');
      const val = row.querySelector('.val');
      const apply = (vRaw) => {
        let v = Number(vRaw);
        if (!Number.isFinite(v)) v = 1.25;
        v = Math.max(0.1, Math.min(3.0, v));
        DevConfig.stationSpriteFrameById[key] = v;
        if (num) num.value = String(v);
        if (slider) slider.value = String(v);
        if (val) val.textContent = '×' + v.toFixed(2);
        try { localStorage.setItem('stationSpriteFrameById', JSON.stringify(DevConfig.stationSpriteFrameById)); } catch {}
        __devtoolsReflectToCfg?.();
        __devtoolsSaveLS?.();
      };
      slider?.addEventListener('input', e => apply(e.target.value));
      slider?.addEventListener('change', e => apply(e.target.value));
      num?.addEventListener('input', e => apply(e.target.value));
      num?.addEventListener('change', e => apply(e.target.value));
    }
  }
  function buildDistancesUI(){
    if (!ui.distancesGroup) return;
    ui.distancesGroup.querySelectorAll('.row.dist').forEach(n => n.remove());
    if (!Array.isArray(window.planets) || !window.SUN) return;
    for (const p of window.planets){
      const k = keyFor(p);
      const dWorld = Math.hypot((p.x||0)-SUN.x, (p.y||0)-SUN.y);
      const dAU = (DevConfig.planetOrbitAUById?.[k] ?? formatAUValue(dWorld));
      const row = document.createElement('div');
      row.className = 'row dist';
      row.innerHTML = `
        <label style="min-width:80px">${p.name||('Planet '+(p.id??''))}</label>
        <input data-k="${k}" class="plAU" type="range" min="0" max="60" step="0.01">
        <input data-k="${k}" class="plAUVal" type="number" min="0" max="60" step="0.01" style="width:72px; margin:0 6px;">
        <div class="val" id="au_val_${k}" style="min-width:160px; text-align:right; font-variant-numeric: tabular-nums;"></div>
      `;
      ui.distancesGroup.appendChild(row);
      const inp = row.querySelector('input.plAU');
      const inpVal = row.querySelector('input.plAUVal');
      if (!DevConfig.planetOrbitAUById) DevConfig.planetOrbitAUById = {};
      inp.value = dAU;
      if (inpVal) inpVal.value = (+dAU).toFixed(2);
      const slot = document.getElementById('au_val_'+k);
      const renderVal = (au)=>{
        let num = Number(au);
        if (!Number.isFinite(num)) num = 0;
        const worldR = num * BASE_ORBIT;
        if (slot) slot.textContent = `${num.toFixed(2)} AU (${fmtU(worldR)} u)`;
        if (inpVal) inpVal.value = num.toFixed(2);
      };
      renderVal(dAU);
      inp.addEventListener('input', ()=>{
        const au = +inp.value;
        setPlanetOrbitAU(k, au);
        renderVal(au);
        saveLS();
        reflectToCfg();
        if (inpVal) inpVal.value = au.toFixed(2);
      });
      if (inpVal) {
        const applyAU = ()=>{
          let au = Number(inpVal.value);
          if (!Number.isFinite(au)) return;
          au = Math.max(0, Math.min(60, au));
          inp.value = String(au);
          setPlanetOrbitAU(k, au);
          renderVal(au);
          saveLS();
          reflectToCfg();
        };
        inpVal.addEventListener('change', applyAU);
        inpVal.addEventListener('keyup', (e)=>{ if (e.key === 'Enter') applyAU(); });
      }
    }
  }
  function setPlanetOrbitAU(key, au){
    DevConfig.planetOrbitAUById = DevConfig.planetOrbitAUById || {};
    DevConfig.planetOrbitAUById[key] = +au;
    applyOrbitOverrides();
  }
  function applyOrbitOverrides(){
    if (!Array.isArray(window.planets) || !window.SUN) return;
    const Sx = +SUN.x||0, Sy = +SUN.y||0;
    const map = DevConfig.planetOrbitAUById || {};
    for (const p of window.planets){
      const k = keyFor(p);
      const au = +map[k];
      if (!(au>0)) continue;
      const R = au * BASE_ORBIT;
      const ang = Math.atan2((p.y||0)-Sy, (p.x||0)-Sx);
      p.devOrbitOverrideR = R;
      if ('orbitRadius' in p) p.orbitRadius = R;
      if (p.orbit && 'radius' in p.orbit) p.orbit.radius = R;
      if ('orbitR' in p) p.orbitR = R;
      p.x = Sx + Math.cos(ang)*R;
      p.y = Sy + Math.sin(ang)*R;
    }
    if (typeof scheduleRebuild3D === 'function') scheduleRebuild3D();
  }
  function refreshDistancesReadout(){
    if (!Array.isArray(window.planets) || !window.SUN) return;
    for (const p of window.planets){
      const k = keyFor(p);
      const slot = document.getElementById('au_val_'+k);
      if (!slot) continue;
      const dWorld = Math.hypot((p.x||0)-SUN.x, (p.y||0)-SUN.y);
      const au = DevConfig.planetOrbitAUById?.[k] ?? formatAUValue(dWorld);
      slot.textContent = `${(+au).toFixed(2)} AU (${fmtU(au*BASE_ORBIT)} u)`;
    }
  }

  // listeners
  ui.sunR.addEventListener('input', ()=>{ DevConfig.sunR = +ui.sunR.value; ui.sunRVal.textContent = ui.sunR.value; saveLS(); scheduleRebuild3D(); reflectToCfg(); });
  ui.planetScaleAll.addEventListener('input', ()=>{ DevConfig.planetScaleAll = +ui.planetScaleAll.value; ui.planetScaleAllVal.textContent = '×'+(+DevConfig.planetScaleAll).toFixed(2); saveLS(); scheduleRebuild3D(); reflectToCfg(); });
  ui.pirScale.addEventListener('input', ()=>{
    DevTuning.pirateStationScale = +ui.pirScale.value;
    DevConfig.pirateScale = DevTuning.pirateStationScale;
    ui.pirScaleVal.textContent = '×'+(+DevConfig.pirateScale).toFixed(2);
    saveLS();
    reflectToCfg();
  });
  if (ui.stationSpritePx) {
    const applySpriteSize = () => {
      let v = Math.round(Number(ui.stationSpritePx.value));
      if (!Number.isFinite(v)) v = 512;
      v = Math.max(64, Math.min(4096, v));
      ui.stationSpritePx.value = String(v);
      DevConfig.stationSpriteSize = v;
      try { localStorage.setItem('stationSpriteSize', String(v)); } catch {}
      saveLS();
      reflectToCfg();
    };
    ui.stationSpritePx.addEventListener('change', applySpriteSize);
    ui.stationSpritePx.addEventListener('input', applySpriteSize);
  }
  ui.cbRuler.addEventListener('change', ()=>{ DevFlags.showRuler = ui.cbRuler.checked; saveLS(); });
  ui.cbUnlimited.addEventListener('change', ()=>{ DevFlags.unlimitedWarp = ui.cbUnlimited.checked; saveLS(); });
  if (ui.cbSunDir) {
    ui.cbSunDir.addEventListener('change', ()=>{
      DevFlags.showSunDir = ui.cbSunDir.checked;
      saveLS();
    });
  }
  if (ui.cbPlanetStations3D) {
    ui.cbPlanetStations3D.addEventListener('change', () => {
      DevFlags.usePlanetStations3D = ui.cbPlanetStations3D.checked;
      window.USE_PLANET_STATIONS_3D = ui.cbPlanetStations3D.checked;
      if (Array.isArray(window.stations) && typeof window.updateStations3D === 'function') {
        window.updateStations3D(window.stations);
      }
      saveLS();
    });
  }
  if (ui.cbPirate3D) {
    ui.cbPirate3D.addEventListener('change', ()=>{
      DevFlags.use3DPirateStation = ui.cbPirate3D.checked;
      window.USE_STATION_3D = ui.cbPirate3D.checked;
      if (window.USE_STATION_3D && window.__setStation3DScale && typeof Dev.station3DScale === 'number') {
        __setStation3DScale(Dev.station3DScale);
      }
      saveLS();
    });
  }

  ui.btnCopy.addEventListener('click', async ()=>{
    try { await navigator.clipboard.writeText(ui.cfgOut.value); ui.btnCopy.textContent='Skopiowano!'; setTimeout(()=>ui.btnCopy.textContent='Kopiuj aktualną konfigurację', 1200); } catch{}
  });
  ui.btnReset.addEventListener('click', ()=>{
    localStorage.removeItem('devConfig'); localStorage.removeItem('devFlags'); localStorage.removeItem('stationSpriteSize');
    localStorage.removeItem('stationSpriteFrame'); localStorage.removeItem('stationSpriteFrameById');
    location.reload();
  });

  // skróty klawiaturowe
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'F10'){ ui.root.style.display = (ui.root.style.display==='none' || !ui.root.style.display) ? 'block' : 'none'; }
    if (e.key === 'F11'){ DevFlags.showRuler = !DevFlags.showRuler; ui.cbRuler.checked = DevFlags.showRuler; saveLS(); }
    if (e.key === 'F9' ){ DevFlags.unlimitedWarp = !DevFlags.unlimitedWarp; ui.cbUnlimited.checked = DevFlags.unlimitedWarp; saveLS(); }
    if (e.key === 'F8' ){ 
      DevFlags.showSunDir = !DevFlags.showSunDir; 
      if (ui.cbSunDir) ui.cbSunDir.checked = DevFlags.showSunDir; 
      const el = document.getElementById('dt-show-sundir'); 
      if (el) el.checked = DevFlags.showSunDir; 
      saveLS(); 
    }
  });

  // boot
  loadLS();
  bootstrapFromGame();
  if (!DevConfig.planetOrbitAUById || typeof DevConfig.planetOrbitAUById !== 'object') {
    DevConfig.planetOrbitAUById = {};
  }

  // Planety (R)
  buildPlanetsUI();

  // Sekcja: Dystanse od Słońca (AU → promień orbity)
  buildDistancesUI();

  // Sekcja: Kadr sprite per stacja
  buildStationFramesUI();

  // Odbicie stanu
  reflectToUI();
  reflectToCfg();

  // Rebuild 3D po zmianach
  scheduleRebuild3D();

  // Przywróć zapisane AU i przelicz promienie orbit
  applyOrbitOverrides();

  // Aktualizuj readout AU/world-units w panelu
  refreshDistancesReadout();
  setInterval(refreshDistancesReadout, 250);
  setInterval(buildStationFramesUI, 2000);

  // Upewnij się, że panel można włączyć na starcie (dev wygoda)
  // ui.root.style.display = 'block';
})();
</script>

<script>
  // === DevTools: API + handler skali stacji 3D ===
  (function(){
    // API dostępne globalnie — zapisuje skalę w dwóch miejscach, aby
    // 1) logika 3D miała natychmiastową wartość, 2) devtools mógł ją odczytać.
    if (!window.__setStation3DScale) {
      window.__setStation3DScale = (v) => {
        const n = Number(v);
        if (!Number.isFinite(n)) return;
        window.Dev       = window.Dev       || {};
        window.DevTuning = window.DevTuning || {};
        window.Dev.station3DScale           = n;
        window.DevTuning.pirateStationScale = n;
        const cfg = window.DevConfig;
        if (cfg && typeof cfg === 'object') cfg.station3DScale = n;
        try { localStorage.setItem('station3DScale', String(n)); } catch {}
      };
    }

    // Podpięcie suwaka i wyświetlacza wartości (×1.00, ×1.25 itd.)
    const s  = document.getElementById('station3DScale');
    const sv = document.getElementById('station3DScaleVal');
    if (s) {
      // inicjalizacja z LS (opcjonalnie)
      const saved = Number(localStorage.getItem('station3DScale'));
      if (Number.isFinite(saved)) {
        s.value = String(saved);
        if (sv) sv.textContent = '×' + saved.toFixed(2);
        window.__setStation3DScale(saved);
      }

      s.addEventListener('input', () => {
        const v = +s.value;
        window.__setStation3DScale(v);
        if (sv) sv.textContent = '×' + v.toFixed(2);
        if (window.DevConfig && typeof window.DevConfig === 'object') {
          window.DevConfig.station3DScale = v;
        }
        window.__devtoolsSaveLS?.();
        window.__devtoolsReflectToCfg?.();
      });
    }
  })();

  (function setupPerStationScales(){
    const root = document.getElementById('dt-stations-per-scale');
    if (!root) return;

    if (!window.DevConfig) window.DevConfig = {};
    if (!window.DevConfig.stationScaleById || typeof window.DevConfig.stationScaleById !== 'object') {
      window.DevConfig.stationScaleById = {};
    }

    function currentStations() {
      if (Array.isArray(window.stations) && window.stations.length) return window.stations;
      if (Array.isArray(window.planets)) {
        return window.planets.map((pl) => ({ id: pl.id || pl.name || '', planet: pl }));
      }
      return [];
    }

    function makeRow(st) {
      const id = String(st?.id || st?.planet?.id || st?.planet?.name || '').toLowerCase();
      if (!id) return null;

      const map = typeof window.getStationScales === 'function' ? window.getStationScales() : null;
      const rawInitial = (window.DevConfig.stationScaleById && window.DevConfig.stationScaleById[id])
        ?? (map ? map[id] : undefined)
        ?? 1;
      const initial = Number(rawInitial) || 1;

      const wrap = document.createElement('div');
      wrap.className = 'dt-row';
      wrap.style.alignItems = 'center';

      const label = document.createElement('div');
      label.className = 'dt-col';
      label.style.minWidth = '120px';
      label.textContent = id[0].toUpperCase() + id.slice(1);

      const col = document.createElement('div');
      col.className = 'dt-col';
      col.style.flex = '1';

      const range = document.createElement('input');
      range.type = 'range';
      range.min = '0.2';
      range.max = '5';
      range.step = '0.01';
      range.value = String(initial);
      range.id = `dt-scale-station-${id}`;

      const val = document.createElement('span');
      val.style.marginLeft = '8px';
      val.textContent = initial.toFixed(2);

      const num = document.createElement('input');
      num.type = 'number';
      num.min = '0.2';
      num.max = '5';
      num.step = '0.01';
      num.value = String(initial);
      num.id = `dt-scale-station-${id}-num`;
      num.style.width = '72px';
      num.style.marginLeft = '8px';

      const apply = (vRaw) => {
        let v = Number(vRaw);
        if (!Number.isFinite(v)) v = 1;
        v = Math.max(0.2, Math.min(5, v));
        if (!window.DevConfig || typeof window.DevConfig !== 'object') window.DevConfig = {};
        if (!window.DevConfig.stationScaleById || typeof window.DevConfig.stationScaleById !== 'object') {
          window.DevConfig.stationScaleById = {};
        }
        window.DevConfig.stationScaleById[id] = v;
        range.value = String(v);
        num.value = String(v);
        val.textContent = v.toFixed(2);
        if (typeof window.setStationScale === 'function') window.setStationScale(id, v);
        window.__devtoolsSaveLS?.();
      };

      range.addEventListener('input', () => apply(range.value));
      num.addEventListener('input', () => apply(num.value));
      num.addEventListener('change', () => apply(num.value));
      num.addEventListener('keyup', (e) => { if (e.key === 'Enter') apply(num.value); });

      col.appendChild(range);
      col.appendChild(num);
      col.appendChild(val);
      wrap.appendChild(label);
      wrap.appendChild(col);
      return wrap;
    }

    function rebuild() {
      root.innerHTML = '';
      const list = currentStations();
      const seen = new Set();
      for (const st of list) {
        const row = makeRow(st);
        if (!row) continue;
        const input = row.querySelector('input[type="range"]');
        const key = input ? input.id : null;
        if (!key || seen.has(key)) continue;
        seen.add(key);
        root.appendChild(row);
      }
    }

    const btnReset = document.getElementById('dt-reset-station-scales');
    if (btnReset) {
      btnReset.addEventListener('click', () => {
        if (!window.DevConfig) window.DevConfig = {};
        window.DevConfig.stationScaleById = {};
        window.__devtoolsSaveLS?.();
        if (typeof window.__saveDevLS === 'function') window.__saveDevLS();
        rebuild();
        if (Array.isArray(window.stations) && typeof window.updateStations3D === 'function') {
          window.updateStations3D(window.stations);
        }
      });
    }

    rebuild();
    let tries = 0;
    const t = setInterval(() => {
      tries++;
      const count = root.querySelectorAll('input[type="range"]').length;
      const stationCount = Array.isArray(window.stations) ? window.stations.length : 0;
      if (stationCount > count || (count === 0 && tries < 120)) {
        rebuild();
      }
      if (tries >= 120) clearInterval(t);
    }, 500);

    if (typeof window.__saveDevLS !== 'function') {
      window.__saveDevLS = function __saveDevLSFallback(){
        try {
          const data = { DevFlags: window.DevFlags, DevTuning: window.DevTuning, DevConfig: window.DevConfig };
          localStorage.setItem('#__dev', JSON.stringify(data));
        } catch (err) {
          console.warn('DevTools: failed to persist station scales', err);
        }
      };
    }

  })();
</script>

</body>
</html>
