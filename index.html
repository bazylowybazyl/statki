<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Space Survivors — gwiazdy na całej mapie + duży silnik plazmowy</title>
<style>
  :root{
    --fa-font: 'Segoe UI','Frutiger','Inter',system-ui,-apple-system,sans-serif;
    --fa-text: #e8f6ff;
    --fa-muted: #b8d6f3;
    --fa-border: rgba(129,203,255,0.45);
    --fa-strong-border: rgba(129,203,255,0.75);
    --fa-panel: linear-gradient(160deg,rgba(255,255,255,0.08),rgba(62,142,206,0.18));
    --fa-panel-strong: linear-gradient(160deg,rgba(255,255,255,0.10),rgba(36,111,185,0.26));
    --fa-glow: 0 18px 44px rgba(5,32,74,0.55);
    --fa-accent: #6ddcff;
    --fa-accent-2: #3aa1ff;
    --fa-surface-dark: rgba(9,18,38,0.8);
    --fa-surface-gloss: linear-gradient(180deg,rgba(255,255,255,0.08),rgba(255,255,255,0));
  }
  html,body{height:100%;margin:0;background:linear-gradient(135deg, #000000 0%, #080808 40%, #111111 100%);color:var(--fa-text);font-family:var(--fa-font)}
  body,button,input,select,option{font-family:var(--fa-font);}
  body::before{content:'';position:fixed;inset:0;pointer-events:none;background:radial-gradient(circle at 50% 30%,rgba(255,255,255,0.05),transparent 35%);mix-blend-mode:screen;opacity:0.8;z-index:1}
  .hud-topbar{position:fixed;bottom:calc(14px + env(safe-area-inset-bottom));left:50%;transform:translateX(-50%);z-index:120;display:flex;align-items:center;justify-content:center;padding:10px 12px;border-radius:16px;border:1px solid var(--fa-border);background:var(--fa-panel-strong);backdrop-filter:blur(14px);box-shadow:var(--fa-glow);min-width:360px;max-width:560px;}
  .hud-topbar .skill-slot-row{display:grid;grid-template-columns:repeat(10,minmax(36px,1fr));gap:8px;}
  .hud-topbar .skill-slot{position:relative;height:42px;border-radius:12px;border:1px solid var(--fa-border);background:var(--fa-panel);box-shadow:inset 0 1px 0 rgba(255,255,255,0.12),0 12px 22px rgba(5,32,74,0.45);display:flex;align-items:center;justify-content:center;font-size:13px;font-weight:800;letter-spacing:0.08em;text-transform:uppercase;color:#e8f6ff;text-shadow:0 0 14px rgba(109,220,255,0.55);}
  .hud-topbar .skill-slot::after{content:'';position:absolute;inset:0;background:var(--fa-surface-gloss);border-radius:inherit;opacity:0.65;pointer-events:none;}
  .hud-topbar{pointer-events:none;}
  .hud-topbar .skill-slot{pointer-events:none;}
  #ui{position:absolute;left:12px;top:12px;z-index:120;background:var(--fa-panel);padding:12px 14px;border-radius:12px;backdrop-filter:blur(10px);border:1px solid var(--fa-border);box-shadow:var(--fa-glow)}
  #side-panels{position:absolute;left:12px;top:160px;z-index:120;display:flex;flex-direction:column;gap:12px;align-items:flex-start;}
  .side-panel{width:280px;display:flex;flex-direction:column;gap:10px;background:var(--fa-panel-strong);padding:14px 16px;border-radius:14px;border:1px solid var(--fa-border);backdrop-filter:blur(10px);color:var(--fa-text);font-family:var(--fa-font);box-shadow:var(--fa-glow);transition:width 0.32s ease,padding 0.32s ease,gap 0.24s ease, min-height 0.24s ease;align-items:flex-start;}
  .side-panel.hidden{display:none !important;}
  .panel-toggle{display:flex;align-items:center;gap:10px;margin:0;padding:0;border:none;background:transparent;color:#aee3ff;font-size:15px;letter-spacing:0.08em;text-transform:uppercase;text-shadow:0 0 12px rgba(99,208,255,0.45);cursor:pointer;transition:color 0.22s ease,transform 0.22s ease;justify-content:flex-start;}
  .panel-toggle:active{transform:translateY(1px);}
  .panel-chevron{margin-left:auto;font-size:14px;color:var(--fa-muted);opacity:0.85;transition:transform 0.28s ease,opacity 0.2s ease;}
  .side-panel-title{margin:0;font-size:15px;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;color:#aee3ff;text-shadow:0 0 12px rgba(99,208,255,0.45);display:inline-block;transform-origin:left center;transition:transform 0.35s ease,letter-spacing 0.24s ease,opacity 0.24s ease;}
  .side-panel-body{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:10px;max-height:1200px;opacity:1;transform:translateY(0);transition:max-height 0.32s ease,opacity 0.24s ease,transform 0.24s ease;}
  .side-panel.collapsed{width:48px;padding:8px 6px;gap:4px;align-items:center;min-height:auto;}
  .side-panel.collapsed .panel-toggle{justify-content:center;min-height:auto;padding:4px 0;}
  .side-panel.collapsed .side-panel-title{transform:rotate(-90deg);letter-spacing:0.16em;transform-origin:center center;text-align:center;}
  .side-panel.collapsed .panel-chevron{opacity:0;transform:translateY(-4px);}
  .side-panel.collapsed .side-panel-body{max-height:0;opacity:0;transform:translateY(-8px);pointer-events:none;}
  #fleet-ui .side-panel-body{max-height:360px;overflow-y:auto;-ms-overflow-style:none;scrollbar-width:none;}
  #fleet-ui .side-panel-body::-webkit-scrollbar{display:none;}
  #fleet-list{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:10px;}
  .fleet-ship{padding:10px 12px;background:linear-gradient(160deg,rgba(10,26,48,0.82),rgba(12,32,58,0.9));border:1px solid var(--fa-border);border-radius:12px;display:flex;flex-direction:column;gap:8px;box-shadow:0 10px 24px rgba(0,0,0,0.35)}
  .fleet-ship-header{display:flex;flex-direction:column;gap:2px;}
  .fleet-ship-name{font-weight:700;font-size:15px;color:#f6fbff;letter-spacing:0.02em;}
  .fleet-ship-meta{font-size:11px;letter-spacing:0.12em;text-transform:uppercase;color:var(--fa-muted);}
  .fleet-stats{font-size:13px;letter-spacing:0.04em;color:#dfe7ff;display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
  .fleet-fighters{font-size:13px;font-weight:700;color:var(--fa-text);text-shadow:0 0 8px rgba(109,220,255,0.45);letter-spacing:0.04em;}
  .fleet-hardpoints{display:flex;gap:8px;font-size:11px;color:#cde7ff;flex-wrap:wrap;}
  .fleet-hardpoints span{padding:2px 8px;border-radius:999px;background:rgba(99,167,238,0.2);border:1px solid var(--fa-border);box-shadow:0 6px 16px rgba(0,0,0,0.25);}
  .fleet-controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px;}
  .fleet-order-btn{flex:1 1 30%;padding:8px 9px;border-radius:10px;border:1px solid var(--fa-border);background:linear-gradient(150deg,rgba(66,142,210,0.25),rgba(55,116,186,0.35));color:var(--fa-text);font-size:11px;letter-spacing:0.08em;text-transform:uppercase;cursor:pointer;transition:background 0.18s ease,border-color 0.18s ease,color 0.18s ease,transform 0.18s ease;box-shadow:0 10px 20px rgba(0,0,0,0.22);}
  .fleet-order-btn:hover{background:linear-gradient(150deg,rgba(96,188,255,0.35),rgba(55,116,186,0.45));border-color:var(--fa-strong-border);transform:translateY(-1px);}
  .fleet-order-btn.active{background:linear-gradient(150deg,rgba(109,220,255,0.4),rgba(58,161,255,0.42));border-color:var(--fa-strong-border);color:#f1f7ff;box-shadow:0 0 0 1px rgba(96,165,250,0.35) inset,0 12px 26px rgba(3,92,160,0.35);}
  #support-ui{width:280px;}
  .support-row{display:flex;flex-wrap:wrap;gap:8px;}
  .support-btn{flex:1 1 48%;padding:9px 11px;border-radius:10px;border:1px solid var(--fa-border);background:linear-gradient(150deg,rgba(66,142,210,0.25),rgba(55,116,186,0.35));color:var(--fa-text);font-size:12px;letter-spacing:0.06em;text-transform:uppercase;cursor:pointer;transition:background 0.18s ease,border-color 0.18s ease,color 0.18s ease,transform 0.18s ease;box-shadow:0 10px 20px rgba(0,0,0,0.22);}
  .support-btn:hover{background:linear-gradient(150deg,rgba(96,188,255,0.35),rgba(55,116,186,0.45));border-color:var(--fa-strong-border);transform:translateY(-1px);}
  .support-order-btn{flex:1 1 48%;padding:9px 11px;border-radius:10px;border:1px solid var(--fa-border);background:linear-gradient(150deg,rgba(66,142,210,0.28),rgba(55,116,186,0.38));color:var(--fa-text);font-size:12px;letter-spacing:0.08em;text-transform:uppercase;cursor:pointer;transition:background 0.18s ease,border-color 0.18s ease,color 0.18s ease,transform 0.18s ease;box-shadow:0 12px 24px rgba(0,0,0,0.25);}
  .support-order-btn.active{background:linear-gradient(150deg,rgba(109,220,255,0.4),rgba(58,161,255,0.42));border-color:var(--fa-strong-border);color:#f1f7ff;box-shadow:0 0 0 1px rgba(96,165,250,0.35) inset,0 12px 26px rgba(3,92,160,0.35);}
  canvas{display:block;width:100vw;height:100vh}
  #game-root{position:relative;width:100vw;height:100vh;}
  #game-root>canvas{display:block;width:100%;height:100%;}
  #c { position: relative; z-index: 10; }
  /* nie obejmuj overlayu 3D */
  canvas:not(#c):not(.overlay3d) {
    pointer-events: none !important;
    position: absolute;
    inset: 0;
    z-index: 0;
  }
  .stat{font-family:monospace;font-size:13px}
  small{color:#a8b4d9}
  #main-menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 50% 30%,rgba(77,190,255,0.14),rgba(3,4,23,0.9));backdrop-filter:blur(12px);z-index:70;color:var(--fa-text);padding:20px;}
  .menu-panel{width:min(480px,calc(100% - 24px));background:var(--fa-panel-strong);border:1px solid var(--fa-border);border-radius:20px;box-shadow:var(--fa-glow);padding:32px 34px;display:flex;flex-direction:column;gap:16px;position:relative;overflow:hidden;}
  .menu-panel::after{content:'';position:absolute;inset:0;background:var(--fa-surface-gloss);pointer-events:none;}
  .menu-panel h1{margin:0;font-size:28px;letter-spacing:0.08em;text-transform:uppercase;color:#c1e8ff;text-shadow:0 0 18px rgba(109,220,255,0.6);}
  .menu-subtitle{margin:0;color:var(--fa-muted);font-size:15px;line-height:1.5;}
  .menu-view.hidden{display:none;}
  .menu-actions{display:flex;flex-direction:column;gap:12px;}
  .menu-actions button{width:100%;padding:13px 15px;font-size:15px;letter-spacing:0.08em;text-transform:uppercase;border-radius:14px;border:1px solid var(--fa-border);cursor:pointer;transition:background 0.18s ease,border-color 0.18s ease,transform 0.18s ease,box-shadow 0.18s ease;box-shadow:0 12px 28px rgba(0,0,0,0.28);background:linear-gradient(150deg,rgba(66,142,210,0.32),rgba(55,116,186,0.42));color:var(--fa-text);}
  .menu-actions button:disabled{opacity:0.55;cursor:not-allowed;}
  .menu-actions button:not(:disabled):hover{transform:translateY(-1px);border-color:var(--fa-strong-border);}
  .menu-primary{background:linear-gradient(130deg,#6ddcff,#3aa1ff);color:#041226;border:none;box-shadow:0 16px 32px rgba(61,179,255,0.45);}
  .menu-primary:hover{box-shadow:0 18px 40px rgba(61,179,255,0.55);}
  .menu-secondary{background:linear-gradient(150deg,rgba(66,142,210,0.32),rgba(55,116,186,0.42));color:var(--fa-text);}
  .menu-secondary:not(:disabled):hover{background:linear-gradient(150deg,rgba(96,188,255,0.42),rgba(55,116,186,0.52));border-color:var(--fa-strong-border);}
  .menu-options-grid{display:flex;flex-direction:column;gap:16px;margin-top:4px;}
  .menu-option{padding:14px;border-radius:14px;border:1px solid var(--fa-border);background:linear-gradient(160deg,rgba(255,255,255,0.05),rgba(62,142,206,0.12));box-shadow:inset 0 1px 0 rgba(255,255,255,0.06),0 12px 24px rgba(0,0,0,0.22);}
  .menu-option-label{margin:0 0 10px 0;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;color:#b8d6f3;font-size:13px;}
  .menu-chip-group{display:flex;gap:10px;flex-wrap:wrap;}
  .menu-chip{padding:9px 14px;border-radius:12px;border:1px solid var(--fa-border);background:linear-gradient(145deg,rgba(10,16,30,0.82),rgba(12,22,40,0.88));color:var(--fa-text);cursor:pointer;letter-spacing:0.08em;text-transform:uppercase;font-weight:700;transition:background 0.18s ease,border-color 0.18s ease,transform 0.18s ease;box-shadow:0 10px 22px rgba(0,0,0,0.24);}
  .menu-chip:hover{transform:translateY(-1px);border-color:var(--fa-strong-border);}
  .menu-chip.active{background:linear-gradient(150deg,rgba(109,220,255,0.35),rgba(58,161,255,0.35));border-color:var(--fa-strong-border);color:#041226;box-shadow:0 0 0 1px rgba(96,165,250,0.35) inset,0 14px 28px rgba(3,92,160,0.35);}
  .menu-option-hint{margin:10px 0 0 0;font-size:13px;color:#b6d7ff;}
  .menu-hint{margin:0;color:#b6d7ff;font-size:13px;}
  #loading{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 40% 30%,rgba(77,190,255,0.12),rgba(3,4,23,0.94));z-index:80;color:var(--fa-text);font-family:var(--fa-font);padding:20px;}
  .loading-box{width:min(380px,calc(100% - 24px));background:var(--fa-panel-strong);border:1px solid var(--fa-border);border-radius:16px;padding:24px 26px;box-shadow:var(--fa-glow);display:flex;flex-direction:column;gap:12px;position:relative;overflow:hidden;}
  .loading-box::after{content:'';position:absolute;inset:0;background:var(--fa-surface-gloss);pointer-events:none;}
  .loading-title{font-size:18px;letter-spacing:0.1em;text-transform:uppercase;color:#c1e8ff;margin:0;text-shadow:0 0 18px rgba(109,220,255,0.6);}
  .loading-bar{position:relative;width:100%;height:12px;border-radius:999px;background:rgba(28,50,92,0.9);overflow:hidden;border:1px solid var(--fa-border);box-shadow:inset 0 1px 0 rgba(255,255,255,0.08);}
  .loading-bar span{position:absolute;left:0;top:0;height:100%;width:0;background:linear-gradient(90deg,#6ddcff,#3aa1ff);box-shadow:0 8px 18px rgba(61,179,255,0.35);transition:width 0.18s ease-out;}
  .loading-progress{font-size:14px;color:#dff2ff;letter-spacing:0.08em;text-transform:uppercase;}
  .hidden{display:none !important;}
  .station-overlay{position:absolute;top:60px;right:40px;max-width:840px;width:min(840px,calc(100vw - 80px));min-width:540px;max-height:80vh;overflow:hidden;overflow-y:auto;padding:18px 20px;background:radial-gradient(circle at 18% 18%,rgba(109,220,255,0.14),transparent 32%),var(--fa-panel-strong);border:1px solid var(--fa-border);border-radius:16px;z-index:60;color:var(--fa-text);font-family:var(--fa-font);backdrop-filter:blur(14px);box-shadow:0 22px 44px rgba(5,32,74,0.55);}
  .station-overlay::after{content:"";position:absolute;inset:0;background:var(--fa-surface-gloss);pointer-events:none;border-radius:inherit;opacity:0.9;}
  .station-overlay h3{position:relative;z-index:1;margin:0 0 12px 0;font-size:18px;letter-spacing:0.06em;text-transform:uppercase;color:#c1e8ff;text-shadow:0 0 12px rgba(109,220,255,0.45);}
  .station-overlay ul{position:relative;z-index:1;list-style:none;padding:0;margin:0 0 12px 0;display:flex;gap:10px;flex-wrap:wrap;align-items:stretch;}
  .station-overlay li{padding:9px 16px;border:1px solid var(--fa-border);border-radius:12px;background:linear-gradient(150deg,rgba(66,142,210,0.28),rgba(55,116,186,0.46));cursor:pointer;color:var(--fa-text);font-size:14px;transition:background 0.2s,border-color 0.2s,color 0.2s,transform 0.18s ease;flex:1 1 42%;text-align:center;min-width:128px;box-shadow:0 14px 22px rgba(0,0,0,0.26);backdrop-filter:blur(6px);}
  .station-overlay li:hover{background:linear-gradient(150deg,rgba(96,188,255,0.42),rgba(55,116,186,0.54));border-color:var(--fa-strong-border);color:#e6f8ff;transform:translateY(-1px);}
  .station-overlay li.active{background:linear-gradient(150deg,rgba(109,220,255,0.5),rgba(58,161,255,0.56));border-color:var(--fa-strong-border);color:#041226;box-shadow:0 0 0 1px rgba(96,165,250,0.35) inset,0 12px 26px rgba(3,92,160,0.35);}
  .station-tab.hidden{display:none;}
  .station-head{position:relative;z-index:1;display:flex;justify-content:space-between;gap:12px;align-items:flex-start;margin-bottom:12px;}
  .station-title{margin:0;font-size:20px;letter-spacing:0.08em;text-transform:uppercase;color:#e6f8ff;text-shadow:0 0 14px rgba(109,220,255,0.55);}
  .station-subtitle{margin:2px 0 0 0;font-size:12px;letter-spacing:0.16em;text-transform:uppercase;color:var(--fa-muted);}
  .station-balance{display:flex;flex-direction:column;gap:2px;padding:10px 12px;border-radius:12px;background:rgba(8,18,36,0.85);border:1px solid rgba(109,220,255,0.35);box-shadow:0 12px 26px rgba(3,12,32,0.5);}
  .station-balance .label{font-size:11px;letter-spacing:0.14em;text-transform:uppercase;color:#8fb5ff;}
  .station-balance .value{font-size:18px;font-weight:800;color:#f8fbff;letter-spacing:0.04em;}
  .station-panels{position:relative;z-index:1;display:flex;flex-direction:column;gap:12px;}
  .station-tab{display:none;flex-direction:column;gap:12px;}
  .station-tab.active{display:flex;}
  .station-card{padding:12px 14px;border-radius:12px;background:linear-gradient(170deg,rgba(9,16,32,0.92),rgba(12,26,46,0.95));border:1px solid rgba(34,60,104,0.85);box-shadow:0 14px 26px rgba(0,0,0,0.32);display:flex;flex-direction:column;gap:8px;}
  .station-card-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .station-card-title{margin:0;font-size:15px;font-weight:800;letter-spacing:0.04em;color:#e6f8ff;}
  .station-chip{padding:4px 10px;border-radius:999px;background:rgba(63,88,144,0.32);border:1px solid rgba(96,165,250,0.4);color:#dfe7ff;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;}
  .station-card-desc{margin:0;color:#cbd5ff;font-size:13px;line-height:1.5;}
  .station-card-meta{display:flex;flex-wrap:wrap;gap:10px;font-size:12px;color:#9fb4e6;}
  .station-card-actions{display:flex;flex-wrap:wrap;gap:10px;align-items:center;}
  .station-card button{padding:8px 12px;border-radius:10px;border:1px solid var(--fa-border);background:linear-gradient(150deg,rgba(66,142,210,0.28),rgba(55,116,186,0.42));color:var(--fa-text);font-weight:700;letter-spacing:0.06em;text-transform:uppercase;cursor:pointer;transition:background 0.18s,border-color 0.18s,transform 0.18s;box-shadow:0 12px 22px rgba(0,0,0,0.28);} 
  .station-card button:hover:not(:disabled){background:linear-gradient(150deg,rgba(96,188,255,0.38),rgba(55,116,186,0.5));border-color:var(--fa-strong-border);transform:translateY(-1px);} 
  .station-card button:disabled{opacity:0.45;cursor:not-allowed;}
  .station-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;}
  .station-divider{height:1px;background:linear-gradient(90deg,rgba(109,220,255,0),rgba(109,220,255,0.45),rgba(109,220,255,0));margin:4px 0;}
  .trade-resource-card .station-card-meta{margin-top:-4px;}
  .trade-resource-note{display:block;font-size:12px;color:#9fb4e6;margin-top:-2px;}
  .trade-resource-table{width:100%;border-collapse:collapse;margin-top:6px;}
  .trade-resource-table td{padding:6px 4px;font-size:13px;color:#dfe7ff;}
  .trade-resource-table tr+tr td{border-top:1px solid rgba(70,94,140,0.4);}
  .trade-resource-label{display:flex;align-items:center;gap:8px;font-weight:700;letter-spacing:0.03em;}
  .trade-resource-values{white-space:nowrap;text-align:right;font-variant-numeric:tabular-nums;}
  .trade-resource-amount{color:#e6f8ff;font-weight:800;}
  .trade-resource-capacity{color:#9fb4e6;font-size:12px;}
  .resource-icon-wrap{width:22px;height:22px;display:grid;place-items:center;background:rgba(24,36,66,0.85);border:1px solid rgba(96,165,250,0.25);border-radius:8px;box-shadow:0 6px 14px rgba(0,0,0,0.32);}
  .resource-icon{width:16px;height:16px;display:block;}
  .mechanic-toolbar{position:relative;z-index:1;display:flex;align-items:center;gap:8px;margin-bottom:14px;}
  .mechanic-toolbar label{font-weight:700;letter-spacing:0.05em;color:#b8c9f3;text-transform:uppercase;font-size:12px;}
  .mechanic-toolbar select{flex:1;background:linear-gradient(135deg,rgba(6,14,28,0.92),rgba(8,16,34,0.95));color:#dfe7ff;border:1px solid #2a3a5a;border-radius:10px;padding:7px 12px;font-size:14px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.08);} 
  .mechanic-body{display:grid;grid-template-columns:1fr 1.2fr;gap:16px;align-items:flex-start;}
  .mechanic-column{display:flex;flex-direction:column;gap:12px;min-width:0;}
  .mechanic-section{background:linear-gradient(170deg,rgba(9,16,32,0.92),rgba(10,22,42,0.95));border:1px solid #1f2c49;border-radius:12px;padding:12px;box-shadow:0 12px 22px rgba(0,0,0,0.32);position:relative;z-index:1;}
  .mechanic-section-head{display:flex;justify-content:space-between;align-items:flex-start;gap:12px;margin-bottom:10px;}
  .mechanic-kicker{margin:0;font-size:11px;letter-spacing:0.14em;text-transform:uppercase;color:#94a9d6;}
  .mechanic-section-head h4{margin:2px 0 6px 0;font-size:18px;letter-spacing:0.04em;color:#e6f8ff;}
  .mechanic-sub{margin:0;color:#9fb4e6;font-size:13px;line-height:1.5;}
  .weapon-pool{display:flex;flex-direction:column;gap:10px;}
  .weapon-group{border:1px solid rgba(34,60,104,0.75);border-radius:10px;padding:10px;background:linear-gradient(150deg,rgba(14,20,36,0.9),rgba(12,18,32,0.92));box-shadow:0 10px 20px rgba(0,0,0,0.28);}
  .weapon-group-header{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px;}
  .weapon-group-header h5{margin:0;font-size:14px;letter-spacing:0.06em;text-transform:uppercase;color:#dfe7ff;}
  .weapon-count{font-size:12px;color:#8fb5ff;letter-spacing:0.08em;}
  .weapon-chip{display:flex;align-items:center;gap:10px;padding:9px 10px;border:1px solid rgba(60,90,140,0.7);border-radius:10px;background:linear-gradient(145deg,rgba(14,20,36,0.92),rgba(9,13,24,0.9));box-shadow:0 8px 18px rgba(4,8,20,0.45);cursor:grab;transition:border-color 0.2s,transform 0.2s,box-shadow 0.2s;}
  .weapon-chip:hover{border-color:rgba(109,220,255,0.6);box-shadow:0 10px 22px rgba(8,16,32,0.5);}
  .weapon-chip:active{cursor:grabbing;}
  .weapon-chip .weapon-name{font-weight:700;color:#e6f8ff;}
  .weapon-chip .weapon-meta{display:flex;gap:6px;font-size:12px;color:#9fb4e6;flex-wrap:wrap;}
  .weapon-chip.dragging{opacity:0.75;transform:scale(0.99);}
  .hp-groups{position:relative;z-index:1;display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));}
  .hp-group{background:linear-gradient(170deg,rgba(9,16,32,0.92),rgba(10,22,42,0.95));border:1px solid #1f2c49;border-radius:12px;padding:12px;box-shadow:0 12px 22px rgba(0,0,0,0.32);}
  .hp-group h4{margin:0 0 8px 0;font-weight:800;letter-spacing:0.04em;color:#dfe7ff;display:flex;align-items:center;justify-content:space-between;}
  .hp-group small{color:#8fb5ff;letter-spacing:0.08em;text-transform:uppercase;}
  .hp-slot{border:1px dashed rgba(88,108,170,0.55);border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:8px;background:linear-gradient(145deg,rgba(10,16,30,0.82),rgba(9,13,24,0.9));box-shadow:inset 0 1px 0 rgba(255,255,255,0.04),0 8px 18px rgba(4,8,20,0.45);transition:border-color 0.18s ease,background 0.18s ease,transform 0.18s ease;}
  .hp-slot:not(:last-child){margin-bottom:8px;}
  .hp-slot.drag-over{border-color:#60a5fa;background:rgba(30,48,92,0.58);box-shadow:0 10px 24px rgba(12,48,96,0.45);}
  .hp-slot .hp-slot-header{display:flex;align-items:center;justify-content:space-between;gap:8px;}
  .hp-slot .hp-slot-label{font-size:13px;letter-spacing:0.08em;text-transform:uppercase;color:#9fb4e6;}
  .hp-slot .hp-slot-clear{padding:4px 8px;border-radius:8px;border:1px solid rgba(58,76,118,0.8);background:rgba(10,16,30,0.9);color:#cbd5ff;cursor:pointer;transition:background 0.18s ease,border-color 0.18s ease;}
  .hp-slot .hp-slot-clear:hover{background:rgba(22,32,56,0.95);border-color:rgba(109,220,255,0.55);}
  .hp-slot-body{display:flex;align-items:center;gap:10px;}
  .hp-slot.empty .hp-slot-body{opacity:0.85;}
  .hp-slot .weapon-name{font-weight:700;color:#e6f8ff;}
  .hp-slot .weapon-meta{font-size:12px;color:#9fb4e6;display:flex;gap:6px;flex-wrap:wrap;}
  .hp-slot .hp-slot-hint{font-size:12px;color:#7687b4;letter-spacing:0.06em;}
  .weapon-icon-wrap{width:46px;height:46px;border-radius:12px;background:rgba(20,28,46,0.95);border:1px solid rgba(74,104,164,0.45);box-shadow:0 10px 18px rgba(6,12,28,0.55);display:flex;align-items:center;justify-content:center;overflow:hidden;flex-shrink:0;}
  .weapon-icon-wrap img{width:100%;height:100%;object-fit:contain;image-rendering:auto;}
  .weapon-icon-placeholder{width:46px;height:46px;border-radius:12px;border:1px dashed rgba(88,108,170,0.45);background:rgba(10,16,30,0.8);box-shadow:inset 0 0 12px rgba(24,32,56,0.55);display:flex;align-items:center;justify-content:center;color:#6b7da8;font-size:11px;letter-spacing:0.12em;text-transform:uppercase;}
  .weapon-icon-placeholder[data-type="main"]{border-color:rgba(58,130,246,0.55);color:#90b4ff;}
  .weapon-icon-placeholder[data-type="missile"]{border-color:rgba(16,185,129,0.55);color:#6dd9b7;}
  .weapon-icon-placeholder[data-type="aux"]{border-color:rgba(245,158,11,0.55);color:#f6c26a;}
  .weapon-icon-placeholder[data-type="hangar"]{border-color:rgba(167,139,250,0.55);color:#cab5ff;}
  .weapon-icon-placeholder[data-type="special"]{border-color:rgba(239,68,68,0.55);color:#fda4a4;}
  .weapon-pill{padding:3px 8px;border-radius:999px;background:rgba(63,88,144,0.35);border:1px solid rgba(96,165,250,0.35);color:#dfe7ff;font-size:11px;letter-spacing:0.06em;text-transform:uppercase;}
  .hp-main h4, .hp-main .hp-slot{outline:1px solid #3b82f6;}
  .hp-miss h4, .hp-miss .hp-slot{outline:1px solid #10b981;}
  .hp-aux h4, .hp-aux .hp-slot{outline:1px solid #f59e0b;}
  .hp-hangar h4, .hp-hangar .hp-slot{outline:1px solid #a78bfa;}
  .hp-spec h4, .hp-spec .hp-slot{outline:1px solid #ef4444;}
  #infrastructure-overlay{max-width:720px;width:min(720px,calc(100vw - 80px));opacity:0;transform:translate(0,12px);transition:opacity 0.25s ease,transform 0.28s ease;pointer-events:none;}
  #infrastructure-overlay.infra-visible{opacity:1;transform:translate(0,0);pointer-events:auto;}
  #infrastructure-overlay.infra-hiding{opacity:0;transform:translate(0,18px);pointer-events:none;}
  body.infrastructure-editor #infrastructure-overlay{right:24px;left:auto;transform:translate(28px,12px);}
  body.infrastructure-editor #infrastructure-overlay.infra-visible{transform:translate(0,0);}
  body.infrastructure-editor #infrastructure-overlay.infra-hiding{transform:translate(18px,18px);}
  #infrastructure-overlay h3{cursor:grab;user-select:none;}
  #infrastructure-overlay.dragging h3{cursor:grabbing;}
  #infrastructure-overlay.dragging{box-shadow:0 22px 48px rgba(5,32,74,0.65);}
  .infrastructure-body{display:flex;flex-direction:column;gap:14px;align-items:stretch;}
  .infra-building-list{display:flex;flex-direction:column;gap:12px;max-height:520px;overflow-y:auto;padding-right:4px;}
  .infra-building{background:linear-gradient(160deg,rgba(10,26,48,0.82),rgba(12,32,58,0.9));border:1px solid var(--fa-border);border-radius:12px;padding:12px;display:flex;flex-direction:column;align-items:center;gap:8px;cursor:grab;transition:border-color 0.2s,transform 0.2s,box-shadow 0.2s;box-shadow:0 12px 26px rgba(0,0,0,0.28);}
  .infra-building:hover{border-color:var(--fa-strong-border);box-shadow:0 12px 26px rgba(16,38,84,0.45);}
  .infra-building:active{cursor:grabbing;}
  .infra-building.dragging{opacity:0.65;transform:scale(0.98);}
  .infra-building-canvas{width:96px;height:96px;border-radius:12px;background:radial-gradient(circle at 50% 35%,rgba(109,220,255,0.38),rgba(12,18,36,0.95));}
  .infra-building-name{font-weight:700;letter-spacing:0.04em;text-align:center;color:#e6f8ff;text-shadow:0 0 8px rgba(109,220,255,0.35);}
  .infra-building-meta{font-size:12px;color:var(--fa-muted);text-align:center;}
  .infra-progress-bar{position:absolute;top:8px;left:8px;right:8px;height:6px;border-radius:6px;background:rgba(47,68,128,0.45);overflow:hidden;}
  .infra-progress-fill{height:100%;width:0%;background:linear-gradient(90deg,#3b82f6,#60a5fa);transition:width 0.2s ease-out;}
  .infra-info{background:rgba(8,12,24,0.6);border:1px solid #1f2c49;border-radius:12px;padding:12px 14px;min-height:120px;display:flex;flex-direction:column;gap:6px;}
  .infra-info h4{margin:0;font-size:16px;color:#8fb5ff;letter-spacing:0.04em;}
  .infra-info p{margin:0;font-size:14px;color:#cbd5ff;line-height:1.5;}
  .infra-info .infra-info-progress{margin-top:4px;}
  .infra-info .infra-info-progress strong{display:block;font-size:12px;letter-spacing:0.08em;color:#94a9d6;text-transform:uppercase;margin-bottom:4px;}
  .infra-info .infra-info-progress .infra-progress-bar{position:relative;top:auto;left:auto;right:auto;margin-top:4px;}
  .infra-info .infra-info-progress .infra-progress-fill{transition:width 0.15s ease-out;}
  .hover-info{position:absolute;top:120px;right:40px;min-width:220px;max-width:320px;background:var(--fa-panel);border:1px solid var(--fa-border);border-radius:14px;padding:14px 18px;z-index:55;color:var(--fa-text);font-family:var(--fa-font);pointer-events:none;backdrop-filter:blur(12px);box-shadow:var(--fa-glow);}
  .hover-info.hidden{display:none !important;}
  .hover-info .hover-title{font-size:16px;font-weight:600;letter-spacing:0.04em;margin:0 0 4px 0;}
  .hover-info .hover-subtitle{display:block;font-size:11px;letter-spacing:0.18em;text-transform:uppercase;color:#8fb5ff;margin-bottom:12px;}
  .hover-info .hover-section{font-size:11px;letter-spacing:0.12em;text-transform:uppercase;color:#94a9d6;margin-bottom:6px;}
  .hover-info .hover-tags{display:flex;flex-wrap:wrap;gap:6px;}
  .hover-info .hover-tag{padding:4px 10px;border-radius:999px;background:rgba(63,88,144,0.38);color:#dfe7ff;font-size:12px;}
  .hover-info .hover-line{font-size:13px;margin-bottom:6px;display:flex;align-items:center;gap:6px;}
  .hover-info .hover-line strong{font-weight:600;color:#8fb5ff;letter-spacing:0.05em;}
  #zoom-indicator{position:absolute;right:24px;top:22px;padding:8px 12px;background:linear-gradient(150deg,rgba(66,142,210,0.32),rgba(55,116,186,0.42));border:1px solid var(--fa-border);border-radius:10px;color:var(--fa-text);font-family:var(--fa-font);font-size:14px;letter-spacing:0.12em;text-transform:uppercase;box-shadow:0 10px 22px rgba(0,0,0,0.35);opacity:0;transform:translateY(-6px);transition:opacity 0.22s ease,transform 0.22s ease;pointer-events:none;z-index:80;}
  #zoom-indicator.visible{opacity:1;transform:translateY(0);}
  .planet-radar{position:fixed;inset:0;pointer-events:none;z-index:78;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  .planet-radar.hidden{display:none !important;}
  .planet-radar-item{position:absolute;display:flex;flex-direction:column;align-items:center;gap:0;transform:translate(-50%,-50%);color:#e2e8f8;text-shadow:0 2px 10px rgba(0,0,0,0.55);}
  .planet-radar-label{padding:4px 10px;border-radius:999px;background:rgba(26,39,68,0.8);border:1px solid rgba(96,132,194,0.6);font-size:11px;letter-spacing:0.14em;text-transform:uppercase;white-space:nowrap;}
  .planet-radar-item.pirate .planet-radar-label,.planet-radar-label.pirate{background:linear-gradient(150deg,rgba(140,18,18,0.9),rgba(189,42,42,0.9));border-color:rgba(255,124,124,0.75);color:#ffecec;box-shadow:0 14px 24px rgba(255,70,70,0.28);}
  /* --- Styl widoku szczegółowego (Windows Explorer style) --- */

/* Ograniczenie wysokości kolumn, aby pojawił się scrollbar */
.mechanic-body {
  height: 520px; /* Stała wysokość obszaru roboczego */
  max-height: calc(80vh - 160px);
  overflow: hidden;
}

.mechanic-column {
  height: 100%;
  display: flex;
  flex-direction: column;
  min-height: 0;
}

.mechanic-section {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden; /* Ważne dla scrolla wewnątrz */
  padding: 0; /* Reset paddingu dla czystszego wyglądu */
}

.mechanic-section-head {
  padding: 10px 12px;
  background: rgba(16, 24, 40, 0.9);
  border-bottom: 1px solid rgba(60, 90, 140, 0.5);
  flex-shrink: 0; /* Nagłówek się nie kurczy */
}

.mechanic-tabs {
  display: flex;
  gap: 6px;
  padding: 8px 10px;
  flex-shrink: 0;
}

.mechanic-tab-btn {
  padding: 6px 10px;
  border-radius: 10px;
  border: 1px solid rgba(60, 90, 140, 0.6);
  background: rgba(12, 18, 32, 0.92);
  color: #dfe7ff;
  font-size: 12px;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  cursor: pointer;
  transition: background 0.18s ease, border-color 0.18s ease, color 0.18s ease;
}

.mechanic-tab-btn:hover {
  background: rgba(22, 34, 60, 0.95);
  border-color: rgba(109, 220, 255, 0.5);
}

.mechanic-tab-btn.active {
  background: linear-gradient(145deg, rgba(109, 220, 255, 0.28), rgba(58, 116, 186, 0.4));
  color: #e6f8ff;
  border-color: rgba(109, 220, 255, 0.75);
  box-shadow: 0 10px 20px rgba(4, 12, 28, 0.35);
}

/* Kontenery na listy z przewijaniem */
.weapon-pool, .hp-groups {
  overflow-y: auto;
  padding: 8px 10px 10px 10px;
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px; /* Mały odstęp między wierszami */
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.weapon-pool::-webkit-scrollbar, .hp-groups::-webkit-scrollbar {
  display: none;
}

/* --- Wygląd Wiersza (ROW) zamiast Kafelka --- */

/* Nagłówki grup (np. "Broń główna") */
.list-group-header {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: #8fb5ff;
  background: rgba(30, 45, 70, 0.6);
  padding: 4px 8px;
  margin-top: 8px;
  border-radius: 4px;
  font-weight: 700;
}

/* Wiersz z bronią (do przeciągania) */
.weapon-row {
  display: grid;
  grid-template-columns: 28px 2fr 1fr; /* Ikona | Nazwa | Statystyki */
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  background: rgba(14, 20, 36, 0.6);
  border: 1px solid rgba(60, 90, 140, 0.3);
  border-radius: 4px;
  cursor: grab;
  font-size: 12px;
  transition: background 0.15s;
}

.weapon-row:hover {
  background: rgba(60, 100, 160, 0.3);
  border-color: rgba(100, 150, 255, 0.5);
}

.weapon-row.dragging {
  opacity: 0.5;
  background: #2a3a5a;
}

/* Mini ikona w wierszu */
.weapon-row-icon {
  width: 24px;
  height: 24px;
  background: rgba(0,0,0,0.3);
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
.weapon-row-icon img { width: 100%; height: 100%; object-fit: contain; }
.weapon-row-icon.placeholder { font-size: 9px; color: #555; border: 1px dashed #444; }

.weapon-row-name { font-weight: 600; color: #e6f8ff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.weapon-row-meta { color: #94a9d6; font-size: 11px; text-align: right; }

/* Wiersz Hardpointu (Slot) */
.hp-row {
  display: grid;
  grid-template-columns: 28px 80px 1fr 24px; /* Ikona | Typ slotu | Zamontowane | Przycisk X */
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  background: rgba(10, 16, 30, 0.7);
  border: 1px dashed rgba(88, 108, 170, 0.4);
  border-radius: 4px;
  font-size: 12px;
  min-height: 34px;
}

.hp-row.drag-over {
  background: rgba(50, 120, 200, 0.25);
  border-color: #60a5fa;
}

.hp-row-label { color: #6b7da8; font-size: 11px; text-transform: uppercase; }
.hp-row-mount { color: #8fb5ff; font-weight: 600; }
.hp-row-mount.empty { color: #4b5563; font-style: italic; font-weight: 400; }

.hp-row-clear {
  width: 20px;
  height: 20px;
  border: none;
  background: transparent;
  color: #ff6b6b;
  cursor: pointer;
  font-weight: bold;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
}
.hp-row-clear:hover { background: rgba(255, 100, 100, 0.15); }
.hp-row-clear:disabled { color: #333; cursor: default; }

/* Kolorowanie ramek slotów wg typu */
.hp-row[data-hp-type="main"] { border-left: 3px solid #3b82f6; }
.hp-row[data-hp-type="missile"] { border-left: 3px solid #10b981; }
.hp-row[data-hp-type="aux"] { border-left: 3px solid #f59e0b; }
.hp-row[data-hp-type="hangar"] { border-left: 3px solid #a78bfa; }
.hp-row[data-hp-type="special"] { border-left: 3px solid #ef4444; }
</style>
<style>
  /* Overlay 3D musi być nad głównym canvasem (#c) */
  canvas.overlay3d {
    position: absolute;
    inset: 0;
    pointer-events: none !important;
    z-index: 30 !important;
  }
</style>
</head>
<body>
  <div id="ui" class="hidden">
    <div><strong>Space Survivors — gwiazdy na całej mapie + duży silnik plazmowy</strong></div>
    <div class="stat">Czas gry: <span id="game-time">00:00</span></div>
    <div class="stat">W — ciąg (duży silnik plazmowy) · Q/E — strafe · A/D — obrót</div>
    <div class="stat">LPM — rail (A→B, A→B) · PPM — boczne rakiety · F — superbroń · SHIFT — warp / dopalacz na orbitach</div>
    <div style="margin-top:6px"><small>Gwiazdy są proceduralne w całej galaktyce. Silnik: niebieski exhaust + krótki ślad przy ruchu.</small></div>

    <div id="bg-gen-status" style="margin-top: 8px; font-size: 11px; color: #7dd3fc; display: none;">
        Generowanie galaktyki: <span id="bg-gen-percent">0%</span>
    </div>
  </div>
  <div id="hud-topbar" class="hud-topbar hidden">
    <div id="skill-slots" class="skill-slot-row" aria-label="Umiejętności i skille"></div>
  </div>
  <div id="side-panels">
    <div id="fleet-ui" class="side-panel hidden" data-panel="fleet">
      <button class="panel-toggle" type="button">
        <span class="side-panel-title">Flota</span>
        <span class="panel-chevron" aria-hidden="true">⟲</span>
      </button>
      <div class="side-panel-body" role="group" aria-label="Flota">
        <ul id="fleet-list"></ul>
      </div>
    </div>
    <div id="support-ui" class="side-panel hidden" data-panel="support">
      <button class="panel-toggle" type="button">
        <span class="side-panel-title">Wsparcie</span>
        <span class="panel-chevron" aria-hidden="true">⟲</span>
      </button>
      <div class="side-panel-body" role="group" aria-label="Wsparcie">
        <div class="support-row">
          <button class="support-btn" data-support-spawn="carrier_capital">Spawn carrier</button>
          <button class="support-btn" data-support-spawn="carrier_fighter">Carrier Fighter</button>
          <button class="support-btn" data-support-spawn="fighter">Fighter Squad</button>
          <button class="support-btn" data-support-spawn="frigate_pd">Frigate (PD)</button>
          <button class="support-btn" data-support-spawn="frigate_laser">Frigate (Laser)</button>
          <button class="support-btn" data-support-spawn="destroyer">Destroyer</button>
          <button class="support-btn" data-support-spawn="battleship">Battleship</button>
        </div>
        <div class="support-row">
          <button id="support-engage" class="support-order-btn">Engage</button>
          <button id="support-guard" class="support-order-btn active">Guard</button>
        </div>
      </div>
    </div>
    <div id="shield-controls" class="side-panel hidden" data-panel="shield">
      <button class="panel-toggle" type="button">
        <span class="side-panel-title">Tarcza</span>
        <span class="panel-chevron" aria-hidden="true">⟲</span>
      </button>
      <div class="side-panel-body" role="group" aria-label="Sterowanie tarczą">
        <div class="support-row">
          <button id="btn-energy-shot" class="support-order-btn">Energy Shot (+50%)</button>
        </div>
      </div>
    </div>
  </div>
  <div id="main-menu">
    <div class="menu-panel">
      <div id="menu-home-view" class="menu-view">
        <h1>Space Survivors</h1>
        <p class="menu-subtitle">Rozpocznij lot lub zajrzyj do nowych opcji.</p>
        <div class="menu-actions">
          <button id="btn-continue" class="menu-primary hidden">Kontynuuj</button>
          <button id="btn-new-game" class="menu-primary">Nowa gra</button>
          <button id="btn-load-game" class="menu-secondary" disabled>Wczytaj grę</button>
          <button id="btn-options" class="menu-secondary">Opcje</button>
        </div>
        <p class="menu-hint">Wczytywanie zapisów będzie dostępne w kolejnych aktualizacjach.</p>
      </div>
      <div id="menu-options-view" class="menu-view hidden">
        <h1>Opcje</h1>
        <p class="menu-subtitle">Dostosuj jakość tła mgławicy.</p>
        <div class="menu-options-grid">
          <div class="menu-option">
            <div class="menu-option-label">Jakość tła</div>
            <div class="menu-chip-group" role="group" aria-label="Jakość tła">
              <button class="menu-chip" data-quality="2k">2K</button>
              <button class="menu-chip" data-quality="4k">4K</button>
              <button class="menu-chip" data-quality="8k">8K</button>
            </div>
            <p class="menu-option-hint">Wyższa rozdzielczość zwiększa ostrość gwiezdnego tła.</p>
          </div>
        </div>
        <div class="menu-actions">
          <button id="btn-options-back" class="menu-secondary">Powrót</button>
        </div>
      </div>
    </div>
  </div>
<div id="game-root">
  <canvas id="c"></canvas>
</div>
<div id="loading" class="hidden">
  <div class="loading-box">
    <div class="loading-title">Ładowanie</div>
    <div class="loading-bar"><span id="loading-fill"></span></div>
    <div id="loading-progress" class="loading-progress">0%</div>
  </div>
</div>
<div id="station-overlay" class="station-overlay hidden">
  <div class="station-head">
    <div>
      <div id="station-title" class="station-title">Stacja orbitalna</div>
      <div id="station-subtitle" class="station-subtitle">Przestrzeń cywilna</div>
    </div>
    <div class="station-balance">
      <div class="label">Kredyty</div>
      <div id="station-credits" class="value">0 cr</div>
    </div>
  </div>
  <ul id="station-tabs"></ul>
  <div class="station-panels">
    <div id="tab-upgrades" class="station-tab"></div>
    <div id="tab-trade" class="station-tab hidden"></div>
    <div id="tab-cantina" class="station-tab hidden"></div>
    <div id="tab-hangar" class="station-tab hidden"></div>
    <div id="tab-mechanic-html" class="station-tab hidden"></div>
    <div id="tab-infrastructure-html" class="station-tab hidden"></div>
  </div>
</div>
<div id="infrastructure-overlay" class="station-overlay hidden">
  <h3>Station Infrastructure</h3>
  <ul>
    <li data-tab="infrastructure">Infrastructure</li>
  </ul>
  <div class="infrastructure-body">
    <div class="infra-building-list" id="infra-building-list"></div>
    <div class="infra-info" id="infra-info">
      <h4>Budowa stacji</h4>
      <p>Przeciągnij budynki z listy na siatkę wokół stacji, aby rozpocząć ich konstrukcję.</p>
    </div>
  </div>
</div>
<div id="zoom-indicator">ZOOM X1.00</div>
<div id="planet-radar" class="planet-radar"></div>
<div id="hover-info" class="hover-info hidden">
  <div class="hover-title"></div>
  <span class="hover-subtitle"></span>
  <div class="hover-content"></div>
</div>
<script type="importmap">
{
  "imports": {
    "three": "./node_modules/three/build/three.module.js",
    "three/addons/": "./node_modules/three/examples/jsm/"
  }
}
</script>
<script type="module" src="./src/config/constants.js"></script>
<script src="https://unpkg.com/regl/dist/regl.min.js"></script>
<script type="module">
  import * as THREE from "three";
  import { EffectComposer }  from "three/addons/postprocessing/EffectComposer.js";
  import { RenderPass }      from "three/addons/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
  import { ShaderPass }      from "three/addons/postprocessing/ShaderPass.js";
  import { OutputPass }      from "three/addons/postprocessing/OutputPass.js";
  import { CopyShader }      from "three/addons/shaders/CopyShader.js";
  import { createShortNeedleExhaust, createWarpExhaustBlue } from "./Engineeffects.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { initWorld3D, attachPirateStation3D, dettachPirateStation3D, updateWorld3D, drawWorld3D } from "./src/3d/world3d.js";
  import { initStations3D, updateStations3D, detachPlanetStations3D, drawStations3D } from "./src/3d/stations3D.js";
  import { initOverlay } from "./src/effects3d/overlay.js";
  import { createRailgunExplosionFactory } from "./src/effects3d/railgunExplosion.js";
  import { createArmataImpactFactory } from "./src/effects3d/armataImpact.js";
  import { createAutocannonImpactFactory } from "./src/effects3d/autocannonImpact.js";
  import { createReactorBlowFactory } from "./src/effects3d/reactorblow.js";
  import * as Space2DBackground from "./src/lib/space2d/tyroBackground.js";
  import { WarpBlackHole } from "./src/vfx/warpBlackHole.js";
  import { drawInfrastructureIcon, updateInfrastructureAnimations } from './src/buildings/infrastructureView.js';
  import { createShipEntity, applyPlayerInput, runShipAI } from "./src/game/shipEntity.js";
  import { DestructorSystem, initHexBody, drawHexBody, drawHexBodyLocal } from "./src/game/destructor.js";
  window.THREE = THREE;
  window.EffectComposer  = EffectComposer;
  window.RenderPass      = RenderPass;
  window.UnrealBloomPass = UnrealBloomPass;
  window.ShaderPass      = ShaderPass;
  window.OutputPass      = OutputPass;
  window.createShortNeedleExhaust = createShortNeedleExhaust;
  window.createWarpExhaustBlue = createWarpExhaustBlue;
  window.GLTFLoader = GLTFLoader;
  window.initWorld3D = initWorld3D;
  window.attachPirateStation3D = attachPirateStation3D;
  window.dettachPirateStation3D = dettachPirateStation3D;
  window.updateWorld3D = updateWorld3D;
  window.drawWorld3D = drawWorld3D;
  window.initStations3D = initStations3D;
  window.updateStations3D = updateStations3D;
  window.drawStations3D = drawStations3D;
  window.detachPlanetStations3D = detachPlanetStations3D;
  window.initOverlay3D = initOverlay;
  window.createRailgunExplosionFactory = createRailgunExplosionFactory;
  window.createArmataImpactFactory = createArmataImpactFactory;
  window.createAutocannonImpactFactory = createAutocannonImpactFactory;
  window.createReactorBlowFactory = createReactorBlowFactory;
  window.createShipEntity = createShipEntity;
  window.applyPlayerInput = applyPlayerInput;
  window.runShipAI = runShipAI;
  window.drawInfrastructureIcon = drawInfrastructureIcon;
  window.updateInfrastructureAnimations = updateInfrastructureAnimations;
  window.DestructorSystem = DestructorSystem;
  window.initHexBody = initHexBody;
  window.drawHexBody = drawHexBody;
  window.drawHexBodyLocal = drawHexBodyLocal;
  // Nie modyfikujemy namespace'u modułu THREE (jest niemodyfikowalny).
  // Jeśli coś potrzebuje CopyShader globalnie, wystawiamy go przez window:
  window.CopyShader = CopyShader;
  window.Space2DBackground = Space2DBackground;

  const warpFX = new WarpBlackHole({ zIndex: 45, mode: 'offscreen' });
  warpFX.setEnabled(false);
  window.warpBlackHoleFX = warpFX;

</script>
<!-- przełącznik: aktywuj assetowy renderer planet (klasyczny skrypt, aby globalne API było gotowe zanim ruszy pętla gry) -->
<script type="module" src="planet3d.assets.js"></script>

<script type="module">
import { DEFAULT_PLANET_SCALE, TIME_SCALE } from './src/config/constants.js';
import { WORLD, setWorldSize } from './src/world/world.js';
import { initShieldSystem, updateShieldFx, drawShield, registerShieldImpact, resizeShieldSystem, triggerEnergyShot as applyEnergyShot } from './shieldSystem.js';
import { createShipEntity, applyPlayerInput, runShipAI } from "./src/game/shipEntity.js";
import { DestructorSystem, initHexBody, drawHexBody, drawHexBodyLocal } from "./src/game/destructor.js";
// Statki Terran (Wsparcie)
import terranFrigateImg from "./src/assets/ships/terranfrigate.png";
import terranDestroyerImg from "./src/assets/ships/terrandestroyer.png";
import terranBattleshipImg from "./src/assets/ships/terranbattleship.png";

// Statki Piratów
import pirateFrigateImg from "./src/assets/ships/piratefrigate.png";
import pirateDestroyerImg from "./src/assets/ships/piratedestroyer.png";
import pirateBattleshipImg from "./src/assets/ships/piratebattleship.png";

// Jednostki mniejsze
import fighterImg from "./assets/fighter.png";
import npcFriImg from "./assets/npc_friendly.png";
import npcHosImg from "./assets/npc_hostile.png";
window.bullets = [];
// Aby stary kod działał, zrobimy alias:
const bullets = window.bullets;
window.registerShieldImpact = registerShieldImpact;
window.DEFAULT_PLANET_SCALE ??= DEFAULT_PLANET_SCALE;
window.TIME_SCALE ??= TIME_SCALE;
window.WORLD ??= WORLD;

// LOKALNY alias na potrzeby tego modułu (ESM nie widzi 'gołych' globali z window):
const PLANET_SCALE =
  (typeof window !== 'undefined' && typeof window.DEFAULT_PLANET_SCALE !== 'undefined')
    ? window.DEFAULT_PLANET_SCALE : (DEFAULT_PLANET_SCALE ?? 3);

let warpBrakeTimer = 0;

// =============== Canvas & utils ===============
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth, H = canvas.height = innerHeight;

const fleetUIRoot = document.getElementById('fleet-ui');
const fleetListEl = document.getElementById('fleet-list');
const supportUIRoot = document.getElementById('support-ui');
const supportGuardBtn = document.getElementById('support-guard');
const supportEngageBtn = document.getElementById('support-engage');
const supportSpawnButtons = document.querySelectorAll('[data-support-spawn]');
const carrierSpawnBtn = document.querySelector('[data-support-spawn="carrier_capital"]');
const shieldControlsRoot = document.getElementById('shield-controls');
const energyShotBtn = document.getElementById('btn-energy-shot');

function setupSidePanel(panelEl){
  if (!panelEl) return null;
  const toggleBtn = panelEl.querySelector('.panel-toggle');
  const bodyEl = panelEl.querySelector('.side-panel-body');
  let collapsed = false;

  function applyState(){
    panelEl.classList.toggle('collapsed', collapsed);
    if (bodyEl) bodyEl.setAttribute('aria-hidden', collapsed ? 'true' : 'false');
    panelEl.setAttribute('data-collapsed', collapsed ? 'true' : 'false');
  }

  applyState();

  if (toggleBtn){
    toggleBtn.addEventListener('click', () => {
      collapsed = !collapsed;
      applyState();
    });
  }

  return {
    collapse(){ if (!collapsed){ collapsed = true; applyState(); } },
    expand(){ if (collapsed){ collapsed = false; applyState(); } },
    isCollapsed: () => collapsed
  };
}

const fleetPanel = setupSidePanel(fleetUIRoot);
const supportPanel = setupSidePanel(supportUIRoot);
const shieldPanel = setupSidePanel(shieldControlsRoot);
const Fleet = window.Fleet || (window.Fleet = {
  ships: [],
  dirty: true,
  ui: {
    root: fleetUIRoot || null,
    list: fleetListEl || null,
    lastUpdate: 0
  }
});
if (!Fleet.ui.root && fleetUIRoot) Fleet.ui.root = fleetUIRoot;
if (!Fleet.ui.list && fleetListEl) Fleet.ui.list = fleetListEl;
function markFleetDirty(){ Fleet.dirty = true; }

const SupportWing = window.SupportWing || (window.SupportWing = {
  units: [],
  order: 'guard',
  ui: {
    root: supportUIRoot || null,
    guardBtn: supportGuardBtn || null,
    engageBtn: supportEngageBtn || null
  }
});
if (!SupportWing.ui.root && supportUIRoot) SupportWing.ui.root = supportUIRoot;
if (!SupportWing.ui.guardBtn && supportGuardBtn) SupportWing.ui.guardBtn = supportGuardBtn;
if (!SupportWing.ui.engageBtn && supportEngageBtn) SupportWing.ui.engageBtn = supportEngageBtn;

const OPTIONS = {
  vfx: { colorTempK: 8000, bloomGain: 1.1, engineGain: 1.0 },
  audio: { master: 0.8, sfx: 1.0, music: 0.7 },
  controls: { mouseSensitivity: 1.0 } // bez odwracania osi
};
let OPTIONS_OPEN = false;

// --- SYSTEM AUDIO (AudioSys) ---
const AudioSys = {
  ctx: null,
  masterGain: null,
  sounds: {},
  isInit: false,

  // Inicjalizacja kontekstu (musi być po kliknięciu użytkownika)
  init: function() {
    if (this.isInit) return;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AudioContext();
    
    // Główna szyna głośności (Master)
    this.masterGain = this.ctx.createGain();
    // Pobieramy głośność z Twoich OPTIONS (jeśli są dostępne)
    const vol = (typeof OPTIONS !== 'undefined') ? OPTIONS.audio.master : 0.5;
    this.masterGain.gain.value = vol;
    this.masterGain.connect(this.ctx.destination);
    
    this.isInit = true;
    console.log("🔊 AudioSys: Zainicjowano.");
  },

  // Ładowanie pojedynczego dźwięku do pamięci
  loadSound: async function(name, url) {
    if (!this.ctx) this.init();
    try {
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
      this.sounds[name] = audioBuffer;
      console.log(`🔊 AudioSys: Załadowano '${name}'`);
    } catch (e) {
      console.error(`🔊 AudioSys: Błąd ładowania '${name}' z ${url}:`, e);
    }
  },

  // Tworzenie zapętlonego silnika (z kontrolą Pitch i Volume)
  createEngineLoop: function(soundName) {
    if (!this.sounds[soundName]) return null;
    
    const source = this.ctx.createBufferSource();
    source.buffer = this.sounds[soundName];
    source.loop = true;

    const gainNode = this.ctx.createGain();
    gainNode.gain.value = 0; // Na start cisza

    // Łańcuch: Źródło -> Gain -> Master -> Wyjście
    source.connect(gainNode);
    gainNode.connect(this.masterGain);
    
    source.start(0);

    return {
      source: source,
      gain: gainNode,
      
      // Funkcja aktualizująca brzmienie w czasie rzeczywistym
      update: (throttle) => {
        const now = AudioSys.ctx.currentTime;
        const targetPitch = 0.5 + (throttle * 0.6); 
        source.playbackRate.setTargetAtTime(targetPitch, now, 0.2);
        let baseVol = 0.05 + (throttle * 0.25);

        // Pobranie ustawień SFX gracza
        const sfxVol = (typeof OPTIONS !== 'undefined') ? OPTIONS.audio.sfx : 1.0;
        
        // Aplikowanie głośności
        gainNode.gain.setTargetAtTime(baseVol * sfxVol, now, 0.1);
      },
      
      stop: () => {
        try { source.stop(); } catch(e){}
      }
    };
  },
  // Prosta funkcja do strzałów (na przyszłość)
  playSound: function(name) {
    if (!this.sounds[name]) return;
    const source = this.ctx.createBufferSource();
    source.buffer = this.sounds[name];
    const sfxVol = (typeof OPTIONS !== 'undefined') ? OPTIONS.audio.sfx : 1.0;
    
    const gain = this.ctx.createGain();
    gain.gain.value = sfxVol;
    
    source.connect(gain);
    gain.connect(this.masterGain);
    source.start(0);
  }
};

const uiRoot = document.getElementById('ui');
const mainMenuEl = document.getElementById('main-menu');
const newGameButton = document.getElementById('btn-new-game');
const loadGameButton = document.getElementById('btn-load-game');
const optionsButton = document.getElementById('btn-options');
const continueButton = document.getElementById('btn-continue');
const menuHomeView = document.getElementById('menu-home-view');
const menuOptionsView = document.getElementById('menu-options-view');
const MENU_MUSIC_SRC = '/sounds/menu/menu.mp3';
let menuMusicEl = null;
let menuMusicFadeId = null;
let menuMusicUnlockAttached = false;
const optionsBackButton = document.getElementById('btn-options-back');
const qualityButtons = Array.from(document.querySelectorAll('[data-quality]'));
const loadingEl = document.getElementById('loading');
const loadingFillEl = document.getElementById('loading-fill');
const loadingProgressEl = document.getElementById('loading-progress');
const planetRadarRoot = document.getElementById('planet-radar');
const hudTopbarRoot = document.getElementById('hud-topbar');
const skillSlotsEl = document.getElementById('skill-slots');
const hullFillEl = document.getElementById('player-hull-fill');
const shieldFillEl = document.getElementById('player-shield-fill');
const hullLabelEl = document.getElementById('player-hull-label');
const shieldLabelEl = document.getElementById('player-shield-label');
let gameStarted = false;
let menuView = 'home';

function setLoadingProgress(value, label){
  const clamped = Math.max(0, Math.min(100, Math.round(value)));
  if (loadingFillEl) loadingFillEl.style.width = `${clamped}%`;
  if (loadingProgressEl) loadingProgressEl.textContent = label ? `${clamped}% · ${label}` : `${clamped}%`;
}

function showLoadingOverlay(progress = 0, label = ''){
  if (loadingEl) loadingEl.classList.remove('hidden');
  setLoadingProgress(progress, label);
}

function hideLoadingOverlay(){
  if (loadingEl) loadingEl.classList.add('hidden');
}

function nextFrame(){
  return new Promise(resolve => requestAnimationFrame(() => resolve()));
}

function waitForCondition(predicate, timeoutMs = 4000){
  return new Promise(resolve => {
    const start = performance.now();
    (function poll(){
      if (predicate()) return resolve();
      if (performance.now() - start >= timeoutMs) return resolve();
      requestAnimationFrame(poll);
    })();
  });
}

function setMenuView(nextView = 'home'){
  menuView = nextView === 'options' ? 'options' : 'home';
  if (menuHomeView) menuHomeView.classList.toggle('hidden', menuView !== 'home');
  if (menuOptionsView) menuOptionsView.classList.toggle('hidden', menuView !== 'options');
  if (menuView === 'options') applyQualitySelection();
}

function getMenuMusicVolume(){
  const master = OPTIONS?.audio?.master ?? 1;
  const music = OPTIONS?.audio?.music ?? 1;
  return Math.max(0, Math.min(1, master * music));
}

function getMenuMusic(){
  if (!menuMusicEl){
    menuMusicEl = new Audio(MENU_MUSIC_SRC);
    menuMusicEl.loop = true;
    menuMusicEl.volume = getMenuMusicVolume();
  }
  return menuMusicEl;
}

function tryPlayMenuMusic(){
  if (gameStarted) return;
  const audio = getMenuMusic();
  audio.volume = getMenuMusicVolume();
  const unlock = () => {
    audio.play().catch(()=>{});
    document.removeEventListener('pointerdown', unlock);
    document.removeEventListener('keydown', unlock);
    menuMusicUnlockAttached = false;
  };

  const playPromise = audio.play();
  if (playPromise && typeof playPromise.catch === 'function'){
    playPromise.catch(() => {
      if (menuMusicUnlockAttached) return;
      menuMusicUnlockAttached = true;
      document.addEventListener('pointerdown', unlock, { once: true });
      document.addEventListener('keydown', unlock, { once: true });
    });
  }
}

function fadeOutMenuMusic(duration = 1200){
  if (menuMusicFadeId) cancelAnimationFrame(menuMusicFadeId);
  const audio = menuMusicEl;
  if (!audio || audio.paused || audio.volume <= 0.001){
    if (audio){
      audio.pause();
      audio.currentTime = 0;
    }
    return Promise.resolve();
  }
  const startVolume = audio.volume;
  return new Promise(resolve => {
    const start = performance.now();
    const step = (now) => {
      const t = Math.min(1, (now - start) / duration);
      const v = startVolume * (1 - t);
      audio.volume = Math.max(0, v);
      if (t < 1){
        menuMusicFadeId = requestAnimationFrame(step);
      } else {
        audio.pause();
        audio.currentTime = 0;
        resolve();
      }
    };
    menuMusicFadeId = requestAnimationFrame(step);
  });
}

function isMainMenuVisible(){
  return !!mainMenuEl && !mainMenuEl.classList.contains('hidden');
}

if (isMainMenuVisible()) tryPlayMenuMusic();

function showMainMenu(view = 'home'){
  setMenuView(view);
  if (mainMenuEl) mainMenuEl.classList.remove('hidden');
  if (gameStarted) setPaused(true);
  if (!gameStarted) tryPlayMenuMusic();
}

function hideMainMenu(){
  if (mainMenuEl) mainMenuEl.classList.add('hidden');
  if (gameStarted) setPaused(false);
}

function toggleMainMenu(){
  if (isMainMenuVisible()) hideMainMenu();
  else showMainMenu('home');
}

function getBackgroundQuality(){
  if (window.Nebula?.getConfig) return window.Nebula.getConfig().quality;
  if (window.Space2DBackground?.getConfig) return window.Space2DBackground.getConfig().quality;
  return null;
}

function applyQualitySelection(){
  const current = getBackgroundQuality();
  if (!qualityButtons || !qualityButtons.length) return;
  qualityButtons.forEach(btn => {
    const isActive = btn.dataset.quality === current;
    btn.classList.toggle('active', isActive);
    btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  });
}

function setBackgroundQuality(quality){
  if (window.Nebula?.setQuality) window.Nebula.setQuality(quality);
  else if (window.Space2DBackground?.setQuality) window.Space2DBackground.setQuality(quality);
  applyQualitySelection();
}

if (skillSlotsEl && skillSlotsEl.childElementCount === 0) {
  const slots = ['1','2','3','4','5','6','7','8','9','0'];
  slots.forEach(label => {
    const slot = document.createElement('div');
    slot.className = 'skill-slot';
    slot.textContent = label;
    skillSlotsEl.appendChild(slot);
  });
}

// Model widoku overlayu (ortho nad światem 2D)
const overlayView = {
  center: { x: 0, y: 0 },
  viewport: { w: innerWidth, h: innerHeight },
  zoom: 1.0
};

let spaceBg = null;
let spaceBgReady = false;
const warpBlackHoleFX = window.warpBlackHoleFX || null;
let warpLensMode = 'background';
let warpLensSource = null;

const WARP_LENS_DEFAULTS = Object.freeze({
  threshold: 0,
  radiusBase: 0.6,
  radiusScale: 0.3,
  massBase: 0,
  massScale: 0.035,
  softness: 0.6,
  opacityBase: 0.55,
  opacityScale: 0.73,
  tailDepthExtra: -0.2,
  forwardStretch: 1.0
});

const DevVFX = window.DevVFX = window.DevVFX || {};
DevVFX.warpLens = Object.assign({}, WARP_LENS_DEFAULTS, DevVFX.warpLens || {});
window.__WARP_LENS_DEFAULTS = WARP_LENS_DEFAULTS;

function warpLensParam(key){
  const defaults = WARP_LENS_DEFAULTS;
  const bag = DevVFX?.warpLens || defaults;
  const raw = bag[key];
  return Number.isFinite(raw) ? raw : defaults[key];
}

function getAuToWorldUnits(){
  return (typeof BASE_ORBIT === 'number' && BASE_ORBIT > 0) ? BASE_ORBIT : 3000;
}

function getWarpLensThreshold(){
  const v = warpLensParam('threshold');
  if (!Number.isFinite(v)) return WARP_LENS_DEFAULTS.threshold;
  return Math.min(1, Math.max(0, v));
}

function configureWarpLensSource(){
  if (!warpBlackHoleFX) return;
  if (typeof warpBlackHoleFX.setSourceParallaxTransform === 'function') {
    warpBlackHoleFX.setSourceParallaxTransform(null);
  }
  if (warpLensMode === 'background') {
    if (spaceBg && typeof spaceBg.getBackgroundCanvas === 'function') {
      const descriptor = typeof spaceBg.getBackgroundSampleDescriptor === 'function'
        ? spaceBg.getBackgroundSampleDescriptor()
        : null;
      const src = descriptor?.canvas ?? spaceBg.getBackgroundCanvas();
      if (src && warpLensSource !== src) {
        warpLensSource = src;
        warpBlackHoleFX.setSourceCanvas(src);
      }
      if (descriptor && typeof warpBlackHoleFX.setSourceParallaxTransform === 'function') {
        warpBlackHoleFX.setSourceParallaxTransform(descriptor);
      }
    }
  } else if (warpLensMode === 'full') {
    if (warpLensSource !== ctx.canvas) {
      warpLensSource = ctx.canvas;
      warpBlackHoleFX.setSourceCanvas(ctx.canvas);
    }
  }
}

if (warpBlackHoleFX) {
  window.setWarpLensMode = function(mode){
    const next = mode === 'full' ? 'full' : 'background';
    if (warpLensMode !== next) {
      warpLensMode = next;
      warpLensSource = null;
      configureWarpLensSource();
    }
  };
  window.addEventListener('resize', configureWarpLensSource);
}

if (typeof configureWarpLensSource === 'function') {
  configureWarpLensSource();
}

function tryInitSpaceBackground(){
  if (spaceBgReady) return true;
  const module = window.Space2DBackground;
  if (!module) return false;
  spaceBg = module;
  try {
    module.setBgOptions?.({
      renderSun: false,
      renderNebulae: true,
      renderStars: true,
      renderPointStars: false,
      shortScale: true
    });
    module.initSpaceBg?.(window.SUN?.seed ?? 12345);
    module.resizeSpaceBg?.(innerWidth, innerHeight);
    spaceBgReady = true;
    configureWarpLensSource();
    window.removeEventListener('DOMContentLoaded', tryInitSpaceBackground);
    window.removeEventListener('load', tryInitSpaceBackground);
    return true;
  } catch (err) {
    return false;
  }
}

if (!tryInitSpaceBackground()) {
  window.addEventListener('DOMContentLoaded', tryInitSpaceBackground);
  window.addEventListener('load', tryInitSpaceBackground);
  let spaceBgPollAttempts = 0;
  const MAX_SPACE_BG_POLL_ATTEMPTS = 240;
  (function pollSpaceBackground(){
    if (tryInitSpaceBackground() || spaceBgPollAttempts++ >= MAX_SPACE_BG_POLL_ATTEMPTS) return;
    requestAnimationFrame(pollSpaceBackground);
  })();
}

function waitForSpaceBackgroundReady(){
  if (spaceBgReady) return Promise.resolve();
  return waitForCondition(() => spaceBgReady, 2500);
}

let mainScene3D = null;
let planetScene3D = null;
let planetStationsReady = false;

//const { createShipEntity, applyPlayerInput, runShipAI } = window

function asThreeScene(candidate){
  if (!candidate) return null;
  if (candidate.isScene) return candidate;
  if (candidate.scene && candidate.scene.isScene) return candidate.scene;
  if (candidate.scene3D && candidate.scene3D.isScene) return candidate.scene3D;
  if (candidate.planetScene && candidate.planetScene.isScene) return candidate.planetScene;
  if (candidate.sceneObject && candidate.sceneObject.isScene) return candidate.sceneObject;
  return null;
}

function findPlanetScene3D(){
  const directCandidates = [
    mainScene3D,
    planetScene3D,
    window.planetsScene3D,
    window.planetsScene,
    window.planetScene3D,
    window.PlanetScene3D,
    window.PlanetsScene3D,
    window.planets3DScene,
    window.planets3D
  ];
  for (const candidate of directCandidates){
    const scene = asThreeScene(candidate);
    if (scene) return scene;
  }
  const lazyCandidates = [
    typeof window.getPlanetsScene3D === 'function' ? window.getPlanetsScene3D() : null,
    typeof window.getPlanetScene3D === 'function' ? window.getPlanetScene3D() : null
  ];
  for (const candidate of lazyCandidates){
    const scene = asThreeScene(candidate);
    if (scene) return scene;
  }
  return null;
}

function ensurePlanetStationsInit(stationsList){
  if (typeof window.initStations3D !== 'function') return false;
  if (!Array.isArray(stationsList)) return false;
  if (!planetStationsReady) {
    window.initStations3D(null, stationsList);
    planetStationsReady = true;
  }
  return planetStationsReady;
}

function detachPlanetStationsIfNeeded(){
  if (typeof window.detachPlanetStations3D === 'function'){
    window.detachPlanetStations3D(planetScene3D);
  }
  planetScene3D = null;
  planetStationsReady = false;
}

window.addEventListener('beforeunload', detachPlanetStationsIfNeeded);

// Dev flags/tuning (persisted via  where available)
window.DevFlags = Object.assign({
  showRuler: false,
  unlimitedWarp: false,
  showSunDir: false,
  use3DPirateStation: true,
  usePlanetStations3D: true,
  disableCameraShake: false
}, window.DevFlags || {});
const DEFAULT_PIRATE_STATION_SCALE = 6;
const DEFAULT_STATION_3D_SCALE = 2.70;
window.DEFAULT_STATION_SCALE = DEFAULT_PIRATE_STATION_SCALE;
window.DEFAULT_STATION_3D_SCALE = DEFAULT_STATION_3D_SCALE;

window.DevTuning = Object.assign({
  pirateStationScale: DEFAULT_PIRATE_STATION_SCALE
}, window.DevTuning || {});

const DevFlags = window.DevFlags;
const DevTuning = window.DevTuning;
const Dev = window.Dev = window.Dev || {};
if (!Number.isFinite(Dev.station3DScale) || Dev.station3DScale <= 0) {
  Dev.station3DScale = DEFAULT_STATION_3D_SCALE;
}
if (!Number.isFinite(DevTuning.pirateStationScale)) {
  DevTuning.pirateStationScale = DEFAULT_PIRATE_STATION_SCALE;
}

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  function clampTurnAngle(currentAng, targetAng, maxRateRad, dt){
  let d = targetAng - currentAng;
  while(d >  Math.PI) d -= 2*Math.PI;
  while(d < -Math.PI) d += 2*Math.PI;
  const change = Math.max(-maxRateRad * dt, Math.min(maxRateRad * dt, d));
  let out = currentAng + change;
  if(out >  Math.PI) out -= 2*Math.PI;
  if(out < -Math.PI) out += 2*Math.PI;
  return out;
}

function dist2(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return dx*dx + dy*dy;
}
const lerp = (a,b,t)=>a + (b - a) * t;
const add = (a,b)=>({x:a.x+b.x,y:a.y+b.y});
const mul = (v,s)=>({x:v.x*s,y:v.y*s});
const len = v=>Math.hypot(v.x,v.y);
const norm = v=>{ const L=len(v); return L?{x:v.x/L,y:v.y/L}:{x:0,y:0}; };
  
// === AI SPACE PHYSICS UTILS ===
function clampTurnVec(vx, vy, wantVx, wantVy, dt, maxDeg){
  const maxRad = (maxDeg * Math.PI / 180) * dt;
  const a = Math.atan2(vy, vx);
  const b = Math.atan2(wantVy, wantVx);
  let d = b - a;
  while(d >  Math.PI) d -= 2*Math.PI;
  while(d < -Math.PI) d += 2*Math.PI;
  const lim = Math.max(-maxRad, Math.min(maxRad, d));
  const speed = Math.hypot(wantVx, wantVy);
  const ang = a + lim;
  return { vx: Math.cos(ang) * speed, vy: Math.sin(ang) * speed };
}

function getLeadAim(shooter, target, projSpeed){
  const targetX = target.pos ? target.pos.x : target.x;
  const targetY = target.pos ? target.pos.y : target.y;
  const vx = target.vx ?? target.vel?.x ?? 0;
  const vy = target.vy ?? target.vel?.y ?? 0;
  const px = targetX - shooter.x, py = targetY - shooter.y;
  const A = (vx*vx + vy*vy) - projSpeed*projSpeed;
  const B = 2 * (px*vx + py*vy);
  const C = (px*px + py*py);
  let t = 0;
  if(Math.abs(A) < 1e-3){
    t = -C / Math.max(B, -1e-3);
  } else {
    const disc = B*B - 4*A*C;
    t = (disc > 0) ? (-B - Math.sqrt(disc)) / (2*A) : 0;
  }
  t = Math.max(0, Math.min(2.0, t));
  return { x: targetX + vx*t, y: targetY + vy*t };
}
const smoothstep01 = t=>{ const x = clamp(t, 0, 1); return x*x*(3 - 2*x); };
function rotate(local,a){ const c=Math.cos(a), s=Math.sin(a); return {x: local.x*c - local.y*s, y: local.x*s + local.y*c}; }
function rotateInv(world,a){ return rotate(world, -a); }
function muzzlePosFor(entity, dir, extra = 8){
  const rad = (entity.radius != null) ? entity.radius : (entity.r != null ? entity.r : 12);
  return { x: entity.x + dir.x * (rad + extra), y: entity.y + dir.y * (rad + extra) };
}

const fleetNumberFormatter = new Intl.NumberFormat('pl-PL', { maximumFractionDigits: 0 });
const FLEET_UI_REFRESH_MS = 1000;
const SUPPORT_TYPE_LABELS = {
  fighter: 'Mysliwiec',
  frigate_pd: 'Fregata PD',
  frigate_laser: 'Fregata Laserowa',
  destroyer: 'Destroyer',
  battleship: 'Battleship',
  carrier: 'Capital',
  capital: 'Capital',
  supercapital: 'Supercapital'
};
const UNIMPLEMENTED_FLEET_TYPES = new Set(['capital', 'supercapital']);
window.aiSpawnBullet = function(sim, from, to, weapon) {
  const ang = Math.atan2(to.y - from.y, to.x - from.x);
  const spread = (weapon.spread || 0) * (Math.PI / 180);
  const a = ang + (Math.random() * 2 - 1) * spread;
  const speed = weapon.speed || 500;

  // Mapowanie wyglądu pocisku
  let bType = 'plasma';
  if(weapon.name && weapon.name.includes('Rail')) bType = 'rail';
  if(weapon.name && weapon.name.includes('Flak')) bType = 'armata';

  window.bullets.push({
    x: from.x,
    y: from.y,
    vx: Math.cos(a) * speed + (from.vx || 0) * 0.2,
    vy: Math.sin(a) * speed + (from.vy || 0) * 0.2,
    life: (weapon.range || 1000) / speed,
    r: (bType === 'rail') ? 4 : 3,
    owner: from.friendly ? 'player' : 'npc',
    damage: weapon.dmg || 10,
    type: bType,
    color: weapon.color || '#ffd36e',
    source: from,
    explodeRadius: (bType === 'armata') ? (weapon.radius || 40) : 0
  });
};
function formatFleetNumber(value){
  if (!Number.isFinite(value)) return '0';
  return fleetNumberFormatter.format(Math.max(0, Math.round(value)));
}

function getSupportTypeLabel(typeKey){
  if (!typeKey) return 'Jednostka';
  return SUPPORT_TYPE_LABELS[typeKey] || typeKey;
}

function buildSupportEntries(){
  const entries = [];
  const units = Array.isArray(SupportWing?.units) ? SupportWing.units : [];
  const liveUnits = units.filter(u => u && u.npc && !u.npc.dead && u.npc.friendly);
  const fighterCount = liveUnits.filter(u => (u.type || u.npc?.type) === 'fighter').length;
  if (fighterCount > 0){
    entries.push({ kind: 'fighters', label: 'Mysliwce', count: fighterCount });
  }

  for (const unit of liveUnits){
    const npc = unit.npc;
    const typeKey = unit.type || npc.type;
    if (typeKey === 'fighter') continue;
    const shield = npc.shield || {};
    const label = getSupportTypeLabel(typeKey);

    entries.push({
      id: unit.slotIndex ?? `${typeKey || 'support'}_${entries.length}`,
      kind: UNIMPLEMENTED_FLEET_TYPES.has(typeKey) ? 'placeholder' : 'ship',
      name: label,
      typeLabel: label,
      meta: 'Wsparcie',
      hull: Math.max(0, npc.hp ?? 0),
      shield: Math.max(0, shield.val ?? 0)
    });
  }
  return entries;
}

function buildCapitalEntries(){
  const entries = [];
  for (const ship of Fleet.ships){
    const npc = ship.entity;
    if (!npc || npc.dead || !npc.friendly) continue;
    const typeKey = ship.type || npc.type || 'capital';
    const label = ship.displayName || getSupportTypeLabel(typeKey);
    const shield = npc.shield || {};

    entries.push({
      id: ship.id || `${typeKey}_${entries.length}`,
      kind: UNIMPLEMENTED_FLEET_TYPES.has(typeKey) ? 'placeholder' : 'ship',
      name: label,
      typeLabel: ship.roleText || getSupportTypeLabel(typeKey),
      meta: ship.roleText || 'Capital',
      hull: Math.max(0, ship.status?.hull ?? npc.hp ?? 0),
      shield: Math.max(0, ship.status?.shield ?? shield.val ?? 0)
    });
  }
  return entries;
}

function renderFleetEntry(entry){
  const li = document.createElement('li');
  li.className = 'fleet-ship';

  if (entry.kind === 'fighters'){
    const fighters = document.createElement('div');
    fighters.className = 'fleet-fighters';
    fighters.textContent = `${entry.label}: ${formatFleetNumber(entry.count)}`;
    li.appendChild(fighters);
    return li;
  }

  const header = document.createElement('div');
  header.className = 'fleet-ship-header';
  const nameEl = document.createElement('div');
  nameEl.className = 'fleet-ship-name';
  nameEl.textContent = `${entry.name} (${entry.typeLabel})`;
  const metaEl = document.createElement('div');
  metaEl.className = 'fleet-ship-meta';
  metaEl.textContent = entry.meta || 'Flota';
  header.append(nameEl, metaEl);
  li.appendChild(header);

  const stats = document.createElement('div');
  stats.className = 'fleet-stats';
  if (entry.kind === 'placeholder'){
    stats.textContent = 'W przygotowaniu';
  } else {
    const hpSpan = document.createElement('span');
    hpSpan.textContent = `HP: ${formatFleetNumber(entry.hull)}`;
    const shieldSpan = document.createElement('span');
    shieldSpan.textContent = `SHIELD: ${formatFleetNumber(entry.shield)}`;
    stats.append(hpSpan, document.createTextNode(' · '), shieldSpan);
  }
  li.appendChild(stats);

  return li;
}

function updateFleetUI(){
  const ui = Fleet.ui;
  if (!ui || !ui.root || !ui.list) return;
  const now = performance.now();
  if (!Fleet.dirty && now - (ui.lastUpdate || 0) < FLEET_UI_REFRESH_MS) return;
  ui.lastUpdate = now;

  const entries = [...buildSupportEntries(), ...buildCapitalEntries()];
  if (!entries.length){
    ui.root.classList.add('hidden');
    ui.list.innerHTML = '';
    Fleet.dirty = false;
    return;
  }

  ui.root.classList.remove('hidden');
  ui.list.innerHTML = '';
  for (const entry of entries){
    ui.list.appendChild(renderFleetEntry(entry));
  }
  Fleet.dirty = false;
}

const SUPPORT_FORMATION = {
  lineOrder: ['frigate_laser', 'frigate_pd', 'destroyer', 'battleship', 'fighter'],
  lead: 260,
  lineGap: 160,
  lateralGap: 160,
  spawn: { perRow: 4, colGap: 90, rowGap: 70, lead: 160 },
  fighterSquadSize: 9,
  fighterOffsets: [
    { x: -20, y: -15 }, { x: -20, y: 15 },
    { x: -40, y: -30 }, { x: -40, y: 30 },
    { x: -60, y: -45 }, { x: -60, y: 45 },
    { x: -80, y: -60 }, { x: -80, y: 60 }
  ],
  fighterSpacing: 90
};
function supportGuardSlot(slotIndex){
  const data = SupportWing.units[slotIndex] || null;
  const leader = (data?.leader && !data.leader.dead) ? data.leader : ship;
  const leaderPos = leader?.pos || { x: leader?.x ?? ship.pos.x, y: leader?.y ?? ship.pos.y };
  const leaderAng = leader?.angle ?? ship.angle;
  const type = data?.type || 'fighter';
  const lineOrder = SUPPORT_FORMATION.lineOrder || [];
  const lineIndex = lineOrder.includes(type) ? lineOrder.indexOf(type) : lineOrder.length;

  if (type === 'fighter') {
    const squadSize = SUPPORT_FORMATION.fighterSquadSize || 9;
    const fighters = SupportWing.units.filter(u => u && !u.npc?.dead && u.type === 'fighter');
    const fighterIndex = fighters.indexOf(data);
    const squadIndex = Math.max(0, Math.floor(Math.max(0, fighterIndex) / squadSize));
    const squadMateIndex = Math.max(0, fighterIndex % squadSize);
    const squadCount = Math.max(1, Math.ceil(fighters.length / squadSize));

    const lateralSpacing = SUPPORT_FORMATION.fighterSpacing || SUPPORT_FORMATION.lateralGap || 90;
    const lateral = (squadIndex - (squadCount - 1) * 0.5) * lateralSpacing;
    const forward = (SUPPORT_FORMATION.lead + lineIndex * SUPPORT_FORMATION.lineGap);
    const leaderLocal = { x: forward, y: lateral };
    const leaderRotated = rotate(leaderLocal, leaderAng - Math.PI / 2);

    if (squadMateIndex === 0) {
      return { x: leaderPos.x + leaderRotated.x, y: leaderPos.y + leaderRotated.y };
    }

    const offsets = SUPPORT_FORMATION.fighterOffsets || [];
    const formationOffset = offsets[squadMateIndex - 1] || offsets[offsets.length - 1] || { x: -40, y: 0 };
    const rotatedOffset = rotate(formationOffset, leaderAng);
    return {
      x: leaderPos.x + leaderRotated.x + rotatedOffset.x,
      y: leaderPos.y + leaderRotated.y + rotatedOffset.y
    };
  }

  const peers = SupportWing.units.filter(u => u && !u.npc?.dead && u.type === type);
  const colCount = Math.max(1, peers.length);
  const positionInLine = Math.max(0, peers.indexOf(data));
  const lateral = (positionInLine - (colCount - 1) / 2) * SUPPORT_FORMATION.lateralGap;
  const forward = SUPPORT_FORMATION.lead + lineIndex * SUPPORT_FORMATION.lineGap;

  const local = { x: forward, y: lateral };
  const rotated = rotate(local, leaderAng - Math.PI / 2);
  return { x: leaderPos.x + rotated.x, y: leaderPos.y + rotated.y };
}

function setSupportOrder(order, opts = {}){
  const normalized = order === 'engage' ? 'engage' : 'guard';
  if (SupportWing.order === normalized && !opts.force) return;
  SupportWing.order = normalized;

  if (SupportWing.ui.guardBtn){
    SupportWing.ui.guardBtn.classList.toggle('active', normalized === 'guard');
  }
  if (SupportWing.ui.engageBtn){
    SupportWing.ui.engageBtn.classList.toggle('active', normalized === 'engage');
  }
}

function cleanupSupportWing(){
  SupportWing.units = SupportWing.units.filter(data => data?.npc && !data.npc.dead);
  SupportWing.units.forEach((data, idx) => { data.slotIndex = idx; });
}

function getFriendlyCarrierEntity(){
  const carrierEntry = Fleet?.ships?.find(s => s?.type === 'carrier' && s.entity && !s.entity.dead);
  return carrierEntry?.entity || null;
}

function updateSupportWing(dt){
  cleanupSupportWing();
  if (SupportWing.ui.root) {
    SupportWing.ui.root.classList.remove('hidden');
  }
  if (carrierSpawnBtn) {
    carrierSpawnBtn.disabled = !!getFriendlyCarrierEntity();
  }
  if (SupportWing.order === 'engage') {
    const piratesAlive = npcs.some(n => n && !n.dead && n.isPirate);
    if (!piratesAlive) {
      setSupportOrder('guard', { force: true });
    }
  }
}

function supportGuardBehavior(npc, slotIndex, dt){
  const slot = supportGuardSlot(slotIndex);
  const dx = slot.x - npc.x;
  const dy = slot.y - npc.y;
  const dist = Math.hypot(dx, dy) || 1;
  const dir = { x: dx / dist, y: dy / dist };
  const wantSpeed = Math.min(npc.maxSpeed || 240, dist * 1.4);
  const turned = clampTurnVec(npc.vx || 0, npc.vy || 0, dir.x * wantSpeed, dir.y * wantSpeed, dt, 220);
  npc.vx = turned.vx;
  npc.vy = turned.vy;
  npc.angle = Math.atan2(npc.vy || 0, npc.vx || 0);
  if (dist < 12) {
    npc.vx *= 0.92;
    npc.vy *= 0.92;
  }
  npc.forceTarget = null;
  npc.target = null;
}

function steerNpcTowards(npc, target, dt, opts = {}){
  const dx = target.x - npc.x;
  const dy = target.y - npc.y;
  const dist = Math.hypot(dx, dy) || 1;
  const dir = { x: dx / dist, y: dy / dist };
  const wantSpeed = Math.min(opts.maxSpeed || npc.maxSpeed || 240, dist * (opts.speedScale || 1.2));
  const turned = clampTurnVec(npc.vx || 0, npc.vy || 0, dir.x * wantSpeed, dir.y * wantSpeed, dt, opts.turnLimit || 220);
  npc.vx = turned.vx;
  npc.vy = turned.vy;
  npc.angle = Math.atan2(npc.vy || 0, npc.vx || 0);
  return dist;
}
function applySeparationForces(npc, ax, ay) {
  // Iterujemy po wszystkich statkach w grze
  for (const other of npcs) {
    // Warunki ignorowania:
    // 1. To ten sam statek
    // 2. Inny statek jest martwy
    // 3. To wróg (nie odpychamy się od wrogów, wlatujemy w nich)
    // 4. Inny statek to myśliwiec (są za lekkie, żeby nas przepchnąć)
    if (other === npc || other.dead || other.friendly !== npc.friendly) continue;
    if (other.fighter || other.type === 'fighter' || other.type === 'interceptor') continue;

    const distSq = dist2(npc, other);
    const range = (npc.separationRange || 100); // Domyślny zasięg 100, jeśli brak w configu

    // Jeśli jesteśmy w strefie odpychania
    if (distSq < range * range) {
      const dist = Math.sqrt(distSq) || 1;
      // Im bliżej, tym siła odpychania jest większa (0 na granicy, 1 przy zderzeniu)
      const repelStrength = (range - dist) / range;

      // Wektor odpychania (znormalizowany)
      const pushX = (npc.x - other.x) / dist;
      const pushY = (npc.y - other.y) / dist;

      // Dodajemy siłę do przyspieszenia (ax, ay)
      // Mnożnik 0.8 to "siła repulsora" - można dostroić
      ax += pushX * (npc.accel || 100) * 0.8 * repelStrength;
      ay += pushY * (npc.accel || 100) * 0.8 * repelStrength;
    }
  }
  return { ax, ay };
}
function handleCommandedNpc(npc, dt){
  const cmd = npc.command;
  if(!cmd || !cmd.target) return false;
  const attackMove = cmd.type === 'attack-move';
  if (attackMove){
    const target = aiPickTarget(npc);
    if (target){
      npc.forceTarget = target;
      return false;
    }
  }
  const arrival = cmd.arrival || (npc.radius || 20) + 20;
  const dist = steerNpcTowards(npc, cmd.target, dt, { turnLimit: attackMove ? 260 : 220 });
  if (dist <= arrival){
    npc.command = null;
    npc.forceTarget = null;
  }
  return true;
}

// === FIX SUPPORT AI (Guard vs Engage) ===
function runSupportAI(npc, dt) {
    const data = npc.supportData;
    if (!data) return;

    // Zaznacz, że ten NPC należy do skrzydła wsparcia
    npc.isSupportWing = true;

    // Aktualny rozkaz skrzydła (domyślnie guard, jakby coś było nieustawione)
    const order = (typeof SupportWing !== 'undefined' && SupportWing && SupportWing.order)
        ? SupportWing.order
        : 'guard';

    npc.supportOrder = order; // przyda się w fighter AI

    const ENGAGE_RANGE       = 25000; // zasięg polowania w ENGAGE
    const GUARD_ATTACK_RANGE = 6000;  // zasięg odpalenia ataku w GUARD

    const searchRange = (order === 'engage') ? ENGAGE_RANGE : GUARD_ATTACK_RANGE;

    // 1. Znajdź cel
    let target = null;

    if (window.aiPickBestTarget) {
        target = window.aiPickBestTarget(npc, searchRange);
    } else if (window.aiPickTarget) {
        target = window.aiPickTarget(npc);
        // jeżeli aiPickTarget nie respektuje zasięgu – dociśnijmy ręcznie
        if (target) {
            const d2 = dist2(npc, target);
            if (d2 > searchRange * searchRange) {
                target = null;
            }
        }
    }

    // W trybie ENGAGE, jeśli nie ma celu w zasięgu, leć do najbliższego wroga na mapie
    if (order === 'engage' && !target && Array.isArray(npcs)) {
        let best = null;
        let bestD2 = Infinity;
        for (const n of npcs) {
            if (!n || n.dead || !n.isPirate) continue;
            const dx = n.x - npc.x;
            const dy = n.y - npc.y;
            const d2 = dx * dx + dy * dy;
            if (d2 < bestD2) {
                bestD2 = d2;
                best = n;
            }
        }
        target = best;
    }

    // 2. Ustaw cel na NPC
    npc.forceTarget = target || null;
    npc.target      = target || null;

    // 3. Wykonanie AI
    if (target) {
        // --- TRYB BOJOWY ---
        if (data.type === 'fighter') {
            if (window.runAdvancedFighterAI) {
                window.runAdvancedFighterAI(npc, dt);
            }
        } else if (data.type === 'frigate_pd' || data.type === 'frigate_laser') {
            if (window.aiFrigate) window.aiFrigate(null, npc, dt);
        } else if (data.type === 'destroyer') {
            if (window.aiDestroyer) window.aiDestroyer(null, npc, dt);
        } else if (data.type === 'battleship') {
            if (window.aiBattleship) window.aiBattleship(null, npc, dt);
        }
    } else {
        // --- TRYB FORMACJI (Brak wrogów / wróg daleko w GUARD) ---
        supportGuardBehavior(npc, data.slotIndex, dt);

        if (npc.keepAngle) {
            npc.angle = Math.atan2(npc.vy, npc.vx);
        }

        // Myśliwiec bez celu wraca logicznie do stanu "guard"
        if (data.type === 'fighter') {
            npc.state = 'guard';
        }
    }
}

function isPirateStation(st){
  if (!st) return false;
  const name = typeof st.name === 'string' ? st.name.toLowerCase() : '';
  return st.isPirate || st.type === 'pirate' || st.style === 'pirate' || name.includes('pir');
}

function stationScaleFor(st){
  const baseDefault = DEFAULT_STATION_3D_SCALE;
  const rawGlobal = Number.isFinite(Dev.station3DScale) ? Dev.station3DScale : NaN;
  const globalScale = (Number.isFinite(rawGlobal) && rawGlobal > 0) ? rawGlobal : baseDefault;
  const rawPirate = Number.isFinite(DevTuning.pirateStationScale) ? DevTuning.pirateStationScale : NaN;
  const pirateScale = (Number.isFinite(rawPirate) && rawPirate > 0) ? rawPirate : globalScale;
  return isPirateStation(st) ? pirateScale : globalScale;
}

// === HARDPOINTS: enums ===
const HP = {
  MAIN: 'main',
  MISSILE: 'missile',
  AUX: 'aux',
  HANGAR: 'hangar',
  SPECIAL: 'special'
};

// === definicje broni ===
const WEAPONS = {
  railgun_mk1:  { id:'railgun_mk1',  type:HP.MAIN,    name:'Railgun Mk I',  dps:40, energy:6,  ammo:null },
  railgun_mk2:  { id:'railgun_mk2',  type:HP.MAIN,    name:'Railgun Mk II', dps:60, energy:8,  ammo:null },
  armata_mk1:   { id:'armata_mk1',   type:HP.MAIN,    name:'Armata Siege Cannon', damage:220, cooldown:1.8, energy:14, ammo:null },
  heavy_autocannon: { id:'heavy_autocannon', type:HP.MAIN, name:'Heavy Autocannon', damage:28, cooldown:0.16, energy:9, ammo:null },
  missile_rack: { id:'missile_rack', type:HP.MISSILE, name:'Missile Rack',  dps:0,  energy:2,  ammo:20 },
  ciws_mk1:     { id:'ciws_mk1',     type:HP.AUX,     name:'CIWS Mk I',     dps:12, energy:2,  ammo:null },
  laser_pd_mk1: { id:'laser_pd_mk1', type:HP.AUX,     name:'Helios PD Laser', dps:18, energy:3,  ammo:null },
  fighter_bay:  { id:'fighter_bay',  type:HP.HANGAR,  name:'Fighter Bay',   dps:0,  energy:5,  ammo:null },
  super_f:      { id:'super_f',      type:HP.SPECIAL, name:'Super Weapon',  dps:300,energy:20, ammo:null },
};

const WEAPON_ICON_PATHS = {
  heavy_autocannon: 'assets/weapons/heavy_autocannon.svg',
};

// === definicje statków / ram ===
const SHIPS = {
  atlas: {
    id:'atlas', name:'Atlas-class',
    spec: { [HP.MAIN]:4, [HP.MISSILE]:8, [HP.AUX]:8, [HP.HANGAR]:4, [HP.SPECIAL]:1 },
    genHardpoints(bounds){
      const hp = [];
      const w = bounds.w, h = bounds.h;
      placeLine(hp, HP.MAIN,    4, {x:-w*0.25,y:-h*0.48}, {x:w*0.25,y:-h*0.48});
      placeLine(hp, HP.MISSILE, 4, {x:-w*0.48,y:-h*0.15}, {x:-w*0.48,y:h*0.15});
      placeLine(hp, HP.MISSILE, 4, {x:w*0.48, y:-h*0.15}, {x:w*0.48, y:h*0.15});
      placeLine(hp, HP.AUX,     4, {x:-w*0.35,y:-h*0.35}, {x:-w*0.35,y:h*0.35});
      placeLine(hp, HP.AUX,     4, {x:w*0.35, y:-h*0.35}, {x:w*0.35, y:h*0.35});
      placeLine(hp, HP.HANGAR,  2, {x:-w*0.20,y:h*0.48},  {x:w*0.20, y:h*0.48});
      placeLine(hp, HP.HANGAR,  2, {x:-w*0.20,y:h*0.40},  {x:w*0.20, y:h*0.40});
      hp.push({id:uid(), type:HP.SPECIAL, pos:{x:0,y:0,rot:0}, mount:null, ammo:null, maxAmmo:null});
      return hp;
    }
  },
  corvus: {
    id:'corvus', name:'Corvus-class',
    spec: { [HP.MAIN]:2, [HP.MISSILE]:12, [HP.AUX]:4, [HP.HANGAR]:2, [HP.SPECIAL]:1 },
    genHardpoints(bounds){
      const hp=[]; const w=bounds.w, h=bounds.h;
      placeLine(hp, HP.MAIN, 2, {x:-w*0.2,y:-h*0.5}, {x:w*0.2,y:-h*0.5});
      placeLine(hp, HP.MISSILE,6,{x:-w*0.5,y:-h*0.25},{x:-w*0.5,y:h*0.25});
      placeLine(hp, HP.MISSILE,6,{x:w*0.5,y:-h*0.25},{x:w*0.5,y:h*0.25});
      placeLine(hp, HP.AUX,4,{x:0,y:-h*0.2},{x:0,y:h*0.2});
      placeLine(hp, HP.HANGAR,2,{x:-w*0.15,y:h*0.5},{x:w*0.15,y:h*0.5});
      hp.push({id:uid(), type:HP.SPECIAL, pos:{x:0,y:0,rot:0}, mount:null, ammo:null, maxAmmo:null});
      return hp;
    }
  }
};

function placeLine(out, type, count, a, b){
  for (let i=0;i<count;i++){
    const t = count===1 ? 0.5 : (i/(count-1));
    out.push({ id:uid(), type, pos:{ x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t, rot:0 }, mount:null, ammo:null, maxAmmo:null });
  }
}
function uid(){ return 'hp_'+Math.random().toString(36).slice(2,9); }

const Game = window.Game || (window.Game={});
Game.infrastructure = Game.infrastructure || new Map();
Game.stationEconomy = Game.stationEconomy || new Map();
const previousPlayer = Game.player || {};
const defaultInventory = ['railgun_mk1','railgun_mk2','armata_mk1','heavy_autocannon','missile_rack','ciws_mk1','laser_pd_mk1','fighter_bay','super_f'];
const existingInventory = previousPlayer.inventory ? Array.from(previousPlayer.inventory) : [];
const mergedInventory = new Set([...existingInventory, ...defaultInventory]);
const hasSavedShipPosition = !!previousPlayer.pos;

// =============== Ship ===============
const shipOverrides = {};
if (previousPlayer.pos) shipOverrides.pos = previousPlayer.pos;
if (previousPlayer.vel) shipOverrides.vel = previousPlayer.vel;
if (typeof previousPlayer.angle === 'number') shipOverrides.angle = previousPlayer.angle;
if (typeof previousPlayer.angVel === 'number') shipOverrides.angVel = previousPlayer.angVel;
if (typeof previousPlayer.mass === 'number') shipOverrides.mass = previousPlayer.mass;
if (typeof previousPlayer.linearDamping === 'number') shipOverrides.linearDamping = previousPlayer.linearDamping;
if (typeof previousPlayer.angularDamping === 'number') shipOverrides.angularDamping = previousPlayer.angularDamping;
if (typeof previousPlayer.w === 'number') shipOverrides.w = previousPlayer.w;
if (typeof previousPlayer.h === 'number') shipOverrides.h = previousPlayer.h;
if (previousPlayer.controller) shipOverrides.controller = previousPlayer.controller;
if (previousPlayer.aiController) shipOverrides.aiController = previousPlayer.aiController;

Game.player = createShipEntity({ world: WORLD, overlayView, overrides: shipOverrides });
const ship = Game.player;
window.ship = ship;

ship.inventory = mergedInventory;
ship.shipFrame = previousPlayer.shipFrame || 'atlas';
ship.hardpoints = previousPlayer.hardpoints || [];
ship.weapons = previousPlayer.weapons || {};
ship.spriteW = previousPlayer.spriteW || ship.spriteW || 260;
ship.spriteH = previousPlayer.spriteH || ship.spriteH || 520;
ship.destroyed = ship.hull?.val <= 0;

if (previousPlayer && typeof previousPlayer === 'object'){
  for (const [key, value] of Object.entries(previousPlayer)){
    if (ship[key] === undefined){
      ship[key] = value;
    }
  }
}

overlayView.center.x = ship.pos.x;
overlayView.center.y = ship.pos.y;

let rocketAmmo = 0;
let rocketAmmoMax = 0;

function triggerEnergyShot(){
  if (!ship?.shield) return;
  applyEnergyShot(ship);
}
window.triggerEnergyShot = triggerEnergyShot;

function setHardpointMount(hp, weaponId, opts={}){
  if(!hp) return;
  const weapon = weaponId ? WEAPONS[weaponId] : null;
  const inventory = Game.player?.inventory;
  if(!weapon || (inventory && weaponId && !inventory.has(weaponId)) || weapon.type !== hp.type){
    hp.mount = null;
    hp.ammo = null;
    hp.maxAmmo = null;
    return;
  }
  hp.mount = weaponId;
  const baseMax = weapon.ammo != null ? weapon.ammo : null;
  hp.maxAmmo = opts.hasOwnProperty('maxAmmo') ? opts.maxAmmo : baseMax;
  if(weapon.ammo != null){
    const desiredAmmo = opts.hasOwnProperty('ammo') ? opts.ammo : weapon.ammo;
    hp.ammo = Math.max(0, desiredAmmo);
  } else {
    hp.ammo = null;
  }
}

function rebuildHardpointsForFrame(){
  const frame = SHIPS[Game.player.shipFrame];
  if(!frame) return;
  const spriteSize = { w: Game.player.spriteW || 260, h: Game.player.spriteH || 520 };
  Game.player.hardpoints = frame.genHardpoints(spriteSize);
  autoMountDefaults();
  syncWeaponSystems();
}

function autoMountDefaults(){
  mountFirstFree(HP.MAIN, 'railgun_mk2', 4);
  mountFirstFree(HP.MISSILE, 'missile_rack', 8);
  mountFirstFree(HP.AUX, 'ciws_mk1', 8);
  mountFirstFree(HP.HANGAR, 'fighter_bay', 4);
  mountFirstFree(HP.SPECIAL, 'super_f', 1);
}

function mountFirstFree(type, weaponId, howMany){
  if(!Game.player.inventory.has(weaponId)) return;
  for (const hp of Game.player.hardpoints){
    if (howMany<=0) break;
    if (hp.type===type && !hp.mount){
      setHardpointMount(hp, weaponId);
      howMany--;
    }
  }
}

function syncWeaponSystems(){
  const byType = {};
  for (const type of Object.values(HP)) byType[type] = [];
  for (const hp of Game.player.hardpoints){
    if (!hp.mount) continue;
    const weapon = WEAPONS[hp.mount];
    if(weapon) byType[hp.type].push({ hp, weapon });
  }
  Game.player.weapons = byType;
  rocketAmmoMax = missileAmmoCapacity();
  rocketAmmo = missileAmmoTotal();
  updateMainWeaponBehavior();
}

function getMainWeaponBehaviorForWeaponId(id){
  if(!id) return MAIN_WEAPON_BEHAVIOR.default;
  return MAIN_WEAPON_BEHAVIOR[id] || MAIN_WEAPON_BEHAVIOR.default;
}

function updateMainWeaponBehavior(){
  const mainWeapons = Game.player.weapons?.[HP.MAIN] || [];
  let behavior = MAIN_WEAPON_BEHAVIOR.default;
  if(mainWeapons.length){
    for(const loadout of mainWeapons){
      const id = loadout?.weapon?.id;
      const candidate = getMainWeaponBehaviorForWeaponId(id);
      if(!candidate) continue;
      const candidatePriority = candidate.priority ?? 0;
      const currentPriority = behavior.priority ?? 0;
      const candidateCooldown = candidate.cooldown ?? MAIN_WEAPON_BEHAVIOR.default.cooldown;
      const currentCooldown = behavior.cooldown ?? MAIN_WEAPON_BEHAVIOR.default.cooldown;
      const preferCandidate = (candidatePriority > currentPriority)
        || (candidatePriority === currentPriority && candidateCooldown > currentCooldown);
      if(preferCandidate){
        behavior = candidate;
      }
    }
  }
  rail.behaviorId = behavior.id || 'default';
  rail.cdMax = behavior.cooldown ?? MAIN_WEAPON_BEHAVIOR.default.cooldown;
  rail.shotGap = behavior.shotGap ?? MAIN_WEAPON_BEHAVIOR.default.shotGap;
  rail.burstGap = behavior.burstGap ?? MAIN_WEAPON_BEHAVIOR.default.burstGap;
  rail.burstsPerClick = behavior.burstsPerClick ?? MAIN_WEAPON_BEHAVIOR.default.burstsPerClick;
  rail.barrelsPerShot = behavior.barrelsPerShot ?? MAIN_WEAPON_BEHAVIOR.default.barrelsPerShot;
}

function missileAmmoTotal(){
  let total = 0;
  for (const hp of Game.player.hardpoints){
    if(hp.type===HP.MISSILE && hp.mount){
      if(typeof hp.ammo === 'number') total += hp.ammo;
    }
  }
  return total;
}

function missileAmmoCapacity(){
  let total = 0;
  for (const hp of Game.player.hardpoints){
    if(hp.type===HP.MISSILE && hp.mount){
      if(typeof hp.maxAmmo === 'number') total += hp.maxAmmo;
    }
  }
  return total;
}

function tryPreserveMounts(previous){
  if(!previous) return;
  const byType = new Map();
  for (const hp of previous){
    if(!hp.mount) continue;
    const entry = { weaponId: hp.mount, ammo: hp.ammo, maxAmmo: hp.maxAmmo };
    if(!byType.has(hp.type)) byType.set(hp.type, []);
    byType.get(hp.type).push(entry);
  }
  for (const hp of Game.player.hardpoints){
    const arr = byType.get(hp.type);
    if(arr && arr.length){
      const entry = arr.shift();
      setHardpointMount(hp, entry.weaponId, { ammo: entry.ammo, maxAmmo: entry.maxAmmo });
    }
  }
}

function saveLoadout(){
  try{
    localStorage.setItem('loadout', JSON.stringify({
      shipFrame: Game.player.shipFrame,
      hardpoints: Game.player.hardpoints.map(h=>({ id:h.id, type:h.type, mount:h.mount, ammo:h.ammo, maxAmmo:h.maxAmmo }))
    }));
  }catch(e){ console.warn('Loadout save error', e); }
}

function loadLoadout(){
  const raw = localStorage.getItem('loadout');
  if(!raw){ syncWeaponSystems(); return; }
  try{
    const data = JSON.parse(raw);
    if(data.shipFrame && SHIPS[data.shipFrame]){
      Game.player.shipFrame = data.shipFrame;
    }
    const frame = SHIPS[Game.player.shipFrame];
    if(frame){
      const spriteSize = { w: Game.player.spriteW || 260, h: Game.player.spriteH || 520 };
      const fresh = frame.genHardpoints(spriteSize);
      const savedByType = new Map();
      for(const saved of (data.hardpoints||[])){
        if(!saved.mount) continue;
        if(!savedByType.has(saved.type)) savedByType.set(saved.type, []);
        savedByType.get(saved.type).push(saved);
      }
      for(const hp of fresh){
        const arr = savedByType.get(hp.type);
        if(arr && arr.length){
          const saved = arr.shift();
          setHardpointMount(hp, saved.mount, { ammo: saved.ammo, maxAmmo: saved.maxAmmo });
        }
      }
      Game.player.hardpoints = fresh;
    }
  }catch(e){
    console.warn('Loadout parse error', e);
  }
  syncWeaponSystems();
  if(typeof renderMechanic === 'function') renderMechanic();
}

window.addEventListener('beforeunload', saveLoadout);

function drawHardpointGizmos(ctx, worldPos){
  if(!window.DEBUG_DRAW_HARDPOINTS) return;
  ctx.save();
  const screenX = (worldPos.x - camera.x) * camera.zoom + W/2;
  const screenY = (worldPos.y - camera.y) * camera.zoom + H/2;
  ctx.translate(screenX, screenY);
  for (const h of Game.player.hardpoints){
    ctx.beginPath();
    ctx.arc(h.pos.x*camera.zoom, h.pos.y*camera.zoom, 6, 0, Math.PI*2);
    ctx.strokeStyle = ({main:'#3b82f6', missile:'#10b981', aux:'#f59e0b', hangar:'#a78bfa', special:'#ef4444'})[h.type] || '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  ctx.restore();
}

// =============== Floating HUD state ===============
const HUD_SHOW_LEGACY = false; // stary HUD w lewym dolnym rogu – zostaw false

const HUD = {
  dmg: [],       // popupy obrażeń: {x,y,txt,color,vy,life,max}
  navArrows: [], // niebieskie strzałki po X: {x,y,age,life}
};

// =============== Planet radar UI ===============
const planetRadarState = {
  enabled: true,
  visited: new Set(),
  elements: new Map()
};

function formatAuDistance(distAu){
  if (distAu >= 10) return `${distAu.toFixed(0)} AU`;
  if (distAu >= 1) return `${distAu.toFixed(1)} AU`;
  return `${distAu.toFixed(2)} AU`;
}

function projectToScreenEdge(dirX, dirY, margin){
  const halfW = Math.max(1, W / 2 - margin);
  const halfH = Math.max(1, H / 2 - margin);
  const safeX = Math.abs(dirX) < 1e-3 ? 1e-3 : dirX;
  const safeY = Math.abs(dirY) < 1e-3 ? 1e-3 : dirY;
  const scale = Math.min(halfW / Math.abs(safeX), halfH / Math.abs(safeY));
  return { x: W / 2 + safeX * scale, y: H / 2 + safeY * scale };
}

function ensurePlanetRadarItem(id){
  if (!planetRadarRoot) return null;
  let el = planetRadarState.elements.get(id);
  if (el) return el;

  const item = document.createElement('div');
  item.className = 'planet-radar-item';

  const label = document.createElement('div');
  label.className = 'planet-radar-label';

  item.append(label);
  planetRadarRoot.appendChild(item);
  planetRadarState.elements.set(id, item);
  return item;
}

function togglePlanetRadarVisibility(force){
  const next = typeof force === 'boolean' ? force : !planetRadarState.enabled;
  planetRadarState.enabled = next;
  if (planetRadarRoot) {
    planetRadarRoot.classList.toggle('hidden', !next);
  }
}

function updatePlanetRadar(ship, cam){
  if (!Array.isArray(planets)) return;
  const auUnit = getAuToWorldUnits();
  const margin = 32;
  const maxScaleAu = 40;
  const minScale = 0.58;
  const maxScale = 1.4;
  const shouldRender = !!planetRadarRoot && planetRadarState.enabled;

  if (planetRadarRoot) {
    planetRadarRoot.classList.toggle('hidden', !planetRadarState.enabled);
  }

  for (const planet of planets) {
    if (!planet) continue;
    const id = planet.id || planet.name || '';
    if (!id) continue;

    const dx = planet.x - ship.pos.x;
    const dy = planet.y - ship.pos.y;
    const distWorld = Math.hypot(dx, dy);
    const arrivalRadius = Math.max(10, (planet.r || 0) * 2);
    const distAu = Math.max(0, (distWorld - Math.max(planet.r || 0, 0)) / auUnit);

    if (planetRadarState.visited.has(id) && distAu >= 2) {
      planetRadarState.visited.delete(id);
    }

    if (distWorld <= arrivalRadius) {
      planetRadarState.visited.add(id);
      const existing = planetRadarState.elements.get(id);
      if (existing) {
        existing.remove();
        planetRadarState.elements.delete(id);
      }
      continue;
    }

    if (planetRadarState.visited.has(id)) {
      const existing = planetRadarState.elements.get(id);
      if (existing) {
        existing.remove();
        planetRadarState.elements.delete(id);
      }
      continue;
    }

    if (!shouldRender) continue;

    const screenPos = worldToScreen(planet.x, planet.y, cam);
    const dirX = screenPos.x - W / 2;
    const dirY = screenPos.y - H / 2;
    const edgePos = projectToScreenEdge(dirX, dirY, margin);

    const item = ensurePlanetRadarItem(id);
    if (!item) continue;
    const labelEl = item.querySelector('.planet-radar-label');

    if (labelEl) {
      const ratio = clamp(distAu / maxScaleAu, 0, 1);
      const scale = maxScale - (maxScale - minScale) * ratio;
      const label = planet.label || formatPlanetLabel(planet, 0);
      labelEl.textContent = `${label} · ${formatAuDistance(distAu)}`;
      labelEl.style.fontSize = `${11 * scale}px`;
      labelEl.style.opacity = `${0.75 + 0.25 * (1 - ratio)}`;
      labelEl.style.writingMode = '';
      labelEl.style.transform = '';
      labelEl.style.margin = '';
    }

    if (item) {
      let flexDirection = 'column';
      if (labelEl) {
        if (Math.abs(dirX) > Math.abs(dirY)) {
          labelEl.style.writingMode = 'vertical-rl';
          labelEl.style.transform = dirX > 0 ? 'rotate(180deg)' : '';
          labelEl.style.margin = '4px 0 0 0';
        } else {
          labelEl.style.writingMode = 'horizontal-tb';
        }
      }

      if (edgePos.y > H - margin * 1.5) {
        flexDirection = 'column-reverse';
      }

      item.style.flexDirection = flexDirection;
      item.style.transform = 'translate(-50%, -50%)';
    }

    item.style.left = `${edgePos.x}px`;
    item.style.top = `${edgePos.y}px`;
  }

  if (mercMission?.station && shouldRender) {
    const pirate = mercMission.station;
    const id = 'pirate_station';
    const dx = pirate.x - ship.pos.x;
    const dy = pirate.y - ship.pos.y;
    const distWorld = Math.hypot(dx, dy);
    const bodyRadius = Math.max(0, pirate.r || 0);
    const distAu = Math.max(0, (distWorld - bodyRadius) / auUnit);
    const screenPos = worldToScreen(pirate.x, pirate.y, cam);
    const dirX = screenPos.x - W / 2;
    const dirY = screenPos.y - H / 2;
    const edgePos = projectToScreenEdge(dirX, dirY, margin);
    const item = ensurePlanetRadarItem(id);

    if (item) {
      item.classList.add('pirate');
      const labelEl = item.querySelector('.planet-radar-label');
      if (labelEl) {
        const ratio = clamp(distAu / maxScaleAu, 0, 1);
        const scale = maxScale - (maxScale - minScale) * ratio;
        labelEl.textContent = `PIRATE STATION · ${formatAuDistance(distAu)}`;
        labelEl.style.fontSize = `${11 * scale}px`;
        labelEl.style.opacity = `${0.75 + 0.25 * (1 - ratio)}`;
        labelEl.classList.add('pirate');
        labelEl.style.writingMode = '';
        labelEl.style.transform = '';
        labelEl.style.margin = '';

        if (Math.abs(dirX) > Math.abs(dirY)) {
          labelEl.style.writingMode = 'vertical-rl';
          labelEl.style.transform = dirX > 0 ? 'rotate(180deg)' : '';
          labelEl.style.margin = '4px 0 0 0';
        } else {
          labelEl.style.writingMode = 'horizontal-tb';
        }
      }

      let flexDirection = 'column';
      if (edgePos.y > H - margin * 1.5) {
        flexDirection = 'column-reverse';
      }

      item.style.flexDirection = flexDirection;
      item.style.transform = 'translate(-50%, -50%)';
      item.style.left = `${edgePos.x}px`;
      item.style.top = `${edgePos.y}px`;
    }
  }

  if (!shouldRender) return;

  for (const [id, node] of planetRadarState.elements.entries()) {
    const isPirateMarker = id === 'pirate_station';
    const pirateActive = !!mercMission?.station;
    const stillExists = planets.some(pl => (pl?.id || pl?.name) === id) || (isPirateMarker && pirateActive);
    if (!stillExists || (planetRadarState.visited.has(id) && !isPirateMarker)) {
      node.remove();
      planetRadarState.elements.delete(id);
    }
  }
}

function hudSpawnDMG(x,y,amount,kind='npc'){
  const color = (kind==='player') ? '#f87171' : '#a7f3d0';
  HUD.dmg.push({ x, y, txt: Math.round(amount), color, vy: -14, life: 1.15, max: 1.15 });
}
function hudUpdateDMG(dt){
  for(const d of HUD.dmg){ d.y += d.vy*dt; d.life -= dt; }
  HUD.dmg = HUD.dmg.filter(d=>d.life>0);
}
function hudRenderDMG(cam){
  ctx.save();
  ctx.font = 'bold 13px system-ui,monospace';
  ctx.textAlign = 'center';
  for(const d of HUD.dmg){
    const s = worldToScreen(d.x, d.y, cam);
    ctx.globalAlpha = Math.max(0, d.life/d.max);
    ctx.fillStyle = d.color;
    ctx.fillText(d.txt, s.x, s.y);
  }
  ctx.restore();
}

function hudPingNpcStations(){
  // Niebieskie strzałki do stacji nie-misyjnych; gasną po 4s
  const targets = stations.filter(s=>!s.mission).slice(0, 8);
  HUD.navArrows = targets.map(s=>({ x:s.x, y:s.y, age:0, life:4.0 }));
}
function hudUpdateNav(dt){
  for(const p of HUD.navArrows) p.age += dt;
  HUD.navArrows = HUD.navArrows.filter(p=>p.age < p.life);
}

function drawArrowOnRing(cx, cy, R, ang, size, color){
  const x = cx + Math.cos(ang)*R, y = cy + Math.sin(ang)*R;
  ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(size, 0);
  ctx.lineTo(-size*0.6, size*0.6);
  ctx.lineTo(-size*0.2, 0);
  ctx.lineTo(-size*0.6, -size*0.6);
  ctx.closePath(); ctx.fill();
  ctx.restore();
}
function hudRenderNav(ship, cam){
  if(!HUD.navArrows.length) return;
  const s = worldToScreen(ship.pos.x, ship.pos.y, cam);
  const R = Math.max(ship.w, ship.h) * camera.zoom * 0.6 + 30;
  for(const p of HUD.navArrows){
    const ang = Math.atan2(p.y - ship.pos.y, p.x - ship.pos.x);
    const a = Math.max(0, 1 - p.age/p.life);
    ctx.save(); ctx.globalAlpha = 0.3 + 0.7*a;
    drawArrowOnRing(s.x, s.y, R, ang, 12, '#60a5fa');
    ctx.restore();
  }
}

function hudRenderFloatingBars(ship, cam){
  const cx = W/2, cy = H/2;
  const R0 = Math.max(ship.w, ship.h) * camera.zoom * 0.8 + 32;

  // BOOST – pokazuj jako poziom paliwa dopalacza
  const boostFuelRatio = clamp(boost.fuel / boost.fuelMax, 0, 1);
  if (boostFuelRatio < 1 || (boost.state === 'active' && boost.fuel > 0)){
    ctx.save();
    ctx.strokeStyle = 'rgba(41,52,65,0.9)'; ctx.lineWidth = 8;
    ctx.beginPath(); ctx.arc(cx, cy, R0, -Math.PI/2, -Math.PI/2 + Math.PI*1.1); ctx.stroke();
    ctx.strokeStyle = '#60a5fa';
    ctx.beginPath(); ctx.arc(cx, cy, R0, -Math.PI/2, -Math.PI/2 + Math.PI*1.1*boostFuelRatio); ctx.stroke();
    ctx.fillStyle = '#bcd7ff'; ctx.font = '12px system-ui,monospace'; ctx.textAlign = 'center';
    ctx.fillText('BOOST', cx, cy - R0 - 10);
    ctx.restore();
  }

  // WARP – pokazuj przy charge/active
  if (warp.state === 'charging' || warp.state === 'active'){
    const t = (warp.state==='charging') ? Math.min(1, warp.charge/warp.chargeTime) : 1;
    const R1 = R0 + 16;
    ctx.save();
    ctx.strokeStyle = 'rgba(30,41,59,0.9)'; ctx.lineWidth = 8;
    ctx.beginPath(); ctx.arc(cx, cy, R1,  Math.PI/2,  Math.PI/2 - Math.PI*1.1, true); ctx.stroke();
    ctx.strokeStyle = '#7dd3fc';
    ctx.beginPath(); ctx.arc(cx, cy, R1,  Math.PI/2,  Math.PI/2 - Math.PI*1.1*t, true); ctx.stroke();
    ctx.fillStyle = '#d0f0ff'; ctx.font = '12px system-ui,monospace'; ctx.textAlign = 'center';
    ctx.fillText('WARP', cx, cy + R1 + 26);
    ctx.restore();
  }
}

// =============== Zoom indicator ===============
const zoomIndicatorEl = document.getElementById('zoom-indicator');
const zoomIndicator = {
  el: zoomIndicatorEl,
  timer: 0,
  hold: 1.2,
  visible: false,
  update(dt){
    if (!this.el) return;
    if (this.timer > 0) {
      this.timer -= dt;
      if (this.timer <= 0 && this.visible) {
        this.visible = false;
        this.el.classList.remove('visible');
      }
    }
  },
  show(zoomValue){
    if (!this.el) return;
    const normalized = clamp(zoomValue / Math.max(0.0001, camera.maxZoom || 1), 0, 1);
    const display = normalized >= 0.995 ? 1 : Math.max(0.01, normalized);
    this.el.textContent = `ZOOM X${display.toFixed(display >= 1 ? 0 : 2)}`;
    this.timer = this.hold;
    this.visible = true;
    this.el.classList.add('visible');
  }
};

// =============== Game time (1 min real = 1 h game) ===============
let gameTime = 0; // seconds
const gameTimeEl = document.getElementById('game-time');
function formatGameTime(sec){
  const t = Math.floor(sec);
  const h = Math.floor(t / 3600) % 24;
  const m = Math.floor((t % 3600) / 60);
  return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
}

function updatePlayerStatusUI(){
  if (!hudTopbarRoot) return;
  const hull = ship?.hull;
  const shield = ship?.shield;
  if (hull && hullFillEl){
    const frac = clamp(hull.val / Math.max(1, hull.max), 0, 1);
    hullFillEl.style.width = `${(frac * 100).toFixed(1)}%`;
  }
  if (shield && shieldFillEl){
    const frac = clamp(shield.val / Math.max(1, shield.max), 0, 1);
    shieldFillEl.style.width = `${(frac * 100).toFixed(1)}%`;
  }
  if (hull && hullLabelEl){
    hullLabelEl.textContent = `${Math.round(hull.val)}/${Math.round(hull.max)}`;
  }
  if (shield && shieldLabelEl){
    shieldLabelEl.textContent = `${Math.round(shield.val)}/${Math.round(shield.max)}`;
  }
}
function wrapAngle(a){ while(a>Math.PI) a-=2*Math.PI; while(a<-Math.PI) a+=2*Math.PI; return a; }
function interpAngleShort(prev,curr,t){ const d = wrapAngle(curr - prev); return wrapAngle(prev + d * t); }
function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function leadTarget(shooter, shooterVel, target, speed){
  const tx = target.x, ty = target.y;
  const tvx = target.vx || 0, tvy = target.vy || 0;
  const rx = tx - shooter.x, ry = ty - shooter.y;
  const rvx = tvx - shooterVel.x, rvy = tvy - shooterVel.y;
  const a = rvx*rvx + rvy*rvy - speed*speed;
  const b = 2*(rx*rvx + ry*rvy);
  const c = rx*rx + ry*ry;
  let t = 0;
  if(Math.abs(a) < 1e-6){
    if(Math.abs(b) > 1e-6) t = -c / b;
  } else {
    const disc = b*b - 4*a*c;
    if(disc >= 0){
      const sqrtDisc = Math.sqrt(disc);
      const t1 = (-b - sqrtDisc)/(2*a);
      const t2 = (-b + sqrtDisc)/(2*a);
      t = Math.min(t1, t2);
      if(t < 0) t = Math.max(t1, t2);
    }
  }
  if(!isFinite(t) || t < 0) t = 0;
  return { x: tx + tvx*t, y: ty + tvy*t };
}

// =============== World / camera ===============
const camera = {
  x: WORLD.w / 2,
  y: WORLD.h / 2,
  zoom: 1.0,
  defaultZoom: 1.0,
  altZoom: 0.7,
  minZoom: 0.06,
  maxZoom: 3.2,
  wheelSpeed: 0.002,
  manualZoom: false,
  shakeMag: 0,
  shakeTime: 0,
  shakeDur: 0,
  mode: 'ship',
  focusStation: null,
  freePanSpeed: 1,
  lastPointerX: null,
  lastPointerY: null,
  freeKeyPanSpeed: 1400,
  targetX: WORLD.w / 2,
  targetY: WORLD.h / 2,
  targetZoom: 1.0,
  focusScreenXRatio: 0.3,
  focusScreenYRatio: 0.5,
  focusZoom: 1.0,
  focusArrived: false,
  transition: null,
  addShake(mag, dur){
    if (DevFlags && DevFlags.disableCameraShake) {
      this.shakeMag = 0;
      this.shakeTime = 0;
      this.shakeDur = 0;
      return;
    }
    this.shakeMag = mag;
    this.shakeTime = dur;
    this.shakeDur = dur;
  },
  enterFreeMode(){
    this.mode = 'free';
    this.focusStation = null;
    this.targetX = this.x;
    this.targetY = this.y;
    this.targetZoom = this.zoom;
    this.transition = null;
    this.focusArrived = false;
    this.lastPointerX = null;
    this.lastPointerY = null;
  },
  exitFreeMode(){
    this.mode = 'ship';
    this.focusStation = null;
    this.manualZoom = false;
    this.focusArrived = false;
    this.lastPointerX = null;
    this.lastPointerY = null;
    const tx = ship.pos.x;
    const ty = ship.pos.y;
    const tz = this.defaultZoom;
    this.beginTransition(tx, ty, tz, 0.75, () => {
      this.targetX = tx;
      this.targetY = ty;
      this.targetZoom = tz;
    });
  },
  toggleFreeMode(){
    if(this.mode === 'free') this.exitFreeMode();
    else this.enterFreeMode();
  },
  beginTransition(x, y, zoom, duration = 0.8, onComplete){
    const targetZoom = clamp(zoom, this.minZoom, this.maxZoom);
    this.manualZoom = false;
    this.transition = {
      kind: this.mode,
      startX: this.x,
      startY: this.y,
      startZoom: this.zoom,
      targetX: x,
      targetY: y,
      targetZoom,
      elapsed: 0,
      duration: Math.max(0.0001, duration),
      onComplete
    };
  },
  focusOnStation(station){
    if(!station) return;
    this.focusStation = station;
    this.mode = 'focus';
    this.focusArrived = false;
    this.focusScreenXRatio = 0.3;
    this.focusScreenYRatio = 0.5;
    this.lastPointerX = null;
    this.lastPointerY = null;
    const target = computeStationFocusTarget(station);
    this.focusZoom = target.zoom;
    this.targetX = target.x;
    this.targetY = target.y;
    this.targetZoom = target.zoom;
    this.beginTransition(target.x, target.y, target.zoom, 0.85, () => {
      this.focusArrived = true;
    });
  },
  focusOnInfrastructure(station, layout){
    if(!station) return;
    this.focusStation = station;
    this.mode = 'infrastructure';
    this.focusArrived = false;
    this.focusScreenXRatio = 0.42;
    this.focusScreenYRatio = 0.52;
    this.lastPointerX = null;
    this.lastPointerY = null;
    const target = computeInfrastructureFocusTarget(station, layout);
    this.focusZoom = target.zoom;
    this.targetX = target.x;
    this.targetY = target.y;
    this.targetZoom = target.zoom;
    this.beginTransition(target.x, target.y, target.zoom, 0.9, () => {
      this.focusArrived = true;
    });
  },
  clearFocus(){
    if(this.mode === 'focus' || this.mode === 'infrastructure'){
      this.focusStation = null;
      this.mode = 'ship';
      this.focusArrived = false;
      this.manualZoom = false;
      this.targetZoom = this.defaultZoom;
      this.targetX = ship.pos.x;
      this.targetY = ship.pos.y;
      this.beginTransition(this.targetX, this.targetY, this.targetZoom, 0.6);
      this.lastPointerX = null;
      this.lastPointerY = null;
    }
  }
};

function computeStationFocusTarget(station){
  if(!station) return { x: camera.x, y: camera.y, zoom: camera.zoom };
  const ratioX = camera.focusScreenXRatio ?? 0.32;
  const ratioY = camera.focusScreenYRatio ?? 0.52;
  const baseRadius = ((station.r ?? station.baseR) || 120);
  const desiredRadiusPx = clamp(Math.min(W, H) * 0.24, 180, 320);
  const zoom = clamp(desiredRadiusPx / Math.max(60, baseRadius), camera.minZoom, camera.maxZoom);
  const screenX = ratioX * W;
  const screenY = ratioY * H;
  const x = station.x - (screenX - W/2) / zoom;
  const y = station.y - (screenY - H/2) / zoom;
  return { x, y, zoom, screenX, screenY };
}

function computeInfrastructureFocusTarget(station, layout){
  if(!station) return computeStationFocusTarget(station);
  const activeLayout = layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  const padding = (activeLayout?.cellSize || 200) * 0.9;
  const worldWidth = (activeLayout?.width || 600) + padding;
  const worldHeight = (activeLayout?.height || 400) + padding;
  const zoomX = W / Math.max(worldWidth, 1);
  const zoomY = H / Math.max(worldHeight, 1);
  const baseZoom = Math.min(zoomX, zoomY) * 0.92;
  const zoom = clamp(baseZoom, camera.minZoom, camera.maxZoom);
  const ratioX = 0.42;
  const ratioY = 0.52;
  const screenX = ratioX * W;
  const screenY = ratioY * H;
  const x = station.x - (screenX - W/2) / zoom;
  const y = station.y - (screenY - H/2) / zoom;
  return { x, y, zoom, screenX, screenY };
}

// Model widoku overlayu już istnieje – dopasuj początkowy zoom do kamery
overlayView.zoom = camera.zoom;

function updateCameraTarget(dt){
  if(camera.mode === 'ship'){
    camera.targetX = ship.pos.x;
    camera.targetY = ship.pos.y;
    if(!camera.transition && !camera.manualZoom) camera.targetZoom = camera.defaultZoom;
  } else if(camera.mode === 'free'){
    const moveX = (keys['arrowright'] ? 1 : 0) - (keys['arrowleft'] ? 1 : 0);
    const moveY = (keys['arrowdown'] ? 1 : 0) - (keys['arrowup'] ? 1 : 0);
    if(moveX || moveY){
      const len = Math.hypot(moveX, moveY) || 1;
      const panSpeed = camera.freeKeyPanSpeed / Math.max(0.0001, camera.zoom);
      camera.x += (moveX / len) * panSpeed * dt;
      camera.y += (moveY / len) * panSpeed * dt;
    }
    if(mouse.overCanvas && !stationUI.open && !showMap){
      const panSpeed = (camera.freePanSpeed || 1) / Math.max(0.0001, camera.zoom);
      if(mouse.dx || mouse.dy){
        camera.x += mouse.dx * panSpeed;
        camera.y += mouse.dy * panSpeed;
      }
    }
    camera.targetX = camera.x;
    camera.targetY = camera.y;
  } else if(camera.mode === 'focus'){
    const st = camera.focusStation;
    if(st){
      const target = computeStationFocusTarget(st);
      camera.focusZoom = target.zoom;
      camera.targetX = target.x;
      camera.targetY = target.y;
      camera.targetZoom = target.zoom;
      if(camera.transition && camera.transition.kind === 'focus'){
        camera.transition.targetX = target.x;
        camera.transition.targetY = target.y;
        camera.transition.targetZoom = target.zoom;
      }
    } else {
      camera.clearFocus();
      camera.targetX = ship.pos.x;
      camera.targetY = ship.pos.y;
      camera.targetZoom = camera.defaultZoom;
    }
  } else if(camera.mode === 'infrastructure'){
    const st = camera.focusStation;
    if(st){
      const layout = infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      const target = computeInfrastructureFocusTarget(st, layout);
      camera.focusZoom = target.zoom;
      camera.targetX = target.x;
      camera.targetY = target.y;
      camera.targetZoom = target.zoom;
      if(camera.transition && camera.transition.kind === 'infrastructure'){
        camera.transition.targetX = target.x;
        camera.transition.targetY = target.y;
        camera.transition.targetZoom = target.zoom;
      }
    } else {
      camera.clearFocus();
      camera.targetX = ship.pos.x;
      camera.targetY = ship.pos.y;
      camera.targetZoom = camera.defaultZoom;
    }
  }

  if(camera.transition){
    const tr = camera.transition;
    tr.elapsed = Math.min(tr.elapsed + dt, tr.duration);
    const t = tr.duration <= 0 ? 1 : tr.elapsed / tr.duration;
    const eased = smoothstep01(t);
    camera.x = lerp(tr.startX, tr.targetX, eased);
    camera.y = lerp(tr.startY, tr.targetY, eased);
    camera.zoom = lerp(tr.startZoom, tr.targetZoom, eased);
    if(tr.elapsed >= tr.duration - 1e-6){
      camera.x = tr.targetX;
      camera.y = tr.targetY;
      camera.zoom = tr.targetZoom;
      const onComplete = tr.onComplete;
      camera.transition = null;
      if(typeof onComplete === 'function') onComplete();
    }
  } else {
    if(camera.mode === 'ship'){
      camera.x = camera.targetX;
      camera.y = camera.targetY;
    } else {
      const posLerp = Math.min(1, dt * 6);
      camera.x += (camera.targetX - camera.x) * posLerp;
      camera.y += (camera.targetY - camera.y) * posLerp;
    }
    const zoomLerp = Math.min(1, dt * 4);
    camera.zoom += (camera.targetZoom - camera.zoom) * zoomLerp;
  }

  camera.zoom = clamp(camera.zoom, camera.minZoom, camera.maxZoom);
  mouse.dx = 0;
  mouse.dy = 0;
}

// Bezpieczna, odroczona inicjalizacja overlayu 3D
let overlay3D = null;

window.addEventListener('resize', ()=>{
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  resizeShieldSystem(innerWidth, innerHeight);
  spaceBg?.resizeSpaceBg?.(innerWidth, innerHeight);
  configureWarpLensSource?.();
  if(camera.mode === 'focus' && camera.focusStation){
    const target = computeStationFocusTarget(camera.focusStation);
    camera.focusZoom = target.zoom;
    camera.targetX = target.x;
    camera.targetY = target.y;
    camera.targetZoom = target.zoom;
    if(camera.transition && camera.transition.kind === 'focus'){
      camera.transition.targetX = target.x;
      camera.transition.targetY = target.y;
      camera.transition.targetZoom = target.zoom;
    }
  }
  if(camera.mode === 'infrastructure' && camera.focusStation){
    const layout = infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
    const target = computeInfrastructureFocusTarget(camera.focusStation, layout);
    camera.focusZoom = target.zoom;
    camera.targetX = target.x;
    camera.targetY = target.y;
    camera.targetZoom = target.zoom;
    if(camera.transition && camera.transition.kind === 'infrastructure'){
      camera.transition.targetX = target.x;
      camera.transition.targetY = target.y;
      camera.transition.targetZoom = target.zoom;
    }
  }
  resizeOverlay3D();
  initStars(true);
});

function startOverlay3D() {
  const init = window.initOverlay3D;
  const railFactory = window.createRailgunExplosionFactory;
  const armataFactory = window.createArmataImpactFactory;
  const autocannonFactory = window.createAutocannonImpactFactory;
  const reactorFactory = window.createReactorBlowFactory;
  const host = document.getElementById('game-root');

  // Musimy mieć: API z modułu + host z DOM + overlayView z tego skryptu
  if (!init || !railFactory || !host || typeof overlayView === 'undefined') return false;

  const ov = init({ host, getView: () => overlayView });
  overlay3D = ov;
  window.overlay3D = ov;
  window.makeRailgunExplosion = railFactory(ov.scene);
  if (armataFactory) {
    window.makeArmataImpact = armataFactory(ov.scene);
  }
  if (autocannonFactory) {
    window.makeAutocannonImpact = autocannonFactory(ov.scene);
  }
  if (reactorFactory) {
    window.makeReactorBlow = reactorFactory(ov.scene);
  }
  resizeOverlay3D();
  return true;
}

// Moduły <script type="module"> wykonują się po parsowaniu DOM, więc
// DOMContentLoaded zwykle wystarczy. Dla pewności dodajemy krótki polling.
window.addEventListener('DOMContentLoaded', () => {
  if (startOverlay3D()) return;
  let tries = 0;
  const maxTries = 120; // ~2 sekundy przy 60 FPS
  (function poll() {
    if (startOverlay3D() || tries++ > maxTries) return;
    requestAnimationFrame(poll);
  })();
});

// Helper do spawnu eksplozji 3D
function triggerRailgunExplosion3D(x, y, size = ship.h * 0.22){
  if (overlay3D && window.makeRailgunExplosion) {
    const fx = window.makeRailgunExplosion({ x, y, size });
    overlay3D.spawn(fx);
  }
}

function triggerArmataImpact3D(x, y, size = ship.h * 0.3){
  if (overlay3D && window.makeArmataImpact) {
    const fx = window.makeArmataImpact({ x, y, size });
    overlay3D.spawn(fx);
  }
}

function triggerAutocannonImpact3D(x, y, size = ship.h * 0.2){
  if (overlay3D && window.makeAutocannonImpact) {
    const fx = window.makeAutocannonImpact({ x, y, size });
    overlay3D.spawn(fx);
  }
}

function triggerReactorBlow3D(x, y, size = ship.h * 0.35){
  if (overlay3D && window.makeReactorBlow) {
    const fx = window.makeReactorBlow({ x, y, size });
    overlay3D.spawn(fx);
  }
}

// Resize: utrzymuj rozmiar overlayu = okna
function resizeOverlay3D(){
  overlayView.viewport.w = innerWidth;
  overlayView.viewport.h = innerHeight;
  if (overlay3D) overlay3D.resize();
}

resizeOverlay3D();

// === Ship sprite ===
const USE_SHIP_SPRITE = true;
const shipSprite = new Image();
const capitalShipSpriteCache = {};
const fighterSprite = new Image();
const fighterSpriteState = { ready: false, error: false, width: 0, height: 0 };
const hullSpriteCache = new Map();

function loadHullSprite(src){
  if (!src) return null;
  if (!hullSpriteCache.has(src)) {
    const img = new Image();
    const entry = { image: img, ready: false, error: false, width: 1, height: 1 };
    img.onload = () => {
      entry.ready = true;
      entry.width = img.naturalWidth || 1;
      entry.height = img.naturalHeight || 1;
    };
    img.onerror = () => { entry.error = true; };
    img.src = src;
    hullSpriteCache.set(src, entry);
  }
  return hullSpriteCache.get(src) || null;
}

const HULL_SPRITE_PATHS = {
  terran: {
    frigate: terranFrigateImg,
    destroyer: terranDestroyerImg,
    battleship: terranBattleshipImg
  },
  pirate: {
    frigate: pirateFrigateImg,
    destroyer: pirateDestroyerImg,
    battleship: pirateBattleshipImg
  }
};

function getNpcHullClass(npc){
  const type = String(npc?.type || '');
  if (type === 'destroyer') return 'destroyer';
  if (type === 'battleship') return 'battleship';
  if (type.includes('frigate')) return 'frigate';
  return null;
}

function getHullSpriteForNpc(npc){
  const faction = (npc?.isPirate) ? 'pirate' : (npc?.supportData && npc?.friendly ? 'terran' : null);
  if (!faction) return null;
  const hullClass = getNpcHullClass(npc);
  const src = hullClass ? HULL_SPRITE_PATHS[faction]?.[hullClass] : null;
  if (!src) return null;
  const sprite = loadHullSprite(src);
  if (!sprite || !sprite.ready || sprite.error) return null;
  return sprite;
}

function getCapitalShipSprite(src){
  if(!src) return null;
  if(!capitalShipSpriteCache[src]){
    const img = new Image();
    const entry = capitalShipSpriteCache[src] = {
      image: img,
      ready: false,
      error: false,
      width: 0,
      height: 0
    };
    img.onload = () => {
      entry.ready = true;
      entry.width = img.naturalWidth;
      entry.height = img.naturalHeight;
    };
    img.onerror = () => {
      entry.error = true;
    };
    img.src = src;
  }
  return capitalShipSpriteCache[src];
}
ship.spriteReady = false;
shipSprite.onload = () => {
  ship.spriteReady = true;
  ship.spriteW = shipSprite.naturalWidth;
  ship.spriteH = shipSprite.naturalHeight;
  Game.player.spriteW = ship.spriteW;
  Game.player.spriteH = ship.spriteH;
  const prev = Game.player.hardpoints.map(h=>({ type:h.type, mount:h.mount, ammo:h.ammo, maxAmmo:h.maxAmmo }));
  rebuildHardpointsForFrame();
  tryPreserveMounts(prev);
  syncWeaponSystems();
  initHexBody(ship, shipSprite);
  if(typeof renderMechanic === 'function') renderMechanic();
  saveLoadout();
};
shipSprite.src = "assets/capital_ship_rect_v1.png"; // <- ścieżka do pliku

fighterSprite.onload = () => {
  fighterSpriteState.ready = true;
  fighterSpriteState.width = fighterSprite.naturalWidth || 1;
  fighterSpriteState.height = fighterSprite.naturalHeight || 1;
};
fighterSprite.onerror = () => {
  fighterSpriteState.error = true;
};
fighterSprite.src = fighterImg;

const npcSpriteFriendly = new Image();
const npcSpriteHostile = new Image();
let npcSpritesReady = 0;

npcSpriteFriendly.onload = () => { npcSpritesReady++; };
npcSpriteHostile.onload = () => { npcSpritesReady++; };

npcSpriteFriendly.src = npcFriImg;
npcSpriteHostile.src = npcHosImg;

const heavyAutocannonSprite = new Image();
let heavyAutocannonSpriteReady = false;
heavyAutocannonSprite.onload = () => {
  heavyAutocannonSpriteReady = true;
};
heavyAutocannonSprite.src = "assets/weapons/heavy_autocannon.svg";

// =============== Proceduralne gwiazdy na CAŁEJ MAPIE ===============
// Generujemy je "na żądanie" w kafelkach 1024×1024 z deterministycznym seedem.
// Dzięki temu gwiazdy są wszędzie, ale pamięć i CPU trzymamy w ryzach.
const STAR_CELL = 1024;
const starCells = new Map(); // key "ix,iy" -> {stars:[...] , lastSeen: frameId}
let frameId = 0;

function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
function key(ix,iy){ return ix+','+iy; }

function generateCell(ix,iy){
  const seed = ((ix*73856093) ^ (iy*19349663) ^ 0x9e3779b9) >>> 0;
  const rnd = mulberry32(seed);
  const count = 5 + Math.floor(rnd()*5); // ilośc gwiazd na komorke
  const stars = [];
  for(let i=0;i<count;i++){
    const x = ix*STAR_CELL + rnd()*STAR_CELL;
    const y = iy*STAR_CELL + rnd()*STAR_CELL;
    const size = 0.7 + rnd()*2.1;
    const bright = 0.35 + rnd()*0.65;
    stars.push({x,y,size,bright});
  }
  const obj = { stars, lastSeen: frameId };
  starCells.set(key(ix,iy), obj);
  return obj;
}
function getCell(ix,iy){
  const k = key(ix,iy);
  let c = starCells.get(k);
  if(!c) c = generateCell(ix,iy);
  c.lastSeen = frameId;
  return c;
}
function pruneStarCells(){
  // Trzymajmy ~ 600 ostatnio widzianych komórek (wystarczy z zapasem)
  if(starCells.size <= 600) return;
  // Proste LRU: wyrzucamy najstarsze
  const arr = Array.from(starCells.entries());
  arr.sort((a,b)=>a[1].lastSeen - b[1].lastSeen);
  const toDrop = arr.slice(0, Math.max(0, arr.length - 600));
  for(const [k] of toDrop) starCells.delete(k);
}
function initStars(reset=false){
  if(reset){ starCells.clear(); }
}

// =============== Słońce, planety i stacje ===============
const SUN = { x: WORLD.w/2, y: WORLD.h/2, r: 823, r3D: 399,
  color: {
    core:  '#ffe88a',   // jasno-żółty rdzeń
    mid:   '#ffbe3b',   // pomarańcz-żółć
    rim:   '#ff8c1a'    // ciepła krawędź tarczy
  },
  corona: {
    rays: 72,           // ile „igieł”
    jitter: 0.35,       // nieregularność
    length: 0.85,       // długość korony w promieniach R
    pulse: 0.22,        // amplituda pulsu
    haze:  2.8          // rozmiar miękkiej poświaty (×R)
  },
  seed: 93731
};
window.SUN = SUN;

// --- tryb: REALNY UKŁAD SŁONECZNY (domyślnie włączony) ---
const solarParams = new URLSearchParams(location.search);
const USE_SOLAR = solarParams.has('solar') ? solarParams.get('solar') !== '0' : true; // można też sterować paramem URL ?solar=1

function makeSolarPlanets(){
  // Skala: 1 AU ≈ 3000 jednostek świata (Neptun ~ 90k)
  const AU = 3000;
  window.BASE_ORBIT = AU;
  const MIN_SUN_GAP = 600;
  const MIN_PLANET_GAP = 800;
  const INNER_PLANET_COUNT = 4;
  const INNER_EXTRA_ORBIT = 600;
  const INNER_EXTRA_SUN_GAP = 600;
  const INNER_EXTRA_PLANET_GAP = 600;
  const rand = () => Math.random() * Math.PI * 2;
  const defs = [
    { id:'mercury', name:'mercury', baseR: 2000,  orbitAU: 8.0, type:'rocky' },
    { id:'venus',   name:'venus',   baseR: 2800,  orbitAU: 15.0, type:'rocky' },
    { id:'earth',   name:'earth',   baseR: 2800, orbitAU: 25.0, type:'terran' },
    { id:'mars',    name:'mars',    baseR: 3000, orbitAU: 33.0, type:'rocky' },
    { id:'jupiter', name:'jupiter', baseR: 3800, orbitAU: 50.20, type:'gas' },
    { id:'saturn',  name:'saturn',  baseR: 3700,  orbitAU: 80.58, type:'gas' },
    { id:'uranus',  name:'uranus',  baseR: 2000, orbitAU: 100.20, type:'gas' },
    { id:'neptune', name:'neptune', baseR: 2000,  orbitAU: 120.00, type:'gas' },
    // { id:'pluto',   name:'pluto',   baseR:  30, orbitAU:39.50 },
  ];

  let minOrbitEdge = SUN.r;
  return defs.map((def, index) => {
    const effectiveR = def.baseR * PLANET_SCALE;
    const baseOrbit = def.orbitAU * AU;
    const isInner = index < INNER_PLANET_COUNT;
    const extraOrbit = isInner ? INNER_EXTRA_ORBIT : 0;
    const sunGap = SUN.r + effectiveR + MIN_SUN_GAP + (isInner ? INNER_EXTRA_SUN_GAP : 0);
    const neighborGap = minOrbitEdge + effectiveR + MIN_PLANET_GAP + (isInner ? INNER_EXTRA_PLANET_GAP : 0);
    const orbitRadius = Math.max(
      baseOrbit + extraOrbit,
      sunGap,
      neighborGap
    );

    minOrbitEdge = orbitRadius + effectiveR;

    return {
      id: def.id,
      name: def.name,
      type: def.type,
      baseR: def.baseR,
      r: effectiveR,
      orbitAU: def.orbitAU,
      orbitRadius,
      angle: rand(),
      speed: 0
    };
  });
}

const WORLD_BELT_WIDTH_AU = 2;
const WORLD_SAFETY_MARGIN_AU = 2;
const WORLD_EDGE_MARGIN_AU = WORLD_SAFETY_MARGIN_AU;

function computeWorldDiameter(planets){
  const auToWorld = getAuToWorldUnits();
  const beltWidthAU = WORLD_BELT_WIDTH_AU;
  const beltHalfWidthAU = beltWidthAU / 2;
  const safetyMarginAU = WORLD_SAFETY_MARGIN_AU;
  const beltCenterAU = (() => {
    const neptune = planets.find(p => p.id === 'neptune' || p.name === 'neptune');
    if (neptune && Number.isFinite(neptune.orbitAU)) return neptune.orbitAU + 3;

    const maxOrbitAU = planets
      .map(p => p.orbitAU)
      .filter(Number.isFinite)
      .reduce((max, v) => Math.max(max, v), -Infinity);
    if (Number.isFinite(maxOrbitAU)) return maxOrbitAU + 3;

    const maxOrbitRadius = planets
      .map(p => p.orbitRadius)
      .filter(Number.isFinite)
      .reduce((max, v) => Math.max(max, v), -Infinity);
    if (Number.isFinite(maxOrbitRadius)) return (maxOrbitRadius / auToWorld) + 3;

    return 60;
  })();

  const outerRadiusWorld = (beltCenterAU + beltHalfWidthAU + safetyMarginAU) * auToWorld;
  return outerRadiusWorld * 2;
}

function alignWorldToCenter(centerX, centerY){
  SUN.x = centerX;
  SUN.y = centerY;

  if (camera) {
    camera.x = centerX;
    camera.y = centerY;
    camera.targetX = centerX;
    camera.targetY = centerY;
  }

  if (!hasSavedShipPosition && ship) {
    ship.pos.x = centerX;
    ship.pos.y = centerY;
    overlayView.center.x = centerX;
    overlayView.center.y = centerY;
  }
}

// jeśli kiedyś będziemy chcieli wrócić do starych zasad, zostawiamy helper:
function makeProceduralPlanets(){
  // stary kod może zostać, ale domyślnie nieużywany
  const PLANET_TYPES = {
    TERRAN: 'terran',
    VOLCANIC: 'volcanic',
    FROZEN: 'frozen',
    GAS: 'gas',
    BARREN: 'barren'
  };
  const NUM_PLANETS = 7;
  const TYPES = [
    PLANET_TYPES.VOLCANIC,
    PLANET_TYPES.VOLCANIC,
    PLANET_TYPES.TERRAN,
    PLANET_TYPES.TERRAN,
    PLANET_TYPES.BARREN,
    PLANET_TYPES.GAS,
    PLANET_TYPES.FROZEN
  ];
  const BASE_ORBIT = 7000;
  window.BASE_ORBIT = BASE_ORBIT;
  const list = [];
  for (let i = 0; i < NUM_PLANETS; i++) {
    const orbitRadius = BASE_ORBIT * (i + 1);
    const angle = Math.random() * Math.PI * 2;
    const au = i + 1;
    const periodHours = 24 * 365 * Math.pow(au, 1.5);
    const speed = (2 * Math.PI) / (periodHours * 3600);
    const r = (48 + Math.floor(Math.random() * 36)) * 3;
    list.push({ id: i, orbitRadius, angle, speed, r, type: TYPES[i], x: 0, y: 0 });
  }
  return list;
}

const PLANET_DATA = USE_SOLAR ? makeSolarPlanets() : makeProceduralPlanets();

const WORLD_DIAMETER = computeWorldDiameter(PLANET_DATA);
setWorldSize(WORLD, { width: WORLD_DIAMETER, height: WORLD_DIAMETER });
alignWorldToCenter(WORLD.w / 2, WORLD.h / 2);

function formatPlanetLabel(planet, index){
  if (typeof planet.label === 'string' && planet.label.trim().length) {
    return planet.label.trim();
  }
  const candidates = [];
  if (typeof planet.name === 'string') candidates.push(planet.name);
  if (typeof planet.id === 'string') candidates.push(planet.id);
  if (typeof planet.type === 'string') candidates.push(planet.type);

  for (const raw of candidates) {
    if (!raw) continue;
    const pretty = raw
      .replace(/[_-]+/g, ' ')
      .trim()
      .replace(/\b\w/g, ch => ch.toUpperCase());
    if (pretty) return pretty;
  }
  
  // Tego brakowało:
  return `Planet ${index + 1}`;
}
// wylicz pozycje
let planets = PLANET_DATA.map((p, index) => {
  if (p.baseR == null) p.baseR = p.r;
  if (p.r == null && p.baseR != null) {
    p.r = p.baseR * PLANET_SCALE;
  }
  p.x = SUN.x + Math.cos(p.angle) * p.orbitRadius;
  p.y = SUN.y + Math.sin(p.angle) * p.orbitRadius;
  p.label = formatPlanetLabel(p, index);
  return p;
});
window.planets = planets;

// =============== Strefy (planety/słońce/pas asteroid) ===============
const AU_IN_WORLD_UNITS = getAuToWorldUnits();
const ZONE_APPROACH_DISTANCE = AU_IN_WORLD_UNITS; // 1 AU przed granicą
window.ZONE_APPROACH_DISTANCE = ZONE_APPROACH_DISTANCE;

const PIRATE_ORBIT = Object.freeze({
  innerAu: 4,
  outerAu: 6
});

function pirateOrbitRadii(){
  const au = AU_IN_WORLD_UNITS || getAuToWorldUnits();
  return {
    inner: PIRATE_ORBIT.innerAu * au,
    outer: PIRATE_ORBIT.outerAu * au
  };
}

const zoneState = {
  current: null,
  approaching: null,
  lastZoneKey: null,
  lastZoneId: null,
  lastApproachKey: null,
  initialized: false,
  messages: []
};

function makeInterplanetaryZone(){
  return {
    key: 'interplanetary',
    id: 'interplanetary',
    label: 'Interplanetary Zone',
    enteringLabel: 'Interplanetary Zone',
    warpMultiplier: 2,
    wormholeVfx: true
  };
}

const zonePriority = {
  planet_inner: 4,
  planet_outer: 3,
  pirate_inner: 4,
  pirate_outer: 3,
  sun: 2,
  asteroid_belt: 1
};

function zonePropsForId(id){
  if (
    id === 'planet_inner' ||
    id === 'planet_outer' ||
    id === 'pirate_inner' ||
    id === 'pirate_outer' ||
    id === 'sun' ||
    id === 'asteroid_belt'
  ) {
    return { warpMultiplier: 0.3, wormholeVfx: false };
  }
  if (id === 'interplanetary') {
    return { warpMultiplier: 2, wormholeVfx: true };
  }
  return { warpMultiplier: 1, wormholeVfx: false };
}

function isPlanetOrbitZoneId(id){
  return id === 'planet_inner' || id === 'planet_outer' || id === 'pirate_inner' || id === 'pirate_outer';
}

function planetOrbitRadii(planet){
  const baseRadius = Math.max(10, (planet.r || 0) * 2);
  const outerOrbitExtra = Math.max(1600, ZONE_APPROACH_DISTANCE * 0.6);
  const outerRadius = baseRadius + outerOrbitExtra;
  return { inner: baseRadius, outer: outerRadius };
}

function enhanceZoneDescriptor(zone){
  if (!zone) return null;
  const props = zonePropsForId(zone.id);
  zone.warpMultiplier = props.warpMultiplier;
  zone.wormholeVfx = props.wormholeVfx;
  return zone;
}

function formatPlanetOrbitLabel(planet){
  const name = typeof planet.label === 'string' && planet.label.trim().length
    ? planet.label.trim()
    : formatPlanetLabel(planet, 0);
  return name;
}

function formatPirateOrbitLabel(station){
  if (!station) return 'Pirate Station';
  const raw = (station.label || station.name || station.id || '').toString();
  const trimmed = raw.trim();
  return trimmed.length ? trimmed : 'Pirate Station';
}

function detectZones(pos){
  const zones = [];

  for (const [index, planet] of planets.entries()) {
    if (!planet) continue;
    const orbitRadii = planetOrbitRadii(planet);
    const dx = pos.x - planet.x;
    const dy = pos.y - planet.y;
    const dist = Math.hypot(dx, dy);
    const labelName = formatPlanetOrbitLabel(planet) || `Planet ${index + 1}`;
    zones.push({
      key: `planet-${planet.id || planet.name || index}-inner`,
      id: 'planet_inner',
      label: `${labelName} - Inner Orbit`,
      enteringLabel: `${labelName} - Inner Orbit`,
      edgeDist: dist - orbitRadii.inner,
      approachRange: ZONE_APPROACH_DISTANCE,
      priority: zonePriority.planet_inner
    });
    zones.push({
      key: `planet-${planet.id || planet.name || index}-outer`,
      id: 'planet_outer',
      label: `${labelName} - Outer Orbit`,
      enteringLabel: `${labelName} - Outer Orbit`,
      edgeDist: dist - orbitRadii.outer,
      approachRange: ZONE_APPROACH_DISTANCE,
      priority: zonePriority.planet_outer
    });
  }

  const pirateStation = mercMission?.station;
  if (pirateStation) {
    const orbitRadii = pirateOrbitRadii();
    const dx = pos.x - pirateStation.x;
    const dy = pos.y - pirateStation.y;
    const dist = Math.hypot(dx, dy);
    const labelName = formatPirateOrbitLabel(pirateStation);
    if (Number.isFinite(orbitRadii.inner)) {
      zones.push({
        key: `pirate-${pirateStation.id || 'station'}-inner`,
        id: 'pirate_inner',
        label: `${labelName} - Inner Orbit`,
        enteringLabel: `${labelName} - Inner Orbit`,
        edgeDist: dist - orbitRadii.inner,
        approachRange: ZONE_APPROACH_DISTANCE,
        priority: zonePriority.pirate_inner
      });
    }
    if (Number.isFinite(orbitRadii.outer)) {
      zones.push({
        key: `pirate-${pirateStation.id || 'station'}-outer`,
        id: 'pirate_outer',
        label: `${labelName} - Outer Orbit`,
        enteringLabel: `${labelName} - Outer Orbit`,
        edgeDist: dist - orbitRadii.outer,
        approachRange: ZONE_APPROACH_DISTANCE,
        priority: zonePriority.pirate_outer
      });
    }
  }

  const sunRadius = Math.max(10, (SUN.r || 0) * 2);
  const sunDist = Math.hypot(pos.x - SUN.x, pos.y - SUN.y);
  const sunEdge = sunDist - sunRadius;
  zones.push({
    key: 'sun',
    id: 'sun',
    label: 'Sun',
    enteringLabel: 'Entering Sun',
    edgeDist: sunEdge,
    approachRange: ZONE_APPROACH_DISTANCE,
    priority: zonePriority.sun
  });

  if (ASTEROID_BELT) {
    const radial = sunDist;
    const inner = ASTEROID_BELT.inner;
    const outer = ASTEROID_BELT.outer;
    const inside = radial >= inner && radial <= outer;
    const edgeDist = inside
      ? Math.min(radial - inner, outer - radial) * -1
      : Math.min(Math.abs(radial - inner), Math.abs(radial - outer));
    zones.push({
      key: 'asteroid-belt',
      id: 'asteroid_belt',
      label: 'Asteroid Belt',
      enteringLabel: 'Entering Asteroid Belt',
      edgeDist,
      approachRange: ZONE_APPROACH_DISTANCE,
      priority: zonePriority.asteroid_belt
    });
  }

  const insideZones = zones.filter(z => z.edgeDist <= 0);
  insideZones.sort((a, b) => (b.priority - a.priority) || (Math.abs(a.edgeDist) - Math.abs(b.edgeDist)));
  let current = insideZones[0] || makeInterplanetaryZone();

  const approachCandidates = zones
    .filter(z => z.edgeDist > 0 && z.edgeDist <= z.approachRange)
    .sort((a, b) => a.edgeDist - b.edgeDist);
  const approaching = approachCandidates[0] || null;

  return { current: enhanceZoneDescriptor(current), approaching: enhanceZoneDescriptor(approaching) };
}

function pushZoneMessage(text, duration = 3.5){
  zoneState.messages.push({ text, life: duration, maxLife: duration });
}

function updateZoneMessages(dt){
  for (const msg of zoneState.messages) {
    msg.life -= dt;
  }
  zoneState.messages = zoneState.messages.filter(msg => msg.life > 0);
}

function updateZoneState(dt){
  const prevZoneKey = zoneState.current?.key || zoneState.lastZoneKey;
  const prevZoneId = zoneState.current?.id || zoneState.lastZoneId;
  const detection = detectZones(ship.pos);
  zoneState.current = detection.current;
  zoneState.approaching = detection.approaching;

  if (!zoneState.initialized) {
    zoneState.lastZoneKey = zoneState.current?.key || null;
    zoneState.lastZoneId = zoneState.current?.id || null;
    zoneState.initialized = true;
  } else if (zoneState.current && zoneState.current.key !== zoneState.lastZoneKey) {
    if (zoneState.current.label) pushZoneMessage(zoneState.current.label);
    zoneState.lastZoneKey = zoneState.current.key;
  }

  handleZoneTransition(prevZoneId, zoneState.current?.id || null);
  zoneState.lastZoneId = zoneState.current?.id || zoneState.lastZoneId;

  const approachKey = zoneState.approaching?.key || null;
  if (
    zoneState.initialized &&
    approachKey &&
    approachKey !== zoneState.lastApproachKey &&
    approachKey !== zoneState.current?.key &&
    approachKey !== prevZoneKey
  ){
    if (zoneState.approaching?.enteringLabel) pushZoneMessage(zoneState.approaching.enteringLabel);
  }
  zoneState.lastApproachKey = approachKey;

  updateZoneMessages(dt);
}

function handleZoneTransition(prevZoneId, currentZoneId){
  if (currentZoneId === 'pirate_inner' && prevZoneId !== 'pirate_inner') {
    enterPirateInnerOrbit();
  }
}


const ASTEROID_BELT = (() => {
  const AU_TO_WORLD = getAuToWorldUnits();
  const neptuneBelt = (() => {
    const neptune = planets.find(p => p.id === 'neptune' || p.name === 'neptune');
    if (!neptune || !Number.isFinite(neptune.orbitAU)) return null;
    const beltAU = neptune.orbitAU + 3;
    const beltWidthAU = WORLD_BELT_WIDTH_AU;
    const mid = beltAU * AU_TO_WORLD;
    const inner = Math.max(50, mid - (beltWidthAU * AU_TO_WORLD) / 2);
    const outer = mid + (beltWidthAU * AU_TO_WORLD) / 2;
    return { inner, outer, mid };
  })();
  if (neptuneBelt) return neptuneBelt;

  const innerPlanet = planets[3];
  const outerPlanet = planets[4];
  if (innerPlanet && outerPlanet && innerPlanet.orbitRadius && outerPlanet.orbitRadius) {
    const r1 = innerPlanet.orbitRadius;
    const r2 = outerPlanet.orbitRadius;
    const inner = r1 + 0.25 * (r2 - r1);
    const outer = r1 + 0.55 * (r2 - r1);
    return { inner, outer, mid: (inner + outer) / 2 };
  }
  return null;
})();

const STATION_STYLES = ['ringGate','hexHub','triRing','solarPetals','shipyard','tradeSpindle'];

let stations = planets.map(pl => {
  const orbitRadius = 0; // stacje cywilne na środku planety
  const angle = 0; // brak dryfu orbitalnego
  const periodHours = 12; // zachowana spójność parametrów (nieużywane przy orbitRadius=0)
  const speed = 0;
  const x = pl.x;
  const y = pl.y;
  const r = 120;
  const portOffset = r + 40;
  const gateOffset = 220;
  const warpGate = { x: x + gateOffset, y, offset: { x: gateOffset, y: 0 } };
  const ports = [
    {x: portOffset, y: 0},
    {x: 0, y: portOffset},
    {x: -portOffset, y: 0},
    {x: 0, y: -portOffset}
  ];
  const style = STATION_STYLES[Math.floor(Math.random()*STATION_STYLES.length)];
  return {
    id: pl.id,
    planet: pl,
    orbitRadius,
    angle,
    speed,
    r,
    baseR: r,
    x,
    y,
    ports,
    style,
    warpGate
  };
});
window.stations = stations;
window.USE_STATION_3D = true;
if (window.__setStation3DScale) {
  window.__lastStationScale = 1;
  if (window.Dev && typeof Dev.station3DScale === 'number') {
    __setStation3DScale(Dev.station3DScale);
  }
}

if (!hasSavedShipPosition) {
  const earthStation = stations.find(st => st.id === 'earth');
  if (earthStation) {
    const planetRadius = earthStation.planet?.r || 0;
    const orbitPadding = 900;
    const spawnOrbitRadius = Math.max(planetRadius + orbitPadding, earthStation.r + 200);
    const spawnAngle = earthStation.planet?.angle || 0;
    const spawnPos = {
      x: earthStation.x + Math.cos(spawnAngle) * spawnOrbitRadius,
      y: earthStation.y + Math.sin(spawnAngle) * spawnOrbitRadius
    };

    ship.pos.x = spawnPos.x;
    ship.pos.y = spawnPos.y;
    ship.vel.x = 0;
    ship.vel.y = 0;

    camera.x = spawnPos.x;
    camera.y = spawnPos.y;
    camera.targetX = spawnPos.x;
    camera.targetY = spawnPos.y;

    overlayView.center.x = spawnPos.x;
    overlayView.center.y = spawnPos.y;
  }
}

// oznacz stacje wewnątrz pasa asteroid
(() => {
  if (ASTEROID_BELT) {
    const beltRadius = ASTEROID_BELT.mid;
    for (const st of stations) {
      const planetOrbit = st.planet?.orbitRadius;
      const distFromSun = Number.isFinite(planetOrbit)
        ? planetOrbit
        : Math.hypot((st.planet?.x ?? st.x) - SUN.x, (st.planet?.y ?? st.y) - SUN.y);
      st.inner = distFromSun < beltRadius;
    }
  } else {
    for (const st of stations) st.inner = true;
  }
})();

// Warp routes between stations
let warpRoutes = {};
function initWarpRoutes(){
  warpRoutes = {};
  for(const from of stations){
    for(const to of stations){
      if(from.id === to.id) continue;
      if(from.inner !== to.inner) continue;
      const sx = from.warpGate?.x ?? from.x;
      const sy = from.warpGate?.y ?? from.y;
      const ex = to.warpGate?.x ?? to.x;
      const ey = to.warpGate?.y ?? to.y;
      const dx = ex - sx;
      const dy = ey - sy;
      const dist = Math.hypot(dx, dy) || 1;
      warpRoutes[from.id + '-' + to.id] = {
        from: from.id,
        to: to.id,
        fromRef: from,
        toRef: to,
        start: { x: sx, y: sy, queues: [[], []] },
        end: { x: ex, y: ey },
        dir: { x: dx / dist, y: dy / dist },
        length: dist
      };
    }
  }
}
function getWarpRoute(fromId, toId){ return warpRoutes[fromId + '-' + toId]; }
initWarpRoutes();

let npcs = [];
window.npcs = npcs;
// Lista na martwe, dryfujące kawałki
const wrecks = [];
window.wrecks = wrecks;
// === SQUAD SYSTEM ===
const SQUADS = [];
window.SQUADS = SQUADS;
class Squad {
  constructor(team, type) {
    this.id = Math.random().toString(36).substr(2, 9);
    this.team = team; // 'player' lub 'pirate'
    this.type = type; // 'fighter', 'capital'
    this.units = [];
    this.leader = null;
    this.targetSquad = null;
    this.state = 'guard'; // guard, engage, return
  }

  addUnit(u) {
    this.units.push(u);
    u.squad = this;
    
    // FIX: Natychmiast mianuj lidera, jeśli go nie ma
    if (!this.leader) {
        this.leader = u;
    }
    
    this.recalculateFormation();
  }

  update() {
    // 1. Usuń martwe jednostki z listy
    const initialCount = this.units.length;
    this.units = this.units.filter(u => !u.dead);

    // 2. Sprawdź ciągłość dowodzenia
    // Jeśli liczba jednostek się zmieniła (ktoś zginął) LUB obecny lider nie żyje/nie istnieje
    if (this.units.length !== initialCount || !this.leader || this.leader.dead) {
        
        if (this.units.length > 0) {
            // --- AWANS I PRZEGRUPOWANIE ---
            // Nowym liderem zostaje pierwszy żywy na liście
            this.leader = this.units[0];
            
            // Przelicz sloty formacji dla wszystkich ocalałych
            // To jest ten kluczowy mechanizm z AI SPACE, którego brakowało
            this.recalculateFormation();
        } else {
            this.leader = null;
        }
    }
  }

  recalculateFormation() {
      // Przelicza offsety dla każdego statku w oparciu o jego aktualny indeks w eskadrze
      this.units.forEach((u, idx) => {
          if (idx === 0) {
              // Lider jest zawsze w punkcie 0,0
              u.formationOffset = { x: 0, y: 0 };
          } else {
              // Reszta ustawia się w formacji "Chevron" (V)
              // idx: 1 -> row 1, side L
              // idx: 2 -> row 1, side R
              // idx: 3 -> row 2, side L ...
              const row = Math.floor((idx + 1) / 2);
              const side = (idx % 2 === 0) ? 1 : -1; // 1 = Prawa, -1 = Lewa
              
              // Offsety: troche szerzej niż wcześniej, żeby się nie zderzali
              u.formationOffset = { x: -row * 60, y: side * row * 45 };
          }
          // Zabezpieczenie kompatybilności (niektóre funkcje mogą szukać formationSlot)
          u.formationSlot = u.formationOffset;
      });
  }
}

function stationLaunchPose(station, idx){
  const dirs = [
    { x: 1, y: 0 },
    { x:-1, y: 0 },
    { x: 0, y: 1 },
    { x: 0, y:-1 }
  ];
  const dir = dirs[idx % dirs.length];
  const offset = (station.r || 40) + 50;
  const launchSpeed = 120;
  return {
    x: station.x + dir.x * offset,
    y: station.y + dir.y * offset,
    vx: dir.x * launchSpeed,
    vy: dir.y * launchSpeed
  };
}
const MISSION_NPCS = [];
let mercMission = null;
const missionCompleteBanner = {
  active: false,
  text: '',
  timer: 0,
  duration: 5,
  fadeIn: 0.75,
  fadeOut: 1.25,
  trigger(text){
    this.text = text;
    this.timer = 0;
    this.active = true;
  },
  update(dt){
    if(!this.active) return;
    this.timer += dt;
    if(this.timer >= this.duration){
      this.active = false;
      this.timer = 0;
    }
  },
  alpha(){
    if(!this.active) return 0;
    const { timer, duration, fadeIn, fadeOut } = this;
    if(timer < fadeIn){
      const t = clamp(timer / fadeIn, 0, 1);
      return 1 - Math.pow(1 - t, 3);
    }
    if(timer > duration - fadeOut){
      const t = clamp((duration - timer) / fadeOut, 0, 1);
      return t * t * t;
    }
    return 1;
  },
  progress(){
    if(!this.active) return 0;
    return clamp(this.timer / Math.max(0.0001, this.duration), 0, 1);
  }
};

// === Missions / Journal ===
const MISSIONS = {
  active: [],   // {id, title, type, stationId?, pos:{x,y}, status:'active'|'completed'}
  show: false
};

function createShieldState(shieldCfg){
  if (!shieldCfg || !Number.isFinite(shieldCfg.max) || shieldCfg.max <= 0) return null;

  const regenRate = shieldCfg.regenRate ?? shieldCfg.regen ?? 0;
  const regenDelay = shieldCfg.regenDelay ?? 0;
  const val = shieldCfg.val ?? shieldCfg.max;

  return {
    max: shieldCfg.max,
    val: val,
    regenRate,
    regenDelay,
    regenTimer: shieldCfg.regenTimer ?? 0,
    impacts: Array.isArray(shieldCfg.impacts) ? [...shieldCfg.impacts] : [],
    state: shieldCfg.state || (val > 0 ? 'activating' : 'off'),
    activationProgress: shieldCfg.activationProgress ?? 0,
    currentAlpha: shieldCfg.currentAlpha ?? 0,
    energyShotTimer: shieldCfg.energyShotTimer ?? 0,
    energyShotDuration: shieldCfg.energyShotDuration ?? shieldCfg.energyShotTimer ?? 0.5
  };
}

function makeNPCBase(pos, stats){
  stats = stats || {};

  const npc = {
    x: pos.x,
    y: pos.y,
    vx: 0,
    vy: 0,
    angle: 0,

    hp: stats.hp || 100,
    maxHp: stats.hp || 100,

    accel: stats.accel || 0,
    maxSpeed: stats.maxSpeed || 0,
    turn: stats.turn || 0,
    radius: stats.radius || 20,

    // jeśli nie podasz isCollidable w statsach – jest kolizyjny
    isCollidable: stats.isCollidable !== false,

    dead: false,
    ai: null,
    weapons: {}
  };

  // NOWE: przeniesienie fizyki ze statów na NPC
  if (typeof stats.friction === 'number') {
    npc.friction = stats.friction;
  }
  if (typeof stats.mass === 'number') {
    npc.mass = stats.mass;
  }
  if (typeof stats.separationRange === 'number') {
    npc.separationRange = stats.separationRange;
  }

  npc.shield = createShieldState(stats.shield);

  return npc;
}

const SUPPORT_SHIP_TEMPLATES = {
  fighter: {
    color: '#7cff91',
    count: 9,
    stats: {
      hp: 120,
      accel: 350,
      maxSpeed: 650,
      turn: 7.0,
      radius: 12,
      mass: 0.8,
      // BRAK rammingMass i brak heksów -> przelatuje przez statki
      separationRange: 30
    },
    spawnOffset: { x: -60, y: 0 },
    configure(npc, idx){
      npc.fighter = true;
      npc.gun = 'laserS';
      npc.msl = 'AF';
      npc.mslAmmo = 2; // AI SPACE ma 1 lub 2
      npc.gunCD = 0;
      npc.ai = (dt) => { if(window.runAdvancedFighterAI) window.runAdvancedFighterAI(npc, dt); };
    }
  },
  interceptor: { // Dodane, bo spawnPirate używa tej nazwy
    // To samo co fighter, ale dla piratów
    stats: {
      hp: 80,
      accel: 350,
      maxSpeed: 650,
      turn: 7.0,
      radius: 12,
      mass: 0.8,
      // BRAK rammingMass -> przelatuje przez statki
      separationRange: 30
    },
    configure(npc){
      npc.fighter = true;
      npc.gun = 'laserS';
      npc.msl = 'AF';
      npc.mslAmmo = 1;
      npc.ai = (dt) => { if(window.runAdvancedFighterAI) window.runAdvancedFighterAI(npc, dt); };
    }
  },
  frigate_pd: {
    shield: { max: 650, val: 650, regenRate: 130, regenDelay: 3.6, impacts: [], state: 'activating' },
    stats: {
      hp: 1200,
      accel: 200,
      maxSpeed: 280, // AI SPACE ma 160, ty miałeś 280 (za szybko!)
      turn: 1.2,
      radius: 45,
      mass: 2.5,
      rammingMass: 1000, // Fregata (Lekka)
      friction: 0.985,
      separationRange: 160
    },
    configure(npc){
      npc.pd = 'pd_mk1';
      npc.mainGun = 'm_autocannon'; // lub m_rail w zależności od wersji
      npc.preferredRange = 760;
      npc.ai = (dt) => { if(window.aiFrigate) window.aiFrigate(null, npc, dt); };
      npc.keepAngle = true;
    }
  },
  frigate_laser: {
    shield: { max: 900, val: 900, regenRate: 140, regenDelay: 3.8, impacts: [], state: 'activating' },
    stats: {
      hp: 1800,
      accel: 150,
      maxSpeed: 250,
      turn: 1.2,
      radius: 45,
      mass: 2.5,
      rammingMass: 1200, // Fregata (Lekka+)
      friction: 0.985,
      separationRange: 150
    },
    configure(npc){
      npc.pd = 'pd_laser'; // Laser PD
      npc.mainGun = 'h_beam'; // HEAVY BEAM (zgodnie z AI SPACE)
      npc.preferredRange = 920; // Większy zasięg dla lasera
      npc.ai = (dt) => { 
          // Jeśli masz aiLaserFrigate, użyj go, jeśli nie - fallback do aiFrigate
          if(window.aiLaserFrigate) window.aiLaserFrigate(null, npc, dt); 
          else if(window.aiFrigate) window.aiFrigate(null, npc, dt);
      };
      npc.keepAngle = true;
    }
  },
  destroyer: {
    shield: { max: 2200, val: 2200, regenRate: 200, regenDelay: 4.5, impacts: [], state: 'activating' },
    stats: {
      hp: 4200, // AI SPACE
      accel: 140,
      maxSpeed: 200, // AI SPACE: 140
      turn: 0.9,
      radius: 70, // Skalowany do poprzedniego battleshipa
      mass: 8.0,
      rammingMass: 5000, // Destroyer (Średni)
      friction: 0.986, // Duża inercja
      separationRange: 240
    },
    configure(npc){
      npc.isCapitalShip = true;
      npc.mGun = 'm_rail';
      npc.pd = 'pd_mk1';
      npc.boostDur = 1.8; // AI SPACE destroyer ma boosta
      npc.preferredRange = 820;
      npc.ai = (dt) => window.aiDestroyer(null, npc, dt);
      npc.keepAngle = true;
    }
  },
  battleship: {
    shield: { max: 7200, val: 7200, regenRate: 320, regenDelay: 5.2, impacts: [], state: 'activating' },
    stats: {
      hp: 12000, // AI SPACE: 12000! (Ty miałeś 5200)
      accel: 91,
      maxSpeed: 105,
      turn: 0.6,
      radius: 140,
      mass: 25.0,
      rammingMass: 8000, // Battleship (Ciężki, ale lżejszy od Capitali)
      friction: 0.99, // Bardzo duża inercja (płynie)
      separationRange: 440
    },
    configure(npc){
      npc.isCapitalShip = true;
      npc.pd = 'pd_laser';
      npc.mGun = 'h_rapid'; // AI SPACE używa h_rapid na dziobie
      npc.preferredRange = 780;
      // Broadside config z AI SPACE
      npc.broadsideRange = 650;
      npc.ai = (dt) => window.aiBattleship(null, npc, dt);
      npc.keepAngle = true;
    }
  }
};
function spawnSupportShip(templateKey, opts = {}){
  const template = SUPPORT_SHIP_TEMPLATES[templateKey];
  if (!template) return [];
  const anchor = (opts.anchor && !opts.anchor.dead) ? opts.anchor : ship;
  const anchorPos = anchor.pos || { x: anchor.x ?? ship.pos.x, y: anchor.y ?? ship.pos.y };
  const anchorVel = anchor.vel || { x: anchor.vx ?? 0, y: anchor.vy ?? 0 };
  const anchorAngle = anchor.angle ?? ship.angle;

  const created = [];
  const count = Math.max(1, template.count || 1);
  const spawnFormation = SUPPORT_FORMATION.spawn || { perRow: 4, rowGap: 70 };
  for (let i = 0; i < count; i++){
    const jitter = (Math.random() * 12 - 6);
    const offset = {
      x: (template.spawnOffset?.x || -60) + jitter,
      y: (template.spawnOffset?.y || 0) + ((i % spawnFormation.perRow) - (spawnFormation.perRow - 1) * 0.5) * 8
    };
    const rotated = rotate(offset, anchorAngle);
    const spawnPos = { x: anchorPos.x + rotated.x, y: anchorPos.y + rotated.y };
    const npc = makeNPCBase(spawnPos, { ...template.stats, shield: template.shield });
    npc.friendly = true;
    npc.mission = true;
    npc.color = template.color || '#7cff91';
    npc.type = templateKey;
    npc.vx = anchorVel.x ?? npc.vx;
    npc.vy = anchorVel.y ?? npc.vy;
    npc.supportData = { npc, type: templateKey, slotIndex: SupportWing.units.length + created.length, leader: anchor };
    template.configure?.(npc, i);
    npc.ai = dt => runSupportAI(npc, dt);
    SupportWing.units.push(npc.supportData);
    npcs.push(npc);
    created.push(npc);
  }
  if (created.length) markFleetDirty();
  return created;
}

const CAPITAL_SHIP_TEMPLATES = {
  carrier: {
    id: 'capital_carrier',
    displayName: 'CSV Aegis',
    roleText: 'Carrier · Capital',
    hull: 42000,
    mass: 40,
    rammingMass: 15000, // Capital (Ciężki, ale lżejszy od Gracza-SuperCapitala)
    shield: 28000,
    shieldRegen: 260,
    shieldDelay: 6,
    accel: 32,
    maxSpeed: 220,
    turn: 0.9,
    radius: 150,
    hardpoints: { large: 2, medium: 2 },
    formationOffset: { x: -820, y: 380 },
    weaponRange: 2300,
    weapons: {
      mainCannons: [
        { id: 'port',   offset: { x: 0.42, y: -0.18 }, cooldown: 3.4, projectileSpeed: 1700, damage: 210, spread: 0.0038, arc: Math.PI / 2.2 },
        { id: 'starboard', offset: { x: 0.42, y: 0.18 }, cooldown: 3.4, projectileSpeed: 1700, damage: 210, spread: 0.0038, arc: Math.PI / 2.2 }
      ],
      dorsalBatteries: [
        { id: 'dorsal', offset: { x: 0.18, y: 0 }, cooldown: 1.6, projectileSpeed: 1300, damage: 38, spread: 0.012, arc: Math.PI / 1.6 }
      ]
    },
    profile: {
      lengthScale: 1.0, 
      widthScale: 4.0, // Wyszczuplony, żeby nie był "kwadratem"
      hullColor: '#5a7dbe',
      deckColor: '#243150',
      accentColor: '#9dc5ff',
      engineColor: 'rgba(130,200,255,0.9)',
      hangarGlow: 'rgba(160,200,255,0.45)',
      spriteSrc: 'assets/carrier.png',
      spriteScale: 5.0,
      spriteRotation: Math.PI / 2, 
      spriteOffset: { x: 0, y: 0 },
      spriteLayer: 2,
      spriteEngineGlow: false,
      engineOffsets: [
        { x: -0.38, y: 0.92 },
        { x: 0, y: 0.95 },
        { x: 0.38, y: 0.92 }
      ],
      engineGlowSize: 0.28,
      engineOffsetMode: 'relative'
    }
  }
};

Fleet.templates = Object.assign(Fleet.templates || {}, { capital: CAPITAL_SHIP_TEMPLATES });

function addFleetShip(entry){
  if (!entry || !entry.entity) return null;
  Fleet.ships.push(entry);
  npcs.push(entry.entity);
  markFleetDirty();
  return entry;
}

function createCapitalShipEntry(templateKey, overrides = {}){
  const template = CAPITAL_SHIP_TEMPLATES[templateKey];
  if (!template) return null;
  const offset = overrides.formationOffset || template.formationOffset || { x: -820, y: 420 };
  const basePos = overrides.pos || { x: ship.pos.x + offset.x, y: ship.pos.y + offset.y };

  const npc = makeNPCBase(basePos, {
    hp: template.hull,
    accel: template.accel,
    maxSpeed: template.maxSpeed,
    turn: template.turn,
    radius: template.radius
  });

  npc.hp = template.hull;
  npc.maxHp = template.hull;
  npc.radius = template.radius;
  npc.friendly = true;
  npc.mission = true;
  npc.type = template.id;
  npc.color = template.profile?.accentColor || '#9ccfff';
  npc.isCapitalShip = true;
  npc.capitalProfile = Object.assign({
    lengthScale: 3.4,
    widthScale: 1.4
  }, template.profile || {});
  if (npc.capitalProfile.spriteSrc) {
    npc.capitalSprite = getCapitalShipSprite(npc.capitalProfile.spriteSrc);
  }
  npc.shield = {
    val: template.shield,
    max: template.shield,
    regenRate: template.shieldRegen,
    regenDelay: template.shieldDelay,
    regenTimer: 0
  };
  npc.hardpoints = { large: template.hardpoints.large, medium: template.hardpoints.medium };
  npc.fleetFormationOffset = offset;
  npc.vx = 0;
  npc.vy = 0;
  npc.angle = Math.atan2(ship.pos.y - npc.y, ship.pos.x - npc.x);
  npc.desiredAngle = npc.angle;
  npc.keepAngle = true;
  npc.drawLayer = template.profile?.spriteLayer ?? 0;
  npc.carrierWeapons = createCarrierWeaponSystems(template.weapons || {});

  const entry = {
    id: overrides.id || `fleet_${templateKey}_${Math.random().toString(36).slice(2,8)}`,
    type: templateKey,
    displayName: overrides.displayName || template.displayName,
    roleText: overrides.roleText || template.roleText,
    entity: npc,
    hardpoints: { large: template.hardpoints.large, medium: template.hardpoints.medium },
    status: {
      hull: template.hull,
      hullMax: template.hull,
      shield: template.shield,
      shieldMax: template.shield
    },
    template
  };

  npc.fleetEntry = entry;
  npc.ai = dt => updateCapitalCarrier(entry, dt);

  return entry;
}

const CARRIER_DEFAULT_WEAPON_RANGE = 2200;
function createCarrierWeaponSystems(cfg){
  const systems = { mainCannons: [], dorsalBatteries: [] };
  if (cfg && Array.isArray(cfg.mainCannons)){
    for (const weapon of cfg.mainCannons){
      systems.mainCannons.push({
        id: weapon.id || `main_${systems.mainCannons.length}`,
        offset: weapon.offset || { x: 0, y: 0 },
        cooldown: Math.max(0.2, weapon.cooldown || 3.0),
        timer: 0,
        projectileSpeed: weapon.projectileSpeed || 1600,
        damage: weapon.damage || 180,
        spread: weapon.spread || 0,
        arc: weapon.arc || Math.PI / 2,
        muzzleForward: weapon.muzzleForward ?? 0.12,
        type: 'main'
      });
    }
  }
  if (cfg && Array.isArray(cfg.dorsalBatteries)){
    for (const weapon of cfg.dorsalBatteries){
      systems.dorsalBatteries.push({
        id: weapon.id || `aux_${systems.dorsalBatteries.length}`,
        offset: weapon.offset || { x: 0, y: 0 },
        cooldown: Math.max(0.1, weapon.cooldown || 1.4),
        timer: 0,
        projectileSpeed: weapon.projectileSpeed || 1100,
        damage: weapon.damage || 28,
        spread: weapon.spread || 0.01,
        arc: weapon.arc || Math.PI / 1.6,
        muzzleForward: weapon.muzzleForward ?? 0.06,
        type: 'aux'
      });
    }
  }
  return systems;
}

function selectCarrierTarget(entry){
  if (!entry || !entry.entity) return null;
  const carrier = entry.entity;
  const range = entry.template?.weaponRange || CARRIER_DEFAULT_WEAPON_RANGE;

  const primary = entry.primaryTarget;
  if (primary && isHostileNpc(primary)){
    const dist = Math.hypot(primary.x - carrier.x, primary.y - carrier.y);
    if (dist <= range * 1.15){
      return primary;
    }
  }
  if (primary && !isHostileNpc(primary)) {
    entry.primaryTarget = null;
  }

  const anchorX = carrier.x;
  const anchorY = carrier.y;

  const focusCandidates = [];
  for (const target of lockedTargets){
    if (isHostileNpc(target) && !focusCandidates.includes(target)){
      focusCandidates.push(target);
    }
  }
  if (lockedTarget && isHostileNpc(lockedTarget) && !focusCandidates.includes(lockedTarget)){
    focusCandidates.push(lockedTarget);
  }

  let focus = null;
  let focusDist = Infinity;
  for (const candidate of focusCandidates){
    const dist = Math.hypot(candidate.x - anchorX, candidate.y - anchorY);
    if (dist < focusDist){
      focus = candidate;
      focusDist = dist;
    }
  }

  if (focus && focusDist <= range * 1.2){
    entry.primaryTarget = focus;
    return focus;
  }

  let best = null, bestDist = range;
  for (const npc of npcs){
    if (!npc || npc.dead || npc.friendly) continue;
    const dist = Math.hypot(npc.x - anchorX, npc.y - anchorY);
    if (dist < bestDist){
      best = npc;
      bestDist = dist;
    }
  }
  entry.primaryTarget = best;
  return best;
}

function getCapitalDimensions(npc){
  const profile = npc.capitalProfile || {};
  const radius = npc.radius || 1;
  const length = Math.max(60, radius * (profile.lengthScale || 3.2));
  const width = Math.max(30, radius * (profile.widthScale || 1.2));
  return { length, width, halfL: length * 0.5, halfW: width * 0.5 };
}

function capitalLocalFromNormalized(offset, dims){
  if (!offset) return { x: 0, y: 0 };
  if (offset.absolute) return { x: offset.x || 0, y: offset.y || 0 };
  const nx = Number.isFinite(offset.x) ? offset.x : 0;
  const ny = Number.isFinite(offset.y) ? offset.y : 0;
  return { x: nx * dims.halfL, y: ny * dims.halfW };
}

function updateCarrierWeapons(entry, dt, order, target){
  const npc = entry.entity;
  if (!npc || !npc.carrierWeapons) return;
  const profile = npc.capitalProfile || {};
  const dims = getCapitalDimensions(npc);
  const rotation = (npc.angle || 0) + (profile.spriteRotation || 0);
  const systems = npc.carrierWeapons;
  const range = entry.template?.weaponRange || CARRIER_DEFAULT_WEAPON_RANGE;
  const shouldFire = !!target && order !== 'return';

  const fireWeapon = (weapon, type) => {
    weapon.timer = Math.max(0, (weapon.timer || 0) - dt);
    if (!shouldFire || weapon.timer > 0) return;

    const localBase = capitalLocalFromNormalized(weapon.offset, dims);
    const forwardExtra = Number.isFinite(weapon.muzzleForward) ? weapon.muzzleForward * dims.halfL : 0;
    const local = { x: localBase.x + forwardExtra, y: localBase.y };
    const worldOff = rotate(local, rotation);
    const muzzle = { x: npc.x + worldOff.x, y: npc.y + worldOff.y };
    const lead = leadTarget(muzzle, { x: npc.vx, y: npc.vy }, target, weapon.projectileSpeed);
    const aim = Math.atan2(lead.y - muzzle.y, lead.x - muzzle.x);
    const forward = rotate({ x: 1, y: 0 }, rotation);
    const dirToTarget = { x: Math.cos(aim), y: Math.sin(aim) };
    const dot = forward.x * dirToTarget.x + forward.y * dirToTarget.y;
    const angleDiff = Math.acos(clamp(dot, -1, 1));
    const dist = Math.hypot(target.x - muzzle.x, target.y - muzzle.y);
    if (angleDiff > (weapon.arc || Math.PI / 2) * 0.5 || dist > range * 1.1){
      return;
    }

    const jitter = (Math.random() - 0.5) * (weapon.spread || 0);
    const finalAngle = aim + jitter;
    const dir = { x: Math.cos(finalAngle), y: Math.sin(finalAngle) };
    const speed = weapon.projectileSpeed || 1500;
    const life = Math.max(0.6, (range / speed) * 1.15);
    const bullet = {
      x: muzzle.x,
      y: muzzle.y,
      vx: dir.x * speed + npc.vx,
      vy: dir.y * speed + npc.vy,
      life,
      r: type === 'main' ? 6 : 3,
      owner: 'player',
      damage: weapon.damage || (type === 'main' ? 180 : 32),
      type: type === 'main' ? 'armata' : 'autocannon',
      penetration: type === 'main' ? 2 : 0,
      source: npc,
      effectScale: type === 'main' ? 1.2 : 0.9
    };
    window.bullets.push(bullet);
    if (type === 'main'){
      spawnRailMuzzle(muzzle, dir, { x: npc.vx, y: npc.vy }, 1.2);
      camera.addShake(6, 0.15);
    } else {
      spawnAutocannonMuzzle(muzzle, dir, { x: npc.vx, y: npc.vy }, 0.9);
    }
    weapon.timer = weapon.cooldown || 2.5;
  };

  if (Array.isArray(systems.mainCannons)){
    for (const weapon of systems.mainCannons){
      fireWeapon(weapon, 'main');
    }
  }
  if (Array.isArray(systems.dorsalBatteries)){
    for (const weapon of systems.dorsalBatteries){
      fireWeapon(weapon, 'aux');
    }
  }
}

function spawnCarrierEngineFx(entry){
  const npc = entry.entity;
  if (!npc || !npc.capitalProfile) return;
  const profile = npc.capitalProfile;
  const offsets = Array.isArray(profile.engineOffsets) ? profile.engineOffsets : null;
  if (!offsets || !offsets.length) return;

  const dims = getCapitalDimensions(npc);
  const rotation = (npc.angle || 0) + (profile.spriteRotation || 0);
  const speed = Math.hypot(npc.vx || 0, npc.vy || 0);
  const thrust = clamp(speed / Math.max(1, npc.maxSpeed || 1), 0, 1);
  if (thrust < 0.05 && speed < 12) return;

  const dir = rotate({ x: -1, y: 0 }, rotation);
  const glowScale = Number.isFinite(profile.engineGlowSize) ? profile.engineGlowSize : 0.24;
  const baseRadius = Math.max(6, npc.radius * glowScale * 0.32);

  for (const offset of offsets){
    const local = capitalLocalFromNormalized(offset, dims);
    const worldOff = rotate(local, rotation);
    const pos = { x: npc.x + worldOff.x, y: npc.y + worldOff.y };
    const intensity = 0.32 + thrust * 0.55;
    const particleSize = clamp(baseRadius * (0.7 + thrust * 0.9), 6, npc.radius * 0.3);
    const particleLife = 0.16 + thrust * 0.14;
    const vel = {
      x: npc.vx - dir.x * (100 + thrust * 220),
      y: npc.vy - dir.y * (100 + thrust * 220)
    };
    const color = `rgba(135,205,255,${intensity})`;
    spawnParticle(pos, vel, particleLife, color, particleSize, false);
  }
}

function ensureCarrierWarpDrive(entry){
  if (!entry) return null;
  if (!entry.warpDrive){
    const chargeTime = (warp?.chargeTime || 0.8) * 1.05;
    const entryDuration = (warp?.entryDuration || 0.9) * 1.1;
    entry.warpDrive = {
      state: 'idle',
      charge: 0,
      chargeTime,
      entryDuration,
      entryProgress: 0,
      entryBaseSpeed: 0,
      dir: { x: 1, y: 0 },
      turnRate: (warp?.turnRate || Math.PI / 5) * 0.7,
      alignRate: (warp?.alignRate || Math.PI / 2.5) * 0.8,
      exitProgress: 0,
      exitDuration: 0.8
    };
  }
  return entry.warpDrive;
}

function updateCapitalCarrier(entry, dt){
  const npc = entry?.entity;
  if (!npc || npc.dead) return;

  const formation = entry.template?.formationOffset || npc.fleetFormationOffset || { x: -800, y: 360 };
  const rotated = rotate(formation, ship.angle);
  const target = { x: ship.pos.x + rotated.x, y: ship.pos.y + rotated.y };
  const toTarget = { x: target.x - npc.x, y: target.y - npc.y };
  const dist = Math.hypot(toTarget.x, toTarget.y);

  const warpDrive = ensureCarrierWarpDrive(entry);
  const playerWarpState = warp.state;
  const shouldWarp = playerWarpState === 'charging' || playerWarpState === 'active';

  if (warpDrive){
    if (!shouldWarp){
      if (warpDrive.state === 'active'){
        warpDrive.state = 'exiting';
        warpDrive.exitProgress = 0;
      } else if (warpDrive.state === 'charging'){
        warpDrive.state = 'idle';
        warpDrive.charge = 0;
      } else if (warpDrive.state === 'exiting'){
        warpDrive.exitProgress = Math.min(1, warpDrive.exitProgress + dt / Math.max(0.001, warpDrive.exitDuration));
        if (warpDrive.exitProgress >= 1){
          warpDrive.state = 'idle';
          warpDrive.charge = 0;
        }
      }
    } else {
      if (warpDrive.state === 'idle'){
        warpDrive.state = 'charging';
        warpDrive.charge = 0;
      } else if (warpDrive.state === 'exiting'){
        warpDrive.state = 'charging';
        warpDrive.exitProgress = 0;
      }
      if (warpDrive.state === 'charging'){
        warpDrive.charge = Math.min(warpDrive.charge + dt, warpDrive.chargeTime);
        if (playerWarpState === 'active' && warpDrive.charge >= warpDrive.chargeTime){
          warpDrive.state = 'active';
          warpDrive.entryProgress = 0;
          warpDrive.entryBaseSpeed = Math.hypot(npc.vx, npc.vy);
          const dir = warp?.dir || { x: Math.cos(npc.angle), y: Math.sin(npc.angle) };
          const mag = Math.hypot(dir.x, dir.y) || 1;
          warpDrive.dir.x = dir.x / mag;
          warpDrive.dir.y = dir.y / mag;
        }
      } else if (warpDrive.state === 'active'){
        if (playerWarpState !== 'active'){
          warpDrive.state = 'exiting';
          warpDrive.exitProgress = 0;
        } else {
          warpDrive.entryProgress = Math.min(1, warpDrive.entryProgress + dt / Math.max(0.001, warpDrive.entryDuration));
          const curAngle = Math.atan2(warpDrive.dir.y, warpDrive.dir.x);
          const targetAngle = Math.atan2(warp.dir.y || 0, warp.dir.x || 1);
          const delta = wrapAngle(targetAngle - curAngle);
          const maxTurn = warpDrive.turnRate * dt;
          const newAngle = curAngle + clamp(delta, -maxTurn, maxTurn);
          warpDrive.dir.x = Math.cos(newAngle);
          warpDrive.dir.y = Math.sin(newAngle);
        }
      }
    }
    if (warpDrive.state !== 'active' && playerWarpState !== 'active'){
      warpDrive.entryProgress = 0;
    }
  }

  const driveState = warpDrive ? warpDrive.state : 'idle';
  let speedLimit = npc.maxSpeed || 0;
  let followGain = 1.3;
  let matchGain = 2.2;
  let dampenClose = true;

  if (driveState === 'charging'){
    followGain = 1.8;
    matchGain = 3.3;
    speedLimit = Math.max(speedLimit, npc.maxSpeed || 0);
  } else if (driveState === 'active'){
    const ramp = warpDrive ? smoothstep01(warpDrive.entryProgress) : 1;
    followGain = 2.6 + 1.2 * ramp;
    matchGain = 3.8 + 1.8 * ramp;
    speedLimit = Math.max(speedLimit, warp.speed * 1.05);
    dampenClose = false;
  } else if (driveState === 'exiting'){
    followGain = 2.2;
    matchGain = 3.0;
    speedLimit = Math.max(speedLimit, Math.hypot(ship.vel.x, ship.vel.y) + 260, npc.maxSpeed || 0);
  }

  const desiredVel = {
    x: ship.vel.x + toTarget.x * followGain,
    y: ship.vel.y + toTarget.y * followGain
  };

  npc.vx += (desiredVel.x - npc.vx) * Math.min(1, matchGain * dt);
  npc.vy += (desiredVel.y - npc.vy) * Math.min(1, matchGain * dt);

  if (dampenClose && dist < 90){
    const slow = Math.exp(-1.5 * dt);
    npc.vx *= slow;
    npc.vy *= slow;
  }

  limitSpeed(npc, speedLimit);

  if (driveState === 'active' && warpDrive){
    const desiredAngle = Math.atan2(warpDrive.dir.y, warpDrive.dir.x);
    const diff = wrapAngle(desiredAngle - npc.angle);
    const maxAlign = warpDrive.alignRate * dt;
    npc.angle = wrapAngle(npc.angle + clamp(diff, -maxAlign, maxAlign));
  } else {
    const spd = Math.hypot(npc.vx, npc.vy);
    if (spd > 1){
      npc.angle = Math.atan2(npc.vy, npc.vx);
    } else {
      const desiredAngle = Math.atan2(ship.pos.y - npc.y, ship.pos.x - npc.x);
      const diff = wrapAngle(desiredAngle - npc.angle);
      const turnLimit = (entry.template?.turn ?? npc.turn ?? 0) * dt;
      npc.angle = wrapAngle(npc.angle + clamp(diff, -turnLimit, turnLimit));
    }
  }
  npc.desiredAngle = npc.angle;

  const attackTarget = selectCarrierTarget(entry);
  if (attackTarget){
    const desiredAngle = Math.atan2(attackTarget.y - npc.y, attackTarget.x - npc.x);
    const diff = wrapAngle(desiredAngle - npc.angle);
    const turnLimit = (entry.template?.turn ?? npc.turn ?? 0) * dt;
    npc.angle = wrapAngle(npc.angle + clamp(diff, -turnLimit, turnLimit));
    npc.desiredAngle = npc.angle;
  }

  updateCarrierWeapons(entry, dt, 'guard', attackTarget);
  spawnCarrierEngineFx(entry);

  const shield = npc.shield;
  if (shield){
    if (shield.regenTimer > 0){
      shield.regenTimer = Math.max(0, shield.regenTimer - dt);
    } else if (shield.val < shield.max){
      const before = shield.val;
      shield.val = Math.min(shield.max, shield.val + shield.regenRate * dt);
      if (Math.abs(before - shield.val) > 0.5){
        entry.status.shield = shield.val;
        markFleetDirty();
      }
    }
    if (Math.abs(entry.status.shield - shield.val) > 0.5){
      entry.status.shield = shield.val;
      markFleetDirty();
    }
  } else if (entry.status.shield !== 0){
    entry.status.shield = 0;
    markFleetDirty();
  }

  if (Math.abs(entry.status.hull - npc.hp) > 0.5){
    entry.status.hull = Math.max(0, npc.hp);
    markFleetDirty();
  }
}

function spawnFriendlyCarrier(){
  const existing = getFriendlyCarrierEntity();
  if (existing) return existing;

  const au = getAuToWorldUnits();
  const angle = Number.isFinite(ship?.angle) ? ship.angle : Math.random() * Math.PI * 2;
  const spawnPos = {
    x: ship.pos.x + Math.cos(angle) * au,
    y: ship.pos.y + Math.sin(angle) * au
  };

  const carrier = createCapitalShipEntry('carrier', {
    pos: spawnPos,
    formationOffset: { x: 0, y: 0 }
  });
  if (!carrier) return null;

  addFleetShip(carrier);
  return carrier.entity;
}

function initFleet(){
  Fleet.ships.length = 0;
  markFleetDirty();
  if (Fleet.ui?.root) Fleet.ui.root.classList.add('hidden');
}

function makeRailgun(cfg){ return { ...cfg }; }
function makeRocketPod(cfg){ return { ...cfg }; }
function makeGatling(cfg){ return { ...cfg }; }
function spawnPirate(kind, station) {
  // 1. Znajdź szablon
  let template = SUPPORT_SHIP_TEMPLATES[kind];
  
  // Fallback: jeśli wpisano 'fighter', a w szablonach jest 'interceptor' (lub odwrotnie)
  if (!template) {
      if (kind === 'fighter') template = SUPPORT_SHIP_TEMPLATES['interceptor'];
      else if (kind === 'interceptor') template = SUPPORT_SHIP_TEMPLATES['fighter'];
  }

  // Jeśli nadal brak szablonu, użyj domyślnego interceptora (żeby gra się nie wysypała)
  if (!template) {
      console.warn(`Nieznany typ pirata: ${kind}. Spawnuję interceptor.`);
      template = SUPPORT_SHIP_TEMPLATES['interceptor'];
  }

  // 2. Pozycja startowa
  const angle = Math.random() * Math.PI * 2;
  const dist = (station.r || 100) + 150;
  const pos = {
    x: station.x + Math.cos(angle) * dist,
    y: station.y + Math.sin(angle) * dist
  };

  // 3. Stworzenie bazy NPC z szablonu
  const npc = makeNPCBase(pos, { ...template.stats, shield: template.shield });

  // 4. Nadpisanie właściwości pod PIRATA
  npc.type = kind;
  npc.friendly = false;
  npc.isPirate = true;
  npc.mission = true;
  npc.color = '#ff5c7c'; // Czerwony kolor pirata
  
  // Przypisanie referencji do stacji (ważne dla logiki patrolu)
  npc.home = station; 

  // 5. Konfiguracja uzbrojenia i AI z szablonu
  if (template.configure) {
      template.configure(npc);
  }

  // 6. Początkowy obrót w stronę gracza
  npc.angle = Math.atan2(ship.pos.y - npc.y, ship.pos.x - npc.x);

  // 7. Rejestracja w grze
  npcs.push(npc);
  return npc;
}
// Przypisanie do window, żeby konsola widziała
window.spawnPirate = spawnPirate;
// Lista na martwe, dryfujące kawałki
window.createWreckage = function(parentEntity, shards) {
  if (!shards || shards.length === 0) return;

  // 1. Oblicz środek masy nowej grupy heksów
  let sumLx = 0, sumLy = 0;
  for (const s of shards) {
    sumLx += s.lx;
    sumLy += s.ly;
  }
  const avgLx = sumLx / shards.length;
  const avgLy = sumLy / shards.length;

  // 2. Pozycja w świecie (bazując na pozycji rodzica i offsecie środka masy)
  // Musimy uwzględnić obrót rodzica
  const c = Math.cos(parentEntity.angle);
  const s = Math.sin(parentEntity.angle);

  // Pozycja środka nowego wraku w świecie
  const worldX = parentEntity.x + (avgLx * c - avgLy * s);
  const worldY = parentEntity.y + (avgLx * s + avgLy * c);

  // 3. Utwórz obiekt wraku
  const wreck = {
    x: worldX,
    y: worldY,
    vx: parentEntity.vx || parentEntity.vel.x, // Dziedziczy pęd
    vy: parentEntity.vy || parentEntity.vel.y,
    angle: parentEntity.angle,
    angVel: (parentEntity.angVel || 0) + (Math.random() - 0.5) * 0.5, // Dodaj trochę rotacji przy oderwaniu
    mass: shards.length * 10, // Przybliżona masa
    friction: 0.99, // Wraki dryfują
    dead: false,
    isWreck: true,

    // Budujemy mini-hexGrid dla tego kawałka
    hexGrid: {
      shards: [],
      map: {},
      // Offsety muszą być zresetowane względem nowego środka (avgLx, avgLy)
      offsetX: 0,
      offsetY: 0,
      srcWidth: parentEntity.hexGrid.srcWidth // Zachowujemy skalę
    }
  };

  // 4. Przenosimy heksy do wraku
  for (const shard of shards) {
    // Przesuwamy lokalne koordynaty heksa tak, by 0,0 było w środku nowego wraku
    shard.lx -= avgLx;
    shard.ly -= avgLy;
    shard.origLx -= avgLx; // Ważne dla warpStructure
    shard.origLy -= avgLy;

    // Przypisujemy do nowego grida
    wreck.hexGrid.shards.push(shard);
    wreck.hexGrid.map[shard.c + "," + shard.r] = shard;
  }

  // Oblicz promień wraku (dla kolizji zgrubnej)
  let maxR2 = 0;
  for(const sh of wreck.hexGrid.shards) {
    const d2 = sh.lx*sh.lx + sh.ly*sh.ly;
    if(d2 > maxR2) maxR2 = d2;
  }
  wreck.radius = Math.sqrt(maxR2) + 10;

  // Dodaj do listy wraków
  wrecks.push(wreck);

  // Dodaj efekt wizualny (dym/iskry w miejscu oderwania)
  if(window.spawnParticle) {
    for(let i=0; i<5; i++) {
      window.spawnParticle({x: worldX, y: worldY}, {x: wreck.vx, y: wreck.vy}, 1.0, '#aaaaaa', 5, false);
    }
  }
};
  function spawnPirateSquad(station, type, count, mode = 'guard', opts = {}) {
  const squad = new Squad('pirate', 'fighter');
  window.SQUADS.push(squad);
  
  // Parametry orbity / pozycji
  const radius = opts.radius || (station.r + 200);
  const speed = opts.speed || 0.3;
  const startPhase = Math.random() * Math.PI * 2;
  const phaseStep = (Math.PI * 2) / count;

  // Parametry ataku (tylko dla mode='attack')
  let attackAngle = 0;
  let attackDir = {x:0, y:0};
  if (mode === 'attack') {
      // Oblicz kąt w stronę gracza
      const dx = ship.pos.x - station.x;
      const dy = ship.pos.y - station.y;
      attackAngle = Math.atan2(dy, dx);
      attackDir = { x: Math.cos(attackAngle), y: Math.sin(attackAngle) };
  }

  for (let i = 0; i < count; i++) {
    // 1. Spawn jednostki
    const npc = spawnPirate(type, station);
    
    // 2. Pozycja startowa (dla obu trybów startują wokół stacji)
    // Dla ataku: spawnujemy ich w sektorze skierowanym do gracza, żeby nie lecieli przez stację
    const angle = (mode === 'attack') 
        ? attackAngle + (i - (count-1)/2) * 0.15 // Wachlarz w stronę gracza
        : startPhase + (i * phaseStep);          // Równomiernie dookoła (orbita)

    const spawnR = (mode === 'attack') ? station.r + 50 : radius; // Atakujący wylatują z doków
    
    npc.x = station.x + Math.cos(angle) * spawnR;
    npc.y = station.y + Math.sin(angle) * spawnR;

    // 3. Konfiguracja zachowania
    if (mode === 'guard') {
        // --- TRYB STRAŻNIKA (Orbitowanie) ---
        npc.state = 'guard';
        // Lider dostaje dane do orbitowania
        if (i === 0) {
            npc.guardStation = station;
            npc.guardOrbitRadius = radius;
            npc.guardOrbitSpeed = speed;
            npc.guardPhase = angle;
        }
        // Prędkość styczna (żeby już płynęli po orbicie)
        npc.vx = -Math.sin(angle) * radius * speed;
        npc.vy = Math.cos(angle) * radius * speed;
        npc.angle = angle + (speed > 0 ? Math.PI/2 : -Math.PI/2);
    } 
    else {
        // --- TRYB ATAKU (Swarm / Posiłki) ---
        npc.state = 'engage_formation';
        
        // Wyczyść guardStation, żeby nie orbitowali
        npc.guardStation = null; 
        
        // Nadaj dużą prędkość w stronę gracza (Wyrzut z hangaru)
        const launchSpeed = 400;
        npc.vx = Math.cos(angle) * launchSpeed;
        npc.vy = Math.sin(angle) * launchSpeed;
        npc.angle = angle;
        
        // Wymuś szukanie celu
        npc.forceTarget = null;
        npc.target = null;
        npc.retargetTimer = 0;
    }

    squad.addUnit(npc);
    
    // Offsety formacji (dla obu trybów, żeby ładnie latali w grupie)
    if (i > 0) {
        const row = Math.floor((i + 1) / 2);
        const side = (i % 2 === 0) ? 1 : -1;
        npc.formationOffset = { x: -row * 50, y: side * row * 40 };
    } else {
        npc.formationOffset = { x: 0, y: 0 };
    }
  }
  
  return squad;
}
const TRAFFIC_WEIGHTS = {
  mercury: { civilian: 0.02, convoy: 0.25 },
  venus:   { civilian: 0.03, convoy: 0.25 },
  earth:   { civilian: 1.80, convoy: 0.50 },
  mars:    { civilian: 1.60, convoy: 0.55 },
  default: { civilian: 0.40, convoy: 0.40 }
};

function trafficWeightFor(station, kind){
  const table = TRAFFIC_WEIGHTS[station.id] || TRAFFIC_WEIGHTS.default;
  if(kind === 'convoy') return table.convoy ?? TRAFFIC_WEIGHTS.default.convoy;
  if(kind === 'civilian') return table.civilian ?? TRAFFIC_WEIGHTS.default.civilian;
  if(kind && typeof table[kind] === 'number') return table[kind];
  return table.civilian ?? TRAFFIC_WEIGHTS.default.civilian;
}

function weightedPickStation(kind, scope){
  let pool;
  if(Array.isArray(scope)){
    pool = scope.slice();
  }else if(scope === 'inner' || scope === 'outer'){
    const match = scope === 'inner';
    pool = stations.filter(s => s.inner === match);
  }else if(typeof scope === 'boolean'){
    pool = stations.filter(s => s.inner === scope);
  }else{
    pool = stations.slice();
  }
  if(!pool.length) return null;
  let total = 0;
  const weighted = pool.map(st => {
    const w = Math.max(0, trafficWeightFor(st, kind));
    total += w;
    return { st, w };
  });
  if(total <= 0){
    return pool[Math.floor(Math.random()*pool.length)];
  }
  let r = Math.random() * total;
  for(const { st, w } of weighted){
    r -= w;
    if(r <= 0) return st;
  }
  return weighted[weighted.length - 1].st;
}

function preferEarthMarsRoute(stationId){
  return (stationId === 'earth' || stationId === 'mars') && Math.random() < 0.7;
}

function pickNextStation(startStationId, type){
  const start = stations.find(s=>s.id===startStationId) || stations[0];
  if(!start) return startStationId;
  if(preferEarthMarsRoute(start.id)){
    return start.id === 'earth' ? 'mars' : 'earth';
  }
  const isCivil = type && (type.startsWith('civilian') || type.startsWith('freighter'));
  const sameSphere = stations.filter(s => s.inner === start.inner && s.id !== start.id);
  const otherSphere = stations.filter(s => s.inner !== start.inner);
  let pool = sameSphere.length ? sameSphere : stations.filter(s => s.id !== start.id);
  if(isCivil && otherSphere.length && Math.random() < 0.35){
    pool = otherSphere;
  }
  let target = weightedPickStation(isCivil ? 'civilian' : null, pool);
  if(!target || target.id === start.id){
    const fallbackPool = pool.length ? pool : stations.filter(s => s.id !== start.id);
    if(fallbackPool.length){
      return fallbackPool[Math.floor(Math.random()*fallbackPool.length)].id;
    }
    return startStationId;
  }
  return target.id;
}
const NPC_TYPES = {
  'freighter-small':  { radius:10, speed:100, hp:100, color:'#8ab4d6', weapon:null, isCollidable: false },
  'freighter-medium': { radius:15, speed:100, hp:150, color:'#769cb8', weapon:null, isCollidable: false },
  'freighter-large':  { radius:25, speed:100, hp:200, color:'#5d829c', weapon:null, isCollidable: false },
  'freighter-capital':{ radius:48, speed:100, hp:400, color:'#45667d', weapon:null, isCollidable: false },
  'police':           { radius:24, speed:100, hp:200, color:'#44aaff', weapon:'null', isCollidable: true },
  'civilian-small':   { radius:6, speed:100, hp:10, color:'#cccccc', weapon:null, isCollidable: false },
  'civilian-large':   { radius:12, speed:100, hp:50, color:'#bbbbbb', weapon:null, isCollidable: false },
  'guard':            { radius:20, speed:100, hp:100, color:'#ff9933', weapon:'gun', isCollidable: true },
  'mercenary':        { radius:25, speed:100, hp:100, color:'#ff6633', weapon:'gun', isCollidable: true }
};
// ==========================================================================================
// 1. BAZA DANYCH AI SPACE (Statystyki broni i pocisków)
// ==========================================================================================

const AISPACE_GUNS = {
  laserS: { name:'Laser krótki', dps:40, dmg:8,  rps:5,   speed:520, range:380, spread:2,  color:'#86f7ff' },
  pulse:  { name:'Pulse blaster', dps:55, dmg:14, rps:4,   speed:420, range:420, spread:3,  color:'#ffd36e' },
  rail:   { name:'Rail micro',    dps:65, dmg:26, rps:1.8, speed:900, range:560, spread:0.6,color:'#c0b7ff' },
  gatling:{ name:'Gatling',       dps:70, dmg:3,  rps:12,  speed:520, range:320, spread:4,  color:'#9fff75' }
};

const AISPACE_PD = {
  pd_mk1:   { name:'PD Mk1',   dmg:5,  rps:9,  speed:560,  range:380, spread:6,   color:'#8cffd0', burst:3 },
  pd_laser: { name:'PD Laser', dmg:3,  rps:18, speed:1200, range:420, spread:0.7, color:'#ff77ff', burst:10 }
};

const AISPACE_FLAK = {
  flak_L:   { name:'Flak L', burst:1, rps:0.8, speed:380, range:520, radius:48, dmg:28, color:'#ffef8a' }
};

const AISPACE_MISSILES = {
  AF: { name:'AIM-3',  speed:360, turn:600, life:4.0, dmg:45,  seek:'fighter', color:'#7cd7ff' },
  AS: { name:'ASM-6',  speed:300, turn:320, life:6.0, dmg:120, seek:'ship',    color:'#ffad7c' },
  HE: { name:'HET-4',  speed:280, turn:250, life:5.0, dmg:160, seek:'any',     color:'#ff7cf0' },
  SW: { name:'Swarm-8',speed:340, turn:550, life:3.0, dmg:18,  seek:'fighter', color:'#b3ff7c', swarm:6, spread:18 }
};

const AISPACE_GUNS_M = {
  m_beam:       { name:'M Beam',       dmg:24,  rps:1.8, speed:900,  range:820,  spread:0.4, color:'#8fd8ff', isBeam:true },
  m_pulse:      { name:'M Pulse',      dmg:40,  rps:1.1, speed:700,  range:760,  spread:0.8, color:'#ffd98a' },
  m_rail:       { name:'M Rail',       dmg:85,  rps:0.55,speed:1200, range:880,  spread:0.35,color:'#d0c9ff' },
  m_autocannon: { name:'M Auto',       dmg:22,  rps:3.2, speed:780,  range:680,  spread:1.2, color:'#b6ff9a' },
  h_beam:       { name:'Heavy Beam',   dmg:260, rps:0.22,speed:1500, range:1100, spread:0.1, color:'#ff0000', isBeam:true },
  h_rapid:      { name:'Rapid Laser L',dmg:45,  rps:5.0, speed:900,  range:750,  spread:1.0, color:'#00ff00' }
};

const AISPACE_BS_BROADSIDE = {
  dmg:80, rps:0.6, speed:620, range:650, spread:2.5, color:'#ff9b4b'
};

// Hardpoint-friendly rejestr broni z AISPACE
const AISPACE_HARDPOINT_WEAPONS = (() => {
  const toWeapon = (id, def, type) => ({
    id,
    type,
    name: def.name,
    dps: def.dps,
    damage: def.dmg,
    rps: def.rps,
    cooldown: def.rps ? +(1 / def.rps).toFixed(2) : null,
    range: def.range,
    speed: def.speed,
    spread: def.spread,
    color: def.color,
    aispaceDef: def
  });

  const guns = {
    ais_laser_s: toWeapon('ais_laser_s', AISPACE_GUNS.laserS, HP.MAIN),
    ais_pulse: toWeapon('ais_pulse', AISPACE_GUNS.pulse, HP.MAIN),
    ais_rail_micro: toWeapon('ais_rail_micro', AISPACE_GUNS.rail, HP.MAIN),
    ais_gatling: toWeapon('ais_gatling', AISPACE_GUNS.gatling, HP.MAIN),
    ais_m_beam: toWeapon('ais_m_beam', AISPACE_GUNS_M.m_beam, HP.MAIN),
    ais_m_pulse: toWeapon('ais_m_pulse', AISPACE_GUNS_M.m_pulse, HP.MAIN),
    ais_m_rail: toWeapon('ais_m_rail', AISPACE_GUNS_M.m_rail, HP.MAIN),
    ais_m_autocannon: toWeapon('ais_m_autocannon', AISPACE_GUNS_M.m_autocannon, HP.MAIN),
    ais_h_beam: toWeapon('ais_h_beam', AISPACE_GUNS_M.h_beam, HP.MAIN),
    ais_h_rapid: toWeapon('ais_h_rapid', AISPACE_GUNS_M.h_rapid, HP.MAIN),
    ais_broadside: toWeapon('ais_broadside', AISPACE_BS_BROADSIDE, HP.MAIN)
  };

  const pd = {
    ais_pd_mk1: {
      id: 'ais_pd_mk1',
      type: HP.AUX,
      name: AISPACE_PD.pd_mk1.name,
      damage: AISPACE_PD.pd_mk1.dmg,
      rps: AISPACE_PD.pd_mk1.rps,
      cooldown: AISPACE_PD.pd_mk1.rps ? +(1 / AISPACE_PD.pd_mk1.rps).toFixed(2) : null,
      range: AISPACE_PD.pd_mk1.range,
      spread: AISPACE_PD.pd_mk1.spread,
      color: AISPACE_PD.pd_mk1.color,
      aispacePdId: 'pd_mk1'
    },
    ais_pd_laser: {
      id: 'ais_pd_laser',
      type: HP.AUX,
      name: AISPACE_PD.pd_laser.name,
      damage: AISPACE_PD.pd_laser.dmg,
      rps: AISPACE_PD.pd_laser.rps,
      cooldown: AISPACE_PD.pd_laser.rps ? +(1 / AISPACE_PD.pd_laser.rps).toFixed(2) : null,
      range: AISPACE_PD.pd_laser.range,
      spread: AISPACE_PD.pd_laser.spread,
      color: AISPACE_PD.pd_laser.color,
      aispacePdId: 'pd_laser'
    },
    ais_flak_L: {
      id: 'ais_flak_L',
      type: HP.AUX,
      name: AISPACE_FLAK.flak_L.name,
      damage: AISPACE_FLAK.flak_L.dmg,
      rps: AISPACE_FLAK.flak_L.rps,
      cooldown: AISPACE_FLAK.flak_L.rps ? +(1 / AISPACE_FLAK.flak_L.rps).toFixed(2) : null,
      range: AISPACE_FLAK.flak_L.range,
      spread: AISPACE_FLAK.flak_L.spread,
      color: AISPACE_FLAK.flak_L.color,
      aispaceFlakId: 'flak_L'
    }
  };

  const missileDefaults = 12;
  const missileRange = def => (def.speed && def.life) ? def.speed * def.life : def.range;
  const missiles = {
    ais_msl_AF: {
      id: 'ais_msl_AF', type: HP.MISSILE, name: AISPACE_MISSILES.AF.name, damage: AISPACE_MISSILES.AF.dmg,
      ammo: missileDefaults, rps: null, cooldown: null, range: missileRange(AISPACE_MISSILES.AF),
      color: AISPACE_MISSILES.AF.color, aispaceMissileId: 'AF', missileStats: { ...AISPACE_MISSILES.AF, range: missileRange(AISPACE_MISSILES.AF) }
    },
    ais_msl_AS: {
      id: 'ais_msl_AS', type: HP.MISSILE, name: AISPACE_MISSILES.AS.name, damage: AISPACE_MISSILES.AS.dmg,
      ammo: missileDefaults, rps: null, cooldown: null, range: missileRange(AISPACE_MISSILES.AS),
      color: AISPACE_MISSILES.AS.color, aispaceMissileId: 'AS', missileStats: { ...AISPACE_MISSILES.AS, range: missileRange(AISPACE_MISSILES.AS) }
    },
    ais_msl_HE: {
      id: 'ais_msl_HE', type: HP.MISSILE, name: AISPACE_MISSILES.HE.name, damage: AISPACE_MISSILES.HE.dmg,
      ammo: missileDefaults, rps: null, cooldown: null, range: missileRange(AISPACE_MISSILES.HE),
      color: AISPACE_MISSILES.HE.color, aispaceMissileId: 'HE', missileStats: { ...AISPACE_MISSILES.HE, range: missileRange(AISPACE_MISSILES.HE) }
    },
    ais_msl_SW: {
      id: 'ais_msl_SW', type: HP.MISSILE, name: AISPACE_MISSILES.SW.name, damage: AISPACE_MISSILES.SW.dmg,
      ammo: missileDefaults, rps: null, cooldown: null, range: missileRange(AISPACE_MISSILES.SW),
      color: AISPACE_MISSILES.SW.color, aispaceMissileId: 'SW', missileStats: { ...AISPACE_MISSILES.SW, range: missileRange(AISPACE_MISSILES.SW) }
    }
  };

  return { ...guns, ...pd, ...missiles };
})();

Object.assign(WEAPONS, AISPACE_HARDPOINT_WEAPONS);
for (const weaponId of Object.keys(AISPACE_HARDPOINT_WEAPONS)) {
  mergedInventory.add(weaponId);
}

// ==========================================================================================
// 2. ADAPTER SYSTEMU (Most między AI SPACE a Space Survivors)
// ==========================================================================================

// Ten obiekt udaje silnik z AI Space, żebyśmy nie musieli przepisywać każdej linijki AI
const PirateSim = {
  time: 0,
  get units() {
    // Zwraca listę celów: Gracz + jego sojusznicy + wrodzy piraci (dla friendly fire check)
    return [ship, ...npcs.filter(n => !n.dead)];
  },
  // Symulacja pocisków i eksplozji nie jest potrzebna tutaj, bo gra ma własną w main loop
  projectiles: [], 
  wrecks
};

// Funkcja strzelania - TŁUMACZY broń z AI Space na pociski w grze
window.spawnBulletAdapter = function(owner, target, weaponDef, opts = {}) {
  if (!weaponDef) return;

  const origin = opts.origin || owner;
  const originVel = opts.originVel || { x: owner.vx ?? owner.vel?.x ?? 0, y: owner.vy ?? owner.vel?.y ?? 0 };
  const baseAngle = opts.angleOverride ?? owner.angle ?? 0;
  const bulletSpeed = weaponDef.speed || 500;
  const bulletLife = weaponDef.life ?? ((weaponDef.range || 800) / bulletSpeed);
  const vfxKey = resolveBulletVfxKey(opts.vfxKey || weaponDef.id || weaponDef.name, opts.type || weaponDef.type);

  // 1. Celowanie
  let aimPoint;
  if (target) {
     aimPoint = getLeadAim(origin, target, bulletSpeed);
  } else {
     const angle = baseAngle;
     aimPoint = {
         x: origin.x + Math.cos(angle) * 1000,
         y: origin.y + Math.sin(angle) * 1000
     };
  }

  const adjustedAng = Math.atan2(aimPoint.y - origin.y, aimPoint.x - origin.x);
  const spreadRad = (weaponDef.spread || 0) * (Math.PI / 180);
  const finalAngle = adjustedAng + (Math.random() - 0.5) * spreadRad;

  // 2. OBSŁUGA LASERÓW (BEAM) - Przywrócona i naprawiona
  if (weaponDef.isBeam || opts.type === 'beam') {
    const beamRange = weaponDef.range || 800;
    // Punkt końcowy promienia
    const endX = origin.x + Math.cos(finalAngle) * beamRange;
    const endY = origin.y + Math.sin(finalAngle) * beamRange;
    const endPoint = { x: endX, y: endY };

    // Rysowanie promienia
    spawnLaserBeam({ x: origin.x, y: origin.y }, endPoint, opts.beamWidth || 8, {
      life: weaponDef.beamLife || 0.12,
      colorOuter: weaponDef.color || '#ff0000',
      colorInner: '#ffffff',
      glowColor: weaponDef.color,
      glowBlur: 20
    });

    // Natychmiastowe obrażenia (Hitscan)
    if (target) {
       // Sprawdź czy cel jest w linii strzału (prosta kolizja)
       // Dla uproszczenia zakładamy trafienie jeśli celowany był target
       const dist = Math.hypot(target.x - origin.x, target.y - origin.y);
       if (dist <= beamRange) {
          const dmg = weaponDef.dmg || 10;
          if (target === window.ship) applyDamageToPlayer(dmg);
          else if (target.isStation) applyDamageToStation(target, dmg);
          else if (target.isPlatform) applyDamageToPlatform(target, dmg);
          else applyDamageToNPC(target, dmg, 'beam');
          
          // Efekt trafienia
          spawnWeaponImpactFromPreset('beam', weaponDef.color, 1.0, target.x, target.y);
       }
    }
    return; // Laser to hitscan, nie dodajemy pocisku fizycznego
  }

  // 3. OBSŁUGA POCISKÓW (FIXED VISUALS)
  let bType = 'default'; // Domyślnie iskry
  let size = 3;
  const name = (weaponDef.name || '').toLowerCase();

  if (name.includes('rail') || name.includes('beam')) { bType = 'rail'; size = 4; }
  else if (name.includes('flak') || name.includes('armata')) { bType = 'armata'; size = 5; }
  else if (name.includes('auto') || name.includes('gatling')) { bType = 'autocannon'; size = 2; }
  else if (name.includes('pulse') || name.includes('plasma')) { bType = 'plasma'; size = 3; }
  else if (name.includes('laser')) { bType = 'default'; size = 2.5; }

  if (opts.type) bType = opts.type;

  window.bullets.push({
    x: origin.x,
    y: origin.y,
    vx: Math.cos(finalAngle) * bulletSpeed + originVel.x * 0.2,
    vy: Math.sin(finalAngle) * bulletSpeed + originVel.y * 0.2,
    life: bulletLife,
    r: size,
    owner: owner.friendly ? 'player' : 'npc',
    damage: weaponDef.dmg || 10,
    type: bType,
    color: weaponDef.color || '#fff',
    source: owner,
    explodeRadius: (bType === 'armata' || name.includes('flak')) ? (weaponDef.radius || 50) : 0,
    penetration: (bType === 'rail') ? 2 : 0
  });
};
  
window.aiPickBestTarget = function(self, rangeLimit) {
  let bestTarget = null;
  let bestScore = -Infinity;
  
  // Pobierz listę wrogów
  const enemies = self.friendly 
     ? npcs.filter(n => n.isPirate && !n.dead) 
     : [ship, ...npcs.filter(n => n.friendly && !n.dead)];

  // Limit zasięgu przekazywany z AI (np. 25000 dla Engage, 5000 dla Guard)
  const MAX_RANGE_SQ = (rangeLimit || 20000) ** 2;

  for (const u of enemies) {
    // 1. Sprawdź zasięg (twardy limit strefy)
    const distSq = (u.x - self.x)**2 + (u.y - self.y)**2;
    if (distSq > MAX_RANGE_SQ) continue;

    // 2. Tabela punktowa (Port z AI Space - pickBestTarget)
    let score = 0;
    
    // Kara za odległość (im dalej, tym mniejszy priorytet)
    score -= distSq * 0.00008; 

    // Typy jednostek
    const amFighter = self.fighter || self.type === 'fighter' || self.type === 'interceptor';
    const isFighter = u.fighter || u.type === 'fighter' || u.type === 'interceptor';
    const isCapital = u.isCapitalShip || u.type === 'frigate' || u.type === 'destroyer' || u === ship;

    if (amFighter) {
        if (isFighter) {
            // Myśliwiec vs Myśliwiec: Wysoki priorytet jeśli blisko (dogfight)
            // 2500^2 = 6250000
            if (distSq < 6250000) score += 40000; 
            else score += 1000;
        } else {
            // Myśliwiec vs Duży statek: Niższy priorytet
            score += 1000;
        }
    } else {
        // Większe statki (Fregaty itp.)
        if (isFighter) score += 2000;
        else score += 5000; 
    }

    // Samoobrona (Capital Defense z AI Space)
    // Jeśli cel jest BARDZO blisko (<350j), atakuj go bez względu na wszystko
    if (distSq < 122500) {
        score += 50000;
    }

    // Losowość (żeby nie wszyscy rzucili się na ten sam cel w jednej klatce)
    score += Math.random() * 500;

    if (score > bestScore) {
      bestScore = score;
      bestTarget = u;
    }
  }
  
  return bestTarget;
};
  // --- HELPER: Tłumacz typów dla AI (AI Space Port) ---
function getUnitKind(npc) {
  if (!npc) return 'unknown';
  if (npc === window.ship) return 'battleship'; // Gracz to dla AI duży statek
  
  // Czy to myśliwiec?
  if (npc.fighter || npc.type === 'fighter' || npc.type === 'interceptor' || npc.type === 'drone') {
      return 'fighter';
  }
  
  // Czy to fregata?
  if (npc.type && (npc.type.includes('frigate') || npc.type === 'corvette')) {
      return 'frigate';
  }
  
  // Czy to niszczyciel?
  if (npc.type === 'destroyer') {
      return 'destroyer';
  }
  
  // Czy to pancernik / capital?
  if (npc.type === 'battleship' || npc.type === 'carrier' || npc.isCapitalShip) {
      return 'battleship';
  }
  
  return 'other';
}
function pirateRoleKind(npc){
  if (!npc) return 'other';
  const type = npc.type || '';
  if (npc.fighter || type === 'fighter' || type === 'interceptor' || type === 'drone') return 'fighter';
  if (type.includes('frigate')) return npc.subType === 'laser' ? 'frigate_laser' : 'frigate';
  if (type === 'destroyer') return 'destroyer';
  if (type === 'battleship' || npc.isCapitalShip) return 'battleship';
  return 'other';
}

function pirateTargetKind(target){
  if (!target) return 'other';
  if (target === ship) return 'battleship';
  const type = target.type || '';
  if (target.fighter || type === 'fighter' || type === 'interceptor' || type === 'drone') return 'fighter';
  if (type.includes('frigate')) return 'frigate';
  if (type === 'destroyer') return 'destroyer';
  if (type === 'battleship' || target.isCapitalShip) return 'battleship';
  return 'other';
}

function pirateEffectiveHp(target){
  if (!target) return 0;
  const hull = (target.hp ?? target.hull?.val ?? 0);
  const shield = (target.shield?.val ?? target.shield ?? 0);
  return Math.max(0, hull + shield);
}

function pirateEngageScore(attacker, target){
  const attackerKind = pirateRoleKind(attacker);
  const targetKind = pirateTargetKind(target);
  const tx = target?.pos?.x ?? target?.x ?? 0;
  const ty = target?.pos?.y ?? target?.y ?? 0;
  const dx = tx - (attacker?.x ?? 0);
  const dy = ty - (attacker?.y ?? 0);
  const distSq = dx*dx + dy*dy;

  let score = -distSq * 0.0008;

  if (attackerKind === 'fighter') {
    if (targetKind === 'fighter') {
      score += distSq < 6250000 ? 40000 : 1000;
    } else {
      score += 1000;
    }
  } else if (attackerKind === 'frigate') {
    if (targetKind === 'fighter') score += 2000;
    else if (targetKind === 'frigate') score += 800;
    else score += 200;
  } else if (attackerKind === 'frigate_laser') {
    if (targetKind === 'battleship') score += 2500;
    else if (targetKind === 'destroyer') score += 2000;
    else if (targetKind === 'frigate') score += 1500;
    else score -= 300;
  } else if (attackerKind === 'destroyer') {
    if (targetKind === 'frigate') score += 4500;
    else if (targetKind === 'destroyer') score += 2500;
    else if (targetKind === 'battleship') score += 1000;
    else score += 500;
  } else if (attackerKind === 'battleship') {
    if (targetKind === 'battleship') score += 4000;
    else if (targetKind === 'destroyer') score += 3000;
    else if (targetKind === 'frigate') score += 2000;
    else score -= 500;
  }

  if (distSq < 122500) {
    if (attackerKind === 'fighter' && targetKind !== 'fighter') score += 6000;
    else score += 8000;
  }

  const effHp = pirateEffectiveHp(target);
  const incoming = target?.incomingDamage ?? 0;
  if (effHp > 0) {
    const overkill = incoming / (effHp + 1);
    if (overkill > 1.2) score -= 1500 * (overkill - 1.0);
  }

  score += Math.random() * 250;
  return score;
}

function pickPirateEngageTarget(npc){
  if (!npc?.isPirate || mercMission?.alertStage !== 'engage') return null;
  const candidates = [ship, ...npcs.filter(n => n.friendly && !n.dead)];
  let best = null;
  let bestScore = -Infinity;
  for (const target of candidates) {
    const score = pirateEngageScore(npc, target);
    if (score > bestScore) {
      bestScore = score;
      best = target;
    }
  }
  return best;
}
  // ==========================================================================================
// 2. LOGIKA AI (MÓZGI STATKÓW - "AI SPACE PORT")
// ==========================================================================================

// Helper: Znajdowanie najlepszego celu (Gracz lub sojusznik)
function aiPickTarget(npc) {
  if (npc?.isPirate) {
    if (mercMission?.alertStage === 'guard' && npc.guardHold) return null;
    const engageTarget = pickPirateEngageTarget(npc);
    if (engageTarget) return engageTarget;
  }
  if (npc && npc.forceTarget && !npc.forceTarget.dead) {
    return npc.forceTarget;
  }
  let best = null;
  let maxScore = -Infinity;
  
  const targets = npc.friendly 
    ? npcs.filter(n => n.isPirate && !n.dead) 
    : [ship, ...npcs.filter(n => n.friendly && !n.dead)];

  // RADAR POKRYWAJĄCY CAŁĄ STACJĘ PIRACKĄ
  const RADAR_RANGE_SQ = 20000 * 20000; 

  for (const t of targets) {
    const tx = t.pos ? t.pos.x : t.x;
    const ty = t.pos ? t.pos.y : t.y;
    const distSq = (tx - npc.x)**2 + (ty - npc.y)**2;

    if (distSq > RADAR_RANGE_SQ) continue; 

    let score = -distSq;
    if (t === ship) score += 10000000; 
    if (t.isCapitalShip) score += 5000000;
    
    if (score > maxScore) {
      maxScore = score;
      best = t;
    }
  }
  return best;
}

// --- B. AI FREGATY (Ruch, Strafing, Separacja – bez podwójnego tarcia) ---
window.aiFrigate = function(sim, npc, dt) {
  npc.gunCD = Math.max(0, (npc.gunCD || 0) - dt);
  npc.pdCD  = Math.max(0, (npc.pdCD  || 0) - dt);
  npc.mslCD = Math.max(0, (npc.mslCD || 0) - dt);

  // Retargeting
  npc.retargetTimer = (npc.retargetTimer || 0) - dt;
  if (npc.retargetTimer <= 0) {
      const freshTarget = aiPickTarget(npc);
      if (freshTarget) npc.target = freshTarget;
      npc.retargetTimer = 1.0 + Math.random() * 0.5;
  }

  // 1. Pobierz cel
  let target = (npc.forceTarget && !npc.forceTarget.dead) ? npc.forceTarget : npc.target;

  if (!target || target.dead) {
    target = aiPickTarget(npc);
    npc.target = target;
  }

  let targetAng = npc.angle;
  let thrust = 0;
  let strafe = 0;

  // Siły odseparowania
  let ax = 0;
  let ay = 0;

  // 2. Logika ruchu
  if (target) {
    const dx = target.x - npc.x;
    const dy = target.y - npc.y;
    targetAng = Math.atan2(dy, dx);

    const idealRange = npc.preferredRange || 750;
    const dist = Math.hypot(dx, dy);

    // Push-Pull (lekko złagodzone)
    if (dist < idealRange * 0.85)       thrust = -npc.accel * 0.7;
    else if (dist > idealRange * 1.15)  thrust =  npc.accel * 0.9;
    else                                thrust =  npc.accel * 0.25; // delikatny ruch do przodu, żeby nie "stała"

    // Strafe – delikatne kołowanie wokół celu
    const seed = (npc.id && typeof npc.id === 'string') ? npc.id.charCodeAt(0) : Math.floor(Math.random() * 1000);
    const time = performance.now() / 1000;
    strafe = Math.sin(time * 0.7 + seed * 0.3) * npc.accel * 0.4;

  } else {
    // Patrol lub stop
    if (npc.home) {
        const patrolRadius = npc.home.r + 300;
        if (!npc.patrolAngle) npc.patrolAngle = Math.random() * Math.PI * 2;
        npc.patrolAngle += 0.2 * dt;
        const px = npc.home.x + Math.cos(npc.patrolAngle) * patrolRadius;
        const py = npc.home.y + Math.sin(npc.patrolAngle) * patrolRadius;
        const dx = px - npc.x;
        const dy = py - npc.y;
        targetAng = Math.atan2(dy, dx);
        thrust = npc.accel * 0.4;
    } else {
        npc.vx *= 0.95;
        npc.vy *= 0.95;
    }
  }

  // Separacja (ważne przy grupach fregat)
  const sep = applySeparationForces(npc, 0, 0);
  ax += sep.ax;
  ay += sep.ay;

  // 3. Fizyka (Integracja sił)
  npc.angle = clampTurnAngle(npc.angle, targetAng, npc.turn, dt);
  const c = Math.cos(npc.angle);
  const s = Math.sin(npc.angle);

  // Sterowanie + separacja
  const totalAx = ax + (c * thrust - s * strafe);
  const totalAy = ay + (s * thrust + c * strafe);

  npc.vx += totalAx * dt;
  npc.vy += totalAy * dt;

  const v = Math.hypot(npc.vx, npc.vy);
  if (v > npc.maxSpeed) {
    const scale = npc.maxSpeed / v;
    npc.vx *= scale;
    npc.vy *= scale;
  }

  // UWAGA: brak dodatkowego friction – robi to npcStep()

  // 4. Strzelanie
  if (target) {
    const mainDef = AISPACE_GUNS_M[npc.mainGun] || AISPACE_GUNS_M.m_autocannon;
    const distSq = dist2(npc, target);

    if (npc.gunCD <= 0 && distSq < (mainDef.range * mainDef.range)) {
      const dx = target.x - npc.x, dy = target.y - npc.y;
      const dot = (Math.cos(npc.angle)*dx + Math.sin(npc.angle)*dy) / Math.sqrt(distSq);

      if (dot > 0.8) {
         window.spawnBulletAdapter(npc, target, mainDef, { type: mainDef.isBeam ? 'beam' : undefined });
         npc.gunCD = 1.0 / (mainDef.rps || 1.0);
      }
    }

    const pdDef = AISPACE_PD[npc.pd];
    if (pdDef && npc.pdCD <= 0 && distSq < (pdDef.range * pdDef.range)) {
      const burst = pdDef.burst || 1;
      for (let i = 0; i < burst; i++) {
          window.spawnBulletAdapter(npc, target, pdDef, { type: 'ciws' });
      }
      npc.pdCD = 1.0 / (pdDef.rps || 8);
    }

    if (npc.msl && npc.mslAmmo > 0 && npc.mslCD <= 0 && distSq < 1400*1400) {
       const mslDef = AISPACE_MISSILES[npc.msl] || AISPACE_MISSILES.AS;
       const dir = { x: Math.cos(npc.angle), y: Math.sin(npc.angle) };
       window.bullets.push({
        x: npc.x, y: npc.y,
        vx: dir.x * mslDef.speed + npc.vx,
        vy: dir.y * mslDef.speed + npc.vy,
        life: mslDef.life || 5,
        r: 5,
        owner: npc.friendly ? 'player' : 'npc',
        damage: mslDef.dmg || 80,
        type: 'rocket',
        target: target,
        color: mslDef.color,
        turnRate: (mslDef.turn || SIDE_ROCKET_TURN_RATE) * Math.PI / 180,
        homingDelay: 0.3,
        explodeRadius: 50
      });
      npc.mslAmmo -= 1;
      npc.mslCD = 6.0;
    }
  }
};

// --- C. AI NISZCZYCIELA (Ruch, Separacja, Boost – bez podwójnego tarcia) ---
window.aiDestroyer = function(sim, npc, dt) {
  npc.mCD   = Math.max(0, (npc.mCD   || 0) - dt);
  npc.pdCD  = Math.max(0, (npc.pdCD  || 0) - dt);
  npc.boostT  = Math.max(0, (npc.boostT  || 0) - dt);
  npc.boostCd = Math.max(0, (npc.boostCd || 0) - dt);

  // Retargeting
  npc.retargetTimer = (npc.retargetTimer || 0) - dt;
  if (npc.retargetTimer <= 0) {
      const freshTarget = aiPickTarget(npc);
      if (freshTarget) npc.target = freshTarget;
      npc.retargetTimer = 1.0 + Math.random() * 0.5;
  }

  let target = (npc.forceTarget && !npc.forceTarget.dead) ? npc.forceTarget : npc.target;
  if (!target || target.dead) {
    target = aiPickTarget(npc);
    npc.target = target;
  }

  const gunDef = AISPACE_GUNS_M[npc.mGun] || AISPACE_GUNS_M.m_rail;
  let targetAng = npc.angle;
  let thrust = 0;
  let strafe = 0;
  let ax = 0;
  let ay = 0;

  if (target) {
    const dx = target.x - npc.x;
    const dy = target.y - npc.y;
    const dist = Math.hypot(dx, dy);
    targetAng = Math.atan2(dy, dx);

    const range = gunDef.range || 800;
    const wantRange = range * 0.8;

    const ux = Math.cos(npc.angle), uy = Math.sin(npc.angle);
    const dot = (dx/dist)*ux + (dy/dist)*uy;

    // Boost – dobieganie na pozycję
    if (dist > range * 0.95 && npc.boostCd <= 0 && dot > 0.9) {
      npc.boostT  = npc.boostDur || 2.5;
      npc.boostCd = 10.0;
    }
    if (dist < wantRange * 0.9) npc.boostT = 0;

    // Push-Pull
    if (dist < wantRange * 0.95)      thrust = -npc.accel * 1.2;
    else if (dist > wantRange * 1.05) thrust =  npc.accel * 0.9;

    // Strafe – kołowanie wokół celu
    if (dist < range * 1.1) {
       const time = performance.now()/1000;
       const seed = (npc.id && typeof npc.id === 'string') ? npc.id.charCodeAt(0) : Math.floor(Math.random() * 1000);
       strafe = Math.sin(time * 0.55 + seed * 0.2) * npc.accel * 0.5;
       if (npc.boostT > 0) strafe *= 1.5;
    }

    // Separacja
    const sep = applySeparationForces(npc, 0, 0);
    ax += sep.ax * 1.2;
    ay += sep.ay * 1.2;

    // Strzelanie
    if (npc.mCD <= 0 && dist < range && dot > 0.9) {
       window.spawnBulletAdapter(npc, target, gunDef, {type:'rail'});
       npc.mCD = 1.0 / (gunDef.rps || 0.5);
    }
  }

  // Fizyka
  const speedBoost = (npc.boostT > 0) ? 1.7 : 1.0;
  npc.angle = clampTurnAngle(npc.angle, targetAng, npc.turn * speedBoost, dt);

  const c = Math.cos(npc.angle);
  const s = Math.sin(npc.angle);

  const totalAx = ax + (c * thrust - s * strafe) * speedBoost;
  const totalAy = ay + (s * thrust + c * strafe) * speedBoost;

  npc.vx += totalAx * dt;
  npc.vy += totalAy * dt;

  const v = Math.hypot(npc.vx, npc.vy);
  const maxV = npc.maxSpeed * speedBoost;
  if (v > maxV) {
     const scale = maxV/v;
     npc.vx *= scale;
     npc.vy *= scale;
  }

  // UWAGA: brak dodatkowego friction – robi to npcStep()

  const pdDef = AISPACE_PD[npc.pd];
  if (pdDef && npc.pdCD <= 0 && target) {
     if (dist2(npc, target) < pdDef.range**2) {
        window.spawnBulletAdapter(npc, target, pdDef, {type:'ciws'});
        npc.pdCD = 1.0 / (pdDef.rps || 9);
     }
  }
};

// --- D. AI PANCERNIKA (Ruch, Separacja, Broadside – bez podwójnego tarcia) ---
window.aiBattleship = function(sim, npc, dt) {
  npc.broadLeftCD  = Math.max(0, (npc.broadLeftCD  || 0) - dt);
  npc.broadRightCD = Math.max(0, (npc.broadRightCD || 0) - dt);
  npc.pdCD         = Math.max(0, (npc.pdCD         || 0) - dt);
  npc.mCD          = Math.max(0, (npc.mCD          || 0) - dt);

  // Retargeting
  npc.retargetTimer = (npc.retargetTimer || 0) - dt;
  if (npc.retargetTimer <= 0) {
      const freshTarget = aiPickTarget(npc);
      if (freshTarget) npc.target = freshTarget;
      npc.retargetTimer = 1.5 + Math.random() * 0.5;
  }

  let target = (npc.forceTarget && !npc.forceTarget.dead) ? npc.forceTarget : npc.target;
  if (!target || target.dead) {
    target = aiPickTarget(npc);
    npc.target = target;
  }

  const broadsideDef = AISPACE_BS_BROADSIDE;
  const mDef = AISPACE_GUNS_M.h_rapid;

  let targetAng = npc.angle;
  let thrust = 0;
  let strafe = 0;
  let ax = 0;
  let ay = 0;

  if (target) {
    const dx = target.x - npc.x;
    const dy = target.y - npc.y;
    const dist = Math.hypot(dx, dy);
    const toAng = Math.atan2(dy, dx);

    const noseRange = 800;
    const idealDist = noseRange * 0.75;

    if (dist < idealDist * 0.9)       thrust = -npc.accel * 0.5;
    else if (dist > idealDist * 1.15) thrust =  npc.accel * 0.9;
    else                              thrust =  npc.accel * 0.2;

    const time = performance.now()/1000;
    const seed = (npc.id && typeof npc.id === 'string') ? npc.id.charCodeAt(0) : Math.floor(Math.random() * 1000);
    strafe = Math.sin(time * 0.4 + seed * 0.2) * npc.accel * 0.35;

    // Separacja – pancerniki się rozpychają
    const sep = applySeparationForces(npc, 0, 0);
    ax += sep.ax * 1.5;
    ay += sep.ay * 1.5;

    const rightAng = toAng + Math.PI/2;
    const leftAng  = toAng - Math.PI/2;

    const diffNose  = Math.abs(wrapAngle(toAng     - npc.angle));
    const diffRight = Math.abs(wrapAngle(rightAng  - npc.angle));
    const diffLeft  = Math.abs(wrapAngle(leftAng   - npc.angle));

    const broadsideRange = 650;
    let sideBetter = false;
    const minSideDiff = Math.min(diffRight, diffLeft);

    if (dist < broadsideRange * 1.05 && (minSideDiff + 0.2 < diffNose)) {
      sideBetter = true;
    }

    if (sideBetter) {
      if (diffRight <= diffLeft) targetAng = rightAng;
      else targetAng = leftAng;
    } else {
      targetAng = toAng;
    }

    const sideArc = 0.5;

    // Broadside prawa burta
    if (diffRight < sideArc && npc.broadRightCD <= 0 && dist < broadsideDef.range) {
       for(let i=0; i<4; i++) {
         const offsetDist = (i - 1.5) * 25;
         const bx = npc.x + Math.cos(npc.angle)*offsetDist + Math.sin(npc.angle)*20;
         const by = npc.y + Math.sin(npc.angle)*offsetDist - Math.cos(npc.angle)*20;
         const fakeSource = { ...npc, x: bx, y: by };
         window.spawnBulletAdapter(fakeSource, target, broadsideDef, {type:'plasma'});
       }
       npc.broadRightCD = 2.0;
    }

    // Broadside lewa burta
    if (diffLeft < sideArc && npc.broadLeftCD <= 0 && dist < broadsideDef.range) {
       for(let i=0; i<4; i++) {
         const offsetDist = (i - 1.5) * 25;
         const bx = npc.x + Math.cos(npc.angle)*offsetDist - Math.sin(npc.angle)*20;
         const by = npc.y + Math.sin(npc.angle)*offsetDist + Math.cos(npc.angle)*20;
         const fakeSource = { ...npc, x: bx, y: by };
         window.spawnBulletAdapter(fakeSource, target, broadsideDef, {type:'plasma'});
       }
       npc.broadLeftCD = 2.0;
    }

    // Działo dziobowe
    if (diffNose < 0.3 && npc.mCD <= 0 && dist < mDef.range) {
       window.spawnBulletAdapter(npc, target, mDef, {type:'rail'});
       npc.mCD = 1.0 / mDef.rps;
    }
  }

  npc.angle = clampTurnAngle(npc.angle, targetAng, npc.turn, dt);
  const c = Math.cos(npc.angle);
  const s = Math.sin(npc.angle);

  // Sumowanie sił
  ax += c * thrust - s * strafe;
  ay += s * thrust + c * strafe;

  npc.vx += ax * dt;
  npc.vy += ay * dt;

  const v = Math.hypot(npc.vx, npc.vy);
  if (v > npc.maxSpeed) {
    const sc = npc.maxSpeed / v;
    npc.vx *= sc;
    npc.vy *= sc;
  }

  // UWAGA: brak dodatkowego friction – robi to npcStep()

  const pdDef = AISPACE_PD[npc.pd] || AISPACE_PD.pd_laser;
  if (npc.pdCD <= 0 && target && dist2(npc, target) < pdDef.range**2) {
     const burst = pdDef.burst || 1;
     for(let i=0; i<burst; i++) window.spawnBulletAdapter(npc, target, pdDef, {type:'ciws'});
     npc.pdCD = 1.0 / (pdDef.rps || 10);
  }
};
  
window.runAdvancedFighterAI = runAdvancedFighterAI;


// Helper strzelania dla myśliwców
function tryFireFighter(npc, target, dt) {
  if(!target || target.dead) return;
  
  const gunDef = AISPACE_GUNS[npc.gun] || AISPACE_GUNS.laserS;
  const tx = target.pos ? target.pos.x : target.x;
  const ty = target.pos ? target.pos.y : target.y;
  const dx = tx - npc.x;
  const dy = ty - npc.y;
  const dist = Math.hypot(dx, dy);

  // Czy statek patrzy na cel?
  const angleToTarget = Math.atan2(dy, dx);
  const myAngle = Math.atan2(npc.vy, npc.vx); // Fighter patrzy tam gdzie leci
  const diff = Math.abs(wrapAngle(angleToTarget - myAngle));

  // 1. Strzał z działa (Laser)
  if (dist < (gunDef.range || 400) && diff < 0.5 && npc.gunCD <= 0) {
     window.spawnBulletAdapter(npc, target, gunDef);
     npc.gunCD = 1.0 / (gunDef.rps || 5);
  }
  
  // 2. Strzał rakietą (Ograniczony amunicją)
  if (npc.mslAmmo > 0 && npc.mslCD <= 0 && dist < 1200 && diff < 0.6) {
      // Szansa na strzał 10% na klatkę, żeby nie wystrzelili wszystkiego w 0.1 sekundy
      if (Math.random() < 0.1) {
          const mslDef = AISPACE_MISSILES[npc.msl || 'AF'];
          const dir = norm({ x: dx, y: dy });
          const speed = mslDef.speed || 300;
          
          window.bullets.push({
            x: npc.x, y: npc.y,
            vx: dir.x * speed + npc.vx * 0.5,
            vy: dir.y * speed + npc.vy * 0.5,
            life: mslDef.life || 4,
            r: 4,
            owner: npc.friendly ? 'player' : 'npc',
            damage: mslDef.dmg || 40,
            type: 'rocket',
            target: target,
            color: mslDef.color || '#ffaa00',
            turnRate: (mslDef.turn || 6) * Math.PI / 180,
            homingDelay: 0.2,
            explodeRadius: 40
          });
          
          npc.mslAmmo--; // Odejmij amunicję
          npc.mslCD = 5.0; // Długi cooldown (5 sekund)
          
          // Efekt dymu przy wystrzale
          spawnParticle({x:npc.x, y:npc.y}, {x:0,y:0}, 0.5, '#ffffff', 5, true);
      }
  }
}
function initNPCs() {
  npcs = [];
  SQUADS.length = 0; // Reset eskadr
  let npcCounter = 0;

  // 1. Stwórz eskadrę pirackich myśliwców (Interceptor Squad)
  const pirateSquad = new Squad('pirate', 'fighter');
  SQUADS.push(pirateSquad);

  const startX = ship.pos.x + 2000;
  const startY = ship.pos.y;

  // Spawn 5 myśliwców w formacji
  for(let i=0; i<5; i++) {
    const npc = makeNPCBase({ x: startX + Math.random()*100, y: startY + Math.random()*100 }, {
      hp: 80,
      accel: 220, // Wyższe przyspieszenie dla nowej fizyki
      maxSpeed: 450,
      turn: 6.0,
      radius: 18
    });
    
    npc.id = `pirate_${npcCounter++}`;
    npc.friendly = false;
    npc.isPirate = true;
    npc.type = 'interceptor';
    npc.fighter = true;
    npc.color = '#ff5c7c'; // Czerwony z AI SPACE
    npc.mission = true; // Misje używają nowego AI; omijaj cywilny autopilot
    npc.gunCD = 0;
    
    // *** KLUCZOWA ZMIANA: Przypisanie nowego AI ***
    npc.ai = (dt) => runAdvancedFighterAI(npc, dt);
    
    npcs.push(npc);
    pirateSquad.addUnit(npc);
  }

  // 2. Stwórz eskadrę sojuszniczą (jeśli chcesz testować dogfight)
  const allySquad = new Squad('player', 'fighter');
  SQUADS.push(allySquad);
  
  for(let i=0; i<3; i++) {
     const npc = makeNPCBase({ x: ship.pos.x - 200, y: ship.pos.y + 200 }, {
       hp: 100, accel: 220, maxSpeed: 450, turn: 6.0, radius: 18
     });
     npc.id = `ally_${npcCounter++}`;
     npc.friendly = true;
     npc.type = 'ally_fighter';
     npc.fighter = true;
     npc.color = '#7cff91'; // Zielony z AI SPACE
     npc.mission = true; // Wymuś ścieżkę mission dla runAdvancedFighterAI
     npc.ai = (dt) => runAdvancedFighterAI(npc, dt);
     
     npcs.push(npc);
     allySquad.addUnit(npc);
  }
}
// Ensure Three.js modules are loaded before initializing 3D objects
window.addEventListener('DOMContentLoaded', () => {
  const planetInitResult = initPlanets3D(planets, SUN);
  const sceneFromInit = asThreeScene(planetInitResult);
  if (sceneFromInit) {
    planetScene3D = sceneFromInit;
  }
  // overlay main scene
  let overlayScene = null;
  if (typeof window.initWorld3D === 'function') {
    const res = initWorld3D();
    const candidate = asThreeScene(res?.scene || res);
    if (candidate) {
      mainScene3D = candidate;
      overlayScene = candidate;
    } else if (res?.scene) {
      mainScene3D = res.scene;
      overlayScene = res.scene;
    }
    window.mainScene3D = mainScene3D;
  }
  // stacje – własna warstwa 3D (ortho), bez world3D
  if (typeof window.initStations3D === 'function') {
    window.initStations3D(null, stations);
    planetScene3D = overlayScene;
    planetStationsReady = true;
  }
  if (!planetStationsReady && !ensurePlanetStationsInit(stations)) {
    let tries = 0;
    const maxTries = 240;
    (function poll(){
      if (ensurePlanetStationsInit(stations) || tries++ > maxTries) return;
      requestAnimationFrame(poll);
    })();
  }
});

function waitForPlanetsReady(){
  if (planetScene3D || planetStationsReady) return Promise.resolve();
  return waitForCondition(() => planetScene3D || planetStationsReady, 2500);
}

// =============== Bullets & effects ===============

// const particles = []; // USUNIĘTE
const shockwaves = [];
const MAX_PARTICLES = 8000;          // twardy sufit (dobry balans)
const MAX_PARTICLES_DRAW = 4500;     // ile maks. rysujemy na ekranie

// === POCZĄTEK NOWEGO KODU (Pula Cząsteczek) ===
const particlePool = [];
let nextParticleIndex = 0;
(function initParticlePool() { // Samowywołująca się funkcja do zainicjowania puli
  for (let i = 0; i < MAX_PARTICLES; i++) {
    particlePool.push({
      pos: { x: 0, y: 0 },
      vel: { x: 0, y: 0 },
      life: 0,
      age: 0,
      color: '#fff',
      size: 1,
      flash: false,
      beam: false,
      start: { x: 0, y: 0 },
      end: { x: 0, y: 0 },
      width: 0,
      alpha: 1,
      fadeWithLife: true,
      glowColor: null,
      colorOuter: null,
      colorInner: null,
      glowBlur: 0,
      outerWidthMul: 1,
      innerWidthMul: 1,
      active: false // Flaga 'aktywności' jest kluczowa
    });
  }
})();
// === KONIEC NOWEGO KODU ===

function pushParticleSafe(p){
  // Ta funkcja nie jest już potrzebna, ale zostawiamy ją pustą,
  // na wypadek gdyby inne części kodu ją wołały (jak spawnLaserBeam).
  // spawnParticle jest teraz główną funkcją.
}

function spawnParticle(pos, vel, life, color, size, flash){
  const p = particlePool[nextParticleIndex]; // Weź następną cząsteczkę z puli

  // Ustaw jej właściwości
  p.pos.x = pos.x;
  p.pos.y = pos.y;
  p.vel.x = vel.x;
  p.vel.y = vel.y;
  p.life = life;
  p.age = 0;
  p.color = color || '#ffb677';
  p.size = size || 2;
  p.flash = !!flash;
  p.beam = false;
  p.start.x = 0;
  p.start.y = 0;
  p.end.x = 0;
  p.end.y = 0;
  p.width = 0;
  p.alpha = 1;
  p.fadeWithLife = true;
  p.colorOuter = null;
  p.colorInner = null;
  p.glowColor = null;
  p.glowBlur = 0;
  p.outerWidthMul = 1;
  p.innerWidthMul = 1;
  p.active = true; // <-- AKTYWUJ CZĄSTECZKĘ

  // Przesuń indeks na następne wolne miejsce
  nextParticleIndex = (nextParticleIndex + 1) % MAX_PARTICLES;
}

function hexToRgb(hex){
  if(!hex || typeof hex !== 'string') return null;
  const clean = hex.replace('#','');
  if(clean.length === 3){
    const r = clean[0], g = clean[1], b = clean[2];
    return {
      r: parseInt(r+r, 16),
      g: parseInt(g+g, 16),
      b: parseInt(b+b, 16)
    };
  }
  if(clean.length !== 6) return null;
  return {
    r: parseInt(clean.slice(0,2), 16),
    g: parseInt(clean.slice(2,4), 16),
    b: parseInt(clean.slice(4,6), 16)
  };
}
function rgbaFromHex(hex, alpha){
  const rgb = hexToRgb(hex);
  if(!rgb) return null;
  return `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
}
function rgbaPrefixFromHex(hex, fallback = 'rgba(255,200,150,'){
  const rgb = hexToRgb(hex);
  if(!rgb) return fallback;
  return `rgba(${rgb.r},${rgb.g},${rgb.b},`;
}
function resolveAlphaColor(color, alpha, fallback){
  const rgba = rgbaFromHex(color, alpha);
  if(rgba) return rgba;
  if(color?.startsWith('rgba(')){
    const parts = color.split(',');
    if(parts.length >= 3){
      return `${parts[0]},${parts[1]},${parts[2]},${alpha})`;
    }
  }
  return fallback || color || '#ffffff';
}

const WEAPON_VFX_PRESETS = {
  rail: {
    key: 'rail',
    color: '#9cc9ff',
    len: 32,
    widthOuter: 12,
    widthInner: 4,
    glowBlur: 22,
    sparkCount: 18,
    sparkSpeed: [260, 420],
    sparkSize: [1.6, 2.4],
    shock: { r: 12, maxR: 120, w: 3.0, life: 0.32 },
  },
  armata: {
    key: 'armata',
    color: '#ffb46b',
    len: 34,
    widthOuter: 18,
    widthInner: 6,
    glowBlur: 26,
    sparkCount: 26,
    sparkSpeed: [240, 420],
    sparkSize: [2.2, 3.4],
    smoke: 6,
    smokeColor: 'rgba(120,90,60,0.55)',
    shock: { r: 16, maxR: 150, w: 3.6, life: 0.4 },
  },
  autocannon: {
    key: 'autocannon',
    color: '#ffcc8a',
    len: 18,
    widthOuter: 10,
    widthInner: 4,
    glowBlur: 18,
    sparkCount: 14,
    sparkSpeed: [220, 360],
    sparkSize: [1.4, 2.4],
    smoke: 4,
    smokeColor: 'rgba(90,110,180,0.5)',
    shock: { r: 10, maxR: 90, w: 2.8, life: 0.26 },
  },
  plasma: {
    key: 'plasma',
    color: '#7cff9c',
    len: 20,
    widthOuter: 10,
    widthInner: 6,
    glowBlur: 18,
    trailFromPrev: true,
    sparkCount: 14,
    sparkSpeed: [180, 320],
    sparkSize: [1.4, 2.4],
    shock: { r: 12, maxR: 110, w: 2.8, life: 0.3 },
  },
  pulse: {
    key: 'pulse',
    color: '#ffd36e',
    len: 22,
    widthOuter: 12,
    widthInner: 6,
    glowBlur: 20,
    trailFromPrev: true,
    sparkCount: 16,
    sparkSpeed: [200, 360],
    sparkSize: [1.6, 2.6],
    shock: { r: 12, maxR: 130, w: 3.0, life: 0.32 },
  },
  laser: {
    key: 'laser',
    color: '#86f7ff',
    len: 28,
    widthOuter: 11,
    widthInner: 3.5,
    glowBlur: 24,
    sparkCount: 12,
    sparkSpeed: [220, 360],
    sparkSize: [1.2, 2.0],
    shock: { r: 10, maxR: 100, w: 2.4, life: 0.26 },
  },
  beam: {
    key: 'beam',
    color: '#ff7c7c',
    len: 30,
    widthOuter: 12,
    widthInner: 5,
    glowBlur: 26,
    sparkCount: 16,
    sparkSpeed: [260, 380],
    sparkSize: [1.6, 2.8],
    shock: { r: 16, maxR: 160, w: 3.4, life: 0.36 },
  },
  flak: {
    key: 'flak',
    color: '#ffef8a',
    len: 20,
    widthOuter: 14,
    widthInner: 6,
    glowBlur: 22,
    sparkCount: 22,
    sparkSpeed: [200, 360],
    sparkSize: [1.6, 3.0],
    smoke: 8,
    smokeColor: 'rgba(120,90,60,0.4)',
    shock: { r: 18, maxR: 170, w: 3.8, life: 0.42 },
  },
  broadside: {
    key: 'broadside',
    color: '#ff9b4b',
    len: 24,
    widthOuter: 14,
    widthInner: 6,
    glowBlur: 22,
    sparkCount: 20,
    sparkSpeed: [220, 360],
    sparkSize: [1.8, 2.8],
    smoke: 5,
    smokeColor: 'rgba(120,80,60,0.45)',
    shock: { r: 16, maxR: 160, w: 3.4, life: 0.4 },
  },
  ciws: {
    key: 'ciws',
    color: '#8cffd0',
    len: 14,
    widthOuter: 8,
    widthInner: 3,
    glowBlur: 14,
    sparkCount: 10,
    sparkSpeed: [180, 280],
    sparkSize: [1.0, 1.8],
    shock: { r: 8, maxR: 70, w: 2.0, life: 0.2 },
  },
  default: {
    key: 'default',
    color: '#ffd86b',
    len: 18,
    widthOuter: 10,
    widthInner: 4,
    glowBlur: 18,
    sparkCount: 14,
    sparkSpeed: [200, 320],
    sparkSize: [1.2, 2.0],
    shock: { r: 10, maxR: 100, w: 2.6, life: 0.3 },
  },
};

function resolveBulletVfxKey(rawKey, type){
  const key = (rawKey || '').toString().toLowerCase();
  if(key.includes('broadside')) return 'broadside';
  if(key.includes('flak')) return 'flak';
  if(key.includes('beam') || key.includes('laser')) return key.includes('heavy') ? 'beam' : 'laser';
  if(key.includes('rail')) return 'rail';
  if(key.includes('armata')) return 'armata';
  if(key.includes('auto') || key.includes('gatling')) return 'autocannon';
  if(key.includes('pulse')) return 'pulse';
  if(key.includes('pd')) return 'ciws';
  if(key.includes('missile') || key.includes('aim-') || key.includes('asm') || key.includes('het') || key.includes('swarm')) return 'armata';
  if(type === 'beam') return 'beam';
  if(type === 'rail') return 'rail';
  if(type === 'armata') return 'armata';
  if(type === 'ciws') return 'ciws';
  if(type === 'autocannon') return 'autocannon';
  if(type === 'plasma') return 'plasma';
  return 'default';
}

function buildBulletVfxInstance(presetKey, color){
  const preset = WEAPON_VFX_PRESETS[presetKey] || WEAPON_VFX_PRESETS.default;
  const resolvedColor = color || preset.color;
  return {
    ...preset,
    key: preset.key,
    color: resolvedColor,
    glowColor: preset.glowColor || resolvedColor,
    trailColor: preset.trailColor || resolvedColor,
    shockColorPrefix: rgbaPrefixFromHex(preset.shockColor || resolvedColor, 'rgba(255,200,150,'),
  };
}

function spawnWeaponImpactFromPreset(presetKey, color, scale = 1, x = 0, y = 0){
  const fx = buildBulletVfxInstance(presetKey, color);
  const sparks = Math.round((fx.sparkCount || 12) * scale);
  for(let i = 0; i < sparks; i++){
    const a = Math.random() * Math.PI * 2;
    const speedMin = fx.sparkSpeed?.[0] || 200;
    const speedMax = fx.sparkSpeed?.[1] || 360;
    const speed = speedMin + Math.random() * (speedMax - speedMin);
    const sizeMin = fx.sparkSize?.[0] || 1.4;
    const sizeMax = fx.sparkSize?.[1] || 2.6;
    const size = sizeMin + Math.random() * (sizeMax - sizeMin);
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.2 + Math.random() * 0.18,
      resolveAlphaColor(fx.color, 0.9, fx.color),
      size * scale,
      true
    );
  }

  if(fx.smoke && fx.smokeColor){
    for(let i = 0; i < fx.smoke * scale; i++){
      const a = Math.random() * Math.PI * 2;
      const speed = 60 + Math.random() * 100;
      spawnParticle(
        { x, y },
        { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
        0.32 + Math.random() * 0.24,
        fx.smokeColor,
        3 * scale,
        false
      );
    }
  }

  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.12, resolveAlphaColor(fx.color, 1, '#ffffff'), (6 + (fx.widthInner || 4)) * 0.7 * scale, true);
  spawnShockwave(x, y, {
    r: (fx.shock?.r || 10) * scale,
    maxR: (fx.shock?.maxR || 100) * scale,
    w: (fx.shock?.w || 2.6) * scale,
    maxLife: fx.shock?.life || 0.32,
    color: fx.shockColorPrefix
  });
}

function resolveBulletVfx(bullet){
  if(!bullet.vfx){
    const presetKey = resolveBulletVfxKey(bullet.vfxKey || bullet.weaponId || bullet.weaponName, bullet.type);
    bullet.vfx = buildBulletVfxInstance(presetKey, bullet.vfxColor || bullet.color);
  }
  return bullet.vfx;
}

function drawBulletVisual(ctx, b, cam){
  const vfx = resolveBulletVfx(b);
  const s = worldToScreen(b.x, b.y, cam);
  const angle = Math.atan2(b.vy, b.vx);
  const lenPx = (vfx.len || 18) * camera.zoom;
  const dx = Math.cos(angle) * (lenPx * 0.5);
  const dy = Math.sin(angle) * (lenPx * 0.5);

  if(vfx.trailFromPrev){
    const sp = worldToScreen(b.px, b.py, cam);
    const grad = ctx.createLinearGradient(sp.x, sp.y, s.x, s.y);
    grad.addColorStop(0, resolveAlphaColor(vfx.trailColor, 0, vfx.color));
    grad.addColorStop(1, resolveAlphaColor(vfx.trailColor, 0.8, vfx.color));
    ctx.save();
    ctx.lineCap = 'round';
    ctx.strokeStyle = grad;
    ctx.shadowBlur = (vfx.glowBlur || 14) * 0.6 * camera.zoom;
    ctx.shadowColor = resolveAlphaColor(vfx.glowColor, 0.6, vfx.color);
    ctx.lineWidth = Math.max(1.2, (vfx.widthOuter || 8) * 0.6 * camera.zoom);
    ctx.beginPath(); ctx.moveTo(sp.x, sp.y); ctx.lineTo(s.x, s.y); ctx.stroke();
    ctx.restore();
  }

  ctx.save();
  ctx.lineCap = 'round';
  ctx.shadowBlur = (vfx.glowBlur || 16) * camera.zoom;
  ctx.shadowColor = resolveAlphaColor(vfx.glowColor, 0.9, vfx.color);
  ctx.strokeStyle = resolveAlphaColor(vfx.trailColor, 0.75, vfx.color);
  ctx.lineWidth = (vfx.widthOuter || 10) * camera.zoom;
  ctx.beginPath(); ctx.moveTo(s.x - dx, s.y - dy); ctx.lineTo(s.x + dx, s.y + dy); ctx.stroke();
  ctx.restore();

  ctx.save();
  ctx.lineCap = 'round';
  ctx.strokeStyle = resolveAlphaColor('#ffffff', 0.95, vfx.color);
  ctx.lineWidth = Math.max(1.2, (vfx.widthInner || 4) * camera.zoom);
  ctx.beginPath(); ctx.moveTo(s.x - dx * 0.35, s.y - dy * 0.35); ctx.lineTo(s.x + dx * 0.9, s.y + dy * 0.9); ctx.stroke();
  ctx.restore();
}
function spawnExplosionPlasma(x, y, scale = 1) {
  spawnParticle(
    {x, y},         // Pozycja
    {x: 0, y: 0},   // Brak ruchu
    0.1,            // Bardzo krótki czas życia (0.1s)
    '#AAFFAA',      // Jaśniejszy środek
    4 * scale,      // Mały rozmiar (np. 4px)
    true            // Flash (efekt świecenia)
  );
  spawnShockwave(x, y, { 
    r: 2,               // Startuje od punktu
    maxR: 14 * scale,   // Rośnie tylko do ~14 pikseli (bardzo małe)
    w: 2,               // Cienka linia
    maxLife: 0.15,      // Bardzo szybki zanik
    color: 'rgba(124, 255, 124,' 
  });
}
function spawnRailHitEffect(x,y,scale=1){
  // Tylko 3D (skalowane parametrem efektu)
  triggerRailgunExplosion3D(x, y, ship.h * 0.22 * scale);
}

function spawnArmataHitEffect(x, y, scale = 1){
  triggerArmataImpact3D(x, y, ship.h * 0.3 * scale);
  const count = Math.round(28 * scale);
  for(let i=0;i<count;i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 200 + Math.random() * 280;
    const color = (Math.random() < 0.45) ? '#ffd2a0' : '#ff9f58';
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.22 + Math.random() * 0.18,
      color,
      2.2 + Math.random() * 2.6,
      true
    );
  }
  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.12, '#fff2d0', 7.5 * scale, true);
  spawnShockwave(x, y, { r: 14 * scale, maxR: 120 * scale, w: 3.2 * scale, maxLife: 0.42, color: 'rgba(255,170,90,' });
}

function spawnAutocannonHitEffect(x, y, scale = 1){
  triggerAutocannonImpact3D(x, y, ship.h * 0.18 * scale);
  const sparkCount = Math.round(20 * scale);
  for(let i = 0; i < sparkCount; i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 280 + Math.random() * 240;
    const color = (Math.random() < 0.5) ? '#ffe4a8' : '#ffba60';
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.18 + Math.random() * 0.14,
      color,
      1.6 + Math.random() * 1.4,
      true
    );
  }
  const smokeCount = Math.round(6 * scale);
  for(let i = 0; i < smokeCount; i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 60 + Math.random() * 80;
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.32 + Math.random() * 0.18,
      'rgba(90,110,180,0.55)',
      3.2 * scale,
      false
    );
  }
  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.1, '#ffffff', 5.4 * scale, true);
  spawnShockwave(x, y, { r: 10 * scale, maxR: 90 * scale, w: 2.6 * scale, maxLife: 0.28, color: 'rgba(255,205,140,' });
}

function spawnRailMuzzle(pos, dir, baseVel, scale = 1){
  spawnParticle({ x: pos.x, y: pos.y }, { x: 0, y: 0 }, 0.1, '#bfe7ff', 6 * scale, true);
  const angle = Math.atan2(dir.y, dir.x);
  for(let i = 0; i < 5; i++){
    const aa = angle + (Math.random() - 0.5) * 0.14;
    const speed = 220 + Math.random() * 60;
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 6 * scale, y: pos.y + Math.sin(aa) * 6 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.2, y: Math.sin(aa) * speed + baseVel.y * 0.2 },
      0.12,
      '#bfe7ff',
      1.6 * scale,
      true
    );
  }
}

function spawnArmataMuzzle(pos, dir, baseVel, scale = 1){
  const angle = Math.atan2(dir.y, dir.x);
  spawnParticle(
    { x: pos.x, y: pos.y },
    { x: dir.x * 160 + baseVel.x * 0.12, y: dir.y * 160 + baseVel.y * 0.12 },
    0.16,
    '#ffd6a0',
    9 * scale,
    true
  );
  for(let i = 0; i < 10; i++){
    const spread = (Math.random() - 0.5) * 0.38;
    const aa = angle + spread;
    const speed = 260 + Math.random() * 140;
    const size = 2.6 + Math.random() * 2.8;
    const life = 0.16 + Math.random() * 0.14;
    const color = (Math.random() < 0.5) ? '#ffbe7a' : '#ffcfa0';
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 8 * scale, y: pos.y + Math.sin(aa) * 8 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.18, y: Math.sin(aa) * speed + baseVel.y * 0.18 },
      life,
      color,
      size * scale,
      true
    );
  }
  for(let i = 0; i < 4; i++){
    const aa = angle + (Math.random() - 0.5) * 0.25;
    const speed = 120 + Math.random() * 60;
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 4 * scale, y: pos.y + Math.sin(aa) * 4 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.08, y: Math.sin(aa) * speed + baseVel.y * 0.08 },
      0.3 + Math.random() * 0.18,
      '#d76926',
      1.8 * scale,
      false
    );
  }
  spawnShockwave(pos.x, pos.y, { r: 10 * scale, maxR: 80 * scale, w: 2.6 * scale, maxLife: 0.3, color: 'rgba(255,170,90,' });
}

function spawnAutocannonMuzzle(pos, dir, baseVel, scale = 1){
  const angle = Math.atan2(dir.y, dir.x);
  spawnParticle(
    { x: pos.x, y: pos.y },
    { x: dir.x * 220 + baseVel.x * 0.18, y: dir.y * 220 + baseVel.y * 0.18 },
    0.12,
    '#ffdba6',
    7 * scale,
    true
  );
  for(let i = 0; i < 8; i++){
    const spread = (Math.random() - 0.5) * 0.32;
    const aa = angle + spread;
    const speed = 300 + Math.random() * 180;
    const color = (Math.random() < 0.35) ? '#ffe6b0' : '#ffbf6b';
    const size = 1.6 + Math.random() * 1.6;
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 6 * scale, y: pos.y + Math.sin(aa) * 6 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.16, y: Math.sin(aa) * speed + baseVel.y * 0.16 },
      0.16 + Math.random() * 0.12,
      color,
      size * scale,
      true
    );
  }
  for(let i = 0; i < 4; i++){
    const aa = angle + (Math.random() - 0.5) * 0.2;
    const speed = 120 + Math.random() * 60;
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 4 * scale, y: pos.y + Math.sin(aa) * 4 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.08, y: Math.sin(aa) * speed + baseVel.y * 0.08 },
      0.24 + Math.random() * 0.18,
      '#6b7cff',
      1.4 * scale,
      false
    );
  }
  spawnShockwave(pos.x, pos.y, { r: 8 * scale, maxR: 70 * scale, w: 2.2 * scale, maxLife: 0.22, color: 'rgba(255,200,120,' });
}

function spawnSiegeMuzzle(pos, dir, baseVel, scale = 1){
  const angle = Math.atan2(dir.y, dir.x);
  spawnParticle(
    { x: pos.x, y: pos.y },
    { x: dir.x * 200 + baseVel.x * 0.15, y: dir.y * 200 + baseVel.y * 0.15 },
    0.18,
    '#ffe6b0',
    12 * scale,
    true
  );
  for(let i = 0; i < 14; i++){
    const spread = (Math.random() - 0.5) * 0.32;
    const aa = angle + spread;
    const speed = 320 + Math.random() * 160;
    const color = (Math.random() < 0.4) ? '#ffcf7f' : '#ffdca8';
    const vel = {
      x: Math.cos(aa) * speed + baseVel.x * 0.16,
      y: Math.sin(aa) * speed + baseVel.y * 0.16
    };
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 10 * scale, y: pos.y + Math.sin(aa) * 10 * scale },
      vel,
      0.22 + Math.random() * 0.14,
      color,
      2.4 * scale,
      true
    );
  }
  spawnShockwave(pos.x, pos.y, { r: 12 * scale, maxR: 100 * scale, w: 3.0 * scale, maxLife: 0.32, color: 'rgba(255,190,110,' });
}

function spawnSiegeHitEffect(x, y, scale = 1){
  triggerArmataImpact3D(x, y, ship.h * 0.36 * scale);
  const count = Math.round(36 * scale);
  for(let i = 0; i < count; i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 240 + Math.random() * 320;
    const color = (Math.random() < 0.45) ? '#ffd09a' : '#ffb670';
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.26 + Math.random() * 0.18,
      color,
      2.6 + Math.random() * 2.8,
      true
    );
  }
  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.16, '#fff6d6', 9.5 * scale, true);
  spawnShockwave(x, y, { r: 16 * scale, maxR: 150 * scale, w: 3.4 * scale, maxLife: 0.42, color: 'rgba(255,195,120,' });
}
function spawnDefaultHit(x, y, scale = 1) {
  spawnParticle(
    { x, y }, 
    { x: 0, y: 0 }, 
    0.15,           
    '#fff5d6',      
    7 * scale,      
    true            // Tryb flash (świecenie)
  );

  // 2. Fala uderzeniowa (Shockwave)
  spawnShockwave(x, y, { 
    r: 4 * scale,
    maxR: 45 * scale, // Mniejszy zasięg fali (rakiety mają ~100+)
    w: 3 * scale,     // Cieńsza linia
    maxLife: 0.25,    // Szybszy zanik
    color: 'rgba(255, 220, 180,' // Kolor fali (ciepły biały/żółty)
  });
}

function spawnShockwave(x, y, opts = {}){
  shockwaves.push({
    x, y,
    r: opts.r || 20,
    maxR: opts.maxR || 800,
    w: opts.w || 8,
    life: 0,
    maxLife: opts.maxLife || 0.6,
    color: opts.color || 'rgba(180,200,255,'
  });
}

// =============== Station UI ===============
let stationUI = {
  open:false,
  visible:false,
  awaitingCamera:false,
  appear:0,
  autoPosition:true,
  tab:'upgrades',
  station:null,
  cursorOver:false,
  hoverId:null,
  x:(W-450)/2,
  y:(H-520)/2,
  w:450,
  h:520,
  dragging:false,
  dragDX:0,
  dragDY:0,
  editorMode:false
};

function stationUnderCursor(){
  const world = screenToWorld(mouse.x, mouse.y);
  for(const s of stations){
    const d = Math.hypot(world.x - s.x, world.y - s.y);
    if(d < (s.r||120)) return s;
  }
  return null;
}

function openStationUI(station){
  if(!station) return;
  setStationEditorMode(false);
  stationUI.open = true;
  stationUI.visible = false;
  stationUI.awaitingCamera = true;
  stationUI.station = station;
  stationUI.tab = 'upgrades';
  stationUI.appear = 0;
  stationUI.autoPosition = true;
  stationUI.x = (W - stationUI.w) / 2;
  stationUI.y = (H - stationUI.h) / 2;
  stationUI.dragging = false;
  stationUI.editorMode = false;
  mouse.left = false;
  mouse.right = false;
  setInfrastructureActiveStation(station);
  camera.focusOnStation(station);
}

function closeStationUI(){
  if(!stationUI.open) return;
  setStationEditorMode(false);
  stationUI.open = false;
  stationUI.visible = false;
  stationUI.awaitingCamera = false;
  stationUI.station = null;
  stationUI.dragging = false;
  stationUI.autoPosition = false;
  stationUI.editorMode = false;
  setInfrastructureActiveStation(null);
  setInfrastructureUIVisible(false);
  camera.clearFocus();
}

function setStationEditorMode(enabled){
  const body = document.body;
  const overlay = infrastructureBuilder.overlay;
  const allow = !!enabled && !!stationUI.station && stationUI.open && !stationUI.awaitingCamera;
  if(allow === stationUI.editorMode) return;
  stationUI.editorMode = allow;
  if(body){
    body.classList.toggle('infrastructure-editor', stationUI.editorMode);
  }
  if(!stationUI.editorMode){
    infrastructureBuilder.hoveredCell = null;
    infrastructureBuilder.draggingBuildingId = null;
    if(overlay) overlay.classList.remove('editor-active');
    if(stationUI.open && stationUI.station){
      camera.focusOnStation(stationUI.station);
    } else {
      camera.clearFocus();
    }
    return;
  }
  if(overlay) overlay.classList.add('editor-active');
  const station = stationUI.station;
  if(!station) return;
  const state = ensureInfrastructureState(station);
  const layout = state?.layout;
  camera.focusOnInfrastructure(station, layout);
}

function updateStationUIState(dt){
  if(!stationUI.open && stationUI.awaitingCamera){
    stationUI.awaitingCamera = false;
  }

  if(stationUI.open && stationUI.awaitingCamera){
    const sameStation = camera.mode === 'focus' && camera.focusStation === stationUI.station;
    if(sameStation){
      const dx = camera.x - camera.targetX;
      const dy = camera.y - camera.targetY;
      const closeEnough = Math.hypot(dx, dy) < 2.0 && Math.abs(camera.zoom - camera.targetZoom) < 0.02;
      const arrived = camera.focusArrived || closeEnough;
      if(!camera.transition && arrived){
        stationUI.awaitingCamera = false;
        stationUI.visible = true;
        stationUI.appear = Math.max(0, stationUI.appear);
        stationUI.autoPosition = true;
        camera.focusArrived = false;
      }
    }
    if(camera.mode !== 'focus' || camera.focusStation !== stationUI.station){
      stationUI.awaitingCamera = false;
    }
  }

  const shouldBeVisible = stationUI.open && stationUI.visible && !stationUI.awaitingCamera;
  const targetAlpha = shouldBeVisible ? 1 : 0;
  const fadeInSpeed = 4;
  const fadeOutSpeed = 5;
  if(targetAlpha > stationUI.appear){
    stationUI.appear = Math.min(targetAlpha, stationUI.appear + dt * fadeInSpeed);
  } else if(targetAlpha < stationUI.appear){
    stationUI.appear = Math.max(targetAlpha, stationUI.appear - dt * fadeOutSpeed);
  }

  if(!stationUI.open && stationUI.appear <= 0.0001){
    stationUI.appear = 0;
    stationUI.visible = false;
    stationUI.station = null;
    stationUI.autoPosition = true;
  }

  const wantsEditor = stationUI.open && stationUI.visible && !stationUI.awaitingCamera && stationUI.tab === 'infrastructure';
  setStationEditorMode(wantsEditor);
}

const hoverInfoState = {
  el: document.getElementById('hover-info'),
  title: document.querySelector('#hover-info .hover-title'),
  subtitle: document.querySelector('#hover-info .hover-subtitle'),
  content: document.querySelector('#hover-info .hover-content'),
  type: null,
  target: null
};

function toTitleCaseFromKey(value){
  return String(value || '')
    .split(/[-_\s]+/g)
    .filter(Boolean)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

function availableStationTabs(station){
  if (Array.isArray(station?.tabs) && station.tabs.length) {
    return station.tabs.map(toTitleCaseFromKey);
  }
  return ['Upgrades', 'Trade', 'Cantina', 'Hangar', 'Mechanic', 'Infrastructure'];
}

function formatNpcName(npc){
  if(!npc) return '';
  if(typeof npc.name === 'string' && npc.name.trim()) return npc.name;
  if(typeof npc.callsign === 'string' && npc.callsign.trim()) return npc.callsign;
  if(npc.type) return toTitleCaseFromKey(npc.type);
  if(npc.id != null) return `Jednostka #${npc.id}`;
  return 'Jednostka';
}

function formatShieldValue(entity){
  const shield = entity?.shield;
  if(shield && typeof shield.val === 'number' && typeof shield.max === 'number'){
    return `${Math.max(0, Math.round(shield.val))}/${Math.max(0, Math.round(shield.max))}`;
  }
  return 'Brak';
}

function formatWeaponName(weapon){
  if(!weapon) return 'Brak';
  if(typeof weapon === 'string') return toTitleCaseFromKey(weapon);
  if(weapon.name) return toTitleCaseFromKey(weapon.name);
  return 'Brak';
}

function hideHoverInfo(){
  const { el, content } = hoverInfoState;
  if(!el) return;
  if(content) content.innerHTML = '';
  if(!el.classList.contains('hidden')) el.classList.add('hidden');
  hoverInfoState.type = null;
  hoverInfoState.target = null;
}

function updateHoverInfo(target, type){
  const { el, title, subtitle, content } = hoverInfoState;
  if(!el) return;
  if(!target || !type){
    hideHoverInfo();
    return;
  }
  hoverInfoState.type = type;
  hoverInfoState.target = target;
  el.classList.remove('hidden');
  if(content) content.innerHTML = '';

  if(type === 'station'){
    if(title) title.textContent = target.name || (target.id ? `Stacja ${String(target.id).toUpperCase()}` : 'Stacja');
    if(subtitle) subtitle.textContent = 'STACJA ORBITALNA';
    if(content){
      const section = document.createElement('div');
      section.className = 'hover-section';
      section.textContent = 'Zakładki';
      content.appendChild(section);

      const tags = document.createElement('div');
      tags.className = 'hover-tags';
      for(const tab of availableStationTabs(target)){
        const span = document.createElement('span');
        span.className = 'hover-tag';
        span.textContent = tab;
        tags.appendChild(span);
      }
      content.appendChild(tags);
    }
  } else if(type === 'npc'){
    if(title) title.textContent = formatNpcName(target);
    if(subtitle) subtitle.textContent = target.friendly ? 'SOJUSZNIK' : 'CELE NPC';
    if(content){
      const lines = [
        { label:'HP', value: `${Math.max(0, Math.round(target.hp ?? 0))}/${Math.max(0, Math.round(target.maxHp ?? target.hp ?? 0))}` },
        { label:'Tarcza', value: formatShieldValue(target) },
        { label:'Broń', value: formatWeaponName(target.weapon) }
      ];
      for(const line of lines){
        const row = document.createElement('div');
        row.className = 'hover-line';
        const strong = document.createElement('strong');
        strong.textContent = `${line.label}:`;
        const span = document.createElement('span');
        span.textContent = line.value;
        row.appendChild(strong);
        row.appendChild(span);
        content.appendChild(row);
      }
    }
  } else if(type === 'platform'){
    if(title) title.textContent = target.label || 'Platforma obronna';
    if(subtitle) subtitle.textContent = 'PIRACKA OBRONA';
    if(content){
      const lines = [];
      if(target.shield){
        lines.push({ label:'Osłony', value: `${Math.max(0, Math.round(target.shield.val))}/${target.shield.max}` });
      }
      lines.push({ label:'Kadłub', value: `${Math.max(0, Math.round(target.hp ?? 0))}/${Math.max(0, Math.round(target.maxHp ?? target.hp ?? 0))}` });
      lines.push({ label:'Orbita', value: `${Math.round(target.orbitRadius)} u` });
      for(const line of lines){
        const row = document.createElement('div');
        row.className = 'hover-line';
        const strong = document.createElement('strong');
        strong.textContent = `${line.label}:`;
        const span = document.createElement('span');
        span.textContent = line.value;
        row.appendChild(strong);
        row.appendChild(span);
        content.appendChild(row);
      }
    }
  }
}

window.addEventListener('keydown', (e)=>{
  if(stationUI.open){
    if(e.code==='Escape'){ closeStationUI(); e.stopImmediatePropagation(); return; }
    if(e.code==='Digit1') stationUI.tab='upgrades';
    if(e.code==='Digit2') stationUI.tab='trade';
    if(e.code==='Digit3') stationUI.tab='cantina';
    if(e.code==='Digit4') stationUI.tab='hangar';
    if(e.code==='Digit5') stationUI.tab='mechanic';
    if(e.code==='Digit6') stationUI.tab='infrastructure';
  }
});

window.addEventListener('keydown', (e)=>{
  if(e.code==='KeyO' && !stationUI.open){ OPTIONS_OPEN = !OPTIONS_OPEN; }
});

function renderStationUI(){
  const alpha = clamp(stationUI.appear, 0, 1);

  const shouldShow = stationUI.open && stationUI.visible && !stationUI.awaitingCamera && alpha > 0.001;
  const showInfrastructure = shouldShow && stationUI.tab === 'infrastructure';

  setInfrastructureUIVisible(showInfrastructure);

  const overlay = stationOverlayDom.root;
  if(!overlay){
    return;
  }

  overlay.style.opacity = shouldShow ? alpha.toFixed(2) : '0';
  overlay.classList.toggle('hidden', !shouldShow);
  if(shouldShow){
    renderStationOverlay(stationUI.tab, stationUI.station);
  }
}

function positionStationUIPanel(){
  const st = stationUI.station;
  if(!st) return;
  const screen = worldToScreen(st.x, st.y, camera);
  const margin = 48;
  const maxX = W - stationUI.w - margin;
  stationUI.x = clamp(screen.x + margin, margin, maxX);
  const centeredY = (H - stationUI.h) / 2;
  stationUI.y = clamp(centeredY, margin, H - stationUI.h - margin);
}

function setMechanicUIVisible(visible){
  const overlay = document.getElementById('mechanic-overlay');
  if(!overlay) return;
  const panel = document.getElementById('tab-mechanic');
  const tabBtn = overlay.querySelector('li[data-tab="mechanic"]');
  const active = !!visible;
  overlay.classList.toggle('hidden', !active);
  if(panel) panel.classList.toggle('hidden', !active);
  if(tabBtn) tabBtn.classList.toggle('active', active);
}

const INFRASTRUCTURE_BUILDINGS = [
  { id:'solar_array', name:'Orbitalna Elektrownia Słoneczna', buildTime:75, icon:'solar', footprint:{ w:4, h:4 } },
  { id:'dock_s', name:'Dok Orbitalny (S)', buildTime:55, icon:'dock', footprint:{ w:1, h:1 } },
  { id:'dock_m', name:'Dok Orbitalny (M)', buildTime:75, icon:'dock', footprint:{ w:2, h:1 }, rotatable:true },
  { id:'dock_l', name:'Dok Orbitalny (L)', buildTime:105, icon:'dock', footprint:{ w:2, h:2 } },
  { id:'dock_capital', name:'Dok Orbitalny (Capital)', buildTime:140, icon:'dock', footprint:{ w:3, h:3 } },
  { id:'shipyard_s', name:'Fighter Factory', buildTime:90, icon:'shipyard', tier:'S', footprint:{ w:3, h:3 }, rotatable:true },
  { id:'shipyard_m', name:'Orbitalna Stocznia (M)', buildTime:110, icon:'shipyard', tier:'M', footprint:{ w:2, h:2 } },
  { id:'shipyard_l', name:'Orbitalna Stocznia (L)', buildTime:140, icon:'shipyard', tier:'L', footprint:{ w:3, h:2 }, rotatable:true },
  { id:'shipyard_capital', name:'Orbitalna Stocznia (Capital)', buildTime:170, icon:'shipyard', tier:'C', footprint:{ w:3, h:4 }, rotatable:true },
  { id:'shipyard_supercapital', name:'Orbitalna Stocznia (SuperCapital)', buildTime:210, icon:'shipyard', tier:'SC', footprint:{ w:3, h:4 }, rotatable:true },
  { id:'storage_metal', name:'Magazyn Metali', buildTime:60, icon:'storage', label:'M', color:'#60a5fa', footprint:{ w:4, h:4 } },
  { id:'storage_fuel', name:'Magazyn Paliwa', buildTime:70, icon:'storage', label:'F', color:'#f97316', footprint:{ w:4, h:4 } },
  { id:'storage_gas', name:'Magazyn Gazów', buildTime:65, icon:'storage', label:'G', color:'#14b8a6', footprint:{ w:4, h:4 } },
  { id:'storage_plastics', name:'Magazyn Tworzyw Sztucznych', buildTime:85, icon:'storage', label:'P', color:'#a855f7', footprint:{ w:4, h:4 } },
  { id:'metal_harvester', name:'Metal Harvester', buildTime:95, icon:'metal_harvester', footprint:{ w:4, h:4 }, allowedPlanetTypes:['rocky'] },
  { id:'metal_refinery', name:'Metal Refinery', buildTime:125, icon:'metal_refinery', footprint:{ w:4, h:4 }, allowedPlanetTypes:['rocky'] },
  { id:'gas_harvester', name:'Gas Harvester', buildTime:110, icon:'gas_harvester', footprint:{ w:4, h:4 }, requiresSolarSystem:true, allowedPlanetTypes:['gas'] },
  { id:'gas_refinery', name:'Gas Refinery', buildTime:140, icon:'gas_refinery', footprint:{ w:4, h:4 }, requiresSolarSystem:true, allowedPlanetTypes:['gas'] }
];
const ECONOMY_RESOURCES = {
  gas:{ label:'Gaz' },
  fuel:{ label:'Paliwo' },
  rawMetal:{ label:'Surowy metal' },
  refinedMetal:{ label:'Rafinowany metal' }
};
const ECONOMY_RESOURCE_KEYS = Object.keys(ECONOMY_RESOURCES);
const ECONOMY_BASE_CAPACITY = { gas:60, fuel:90, rawMetal:140, refinedMetal:100 };
const ECONOMY_STORAGE_BONUS = {
  storage_gas: { gas:260 },
  storage_fuel: { fuel:240 },
  storage_metal: { rawMetal:320, refinedMetal:240 }
};
const ECONOMY_BUILDING_RULES = {
  gas_harvester: { produce: { gas: 22 } },
  gas_refinery: { consume: { gas: 16 }, produce: { fuel: 14 } },
  metal_harvester: { produce: { rawMetal: 24 } },
  metal_refinery: { consume: { rawMetal: 18 }, produce: { refinedMetal: 12 } }
};
const ECONOMY_TICK_SECONDS = 60;
const INFRA_BUILDING_MAP = new Map(INFRASTRUCTURE_BUILDINGS.map(b => [b.id, b]));

const INFRA_CELL_WORLD_SIZE = 220;
const INFRA_CELL_WORLD_GAP = 60;
const INFRA_CELL_WORLD_STEP = INFRA_CELL_WORLD_SIZE + INFRA_CELL_WORLD_GAP;
const INFRA_STATION_CORE_SIZE = 4;
const INFRA_MIN_GRID = 8;
const INFRA_MAX_GRID = 26;
let infrastructureLayoutCache = null;
let infrastructureLayoutKey = '';

function computeInfrastructureLayout(cols, rows){
  const width = INFRA_CELL_WORLD_SIZE + (cols - 1) * INFRA_CELL_WORLD_STEP;
  const height = INFRA_CELL_WORLD_SIZE + (rows - 1) * INFRA_CELL_WORLD_STEP;
  const originOffset = { x: -width / 2, y: -height / 2 };
  const cells = [];
  const coreStartCol = Math.max(0, Math.floor((cols - INFRA_STATION_CORE_SIZE) / 2));
  const coreStartRow = Math.max(0, Math.floor((rows - INFRA_STATION_CORE_SIZE) / 2));
  const coreEndCol = Math.min(cols, coreStartCol + INFRA_STATION_CORE_SIZE) - 1;
  const coreEndRow = Math.min(rows, coreStartRow + INFRA_STATION_CORE_SIZE) - 1;
  const coreIndices = [];
  const centerIndex = (coreStartRow + Math.floor(INFRA_STATION_CORE_SIZE / 2)) * cols + coreStartCol + Math.floor(INFRA_STATION_CORE_SIZE / 2);
  for(let row=0; row<rows; row++){
    for(let col=0; col<cols; col++){
      const idx = row * cols + col;
      const local = {
        x: originOffset.x + col * INFRA_CELL_WORLD_STEP + INFRA_CELL_WORLD_SIZE / 2,
        y: originOffset.y + row * INFRA_CELL_WORLD_STEP + INFRA_CELL_WORLD_SIZE / 2
      };
      const blocked = col >= coreStartCol && col <= coreEndCol && row >= coreStartRow && row <= coreEndRow;
      if(blocked) coreIndices.push(idx);
      cells.push({ index: idx, col, row, local, blocked });
    }
  }
  return {
    cellSize: INFRA_CELL_WORLD_SIZE,
    cellGap: INFRA_CELL_WORLD_GAP,
    step: INFRA_CELL_WORLD_STEP,
    cols,
    rows,
    originOffset,
    width,
    height,
    cells,
    centerIndex,
    core:{ startCol: coreStartCol, startRow: coreStartRow, indices: coreIndices }
  };
}

function getInfrastructureLayout(cols, rows){
  const key = `${cols}x${rows}`;
  if(!infrastructureLayoutCache || infrastructureLayoutKey !== key){
    infrastructureLayoutCache = computeInfrastructureLayout(cols, rows);
    infrastructureLayoutKey = key;
  }
  return infrastructureLayoutCache;
}

function computeInfrastructureGridSize(station){
  const planet = station?.planet;
  const orbitRadii = planet ? planetOrbitRadii(planet) : null;
  const innerOrbitRadius = orbitRadii?.inner || Math.max(1200, (station?.r || 0) * 10);
  const squareSide = innerOrbitRadius * Math.SQRT2;
  const approximateCols = Math.floor(squareSide / INFRA_CELL_WORLD_STEP);
  let cols = Math.max(INFRA_MIN_GRID, Math.min(INFRA_MAX_GRID, approximateCols));
  if(cols % 2 !== 0) cols += 1; // symetria względem środka stacji
  const rows = cols;
  return { cols, rows };
}

function rebuildInfrastructureGrid(layout){
  const grid = infrastructureBuilder.grid;
  if(!grid) return;
  const cols = infrastructureBuilder.gridCols;
  grid.style.setProperty('--infra-cols', cols);
  grid.innerHTML = '';
  infrastructureBuilder.gridCells = [];
  const total = cols * infrastructureBuilder.gridRows;
  for(let i=0;i<total;i++){
    const meta = layout.cells?.[i];
    const cell = document.createElement('div');
    cell.className = 'infra-cell empty';
    cell.dataset.index = String(i);
    if(meta?.blocked){
      cell.classList.add('core');
      cell.classList.remove('empty');
      cell.dataset.blocked = '1';
    } else {
      cell.dataset.blocked = '0';
    }
    const canvas = document.createElement('canvas');
    canvas.width = 96;
    canvas.height = 96;
    cell.appendChild(canvas);
    const progressBar = document.createElement('div');
    progressBar.className = 'infra-progress-bar';
    const fill = document.createElement('div');
    fill.className = 'infra-progress-fill';
    progressBar.appendChild(fill);
    cell.appendChild(progressBar);
    const status = document.createElement('div');
    status.className = 'infra-cell-status';
    status.textContent = meta?.blocked ? 'Rdzeń stacji' : 'Puste';
    cell.appendChild(status);
    cell.addEventListener('dragenter', handleInfrastructureCellDragEnter);
    cell.addEventListener('dragover', handleInfrastructureCellDragOver);
    cell.addEventListener('dragleave', handleInfrastructureCellDragLeave);
    cell.addEventListener('drop', handleInfrastructureCellDrop);
    cell.addEventListener('click', ()=>{
      const state = getActiveInfrastructureState();
      const rootIdx = state ? getRootCellIndex(state, i) : null;
      infrastructureBuilder.selectedCell = rootIdx != null ? rootIdx : i;
      renderInfrastructureOverlay();
    });
    infrastructureBuilder.gridCells.push(cell);
    grid.appendChild(cell);
  }
}

function updateInfrastructureGridForStation(station){
  const size = computeInfrastructureGridSize(station);
  const changed = size && (size.cols !== infrastructureBuilder.gridCols || size.rows !== infrastructureBuilder.gridRows);
  if(changed){
    infrastructureBuilder.gridCols = size.cols;
    infrastructureBuilder.gridRows = size.rows;
    infrastructureLayoutCache = null;
    infrastructureLayoutKey = '';
    infrastructureBuilder.selectedCell = null;
    infrastructureBuilder.hoveredCell = null;
  }
  const layout = getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  if(changed || !infrastructureBuilder.layout){
    infrastructureBuilder.layout = layout;
    rebuildInfrastructureGrid(layout);
    infrastructureBuilder.needsRender = true;
  }
  return layout;
}

const infrastructureBuilder = {
  overlay: document.getElementById('infrastructure-overlay'),
  list: document.getElementById('infra-building-list'),
  grid: document.getElementById('infra-grid'),
  info: document.getElementById('infra-info'),
  gridCols: INFRA_MIN_GRID,
  gridRows: INFRA_MIN_GRID,
  gridCells: [],
  stationStates: new Map(),
  selectedCell: null,
  activeStationKey: null,
  activeStationRef: null,
  hideTimer: null,
  isVisible: false,
  needsRender: false,
  hoveredCell: null,
  draggingBuildingId: null,
  draggingOverlay: false,
  overlayOffset: { x: 0, y: 0 },
  overlayPosition: null,
  editorAlpha: 0,
  ghostAlpha: 0,
  ghostRotation: 0,
  layout: null
};

function clampInfrastructureOverlayPosition(pos, overlay){
  const maxX = Math.max(8, window.innerWidth - overlay.offsetWidth - 8);
  const maxY = Math.max(12, window.innerHeight - overlay.offsetHeight - 12);
  return {
    x: Math.min(Math.max(8, pos.x), maxX),
    y: Math.min(Math.max(12, pos.y), maxY)
  };
}

function applyInfrastructureOverlayPosition(){
  const overlay = infrastructureBuilder.overlay;
  if(!overlay) return;
  if(!infrastructureBuilder.overlayPosition){
    const rect = overlay.getBoundingClientRect();
    infrastructureBuilder.overlayPosition = { x: rect.left, y: rect.top };
  }
  const pos = clampInfrastructureOverlayPosition(infrastructureBuilder.overlayPosition, overlay);
  infrastructureBuilder.overlayPosition = pos;
  overlay.style.left = `${pos.x}px`;
  overlay.style.top = `${pos.y}px`;
  overlay.style.right = 'auto';
  overlay.style.bottom = 'auto';
}

function setupInfrastructureOverlayDrag(){
  const overlay = infrastructureBuilder.overlay;
  if(!overlay) return;
  const header = overlay.querySelector('h3');
  if(!header) return;

  const endDrag = ()=>{
    if(!infrastructureBuilder.draggingOverlay) return;
    infrastructureBuilder.draggingOverlay = false;
    overlay.classList.remove('dragging');
    document.removeEventListener('pointermove', onMove);
    document.removeEventListener('pointerup', endDrag);
  };

  const onMove = (ev)=>{
    if(!infrastructureBuilder.draggingOverlay) return;
    const nextPos = {
      x: ev.clientX - infrastructureBuilder.overlayOffset.x,
      y: ev.clientY - infrastructureBuilder.overlayOffset.y
    };
    infrastructureBuilder.overlayPosition = clampInfrastructureOverlayPosition(nextPos, overlay);
    overlay.style.left = `${infrastructureBuilder.overlayPosition.x}px`;
    overlay.style.top = `${infrastructureBuilder.overlayPosition.y}px`;
  };

  header.addEventListener('pointerdown', (ev)=>{
    if(ev.button !== 0 || !infrastructureBuilder.isVisible) return;
    const rect = overlay.getBoundingClientRect();
    infrastructureBuilder.overlayOffset = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
    infrastructureBuilder.overlayPosition = { x: rect.left, y: rect.top };
    infrastructureBuilder.draggingOverlay = true;
    overlay.classList.add('dragging');
    applyInfrastructureOverlayPosition();
    document.addEventListener('pointermove', onMove);
    document.addEventListener('pointerup', endDrag);
  });

  window.addEventListener('resize', ()=>{
    if(infrastructureBuilder.overlayPosition && infrastructureBuilder.isVisible){
      applyInfrastructureOverlayPosition();
    }
  });
}

setupInfrastructureOverlayDrag();

function handleInfrastructureRotationWheel(ev){
  if(!infrastructureBuilder.draggingBuildingId) return;
  if(!stationUI.open || stationUI.tab !== 'infrastructure') return;
  const building = INFRA_BUILDING_MAP.get(infrastructureBuilder.draggingBuildingId);
  const fp = building?.footprint;
  const canRotate = building && (building.rotatable || (fp && fp.w !== fp.h));
  if(!canRotate) return;
  ev.preventDefault();
  const delta = ev.deltaY > 0 ? 1 : -1;
  infrastructureBuilder.ghostRotation = (infrastructureBuilder.ghostRotation + delta + 2) % 2;
  infrastructureBuilder.needsRender = true;
}
window.addEventListener('wheel', handleInfrastructureRotationWheel, { passive:false });

function getInfrastructureStationKey(station){
  if(!station) return null;
  if(station.id != null) return `station-${station.id}`;
  if(station.name) return `station-${station.name}`;
  const x = Math.round(station.x ?? 0);
  const y = Math.round(station.y ?? 0);
  return `station-${x}-${y}`;
}

function findStationByKey(key){
  if(!key) return null;
  for(const st of stations){
    if(getInfrastructureStationKey(st) === key) return st;
  }
  return null;
}

function ensureInfrastructureState(station){
  const key = getInfrastructureStationKey(station);
  if(!key) return null;
  const layout = updateInfrastructureGridForStation(station);
  const cols = infrastructureBuilder.gridCols;
  const rows = infrastructureBuilder.gridRows;
  const totalCells = cols * rows;
  infrastructureBuilder.layout = layout;
  let state = infrastructureBuilder.stationStates.get(key);
  if(!state){
    state = {
      stationKey: key,
      stationRef: station || null,
      stationName: station?.name || null,
      cells: Array.from({ length: totalCells }, () => null),
      cellMeta: layout.cells,
      layout,
      centerIndex: layout.centerIndex
    };
    infrastructureBuilder.stationStates.set(key, state);
  } else {
    if(state.cells.length !== totalCells){
      if(state.cells.length > totalCells){
        state.cells.length = totalCells;
      } else {
        state.cells = state.cells.concat(Array(totalCells - state.cells.length).fill(null));
      }
    }
    state.cellMeta = layout.cells;
    state.layout = layout;
    state.centerIndex = layout.centerIndex;
    if(station) state.stationRef = station;
    if(station?.name) state.stationName = station.name;
  }
  if(!state.stationRef){
    state.stationRef = station || findStationByKey(key) || null;
  }
  return state;
}

function createEmptyEconomyResources(){
  const res = {};
  for(const key of ECONOMY_RESOURCE_KEYS){
    res[key] = 0;
  }
  return res;
}

function getEconomyStationKey(ctx){
  if(!ctx) return null;
  if(ctx.stationKey) return ctx.stationKey;
  if(ctx.stationRef) return getInfrastructureStationKey(ctx.stationRef);
  return getInfrastructureStationKey(ctx);
}

function ensureStationEconomy(ctx){
  const key = getEconomyStationKey(ctx);
  if(!key) return null;
  if(!Game.stationEconomy) Game.stationEconomy = new Map();
  let econ = Game.stationEconomy.get(key);
  if(!econ){
    econ = {
      stationKey: key,
      resources: createEmptyEconomyResources(),
      capacity: { ...ECONOMY_BASE_CAPACITY },
      timer: 0
    };
    Game.stationEconomy.set(key, econ);
  }
  econ.stationRef = ctx?.stationRef || ctx || findStationByKey(key);
  return econ;
}

function computeEconomyCapacities(buildingCounts){
  const capacity = { ...ECONOMY_BASE_CAPACITY };
  for(const [buildingId, bonus] of Object.entries(ECONOMY_STORAGE_BONUS)){
    const count = buildingCounts?.[buildingId] || 0;
    if(!count) continue;
    for(const [res, value] of Object.entries(bonus)){
      capacity[res] = (capacity[res] || 0) + value * count;
    }
  }
  return capacity;
}

function clampEconomyResources(econ){
  if(!econ) return;
  for(const key of ECONOMY_RESOURCE_KEYS){
    const cap = econ.capacity?.[key];
    const value = econ.resources?.[key] ?? 0;
    econ.resources[key] = Number.isFinite(cap) ? clamp(value, 0, cap) : Math.max(0, value);
  }
}

function applyEconomyProduction(econ, buildingCounts, ticks){
  if(!econ || ticks <= 0) return;
  for(const [buildingId, rule] of Object.entries(ECONOMY_BUILDING_RULES)){
    const count = buildingCounts?.[buildingId] || 0;
    if(!count) continue;
    const cycles = count * ticks;
    let ratio = 1;
    if(rule.consume){
      for(const [res, amount] of Object.entries(rule.consume)){
        const required = amount * cycles;
        if(required <= 0) continue;
        const available = econ.resources?.[res] ?? 0;
        ratio = Math.min(ratio, available / required);
      }
    }
    if(ratio <= 0) continue;
    if(rule.consume){
      for(const [res, amount] of Object.entries(rule.consume)){
        const delta = amount * cycles * ratio;
        econ.resources[res] = Math.max(0, (econ.resources?.[res] ?? 0) - delta);
      }
    }
    if(rule.produce){
      for(const [res, amount] of Object.entries(rule.produce)){
        const current = econ.resources?.[res] ?? 0;
        const cap = econ.capacity?.[res];
        const next = current + amount * cycles * ratio;
        econ.resources[res] = Number.isFinite(cap) ? Math.min(cap, next) : next;
      }
    }
  }
  clampEconomyResources(econ);
}

function updateStationEconomyFromBuildings(state, buildingCounts, dt){
  const econ = ensureStationEconomy(state);
  if(!econ) return;
  econ.capacity = computeEconomyCapacities(buildingCounts || {});
  clampEconomyResources(econ);
  econ.timer = (econ.timer || 0) + dt;
  if(econ.timer < ECONOMY_TICK_SECONDS) return;
  const ticks = Math.floor(econ.timer / ECONOMY_TICK_SECONDS);
  econ.timer -= ticks * ECONOMY_TICK_SECONDS;
  applyEconomyProduction(econ, buildingCounts, ticks);
}

function setInfrastructureActiveStation(station){
  updateInfrastructureGridForStation(station);
  const key = getInfrastructureStationKey(station);
  if(infrastructureBuilder.activeStationKey === key){
    infrastructureBuilder.activeStationRef = station || null;
    if(key){
      const state = ensureInfrastructureState(station || findStationByKey(key));
      if(state && station) state.stationRef = station;
    }
    return;
  }
  infrastructureBuilder.activeStationKey = key;
  infrastructureBuilder.activeStationRef = station || null;
  if(key){
    const state = ensureInfrastructureState(station || findStationByKey(key));
    if(state && station) state.stationRef = station;
  }
  infrastructureBuilder.selectedCell = null;
  infrastructureBuilder.needsRender = true;
  if(infrastructureBuilder.isVisible){
    renderInfrastructureOverlay();
  }
}

function getActiveInfrastructureState(){
  const station = infrastructureBuilder.activeStationRef || stationUI.station;
  return station ? ensureInfrastructureState(station) : null;
}

function getRootCellIndex(state, idx){
  if(!state || !state.cells || !Number.isInteger(idx)) return null;
  const cell = state.cells[idx];
  if(!cell) return null;
  if(Number.isInteger(cell.rootIndex)) return cell.rootIndex;
  return idx;
}

function getRootCell(state, idx){
  const rootIdx = getRootCellIndex(state, idx);
  if(rootIdx == null) return null;
  return state.cells[rootIdx] || null;
}

function buildingFootprint(building, rotation = 0){
  const base = building?.footprint || { w:1, h:1 };
  const rotated = (rotation % 2 !== 0) ? { w: base.h, h: base.w } : base;
  return { ...rotated };
}

function computeFootprintCells(layout, anchorIdx, building, rotation){
  if(!layout || !layout.cells || !building || !Number.isInteger(anchorIdx)) return null;
  const anchorMeta = layout.cells[anchorIdx];
  if(!anchorMeta) return null;
  const fp = buildingFootprint(building, rotation);
  const width = fp.w || 1;
  const height = fp.h || 1;
  if(anchorMeta.col + width > layout.cols || anchorMeta.row + height > layout.rows) return null;
  const cells = [];
  for(let dy=0; dy<height; dy++){
    for(let dx=0; dx<width; dx++){
      const col = anchorMeta.col + dx;
      const row = anchorMeta.row + dy;
      const idx = row * layout.cols + col;
      const meta = layout.cells[idx];
      if(!meta) return null;
      cells.push(meta);
    }
  }
  const center = cells.reduce((acc, meta)=>{
    acc.x += meta.local.x; acc.y += meta.local.y; return acc;
  }, { x:0, y:0 });
  center.x /= cells.length;
  center.y /= cells.length;
  return { cells, width, height, center };
}

function isBuildingAllowedOnStation(building, station){
  if(!building) return { allowed:false, reason:'Brak definicji budynku.' };
  if(building.requiresSolarSystem && !USE_SOLAR){
    return { allowed:false, reason:'Dostępne tylko w Układzie Słonecznym.' };
  }
  if(Array.isArray(building.allowedPlanetTypes) && building.allowedPlanetTypes.length){
    const allowed = building.allowedPlanetTypes.map(t => String(t).toLowerCase());
    const planetType = typeof station?.planet?.type === 'string' ? station.planet.type.toLowerCase() : null;
    if(!planetType || !allowed.includes(planetType)){
      return { allowed:false, reason:'Wymaga planety gazowej.' };
    }
  }
  return { allowed:true, reason:null };
}

function validateInfrastructurePlacement(state, anchorIdx, building, rotation){
  const layout = state?.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  const station = state?.stationRef || stationUI.station || null;
  const availability = isBuildingAllowedOnStation(building, station);
  if(!availability.allowed) return { valid:false, footprint:null, reason: availability.reason };
  const footprint = computeFootprintCells(layout, anchorIdx, building, rotation);
  if(!layout || !footprint) return { valid:false, footprint:null };
  const blocked = footprint.cells.some(meta => meta.blocked);
  const occupied = footprint.cells.some(meta => state.cells?.[meta.index]);
  return { valid: !blocked && !occupied, blocked, occupied, layout, footprint };
}

function infrastructureHasBuildings(state){
  if(!state || !Array.isArray(state.cells)) return false;
  return state.cells.some(Boolean);
}

function finalizeInfrastructurePlacement(state, anchorIdx, building, placement, rotation){
  if(!state || !placement || !building || !placement.footprint) return null;
  const layout = placement.layout || state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  const normalizedRotation = Math.abs(rotation || 0) % 2;
  const duration = Math.max(1, building.buildTime);
  const base = {
    buildingId: building.id,
    status: 'completed',
    elapsed: duration,
    duration,
    progress: 1,
    startedAt: (performance.now() / 1000) - duration,
    cellIndex: anchorIdx,
    rootIndex: anchorIdx,
    rotation: normalizedRotation,
    footprint: { w: placement.footprint.width, h: placement.footprint.height },
    cells: placement.footprint.cells.map(meta => meta.index),
    gridX: layout.cells?.[anchorIdx]?.col ?? 0,
    gridY: layout.cells?.[anchorIdx]?.row ?? 0,
    localPos: { x: placement.footprint.center.x, y: placement.footprint.center.y },
    emitted: false
  };
  for(const meta of placement.footprint.cells){
    state.cells[meta.index] = base;
    if(state.cellMeta) state.cellMeta[meta.index] = layout.cells?.[meta.index] || meta;
  }
  return base;
}

function autoplaceInfrastructureBuilding(state, buildingId, desiredCol, desiredRow, rotation = 0){
  const building = INFRA_BUILDING_MAP.get(buildingId);
  if(!state || !building) return false;
  const availability = isBuildingAllowedOnStation(building, state.stationRef || null);
  if(!availability.allowed) return false;
  const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  const fp = buildingFootprint(building, rotation);
  if(!fp || !layout) return false;
  const targetCol = clamp(Math.round(desiredCol), 0, Math.max(0, layout.cols - fp.w));
  const targetRow = clamp(Math.round(desiredRow), 0, Math.max(0, layout.rows - fp.h));
  const targetCenterCol = targetCol + (fp.w - 1) / 2;
  const targetCenterRow = targetRow + (fp.h - 1) / 2;
  const candidates = layout.cells.filter(meta => !meta.blocked);
  candidates.sort((a, b) => {
    const ac = { col: a.col + (fp.w - 1) / 2, row: a.row + (fp.h - 1) / 2 };
    const bc = { col: b.col + (fp.w - 1) / 2, row: b.row + (fp.h - 1) / 2 };
    const da = Math.hypot(ac.col - targetCenterCol, ac.row - targetCenterRow);
    const db = Math.hypot(bc.col - targetCenterCol, bc.row - targetCenterRow);
    return da - db;
  });
  for(const meta of candidates){
    const placement = validateInfrastructurePlacement(state, meta.index, building, rotation);
    if(placement && placement.valid){
      finalizeInfrastructurePlacement(state, meta.index, building, placement, rotation);
      return true;
    }
  }
  return false;
}

function autoplaceBuildingByOffset(state, buildingId, offsetCol, offsetRow, rotation = 0){
  if(!state) return false;
  const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  if(!layout) return false;
  const building = INFRA_BUILDING_MAP.get(buildingId);
  if(!building) return false;
  const fp = buildingFootprint(building, rotation);
  const centerCol = (layout.cols - 1) / 2 + offsetCol;
  const centerRow = (layout.rows - 1) / 2 + offsetRow;
  const anchorCol = centerCol - (fp.w - 1) / 2;
  const anchorRow = centerRow - (fp.h - 1) / 2;
  return autoplaceInfrastructureBuilding(state, buildingId, anchorCol, anchorRow, rotation);
}

function drawMetalHarvesterIcon(ctx){
  ctx.save();
  ctx.fillStyle = 'rgba(59,130,246,0.10)';
  ctx.strokeStyle = '#60a5fa';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.rect(-34, -26, 68, 52);
  ctx.fill();
  ctx.stroke();

  ctx.strokeStyle = '#93c5fd';
  ctx.lineWidth = 2.5;
  const gearTeeth = 8;
  for(let i=0;i<gearTeeth;i++){
    const angle = i * (Math.PI * 2 / gearTeeth);
    const x = Math.cos(angle) * 26;
    const y = Math.sin(angle) * 26;
    ctx.beginPath();
    ctx.moveTo(x * 0.6, y * 0.6);
    ctx.lineTo(x, y);
    ctx.stroke();
  }

  ctx.fillStyle = '#0b1224';
  ctx.strokeStyle = '#38bdf8';
  ctx.beginPath();
  ctx.arc(0, 0, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawMetalRefineryIcon(ctx){
  ctx.save();
  ctx.fillStyle = 'rgba(12,74,110,0.12)';
  ctx.strokeStyle = '#38bdf8';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.rect(-30, -30, 60, 60);
  ctx.fill();
  ctx.stroke();

  ctx.strokeStyle = '#67e8f9';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-24, 12);
  ctx.lineTo(24, 12);
  ctx.moveTo(-18, 4);
  ctx.lineTo(18, 4);
  ctx.moveTo(-12, -4);
  ctx.lineTo(12, -4);
  ctx.moveTo(-6, -12);
  ctx.lineTo(6, -12);
  ctx.stroke();

  ctx.fillStyle = '#0f172a';
  ctx.strokeStyle = '#e0f2fe';
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  ctx.moveTo(-18, 18);
  ctx.lineTo(0, -14);
  ctx.lineTo(18, 18);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawGasHarvesterIcon(ctx){
  ctx.save();
  ctx.fillStyle = 'rgba(20,184,166,0.12)';
  ctx.strokeStyle = '#14b8a6';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(0, 0, 36, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();

  ctx.strokeStyle = '#5eead4';
  ctx.lineWidth = 2.5;
  for(let i=0;i<3;i++){
    const angle = (-Math.PI / 2) + i * (Math.PI * 2 / 3);
    const x = Math.cos(angle) * 18;
    const y = Math.sin(angle) * 18;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(x, y);
    ctx.stroke();
  }

  ctx.fillStyle = '#0f172a';
  ctx.strokeStyle = '#22c55e';
  ctx.beginPath();
  ctx.arc(0, 0, 10, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  ctx.restore();
}

function drawGasRefineryIcon(ctx){
  ctx.save();
  ctx.fillStyle = 'rgba(30,64,175,0.12)';
  ctx.strokeStyle = '#38bdf8';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.rect(-32, -28, 64, 56);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = '#0f172a';
  ctx.strokeStyle = '#fbbf24';
  ctx.beginPath();
  ctx.moveTo(-20, 18); ctx.lineTo(0, -18); ctx.lineTo(20, 18); ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.strokeStyle = '#22d3ee';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(-18, 8);
  ctx.lineTo(18, 8);
  ctx.moveTo(-12, 0);
  ctx.lineTo(12, 0);
  ctx.moveTo(-6, -8);
  ctx.lineTo(6, -8);
  ctx.stroke();
  ctx.restore();
}

function drawDockIcon(ctx, size = 72){
  const sprite = [
    '..cc..cc..',
    '.cddccddc.',
    'cddddddddc',
    '.cddddddc.',
    '..cddddc..',
    '..cddddc..',
    '.cddccddc.',
    'cddddddddc',
    '.cddddddc.',
    '..cddcc...',
    '..cc.....'
  ];
  const palette = {
    c:'#a5b4fc',
    d:'#38bdf8'
  };
  const cols = sprite[0].length;
  const rows = sprite.length;
  const cell = size / cols;
  ctx.save();
  ctx.translate(-(cols * cell) / 2, -(rows * cell) / 2);
  for(let y=0; y<rows; y++){
    const row = sprite[y];
    for(let x=0; x<cols; x++){
      const ch = row[x];
      if(palette[ch]){
        ctx.fillStyle = palette[ch];
        ctx.fillRect(x * cell, y * cell, cell - 0.5, cell - 0.5);
      }
    }
  }
  ctx.restore();
}

function drawBuildingPreview(canvas, building){
  if(!canvas || !building) return;
  const ctx = canvas.getContext('2d');
  if(!ctx) return;
  const w = canvas.width;
  const h = canvas.height;
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = 'rgba(6,10,24,0.95)';
  ctx.fillRect(0, 0, w, h);
  ctx.translate(w / 2, h / 2);
  ctx.shadowColor = 'rgba(32,64,128,0.45)';
  ctx.shadowBlur = 12;
  if (window.drawInfrastructureIcon) {
    const size = Math.min(w, h) * 0.6;
    window.drawInfrastructureIcon(ctx, building, { x: 0, y: 0 }, size, 1, null);
  }
  ctx.restore();
}

function infrastructureDragBuildingId(ev){
  let id = null;
  if(ev && ev.dataTransfer){
    id = ev.dataTransfer.getData('text/infrastructure-building') || ev.dataTransfer.getData('text/plain');
  }
  if(!id){
    id = infrastructureBuilder.draggingBuildingId;
  }
  if(!id) return null;
  return INFRA_BUILDING_MAP.has(id) ? id : null;
}

function handleInfrastructureCellDragEnter(ev){
  const id = infrastructureDragBuildingId(ev);
  const cellEl = ev.currentTarget;
  const idx = Number.parseInt(cellEl.dataset.index, 10);
  const state = getActiveInfrastructureState();
  const building = INFRA_BUILDING_MAP.get(id);
  const placement = building ? validateInfrastructurePlacement(state, idx, building, infrastructureBuilder.ghostRotation) : null;
  if(!id || !state || !placement || !placement.footprint) return;
  ev.preventDefault();
  infrastructureBuilder.hoveredCell = idx;
  cellEl.classList.add('drag-over');
}

function handleInfrastructureCellDragOver(ev){
  const id = infrastructureDragBuildingId(ev);
  const cellEl = ev.currentTarget;
  const idx = Number.parseInt(cellEl.dataset.index, 10);
  const state = getActiveInfrastructureState();
  const building = INFRA_BUILDING_MAP.get(id);
  const placement = building ? validateInfrastructurePlacement(state, idx, building, infrastructureBuilder.ghostRotation) : null;
  if(!id || !state || !placement || !placement.footprint) return;
  ev.preventDefault();
  if(ev.dataTransfer){
    ev.dataTransfer.dropEffect = placement.valid ? 'copy' : 'none';
  }
  infrastructureBuilder.hoveredCell = idx;
}

function handleInfrastructureCellDragLeave(ev){
  const cellEl = ev.currentTarget;
  cellEl.classList.remove('drag-over');
  const related = ev.relatedTarget;
  if(!cellEl.contains(related)){ // left the cell entirely
    const idx = Number.parseInt(cellEl.dataset.index, 10);
    if(Number.isInteger(idx) && infrastructureBuilder.hoveredCell === idx){
      infrastructureBuilder.hoveredCell = null;
    }
  }
}

function handleInfrastructureCellDrop(ev){
  ev.preventDefault();
  const cellEl = ev.currentTarget;
  cellEl.classList.remove('drag-over');
  const id = infrastructureDragBuildingId(ev);
  if(!id) return;
  const idx = Number.parseInt(cellEl.dataset.index, 10);
  if(!Number.isInteger(idx)) return;
  const state = getActiveInfrastructureState();
  if(!state) return;
  const building = INFRA_BUILDING_MAP.get(id);
  const placement = building ? validateInfrastructurePlacement(state, idx, building, infrastructureBuilder.ghostRotation) : null;
  if(!placement || !placement.valid) return;
  startInfrastructureBuildAtCell(state, idx, id, infrastructureBuilder.ghostRotation, placement.footprint);
  infrastructureBuilder.hoveredCell = idx;
  renderInfrastructureOverlay();
}

function infrastructureCellFromWorld(worldPos, station, layout){
  if(!worldPos || !station || !layout) return null;
  const localX = worldPos.x - station.x;
  const localY = worldPos.y - station.y;
  const col = Math.floor((localX - layout.originOffset.x) / layout.step);
  const row = Math.floor((localY - layout.originOffset.y) / layout.step);
  if(col < 0 || row < 0 || col >= layout.cols || row >= layout.rows) return null;
  return row * layout.cols + col;
}

function getInfrastructureDragContext(ev){
  if(!stationUI.editorMode || stationUI.tab !== 'infrastructure') return null;
  const station = stationUI.station || infrastructureBuilder.activeStationRef;
  if(!station) return null;
  const state = ensureInfrastructureState(station);
  const layout = state?.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  const world = screenToWorld(ev.clientX ?? mouse.x, ev.clientY ?? mouse.y);
  const idx = infrastructureCellFromWorld(world, station, layout);
  if(idx == null) return null;
  return { station, state, layout, idx };
}

function handleInfrastructureCanvasDragOver(ev){
  if(!stationUI.editorMode || stationUI.tab !== 'infrastructure') return;
  const id = infrastructureDragBuildingId(ev);
  const ctx = getInfrastructureDragContext(ev);
  if(!ctx){
    infrastructureBuilder.hoveredCell = null;
    return;
  }
  if(!id || !ctx.state) return;
  const building = INFRA_BUILDING_MAP.get(id);
  const placement = building ? validateInfrastructurePlacement(ctx.state, ctx.idx, building, infrastructureBuilder.ghostRotation) : null;
  if(placement && placement.footprint){
    ev.preventDefault();
    if(ev.dataTransfer){
      ev.dataTransfer.dropEffect = placement.valid ? 'copy' : 'none';
    }
    infrastructureBuilder.hoveredCell = ctx.idx;
    infrastructureBuilder.needsRender = true;
  }
}

function handleInfrastructureCanvasDrop(ev){
  if(!stationUI.editorMode || stationUI.tab !== 'infrastructure') return;
  const id = infrastructureDragBuildingId(ev);
  if(!id) return;
  const ctx = getInfrastructureDragContext(ev);
  if(!ctx || !ctx.state) return;
  const building = INFRA_BUILDING_MAP.get(id);
  const placement = building ? validateInfrastructurePlacement(ctx.state, ctx.idx, building, infrastructureBuilder.ghostRotation) : null;
  if(!placement || !placement.valid) return;
  ev.preventDefault();
  startInfrastructureBuildAtCell(ctx.state, ctx.idx, id, infrastructureBuilder.ghostRotation, placement.footprint);
  infrastructureBuilder.hoveredCell = ctx.idx;
  renderInfrastructureOverlay();
}

function handleInfrastructureCanvasDragLeave(){
  infrastructureBuilder.hoveredCell = null;
}

function startInfrastructureBuildAtCell(state, idx, buildingId, rotation = 0, footprintOverride = null){
  const building = INFRA_BUILDING_MAP.get(buildingId);
  if(!state || !building) return false;
  const station = state.stationRef || stationUI.station || null;
  const availability = isBuildingAllowedOnStation(building, station);
  if(!availability.allowed) return false;
  const totalCells = infrastructureBuilder.gridCols * infrastructureBuilder.gridRows;
  if(idx < 0 || idx >= totalCells) return false;
  const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  const placement = footprintOverride ? { footprint: footprintOverride, layout } : validateInfrastructurePlacement(state, idx, building, rotation);
  if(!placement || !placement.footprint || placement.blocked || placement.occupied) return false;
  const footprint = placement.footprint;
  const normalizedRotation = Math.abs(rotation) % 2;
  const base = {
    buildingId,
    status:'building',
    elapsed:0,
    duration:Math.max(1, building.buildTime),
    progress:0,
    startedAt:performance.now()/1000,
    cellIndex: idx,
    rootIndex: idx,
    rotation: normalizedRotation,
    footprint: { w: footprint.width, h: footprint.height },
    cells: footprint.cells.map(meta => meta.index),
    gridX: layout.cells[idx]?.col ?? 0,
    gridY: layout.cells[idx]?.row ?? 0,
    localPos: { x: footprint.center.x, y: footprint.center.y },
    emitted: false
  };
  for(const meta of footprint.cells){
    state.cells[meta.index] = base;
  }
  infrastructureBuilder.selectedCell = idx;
  infrastructureBuilder.needsRender = true;
  return true;
}

function infrastructureLocalToWorld(station, local){
  if(!station || !local) return { x: station?.x ?? 0, y: station?.y ?? 0 };
  return { x: station.x + local.x, y: station.y + local.y };
}

function emitInfrastructureCompletion(state, idx, cell){
  if(!state || !cell || cell.emitted) return;
  const station = state.stationRef || findStationByKey(state.stationKey);
  if(!station) return;
  const rootIdx = getRootCellIndex(state, idx);
  const meta = state.cellMeta?.[rootIdx ?? idx];
  const local = cell.localPos || meta?.local;
  if(!local) return;
  cell.localPos = { x: local.x, y: local.y };
  const worldPos = infrastructureLocalToWorld(station, cell.localPos);
  if(!Game.infrastructure) Game.infrastructure = new Map();
  let list = Game.infrastructure.get(state.stationKey);
  if(!list){
    list = [];
    Game.infrastructure.set(state.stationKey, list);
  }
  let existing = list.find(inst => inst.cellIndex === idx);
  if(!existing){
    existing = { cellIndex: idx };
    list.push(existing);
  }
  existing.buildingId = cell.buildingId;
  existing.stationKey = state.stationKey;
  existing.localPos = { x: cell.localPos.x, y: cell.localPos.y };
  existing.worldPos = worldPos;
  existing.stationRef = station;
  existing.footprint = cell.footprint;
  existing.rotation = cell.rotation;
  existing.status = 'completed';
  cell.emitted = true;
}

function drawInfrastructureGrid(ctx, cam, station, state){
  if(!ctx || !cam || !station || !state) return;
  const alpha = infrastructureBuilder.editorAlpha;
  if(alpha <= 0.001) return;
  const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  const cellSizeWorld = layout?.cellSize ?? INFRA_CELL_WORLD_SIZE;
  const cellSize = cellSizeWorld * cam.zoom;
  const half = cellSize / 2;
  ctx.save();
  ctx.globalAlpha = alpha * 0.85;
  const processedRoots = new Set();
  for(let i=0;i<layout.cells.length;i++){
    const meta = layout.cells[i];
    const worldCenter = infrastructureLocalToWorld(station, meta.local);
    const screen = worldToScreen(worldCenter.x, worldCenter.y, cam);
    const rootIdx = getRootCellIndex(state, i);
    const rootCell = rootIdx != null ? state.cells[rootIdx] : null;
    const building = rootCell ? INFRA_BUILDING_MAP.get(rootCell.buildingId) : null;
    const blocked = !!meta.blocked;
    const done = rootCell?.status === 'completed';
    const progress = clamp(rootCell?.progress ?? 0, 0, 1);
    const belongsToBuilding = rootCell && rootCell.cells?.includes(meta.index);

    if(blocked){
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,110,90,0.65)';
      ctx.setLineDash([8 * cam.zoom, 6 * cam.zoom]);
      ctx.lineDashOffset = performance.now() * 0.04;
      ctx.strokeRect(screen.x - half, screen.y - half, cellSize, cellSize);
      ctx.setLineDash([]);
      continue;
    }

    if(belongsToBuilding){
      ctx.fillStyle = done ? 'rgba(56,180,135,0.26)' : 'rgba(90,140,220,0.28)';
      ctx.fillRect(screen.x - half, screen.y - half, cellSize, cellSize);
      ctx.lineWidth = Math.max(1, 1.3 * cam.zoom);
      ctx.strokeStyle = done ? 'rgba(82,205,150,0.8)' : 'rgba(108,170,255,0.75)';
      ctx.strokeRect(screen.x - half, screen.y - half, cellSize, cellSize);
    } else {
      ctx.fillStyle = 'rgba(60,100,180,0.18)';
      ctx.fillRect(screen.x - half, screen.y - half, cellSize, cellSize);
      ctx.lineWidth = Math.max(1, 1.3 * cam.zoom);
      ctx.strokeStyle = 'rgba(130,170,255,0.35)';
      ctx.strokeRect(screen.x - half, screen.y - half, cellSize, cellSize);
    }

    if(rootCell && building && !processedRoots.has(rootIdx)){
      processedRoots.add(rootIdx);
      const centerWorld = infrastructureLocalToWorld(station, rootCell.localPos || meta.local);
      const centerScreen = worldToScreen(centerWorld.x, centerWorld.y, cam);
      const footprintScale = Math.max(rootCell.footprint?.w || 1, rootCell.footprint?.h || 1);
      const iconSize = cellSize * 0.72 * footprintScale;
      ctx.globalAlpha = done ? alpha * 0.92 : alpha * 0.85;
      if (window.drawInfrastructureIcon) {
        window.drawInfrastructureIcon(ctx, building, centerScreen, iconSize, alpha, null);
      }
      if(!done){
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(96,165,250,0.85)';
        ctx.lineWidth = Math.max(1.4, cam.zoom * 2.2);
        ctx.arc(centerScreen.x, centerScreen.y, (cellSize * 0.38) * footprintScale, -Math.PI/2, -Math.PI/2 + Math.PI * 2 * progress);
        ctx.stroke();
      }
    }
  }

  const hovered = infrastructureBuilder.hoveredCell;
  const ghostId = infrastructureBuilder.draggingBuildingId;
  if(ghostId && hovered != null){
    const building = INFRA_BUILDING_MAP.get(ghostId);
    const placement = building ? validateInfrastructurePlacement(state, hovered, building, infrastructureBuilder.ghostRotation) : null;
    if(placement && placement.footprint){
      const ghostAlpha = infrastructureBuilder.ghostAlpha * alpha;
      if(ghostAlpha > 0.02){
        const blocked = placement.blocked || placement.occupied;
        ctx.globalAlpha = ghostAlpha * 0.9;
        ctx.fillStyle = blocked ? 'rgba(220,70,70,0.35)' : 'rgba(80,150,255,0.3)';
        for(const meta of placement.footprint.cells){
          const worldCenter = infrastructureLocalToWorld(station, meta.local);
          const screen = worldToScreen(worldCenter.x, worldCenter.y, cam);
          ctx.fillRect(screen.x - half, screen.y - half, cellSize, cellSize);
        }
        if(!blocked){
          const centerWorld = infrastructureLocalToWorld(station, placement.footprint.center);
          const centerScreen = worldToScreen(centerWorld.x, centerWorld.y, cam);
          const footprintScale = Math.max(placement.footprint.width, placement.footprint.height);
          if (window.drawInfrastructureIcon) {
            window.drawInfrastructureIcon(ctx, building, centerScreen, cellSize * 0.72 * footprintScale, ghostAlpha, null);
          }
        }
        ctx.globalAlpha = alpha * 0.85;
      }
    }
  }
  ctx.restore();
}

function drawInfrastructureInstances(ctx, cam){
  if(!ctx || !cam || !Game.infrastructure) return;
  const activeKey = (stationUI.editorMode && stationUI.station) ? getInfrastructureStationKey(stationUI.station) : null;
  ctx.save();
  Game.infrastructure.forEach((list, key) => {
    if(activeKey && key === activeKey) return;
    for(const inst of list){
      if(!inst || !inst.worldPos || !inst.buildingId) continue;
      const building = INFRA_BUILDING_MAP.get(inst.buildingId);
      if(!building) continue;
      const screen = worldToScreen(inst.worldPos.x, inst.worldPos.y, cam);
      const footprintScale = inst.footprint ? Math.max(inst.footprint.w || 1, inst.footprint.h || 1) : 1;
      const size = INFRA_CELL_WORLD_SIZE * cam.zoom * 0.6 * footprintScale;
      ctx.globalAlpha = 0.9;
      if (window.drawInfrastructureIcon) {
        window.drawInfrastructureIcon(ctx, building, screen, size, 0.95, inst);
      }
    }
  });
  ctx.restore();
}

function initInfrastructureUI(){
  const overlay = infrastructureBuilder.overlay;
  if(!overlay) return;
  const tabBtn = overlay.querySelector('li[data-tab="infrastructure"]');
  if(tabBtn){
    tabBtn.addEventListener('click', ()=>{
      stationUI.open = true;
      stationUI.tab = 'infrastructure';
      setInfrastructureUIVisible(true);
    });
  }

  const list = infrastructureBuilder.list;
  if(list){
    list.innerHTML = '';
    for(const building of INFRASTRUCTURE_BUILDINGS){
      const item = document.createElement('div');
      item.className = 'infra-building';
      item.draggable = true;
      item.dataset.building = building.id;
      const canvas = document.createElement('canvas');
      canvas.width = 96;
      canvas.height = 96;
      canvas.className = 'infra-building-canvas';
      item.appendChild(canvas);
      const name = document.createElement('div');
      name.className = 'infra-building-name';
      name.textContent = building.name;
      item.appendChild(name);
      const meta = document.createElement('div');
      meta.className = 'infra-building-meta';
      const fp = buildingFootprint(building);
      meta.textContent = `Czas budowy: ${building.buildTime}s • Rozmiar: ${fp.w}×${fp.h}`;
      item.appendChild(meta);
      item.addEventListener('dragstart', (ev)=>{
        item.classList.add('dragging');
        infrastructureBuilder.draggingBuildingId = building.id;
        infrastructureBuilder.ghostRotation = 0;
        if(ev.dataTransfer){
          ev.dataTransfer.effectAllowed = 'copy';
          ev.dataTransfer.setData('text/plain', building.id);
          ev.dataTransfer.setData('text/infrastructure-building', building.id);
        }
      });
      item.addEventListener('dragend', ()=>{
        item.classList.remove('dragging');
        infrastructureBuilder.draggingBuildingId = null;
        infrastructureBuilder.ghostRotation = 0;
        infrastructureBuilder.hoveredCell = null;
      });
      list.appendChild(item);
      drawBuildingPreview(canvas, building);
    }
  }

  const grid = infrastructureBuilder.grid;
  if(grid){
    const layout = updateInfrastructureGridForStation(stationUI.station || null);
    rebuildInfrastructureGrid(layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows));
  }

  setInfrastructureUIVisible(false);
  renderInfrastructureOverlay();
}

function setInfrastructureUIVisible(visible){
  const overlay = infrastructureBuilder.overlay;
  if(!overlay) return;
  if(visible){
    if(infrastructureBuilder.isVisible){
      if(stationUI.station){
        setInfrastructureActiveStation(stationUI.station);
      }
      if(infrastructureBuilder.needsRender){
        renderInfrastructureOverlay();
      }
      return;
    }
    if(infrastructureBuilder.hideTimer){
      clearTimeout(infrastructureBuilder.hideTimer);
      infrastructureBuilder.hideTimer = null;
    }
    overlay.classList.remove('hidden');
    overlay.classList.remove('infra-hiding');
    void overlay.offsetWidth;
    overlay.classList.add('infra-visible');
    applyInfrastructureOverlayPosition();
    infrastructureBuilder.isVisible = true;
    if(stationUI.station){
      setInfrastructureActiveStation(stationUI.station);
    }
    renderInfrastructureOverlay();
  } else {
    if(!infrastructureBuilder.isVisible){
      overlay.classList.add('hidden');
      return;
    }
    overlay.classList.remove('infra-visible');
    overlay.classList.add('infra-hiding');
    infrastructureBuilder.isVisible = false;
    if(infrastructureBuilder.hideTimer){
      clearTimeout(infrastructureBuilder.hideTimer);
    }
    infrastructureBuilder.hideTimer = setTimeout(()=>{
      overlay.classList.add('hidden');
      overlay.classList.remove('infra-hiding');
    }, 220);
    infrastructureBuilder.hoveredCell = null;
    infrastructureBuilder.draggingOverlay = false;
    overlay.classList.remove('dragging');
  }
}

function renderInfrastructureInfo(state, uniqueRoots = new Set(), completedRoots = new Set()){
  const info = infrastructureBuilder.info;
  if(!info) return;
  info.innerHTML = '';
  const station = infrastructureBuilder.activeStationRef || stationUI.station;
  const title = document.createElement('h4');
  title.textContent = station?.name ? `Infrastruktura: ${station.name}` : 'Budowa stacji';
  info.appendChild(title);

  if(!state){
    const p = document.createElement('p');
    p.textContent = 'Brak aktywnej stacji. Wybierz stację, aby rozpocząć budowę.';
    info.appendChild(p);
    return;
  }

  const totalUsed = uniqueRoots.size || state.cells.filter(Boolean).length;
  const completed = completedRoots.size || state.cells.filter(cell => cell && cell.status === 'completed').length;

  if(infrastructureBuilder.selectedCell == null){
    const p = document.createElement('p');
    p.textContent = 'Przeciągnij budynek z listy na siatkę wokół stacji, aby rozpocząć budowę.';
    info.appendChild(p);
    const summary = document.createElement('p');
    summary.textContent = `Ukończone budynki: ${completed}/${totalUsed}.`;
    summary.style.fontSize = '12px';
    summary.style.color = '#94a9d6';
    info.appendChild(summary);
    return;
  }

  const idx = getRootCellIndex(state, infrastructureBuilder.selectedCell ?? 0);
  const meta = state.cellMeta?.[idx ?? 0];
  if(!meta){
    const p = document.createElement('p');
    p.textContent = 'Nie można odczytać danych pola. Odśwież interfejs.';
    info.appendChild(p);
    return;
  }
  const cell = getRootCell(state, idx);
  const local = cell?.localPos || meta.local;
  if(cell && !cell.localPos && local){
    cell.localPos = { x: local.x, y: local.y };
  }
  if(meta.blocked && !cell){
    const p = document.createElement('p');
    p.textContent = 'Rdzeń stacji — strefa serwisowa niedostępna dla infrastruktury.';
    info.appendChild(p);
    const coords = document.createElement('p');
    coords.textContent = `Położenie rdzenia: Δx ${Math.round(local?.x ?? 0)}, Δy ${Math.round(local?.y ?? 0)}.`;
    coords.style.fontSize = '12px';
    coords.style.color = '#94a9d6';
    info.appendChild(coords);
    return;
  }
  if(!cell){
    const p = document.createElement('p');
    p.textContent = 'Puste pole. Upuść budynek z listy po lewej, aby rozpocząć konstrukcję.';
    info.appendChild(p);
    if(local){
      const coords = document.createElement('p');
      coords.textContent = `Położenie względem centrum: Δx ${Math.round(local.x)}, Δy ${Math.round(local.y)}.`;
      coords.style.fontSize = '12px';
      coords.style.color = '#94a9d6';
      info.appendChild(coords);
    }
    return;
  }

  const building = INFRA_BUILDING_MAP.get(cell.buildingId);
  const name = document.createElement('p');
  name.textContent = building?.name || 'Budowa';
  name.style.fontWeight = '600';
  info.appendChild(name);

  const status = document.createElement('p');
  const progress = cell.status === 'completed' ? 1 : clamp(cell.progress ?? 0, 0, 1);
  if(cell.status === 'completed'){
    status.textContent = 'Status: Zakończono budowę.';
  } else {
    const remaining = Math.max(0, (cell.duration ?? 0) - (cell.elapsed ?? 0));
    status.textContent = `Status: W budowie — ${Math.round(progress*100)}% (pozostało ${remaining.toFixed(1)}s).`;
  }
  info.appendChild(status);

  const buildTime = document.createElement('p');
  buildTime.textContent = `Czas budowy: ${building?.buildTime ?? '?'} s`;
  buildTime.style.fontSize = '13px';
  buildTime.style.color = '#a8b4d9';
  info.appendChild(buildTime);

  if(cell.footprint){
    const fp = cell.footprint;
    const footprint = document.createElement('p');
    footprint.textContent = `Zajętość siatki: ${fp.w}×${fp.h}`;
    footprint.style.fontSize = '12px';
    footprint.style.color = '#94a9d6';
    info.appendChild(footprint);
  }

  if(local){
    const coords = document.createElement('p');
    coords.textContent = `Położenie względem stacji: Δx ${Math.round(local.x)}, Δy ${Math.round(local.y)}.`;
    coords.style.fontSize = '12px';
    coords.style.color = '#94a9d6';
    info.appendChild(coords);
  }

  const progressWrap = document.createElement('div');
  progressWrap.className = 'infra-info-progress';
  const strong = document.createElement('strong');
  strong.textContent = 'Postęp';
  progressWrap.appendChild(strong);
  const bar = document.createElement('div');
  bar.className = 'infra-progress-bar';
  const fill = document.createElement('div');
  fill.className = 'infra-progress-fill';
  fill.style.width = `${Math.round(progress * 100)}%`;
  bar.appendChild(fill);
  progressWrap.appendChild(bar);
  info.appendChild(progressWrap);
}

function renderInfrastructureOverlay(){
  const station = infrastructureBuilder.activeStationRef || stationUI.station;
  const state = station ? ensureInfrastructureState(station) : null;
  if(station && !infrastructureBuilder.activeStationRef){
    infrastructureBuilder.activeStationRef = station;
  }
  const uniqueRoots = new Set();
  const completedRoots = new Set();
  if(state){
    state.cells.forEach((cell, idx)=>{
      if(!cell) return;
      const rootIdx = getRootCellIndex(state, idx) ?? idx;
      uniqueRoots.add(rootIdx);
      if(cell.status === 'completed') completedRoots.add(rootIdx);
    });
  }
  infrastructureBuilder.needsRender = false;
  renderInfrastructureInfo(state || null, uniqueRoots, completedRoots);
}

function renderInfrastructureTab(){
  uiTitle('Infrastruktura stacji');
  const station = stationUI.station;
  if(!station){
    uiText('Brak aktywnej stacji.');
    return;
  }
  const state = ensureInfrastructureState(station);
  const totalUsed = state.cells.filter(Boolean).length;
  const completed = state.cells.filter(cell => cell && cell.status === 'completed').length;
  uiText('Zarządzaj infrastrukturą w panelu Infrastructure obok.');
  uiText(`Budowy ukończone: ${completed}/${totalUsed}.`);
  uiText('Przeciągnij budynek na siatkę, aby rozpocząć konstrukcję lub kliknij pole, by zobaczyć postęp.');
}

function updateInfrastructureEditorState(dt){
  const target = stationUI.editorMode ? 1 : 0;
  if(target > infrastructureBuilder.editorAlpha){
    infrastructureBuilder.editorAlpha = Math.min(target, infrastructureBuilder.editorAlpha + dt * 4.2);
  } else if(target < infrastructureBuilder.editorAlpha){
    infrastructureBuilder.editorAlpha = Math.max(target, infrastructureBuilder.editorAlpha - dt * 5.6);
    if(infrastructureBuilder.editorAlpha <= 0.001){
      infrastructureBuilder.editorAlpha = 0;
      infrastructureBuilder.hoveredCell = null;
    }
  }

  const ghostTarget = infrastructureBuilder.draggingBuildingId ? 1 : 0;
  if(ghostTarget > infrastructureBuilder.ghostAlpha){
    infrastructureBuilder.ghostAlpha = Math.min(ghostTarget, infrastructureBuilder.ghostAlpha + dt * 10);
  } else if(ghostTarget < infrastructureBuilder.ghostAlpha){
    infrastructureBuilder.ghostAlpha = Math.max(ghostTarget, infrastructureBuilder.ghostAlpha - dt * 8);
  }
}

function updateInfrastructureState(dt){
  let changed = false;
  infrastructureBuilder.stationStates.forEach(state => {
    if(!state || !state.cells) return;
    const processed = new Set();
    const buildingCounts = {};
    state.cells.forEach((cell, idx) => {
      if(!cell) return;
      const rootIdx = getRootCellIndex(state, idx);
      if(rootIdx == null || processed.has(rootIdx)) return;
      processed.add(rootIdx);
      if(cell.status === 'building'){
        const prev = cell.progress || 0;
        cell.elapsed = (cell.elapsed || 0) + dt;
        const duration = Math.max(0.1, cell.duration || 1);
        cell.progress = clamp(cell.elapsed / duration, 0, 1);
        if(cell.progress !== prev) changed = true;
        if(cell.progress >= 1 && cell.status !== 'completed'){
          cell.status = 'completed';
          changed = true;
        }
      }
      if(cell.status === 'completed'){
        buildingCounts[cell.buildingId] = (buildingCounts[cell.buildingId] || 0) + 1;
      }
      if(cell.status === 'completed' && !cell.emitted){
        emitInfrastructureCompletion(state, rootIdx, cell);
        changed = true;
      }
    });
    updateStationEconomyFromBuildings(state, buildingCounts, dt);
  });
  if(changed){
    if(infrastructureBuilder.isVisible){
      renderInfrastructureOverlay();
    } else {
      infrastructureBuilder.needsRender = true;
    }
  } else if(infrastructureBuilder.isVisible && infrastructureBuilder.needsRender){
    renderInfrastructureOverlay();
  }
}

function syncInfrastructureWorldPositions(){
  if(!Game.infrastructure) return;
  Game.infrastructure.forEach((list, key) => {
    const station = findStationByKey(key);
    if(!station) return;
    for(const inst of list){
      if(!inst || !inst.localPos) continue;
      inst.stationRef = station;
      inst.worldPos = infrastructureLocalToWorld(station, inst.localPos);
    }
  });
}

function populateStationInfrastructureDefaults(station, preset){
  if(!station || !preset) return false;
  const state = ensureInfrastructureState(station);
  if(!state || infrastructureHasBuildings(state)) return false;
  const stationKey = getInfrastructureStationKey(station);
  const existingList = stationKey && Game.infrastructure ? Game.infrastructure.get(stationKey) : null;
  if(existingList && existingList.length) return false;
  const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  if(!layout) return false;

  const bandBase = Math.floor(Math.min(layout.cols, layout.rows) / 4);
  const midBand = Math.max(bandBase, INFRA_STATION_CORE_SIZE + 3);
  const farBand = Math.max(Math.floor(Math.min(layout.cols, layout.rows) / 3), midBand + 2);

  const plans = {
    mercury: [
      { id:'metal_harvester', offset:{ col: -midBand, row: 0 }, rotation:0 },
      { id:'metal_harvester', offset:{ col: midBand, row: 0 }, rotation:0 },
      { id:'metal_refinery', offset:{ col: 0, row: -midBand }, rotation:0 },
      { id:'metal_refinery', offset:{ col: 0, row: midBand }, rotation:0 },
      { id:'solar_array', offset:{ col: -midBand + 1, row: midBand - 1 }, rotation:0 },
      { id:'solar_array', offset:{ col: midBand - 1, row: midBand - 1 }, rotation:0 },
    ],
    earth: [
      { id:'shipyard_capital', offset:{ col: midBand + 2, row: 0 }, rotation:0 },
      { id:'shipyard_l', offset:{ col: -(midBand + 2), row: 0 }, rotation:0 },
      { id:'shipyard_m', offset:{ col: 0, row: -midBand }, rotation:0 },
      { id:'shipyard_s', offset:{ col: -2, row: midBand - 1 }, rotation:0 },
      { id:'shipyard_s', offset:{ col: 2, row: midBand - 1 }, rotation:0 },
      { id:'solar_array', offset:{ col: -midBand + 1, row: -(midBand + 1) }, rotation:0 },
      { id:'solar_array', offset:{ col: midBand - 1, row: -(midBand + 1) }, rotation:0 },
      { id:'solar_array', offset:{ col: 0, row: midBand }, rotation:0 },
      { id:'storage_metal', offset:{ col: -farBand, row: -farBand }, rotation:0 },
      { id:'storage_metal', offset:{ col: -farBand, row: farBand }, rotation:0 },
      { id:'storage_fuel', offset:{ col: farBand, row: -farBand }, rotation:0 },
      { id:'storage_fuel', offset:{ col: farBand, row: farBand }, rotation:0 },
      { id:'storage_gas', offset:{ col: -(farBand + 2), row: 0 }, rotation:0 },
      { id:'storage_gas', offset:{ col: farBand + 2, row: 0 }, rotation:0 },
      { id:'storage_plastics', offset:{ col: 0, row: -(farBand + 2) }, rotation:0 },
      { id:'storage_plastics', offset:{ col: 0, row: farBand + 2 }, rotation:0 },
    ],
    mars: [
      { id:'shipyard_l', offset:{ col: midBand, row: 0 }, rotation:0 },
      { id:'solar_array', offset:{ col: -midBand + 1, row: -(midBand + 1) }, rotation:0 },
      { id:'solar_array', offset:{ col: midBand - 1, row: midBand - 1 }, rotation:0 },
      { id:'metal_harvester', offset:{ col: -farBand, row: -farBand }, rotation:0 },
      { id:'metal_refinery', offset:{ col: farBand, row: farBand }, rotation:0 },
      { id:'storage_metal', offset:{ col: -farBand, row: 0 }, rotation:0 },
      { id:'storage_fuel', offset:{ col: 0, row: -farBand }, rotation:0 },
      { id:'storage_gas', offset:{ col: farBand, row: 0 }, rotation:0 },
      { id:'storage_plastics', offset:{ col: 0, row: farBand }, rotation:0 },
    ],
    jupiter: [
      { id:'gas_harvester', offset:{ col: -farBand, row: -farBand }, rotation:0 },
      { id:'gas_harvester', offset:{ col: farBand, row: -farBand }, rotation:0 },
      { id:'gas_harvester', offset:{ col: -farBand, row: farBand }, rotation:0 },
      { id:'gas_harvester', offset:{ col: farBand, row: farBand }, rotation:0 },
      { id:'gas_refinery', offset:{ col: midBand, row: 0 }, rotation:0 },
      { id:'gas_refinery', offset:{ col: -midBand, row: 0 }, rotation:0 },
      { id:'storage_fuel', offset:{ col: 0, row: -(midBand + 2) }, rotation:0 },
    ]
  };

  const plan = plans[preset];
  if(!Array.isArray(plan)) return false;

  let placedAny = false;
  for(const step of plan){
    const success = autoplaceBuildingByOffset(state, step.id, step.offset.col, step.offset.row, step.rotation || 0);
    placedAny = placedAny || success;
  }
  return placedAny;
}

function autopopulateDefaultInfrastructure(){
  if(!Array.isArray(stations) || !stations.length) return;
  let changed = false;
  for(const st of stations){
    if(!st || !st.id) continue;
    const key = st.id.toLowerCase();
    if(key === 'mercury') changed = populateStationInfrastructureDefaults(st, 'mercury') || changed;
    if(key === 'earth') changed = populateStationInfrastructureDefaults(st, 'earth') || changed;
    if(key === 'mars') changed = populateStationInfrastructureDefaults(st, 'mars') || changed;
    if(key === 'jupiter') changed = populateStationInfrastructureDefaults(st, 'jupiter') || changed;
  }
  if(changed){
    updateInfrastructureState(0.001);
    syncInfrastructureWorldPositions();
  }
}

function renderMechanicTab(){
  uiTitle('Mechanic');
  uiText('Zarządzaj hardpointami i uzbrojeniem w panelu obok.');
}

function initMechanicUI(){
  // Ta funkcja jest teraz uproszczona, ponieważ logika została przeniesiona 
  // bezpośrednio do buildMechanicPanel w głównym oknie stacji.
  // Zachowujemy ją tylko dla kompatybilności, jeśli coś ją wywołuje.
}

const HP_GROUP_META = {
  [HP.MAIN]:    { title:'Broń główna', css:'hp-main' },
  [HP.MISSILE]: { title:'Rakiety', css:'hp-miss' },
  [HP.AUX]:     { title:'Broń dodatkowa', css:'hp-aux' },
  [HP.HANGAR]:  { title:'Hangary', css:'hp-hangar' },
  [HP.SPECIAL]: { title:'Broń specjalna', css:'hp-spec' },
};
let mechanicWeaponFilter = 'all';
let mechanicHardpointFilter = 'all';
let mechanicDragWeaponId = null;

function mechanicIconForWeapon(weapon, hpType){
  const iconPath = weapon ? WEAPON_ICON_PATHS[weapon.id] : null;
  const hasIcon = !!iconPath;
  if(hasIcon){
    const wrap = document.createElement('span');
    wrap.className = 'weapon-icon-wrap';
    const img = document.createElement('img');
    img.src = iconPath;
    img.loading = 'lazy';
    img.alt = weapon?.name || 'Broń';
    wrap.appendChild(img);
    return wrap;
  }
  const placeholder = document.createElement('span');
  placeholder.className = 'weapon-icon-placeholder';
  placeholder.dataset.type = hpType;
  placeholder.textContent = weapon ? 'NO ART' : 'EMPTY';
  return placeholder;
}

function weaponMetaText(weapon){
  if(!weapon) return '';
  const parts = [];
  if(weapon.dps != null) parts.push(`${weapon.dps} dps`);
  if(weapon.damage != null) parts.push(`${weapon.damage} dmg`);
  if(weapon.cooldown != null) parts.push(`${weapon.cooldown}s cd`);
  if(weapon.ammo != null) parts.push(`${weapon.ammo} ammo`);
  if(weapon.energy != null) parts.push(`${weapon.energy}e`);
  return parts.join(' • ');
}

function applyWeaponToHardpoint(hp, weaponId){
  if(!hp) return;
  const weapon = weaponId ? WEAPONS[weaponId] : null;
  setHardpointMount(hp, weaponId);
  if(weapon && weapon.ammo != null){
    hp.ammo = weapon.ammo;
    hp.maxAmmo = weapon.ammo;
  }
  syncWeaponSystems();
  renderMechanic();
  saveLoadout();
}

function attachSlotDnD(slot, hp){
  slot.addEventListener('dragover', (e)=>{
    const weaponId = mechanicDragWeaponId || e.dataTransfer?.getData('text/plain');
    const weapon = weaponId ? WEAPONS[weaponId] : null;
    if(!weapon || weapon.type !== hp.type) return;
    e.preventDefault();
    slot.classList.add('drag-over');
  });
  slot.addEventListener('dragleave', ()=>{ slot.classList.remove('drag-over'); });
  slot.addEventListener('drop', (e)=>{
    const weaponId = e.dataTransfer?.getData('text/plain') || mechanicDragWeaponId;
    const weapon = weaponId ? WEAPONS[weaponId] : null;
    slot.classList.remove('drag-over');
    if(!weapon || weapon.type !== hp.type) return;
    e.preventDefault();
    applyWeaponToHardpoint(hp, weapon.id);
  });
}

function quickMountWeapon(weapon){
  if(!weapon) return;
  const targetHp = Game.player.hardpoints.find(h=>h.type === weapon.type);
  if(targetHp){
    applyWeaponToHardpoint(targetHp, weapon.id);
  }
}

function createWeaponRow(weapon) {
  const row = document.createElement('div');
  row.className = 'weapon-row'; // Nowa klasa CSS
  row.draggable = true;
  row.dataset.weaponId = weapon.id;
  row.dataset.weaponType = weapon.type;

  // 1. Mała ikona
  const iconWrap = document.createElement('div');
  const iconPath = WEAPON_ICON_PATHS[weapon.id];
  if (iconPath) {
    iconWrap.className = 'weapon-row-icon';
    const img = document.createElement('img');
    img.src = iconPath;
    iconWrap.appendChild(img);
  } else {
    iconWrap.className = 'weapon-row-icon placeholder';
    iconWrap.textContent = 'IMG';
  }
  row.appendChild(iconWrap);

  // 2. Nazwa
  const nameEl = document.createElement('div');
  nameEl.className = 'weapon-row-name';
  nameEl.textContent = weapon.name;
  row.appendChild(nameEl);

  // 3. Statystyki (Dmg/Cd) - skrócone w jednej linii
  const metaEl = document.createElement('div');
  metaEl.className = 'weapon-row-meta';
  let stats = '';
  if (weapon.damage) stats = `${weapon.damage}dmg`;
  else if (weapon.dps) stats = `${weapon.dps}dps`;
  if (weapon.cooldown) stats += ` / ${weapon.cooldown}s`;
  if (weapon.ammo) stats += ` [${weapon.ammo}]`;
  metaEl.textContent = stats;
  row.appendChild(metaEl);

  // Obsługa przeciągania (Drag & Drop)
  row.addEventListener('dragstart', (e) => {
    mechanicDragWeaponId = weapon.id;
    row.classList.add('dragging');
    if (e.dataTransfer) {
      e.dataTransfer.setData('text/plain', weapon.id);
      e.dataTransfer.effectAllowed = 'copy';
    }
  });
  row.addEventListener('dragend', () => {
    mechanicDragWeaponId = null;
    row.classList.remove('dragging');
  });
  row.addEventListener('dblclick', () => quickMountWeapon(weapon));

  return row;
}

function setMechanicFilterActive(containerId, value){
  const container = document.getElementById(containerId);
  if(!container) return;
  container.querySelectorAll('button[data-filter]').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.filter === value);
  });
}

function initMechanicFilter(containerId, getValue, setValue){
  const container = document.getElementById(containerId);
  if(!container) return;
  container.querySelectorAll('button[data-filter]').forEach(btn => {
    btn.addEventListener('click', () => {
      const val = btn.dataset.filter;
      if(!val) return;
      setValue(val);
      renderMechanic();
    });
  });
  setMechanicFilterActive(containerId, getValue());
}

function renderAvailableWeapons(root) {
  if (!root) return;
  root.innerHTML = '';
  const inventory = Game.player?.inventory || new Set();
  const filter = mechanicWeaponFilter;
  const weapons = [...inventory]
    .map(id => WEAPONS[id])
    .filter(Boolean)
    .filter(w => filter === 'all' || w.type === filter);
  
  // Sortowanie i grupowanie
  const grouped = {};
  for (const t of Object.values(HP)) grouped[t] = [];
  for (const w of weapons) grouped[w.type].push(w);

  for (const type of Object.values(HP)) {
    if (!grouped[type].length) continue;

    // Nagłówek grupy (np. "MAIN") - teraz jako prosty tekst
    const header = document.createElement('div');
    header.className = 'list-group-header';
    const meta = HP_GROUP_META[type];
    header.textContent = meta ? meta.title : type;
    root.appendChild(header);

    // Sortowanie alfabetyczne (z ochroną przed brakującymi nazwami)
    grouped[type].sort((a, b) => (a?.name || '').localeCompare(b?.name || ''));
    
    // Generowanie wierszy
    for (const weapon of grouped[type]) {
      root.appendChild(createWeaponRow(weapon));
    }
  }
  
  if (weapons.length === 0) {
    const empty = document.createElement('div');
    empty.style.padding = '10px';
    empty.style.color = '#777';
    empty.textContent = filter === 'all' ? 'Pusty magazyn.' : 'Brak broni w wybranej kategorii.';
    root.appendChild(empty);
  }
}

function createHpRow(hp, idx) {
  const row = document.createElement('div');
  row.className = 'hp-row'; // Nowa klasa CSS
  row.dataset.hpId = hp.id;
  row.dataset.hpType = hp.type;

  // 1. Ikona zamontowanej broni (lub puste miejsce)
  const weapon = hp.mount ? WEAPONS[hp.mount] : null;
  const iconWrap = document.createElement('div');
  const iconPath = weapon ? WEAPON_ICON_PATHS[weapon.id] : null;
  
  if (iconPath) {
    iconWrap.className = 'weapon-row-icon';
    iconWrap.innerHTML = `<img src="${iconPath}">`;
  } else {
    // Pusty kwadracik lub znak zapytania
    iconWrap.className = 'weapon-row-icon placeholder';
    iconWrap.textContent = weapon ? '?' : '-';
  }
  row.appendChild(iconWrap);

  // 2. Typ slotu (np. MAIN #1) - mała etykieta
  const label = document.createElement('div');
  label.className = 'hp-row-label';
  label.textContent = `${hp.type.toUpperCase()} #${idx + 1}`;
  row.appendChild(label);

  // 3. Nazwa zamontowanej broni lub "Puste"
  const mountInfo = document.createElement('div');
  mountInfo.className = 'hp-row-mount';
  if (weapon) {
    mountInfo.textContent = weapon.name;
    mountInfo.classList.remove('empty');
  } else {
    mountInfo.textContent = 'Puste';
    mountInfo.classList.add('empty');
  }
  row.appendChild(mountInfo);

  // 4. Przycisk "X" do odczepiania
  const clearBtn = document.createElement('button');
  clearBtn.className = 'hp-row-clear';
  clearBtn.textContent = '×';
  clearBtn.title = "Odczep broń";
  clearBtn.disabled = !hp.mount;
  clearBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    applyWeaponToHardpoint(hp, null);
  });
  row.appendChild(clearBtn);

  // Podpięcie upuszczania (Drop)
  attachSlotDnD(row, hp); // Ta funkcja pomocnicza zostaje bez zmian w kodzie
  return row;
}

function renderInstalledHardpoints(root) {
  if (!root) return;
  root.innerHTML = '';

  const filter = mechanicHardpointFilter;
  const source = filter === 'all'
    ? Game.player.hardpoints
    : Game.player.hardpoints.filter(hp => hp.type === filter);

  const listByType = {};
  for (const t of Object.values(HP)) listByType[t] = [];
  for (const hp of source) listByType[hp.type].push(hp);

  for (const type of Object.values(HP)) {
    const slots = listByType[type];
    if (!slots || slots.length === 0) continue;

    // Nagłówek grupy (np. "MAIN (4)")
    const meta = HP_GROUP_META[type];
    const header = document.createElement('div');
    header.className = 'list-group-header';
    header.textContent = `${meta ? meta.title : type} (${slots.length})`;
    header.style.marginBottom = '4px';
    root.appendChild(header);

    // Generowanie wierszy slotów
    slots.forEach((hp, idx) => {
      root.appendChild(createHpRow(hp, idx));
    });
  }
  
  if (source.length === 0) {
    const empty = document.createElement('div');
    empty.textContent = filter === 'all' ? 'Brak slotów na uzbrojenie.' : 'Brak slotów dla wybranego filtra.';
    empty.style.padding = '10px';
    root.appendChild(empty);
  }
}
function renderMechanic(){
  setMechanicFilterActive('weapon-filter-tabs', mechanicWeaponFilter);
  setMechanicFilterActive('hp-filter-tabs', mechanicHardpointFilter);
  renderAvailableWeapons(document.getElementById('mechanic-available'));
  renderInstalledHardpoints(document.getElementById('hp-groups'));
  const sel = document.getElementById('ship-frame-select');
  if(sel && sel.value !== Game.player.shipFrame){
    sel.value = Game.player.shipFrame;
  }
}

// --- Zakładki ---
const PLAYER = { credits: 1200, cargo: {}, shipId: 'starter' };
const BLUEPRINTS = {
  upgrades: [
    { id:'rail_cooler', name:'Chłodzenie raila', cost:600, apply(){ rail.heatCap *= 1.25; rail.coolRate *= 1.15; } },
    { id:'boost_core',  name:'Wzmocniony boost', cost:700, apply(){
      boost.extraThrustMul *= 1.15;
      boost.consumeRate *= 0.9;
      boost.handlingMultiplier *= 1.05;
    } },
    { id:'agility',     name:'Zwrotność +',      cost:500, apply(){
      ship.angularDamping *= 0.9;
      ship.engines.torqueLeft.maxThrust  = Math.round(ship.engines.torqueLeft.maxThrust * 1.12);
      ship.engines.torqueRight.maxThrust = Math.round(ship.engines.torqueRight.maxThrust * 1.12);
    } },
  ],
  ships: [
    { id:'scout', name:'Scout', cost:2500, stats:{ hp:0.8, speed:1.3, cargo:0.6 } },
    { id:'frigate', name:'Fregata', cost:4200, stats:{ hp:1.6, speed:0.85, cargo:1.4 } },
  ],
};

const STATION_TAB_CONFIG = [
  { id:'upgrades', label:'Ulepszenia' },
  { id:'trade', label:'Handel' },
  { id:'cantina', label:'Kantyna' },
  { id:'hangar', label:'Hangar' },
  { id:'mechanic', label:'Mechanik' },
  { id:'infrastructure', label:'Infrastruktura' },
];

const MARKET = { // ceny przykładowe
  buy:{ ruda: 22, paliwo: 15, żywność: 8 },
  sell:{ ruda: 18, paliwo: 12, żywność: 6 }
};
const RESOURCE_SVGS = {
  gas: '<svg viewBox="0 0 24 24" fill="none"><path d="M12 3c-3.2 3.5-5 6.3-5 9a5 5 0 1010 0c0-2.7-1.8-5.5-5-9z" fill="#22d3ee" stroke="#67e8f9" stroke-width="1.5"/><circle cx="12" cy="13" r="2.6" fill="#0ea5e9" stroke="#bae6fd" stroke-width="0.8" opacity="0.9"/></svg>',
  fuel: '<svg viewBox="0 0 24 24" fill="none"><path d="M12 4c1.5 2 4 4.5 4 7.5A4.5 4.5 0 0112 16a4.5 4.5 0 01-4-4.5c0-1.6.5-3.3 1.7-5.1L12 4z" fill="#f97316" stroke="#fdba74" stroke-width="1.4"/><path d="M11.2 9.8c-.6.7-.9 1.4-.9 2.2 0 1.4 1 2.4 2.2 2.4 1.1 0 2-.8 2.2-2" stroke="#fff7ed" stroke-width="1.1" stroke-linecap="round"/></svg>',
  rawMetal: '<svg viewBox="0 0 24 24" fill="none"><path d="M12 3 18 7v10l-6 4-6-4V7z" fill="#94a3b8" stroke="#cbd5e1" stroke-width="1.2"/><path d="M12 3v8l6 6" stroke="#e2e8f0" stroke-width="1" stroke-linecap="round"/></svg>',
  refinedMetal: '<svg viewBox="0 0 24 24" fill="none"><rect x="4.5" y="6.5" width="15" height="4" rx="1.2" fill="#d1d5db" stroke="#e5e7eb"/><rect x="6" y="11.5" width="13" height="4" rx="1.2" fill="#cbd5e1" stroke="#e5e7eb"/><rect x="7.5" y="16.5" width="10" height="3" rx="1" fill="#94a3b8" stroke="#cbd5e1"/></svg>'
};

const stationOverlayDom = {
  root: document.getElementById('station-overlay'),
  tabs: document.getElementById('station-tabs'),
  title: document.getElementById('station-title'),
  subtitle: document.getElementById('station-subtitle'),
  credits: document.getElementById('station-credits'),
  panels: {
    upgrades: document.getElementById('tab-upgrades'),
    trade: document.getElementById('tab-trade'),
    cantina: document.getElementById('tab-cantina'),
    hangar: document.getElementById('tab-hangar'),
    mechanic: document.getElementById('tab-mechanic-html'),
    infrastructure: document.getElementById('tab-infrastructure-html'),
  }
};

const stationOverlayState = {
  built:false,
  activeTab:null,
  stationKey:null
};

function createResourceIcon(key){
  const wrap = document.createElement('span');
  wrap.className = 'resource-icon-wrap';
  wrap.innerHTML = RESOURCE_SVGS[key] || '';
  const svg = wrap.querySelector('svg');
  if(svg) svg.classList.add('resource-icon');
  return wrap;
}

function getResourceLabel(key){
  return ECONOMY_RESOURCES[key]?.label || toTitleCaseFromKey(key);
}

function createStationCard({ title, badge, description, meta = [], actions = [], dataset = null }){
  const card = document.createElement('div');
  card.className = 'station-card';
  if(dataset){
    for(const [key, val] of Object.entries(dataset)){
      card.dataset[key] = val;
    }
  }

  const header = document.createElement('div');
  header.className = 'station-card-header';
  const titleEl = document.createElement('h4');
  titleEl.className = 'station-card-title';
  titleEl.textContent = title;
  header.appendChild(titleEl);
  if(badge){
    const chip = document.createElement('span');
    chip.className = 'station-chip';
    chip.textContent = badge;
    header.appendChild(chip);
  }
  card.appendChild(header);

  if(description){
    const desc = document.createElement('p');
    desc.className = 'station-card-desc';
    desc.textContent = description;
    card.appendChild(desc);
  }

  if(meta.length){
    const metaEl = document.createElement('div');
    metaEl.className = 'station-card-meta';
    meta.forEach(text => {
      const span = document.createElement('span');
      span.textContent = text;
      metaEl.appendChild(span);
    });
    card.appendChild(metaEl);
  }

  if(actions.length){
    const actionsEl = document.createElement('div');
    actionsEl.className = 'station-card-actions';
    actions.forEach(action => {
      const btn = document.createElement('button');
      btn.textContent = action.label;
      if(action.dataset){
        for(const [k,v] of Object.entries(action.dataset)){
          btn.dataset[k] = v;
        }
      }
      if(typeof action.disabled === 'boolean') btn.disabled = action.disabled;
      btn.addEventListener('click', action.onClick);
      actionsEl.appendChild(btn);
    });
    card.appendChild(actionsEl);
  }

  return card;
}

function initStationOverlayTabs(){
  if(!stationOverlayDom.tabs) return;
  stationOverlayDom.tabs.innerHTML = '';
  for(const tab of STATION_TAB_CONFIG){
    const li = document.createElement('li');
    li.dataset.tab = tab.id;
    li.textContent = tab.label;
    li.addEventListener('click', ()=>{
      stationUI.tab = tab.id;
      renderStationUI();
    });
    stationOverlayDom.tabs.appendChild(li);
  }
}

function buildUpgradesPanel(){
  const pane = stationOverlayDom.panels.upgrades;
  if(!pane) return;
  pane.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'station-grid';
  for(const upgrade of BLUEPRINTS.upgrades){
    const card = createStationCard({
      title: upgrade.name,
      badge: 'Upgrade',
      description: 'Ulepszenie statku instalowane przez warsztat stacji.',
      meta: [`Koszt: ${upgrade.cost} cr`],
      actions: [{
        label: 'Kup',
        dataset: { upgradeId: upgrade.id, cost: upgrade.cost },
        onClick: ()=>purchaseUpgrade(upgrade)
      }]
    });
    grid.appendChild(card);
  }
  pane.appendChild(grid);
}

function buildTradePanel(){
  const pane = stationOverlayDom.panels.trade;
  if(!pane) return;
  pane.innerHTML = '';

  const resourcesCard = document.createElement('div');
  resourcesCard.className = 'station-card trade-resource-card';

  const resHeader = document.createElement('div');
  resHeader.className = 'station-card-header';
  const resTitle = document.createElement('h4');
  resTitle.className = 'station-card-title';
  resTitle.textContent = 'Magazyny i produkcja';
  resHeader.appendChild(resTitle);
  const resBadge = document.createElement('span');
  resBadge.className = 'station-chip';
  resBadge.textContent = 'Trade';
  resHeader.appendChild(resBadge);
  resourcesCard.appendChild(resHeader);

  const resDesc = document.createElement('p');
  resDesc.className = 'station-card-desc';
  resDesc.textContent = 'Aktualny stan surowców na orbicie planety.';
  resourcesCard.appendChild(resDesc);

  const resMeta = document.createElement('div');
  resMeta.className = 'station-card-meta';
  const resNote = document.createElement('span');
  resNote.className = 'trade-resource-note';
  resNote.textContent = 'Magazyny stacji orbitalnej.';
  resMeta.appendChild(resNote);
  resourcesCard.appendChild(resMeta);

  const resTable = document.createElement('table');
  resTable.className = 'trade-resource-table';
  for(const key of ECONOMY_RESOURCE_KEYS){
    const row = document.createElement('tr');
    row.dataset.resourceKey = key;
    const labelCell = document.createElement('td');
    labelCell.className = 'trade-resource-label';
    labelCell.appendChild(createResourceIcon(key));
    const label = document.createElement('span');
    label.textContent = getResourceLabel(key);
    labelCell.appendChild(label);
    const values = document.createElement('td');
    values.className = 'trade-resource-values';
    const amount = document.createElement('span');
    amount.dataset.field = 'amount';
    amount.className = 'trade-resource-amount';
    amount.textContent = '0';
    const cap = document.createElement('span');
    cap.dataset.field = 'capacity';
    cap.className = 'trade-resource-capacity';
    cap.textContent = '0';
    values.appendChild(amount);
    values.append(' / ');
    values.appendChild(cap);
    row.appendChild(labelCell);
    row.appendChild(values);
    resTable.appendChild(row);
  }
  resourcesCard.appendChild(resTable);
  pane.appendChild(resourcesCard);

  const grid = document.createElement('div');
  grid.className = 'station-grid';
  const allItems = new Set([...Object.keys(MARKET.buy), ...Object.keys(MARKET.sell)]);
  for(const item of allItems){
    const buyPrice = MARKET.buy[item];
    const sellPrice = MARKET.sell[item];
    const card = createStationCard({
      title: toTitleCaseFromKey(item),
      badge: 'Rynek',
      description: 'Handluj surowcami z dokami stacji.',
      meta: [
        buyPrice ? `Kupno: ${buyPrice} cr` : 'Kupno: niedostępne',
        sellPrice ? `Sprzedaż: ${sellPrice} cr` : 'Sprzedaż: niedostępna',
        `Ładownia: ${PLAYER.cargo[item] || 0}`
      ],
      dataset: { tradeCard:'market', tradeItem: item },
      actions: [
        buyPrice ? {
          label: 'Kup',
          dataset: { tradeItem: item, tradeType: 'buy', price: buyPrice },
          onClick: ()=>handleTrade('buy', item, buyPrice)
        } : null,
        sellPrice ? {
          label: 'Sprzedaj',
          dataset: { tradeItem: item, tradeType: 'sell', price: sellPrice },
          onClick: ()=>handleTrade('sell', item, sellPrice)
        } : null
      ].filter(Boolean)
    });
    grid.appendChild(card);
  }
  pane.appendChild(grid);
}

function buildCantinaPanel(){
  const pane = stationOverlayDom.panels.cantina;
  if(!pane) return;
  pane.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'station-grid';
  grid.appendChild(createStationCard({
    title: 'Najemnik: piracka stacja',
    badge: 'Misja',
    description: 'Odbierz kontrakt na zniszczenie pirackiej placówki w pobliskim sektorze.',
    meta: ['Nagrody za eliminację wrogów'],
    actions: [{ label:'Przyjmij', onClick: startMercenaryMission }]
  }));
  grid.appendChild(createStationCard({
    title: 'Wojna o terytorium',
    badge: 'Misja',
    description: 'Dołącz do sił sojuszniczych i odbij punkt kontrolny z rąk piratów.',
    meta: ['Aktywuje wrogie fale w sektorze'],
    actions: [{ label:'Dołącz', onClick: startTerritoryWarMission }]
  }));
  pane.appendChild(grid);
}

function buildHangarPanel(){
  const pane = stationOverlayDom.panels.hangar;
  if(!pane) return;
  pane.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'station-grid';

  const repairCard = createStationCard({
    title: 'Naprawy kadłuba',
    badge: 'Serwis',
    description: 'Przywróć kadłub statku do pełnej sprawności.',
    meta: ['Status: 0% uszkodzeń'],
    actions: [{ label: 'Napraw', dataset:{ action:'repair' }, onClick: handleRepair }]
  });
  grid.appendChild(repairCard);

  for(const shipBP of BLUEPRINTS.ships){
    const card = createStationCard({
      title: shipBP.name,
      badge: 'Hangar',
      description: 'Zamów nową ramę statku i przeładuj systemy.',
      meta: [
        `Koszt: ${shipBP.cost} cr`,
        `Kadłub: ${Math.round(shipBP.stats.hp * 100)}%`,
        `Prędkość: ${Math.round(shipBP.stats.speed * 100)}%`
      ],
      actions: [{
        label: 'Kup',
        dataset:{ shipId: shipBP.id, cost: shipBP.cost },
        onClick: ()=>purchaseShip(shipBP)
      }]
    });
    grid.appendChild(card);
  }
  pane.appendChild(grid);
}

function buildMechanicPanel(){
  const pane = stationOverlayDom.panels.mechanic;
  if(!pane) return;
  
  // Wstrzykujemy strukturę HTML warsztatu bezpośrednio do zakładki
  pane.innerHTML = `
    <div class="mechanic-toolbar">
      <label>Rama statku:</label>
      <select id="ship-frame-select" style="margin-left:8px; width:200px; background:#060e1c; color:#fff; border:1px solid #2a3a5a; padding:4px; border-radius:4px;"></select>
    </div>
    <div class="mechanic-body" style="margin-top:12px;">
      <div class="mechanic-column mechanic-parts">
        <div class="mechanic-section">
          <div class="mechanic-section-head">
            <div>
              <p class="mechanic-kicker">Dostępne części</p>
              <h4>Magazyn broni</h4>
              <p class="mechanic-sub">Przeciągnij broń na slot hardpointu, aby ją zamontować.</p>
            </div>
          </div>
          <div class="mechanic-tabs" id="weapon-filter-tabs">
            <button class="mechanic-tab-btn" data-filter="all">Wszystkie</button>
            <button class="mechanic-tab-btn" data-filter="main">Broń główna</button>
            <button class="mechanic-tab-btn" data-filter="missile">Rakiety</button>
            <button class="mechanic-tab-btn" data-filter="aux">Broń dodatkowa</button>
          </div>
          <div id="mechanic-available" class="weapon-pool"></div>
        </div>
      </div>
      <div class="mechanic-column mechanic-install">
        <div class="mechanic-section">
          <div class="mechanic-section-head">
            <div>
              <p class="mechanic-kicker">Uzbrojenie statku</p>
              <h4>Hardpointy</h4>
              <p class="mechanic-sub">Upuść część na slot po prawej, aby zamienić uzbrojenie.</p>
            </div>
          </div>
          <div class="mechanic-tabs" id="hp-filter-tabs">
            <button class="mechanic-tab-btn" data-filter="all">Wszystkie</button>
            <button class="mechanic-tab-btn" data-filter="main">Broń główna</button>
            <button class="mechanic-tab-btn" data-filter="missile">Rakiety</button>
            <button class="mechanic-tab-btn" data-filter="aux">Broń dodatkowa</button>
          </div>
          <div id="hp-groups" class="hp-groups mechanic-grid"></div>
        </div>
      </div>
    </div>
  `;

  // Inicjalizacja listy wyboru statku (ponieważ właśnie stworzyliśmy element select)
  const sel = document.getElementById('ship-frame-select');
  if(sel){
    sel.innerHTML = Object.values(SHIPS).map(s=>
      `<option value="${s.id}" ${Game.player.shipFrame===s.id?'selected':''}>${s.name}</option>`
    ).join('');
    
    sel.onchange = () => {
      Game.player.shipFrame = sel.value;
      // Przelicz hardpointy dla nowej ramy
      const prev = Game.player.hardpoints.map(h=>({ type:h.type, mount:h.mount, ammo:h.ammo, maxAmmo:h.maxAmmo }));
      if(typeof rebuildHardpointsForFrame === 'function') rebuildHardpointsForFrame();
      if(typeof tryPreserveMounts === 'function') tryPreserveMounts(prev);
      if(typeof syncWeaponSystems === 'function') syncWeaponSystems();
      renderMechanic();
      if(typeof saveLoadout === 'function') saveLoadout();
    };
  }

  initMechanicFilter('weapon-filter-tabs', () => mechanicWeaponFilter, (val) => { mechanicWeaponFilter = val; });
  initMechanicFilter('hp-filter-tabs', () => mechanicHardpointFilter, (val) => { mechanicHardpointFilter = val; });

  // Wymuś renderowanie zawartości (ikony broni i sloty)
  renderMechanic();
}

function buildInfrastructurePanel(){
  const pane = stationOverlayDom.panels.infrastructure;
  if(!pane) return;
  pane.innerHTML = '';
  pane.appendChild(createStationCard({
    title: 'Infrastruktura stacji',
    badge: 'Budowa',
    description: 'Przeciągaj budynki na siatkę infrastruktury, aby rozwijać stację.',
    meta: ['Skrót klawiatury: [6]'],
    actions: [{
      label:'Otwórz budowę',
      onClick: ()=>{
        stationUI.tab = 'infrastructure';
        setInfrastructureUIVisible(true);
        renderStationUI();
      }
    }]
  }));
}

function initStationOverlay(){
  if(!stationOverlayDom.root) return;
  initStationOverlayTabs();
  buildUpgradesPanel();
  buildTradePanel();
  buildCantinaPanel();
  buildHangarPanel();
  buildMechanicPanel();
  buildInfrastructurePanel();
  stationOverlayState.built = true;
}

function updateStationHeader(station){
  if(stationOverlayDom.title){
    stationOverlayDom.title.textContent = station?.name || 'Stacja orbitalna';
  }
  if(stationOverlayDom.subtitle){
    const parts = [];
    if(station?.planet?.name) parts.push(`Orbita: ${station.planet.name}`);
    if(Number.isFinite(station?.x) && Number.isFinite(station?.y)){
      parts.push(`Pozycja: ${Math.round(station.x)}, ${Math.round(station.y)}`);
    }
    stationOverlayDom.subtitle.textContent = parts.join(' • ') || 'Przestrzeń cywilna';
  }
  if(stationOverlayDom.credits){
    stationOverlayDom.credits.textContent = `${Math.round(PLAYER.credits)} cr`;
  }
}

function setActiveStationTab(tab){
  if(stationOverlayDom.tabs){
    stationOverlayDom.tabs.querySelectorAll('li').forEach(li => {
      li.classList.toggle('active', li.dataset.tab === tab);
    });
  }
  for(const [key, pane] of Object.entries(stationOverlayDom.panels)){
    if(!pane) continue;
    const match = key === tab;
    pane.classList.toggle('active', match);
    pane.classList.toggle('hidden', !match);
  }
}

function updateUpgradeButtons(){
  const buttons = stationOverlayDom.panels.upgrades?.querySelectorAll('button[data-upgrade-id]');
  if(!buttons) return;
  buttons.forEach(btn => {
    const cost = Number(btn.dataset.cost) || 0;
    btn.disabled = PLAYER.credits < cost;
  });
}

function updateTradeResourceTable(station){
  const pane = stationOverlayDom.panels.trade;
  if(!pane) return;
  const table = pane.querySelector('.trade-resource-table');
  if(!table) return;
  const econ = station ? ensureStationEconomy(station) : null;
  if(!econ) return;
  table.querySelectorAll('tr[data-resource-key]').forEach(row => {
    const key = row.dataset.resourceKey;
    const amountEl = row.querySelector('[data-field="amount"]');
    const capEl = row.querySelector('[data-field="capacity"]');
    if(amountEl) amountEl.textContent = `${Math.round(econ.resources?.[key] ?? 0)}`;
    if(capEl) capEl.textContent = `${Math.round(econ.capacity?.[key] ?? 0)}`;
  });
  const note = pane.querySelector('.trade-resource-note');
  if(note){
    const label = station?.planet?.name || station?.name;
    note.textContent = label ? `Magazyny: ${label}` : 'Magazyny stacji orbitalnej.';
  }
}

function updateTradeCards(station){
  updateTradeResourceTable(station);
  const cards = stationOverlayDom.panels.trade?.querySelectorAll('.station-card[data-trade-card="market"]');
  if(!cards) return;
  cards.forEach(card => {
    const item = card.dataset.tradeItem
      || card.querySelector('[data-trade-item]')?.dataset.tradeItem
      || card.querySelector('button[data-trade-item]')?.dataset.tradeItem;
    if(!item) return;
    const meta = card.querySelector('.station-card-meta');
    if(meta){
      const metaSpans = [...meta.querySelectorAll('span')];
      if(metaSpans[2]) metaSpans[2].textContent = `Ładownia: ${PLAYER.cargo[item] || 0}`;
    }
    card.querySelectorAll('button[data-trade-type]').forEach(btn => {
      const price = Number(btn.dataset.price) || 0;
      const type = btn.dataset.tradeType;
      if(type === 'buy'){
        btn.disabled = PLAYER.credits < price;
      }
      if(type === 'sell'){
        btn.disabled = (PLAYER.cargo[item] || 0) <= 0;
      }
    });
  });
}

function updateHangarCards(){
  const pane = stationOverlayDom.panels.hangar;
  if(!pane) return;
  const cards = [...pane.querySelectorAll('.station-card')];
  const damageFrac = 1 - (ship.hull.val / ship.hull.max);
  const damagePct = Math.ceil(damageFrac * 100);
  const repairCost = Math.ceil(damageFrac * 600);
  const repairCard = cards.find(card => card.querySelector('button[data-action="repair"]'));
  if(repairCard){
    const meta = repairCard.querySelector('.station-card-meta span');
    if(meta) meta.textContent = `Status: ${damagePct}% uszkodzeń`;
    const btn = repairCard.querySelector('button[data-action="repair"]');
    if(btn) btn.disabled = damagePct <= 0 || PLAYER.credits < repairCost;
  }
  for(const btn of pane.querySelectorAll('button[data-ship-id]')){
    const cost = Number(btn.dataset.cost) || 0;
    btn.disabled = PLAYER.credits < cost;
  }
}

function renderStationOverlay(tab, station){
  if(!stationOverlayState.built) initStationOverlay();
  if(!stationOverlayDom.root) return;
  const stationKey = getInfrastructureStationKey(station) || station?.name || 'station';
  if(stationOverlayState.activeTab !== tab || stationOverlayState.stationKey !== stationKey){
    setActiveStationTab(tab);
    stationOverlayState.activeTab = tab;
    stationOverlayState.stationKey = stationKey;
  }
  updateStationHeader(station);
  updateUpgradeButtons();
  updateTradeCards(station);
  updateHangarCards();
}

function handleTrade(type, item, price){
  if(type === 'buy'){
    if(PLAYER.credits >= price){
      PLAYER.credits -= price;
      PLAYER.cargo[item] = (PLAYER.cargo[item] || 0) + 1;
    } else {
      toast('Za mało kredytów');
    }
  } else if(type === 'sell'){
    if((PLAYER.cargo[item] || 0) > 0){
      PLAYER.cargo[item] -= 1;
      PLAYER.credits += price;
    }
  }
  updateStationOverlay(stationUI.tab, stationUI.station);
}

function purchaseUpgrade(upgrade){
  if(!upgrade) return;
  if(PLAYER.credits >= upgrade.cost){
    PLAYER.credits -= upgrade.cost;
    upgrade.apply();
    toast('Zainstalowano: ' + upgrade.name);
  } else {
    toast('Za mało kredytów');
  }
  updateStationOverlay(stationUI.tab, stationUI.station);
}

function purchaseShip(shipBP){
  if(!shipBP) return;
  if(PLAYER.credits >= shipBP.cost){
    PLAYER.credits -= shipBP.cost;
    PLAYER.shipId = shipBP.id;
    applyShipStats(shipBP.stats);
    toast('Zakupiono: ' + shipBP.name);
  } else {
    toast('Za mało kredytów');
  }
  updateStationOverlay(stationUI.tab, stationUI.station);
}

function handleRepair(){
  const damageFrac = 1 - (ship.hull.val / ship.hull.max);
  const repairCost = Math.ceil(damageFrac * 600);
  if(damageFrac <= 0){
    toast('Kadłub jest w pełni sprawny');
    return;
  }
  if(PLAYER.credits >= repairCost){
    PLAYER.credits -= repairCost;
    ship.hull.val = ship.hull.max;
    toast('Naprawiono kadłub.');
  } else {
    toast('Za mało kredytów');
  }
  updateStationOverlay(stationUI.tab, stationUI.station);
}

function updateStationOverlay(tab, station){
  renderStationOverlay(tab, station);
}

initMechanicUI();
initInfrastructureUI();
autopopulateDefaultInfrastructure();
function startMercenaryMission(){
  if(mercMission) { toast('Misja już aktywna. Wciśnij J aby zobaczyć dziennik.'); return; }

  const beltTarget = (() => {
    if (!ASTEROID_BELT) return null;
    const inner = ASTEROID_BELT.inner;
    if (!Number.isFinite(inner)) return null;
    const safeMargin = Math.max(1200, ZONE_APPROACH_DISTANCE * 0.6);
    const radius = Math.max(500, inner - safeMargin);
    return { radius, angle: Math.random() * Math.PI * 2 };
  })();

  const earth = planets.find(p => p.id === 'earth' || p.name === 'earth');
  const targetPlanet = earth || planets[2] || planets[0];
  const earthOrbit = targetPlanet ? planetOrbitRadii(targetPlanet) : null;

  const orbitRadius = beltTarget?.radius
    ?? earthOrbit?.outer
    ?? Math.max(1600, (targetPlanet?.r || 0) * 4);
  const angle = beltTarget?.angle ?? (Math.random() * Math.PI * 2);
  const centerX = beltTarget ? SUN.x : (targetPlanet?.x || SUN.x);
  const centerY = beltTarget ? SUN.y : (targetPlanet?.y || SUN.y);
  const x = centerX + Math.cos(angle) * orbitRadius;
  const y = centerY + Math.sin(angle) * orbitRadius;

  const r = 220;
  const portOffset = r + 60;
  const ports = [
    {x: portOffset, y: 0},
    {x: 0, y: portOffset},
    {x: -portOffset, y: 0},
    {x: 0, y: -portOffset}
  ];

  const station = {
    id: 'PIR',
    x, y, r,
    baseR: r,
    isPirate: true,
    hp: 10000, maxHp: 10000,
    static: true, mission: true,
    ports,
    style: STATION_STYLES[Math.floor(Math.random()*STATION_STYLES.length)],
    shield: {
      max: 9000,
      val: 9000,
      regenRate: 650,
      regenDelay: 4.5,
      regenTimer: 0
    }
  };

  stations.push(station);
  if (typeof window.attachPirateStation3D === 'function') {
    if (!mainScene3D && typeof window.initWorld3D === 'function') {
      const res = initWorld3D();
      mainScene3D = res?.scene || mainScene3D;
    }
    window.attachPirateStation3D(mainScene3D, station);
  }
  mercMission = {
    station,
    npcsSpawned:false,
    alertStage: 'idle',
    guardConfigured: false,
    weaponPlatforms: [],
    // --- SWARM control ---
    swarm: {
      active:false,
      maxAlive: 200,     // <- zwiększony limit
      timer: 2,
      baseInterval: 1.0, // skraca się wraz z utratą HP stacji
      queue: []
    }
  };

 mercMission.guards = [];

  // 1. Eskadra Interceptorów (6 sztuk)
  // Używamy nowej funkcji: tworzy eskadrę, która orbituje (mode='guard')
  spawnPirateSquad(station, 'interceptor', 6, 'guard', { 
      radius: station.r + 320, 
      speed: 0.45 
  });

  // 2. Fregaty (2 sztuki)
  // Duże statki spawnujemy osobno, żeby nie latały "na ogonie" lidera jak myśliwce,
  // tylko dostojnie krążyły po dalszej orbicie.
  const frigateTypes = ['frigate_pd', 'frigate_laser']; // Różne typy dla urozmaicenia

  for (let i = 0; i < 2; i++) {
      const type = frigateTypes[i % frigateTypes.length];
      const npc = spawnPirate(type, station); // Używamy głównego spawnera

      // Konfiguracja orbitowania (Guard)
      npc.state = 'guard';
      npc.guardStation = station;
      npc.guardOrbitRadius = station.r + 550; // Dalsza orbita
      npc.guardOrbitSpeed = (i === 0 ? 1 : -1) * 0.15; // Lecą w przeciwnych kierunkach
      npc.guardPhase = i * Math.PI; // Startują po przeciwnych stronach (0 i 180 stopni)
      
      // Pozycja startowa na orbicie (żeby nie dolatywały z środka)
      npc.x = station.x + Math.cos(npc.guardPhase) * npc.guardOrbitRadius;
      npc.y = station.y + Math.sin(npc.guardPhase) * npc.guardOrbitRadius;
      npc.angle = npc.guardPhase + (npc.guardOrbitSpeed > 0 ? Math.PI/2 : -Math.PI/2);

      mercMission.guards.push(npc);
  }
  const orbitBase = station.r + 220;
  const baseAngle = Math.random() * Math.PI * 2;
  const angleStep = Math.PI / 2;
  const jitter = 0.25;
  const platformConfigs = [
    { angle: baseAngle + (Math.random()-0.5)*jitter, orbitRadius: orbitBase, label: 'Platforma A' },
    { angle: baseAngle + angleStep + (Math.random()-0.5)*jitter, orbitRadius: orbitBase + 80, label: 'Platforma B', orbitSpeed: 0.18 },
    { angle: baseAngle + angleStep*2 + (Math.random()-0.5)*jitter, orbitRadius: orbitBase + 40, label: 'Platforma C', orbitSpeed: -0.16 },
    { angle: baseAngle + angleStep*3 + (Math.random()-0.5)*jitter, orbitRadius: orbitBase + 120, label: 'Platforma D', orbitSpeed: 0.14 }
  ];
  if (typeof window.resetSwarmQueue === 'function') {
      window.resetSwarmQueue();
  }
  for(const cfg of platformConfigs){
    const platform = spawnWeaponPlatform(station, cfg);
    mercMission.weaponPlatforms.push(platform);
  }

  // Zapis do dziennika + koordy do markera mapy
  const exists = MISSIONS.active.find(m => m.id === 'merc_pirate_station' && m.status === 'active');
  if(!exists){
    MISSIONS.active.push({
      id: 'merc_pirate_station',
      title: 'Najemnik: piracka stacja',
      type: 'mercenary',
      stationId: station.id,
      pos: { x, y },
      status: 'active'
    });
  }

  toast('Misja najemnik rozpoczęta. Wciśnij M aby otworzyć mapę — cel oznaczony X. Dziennik: J.');
}

function spawnWeaponPlatform(station, config = {}){
  const radius = config.radius ?? 52;
  const canvasSize = Math.max(64, Math.ceil(radius * 2.6));
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = canvasSize;
  const ctxPlatform = canvas.getContext('2d');
  const center = canvasSize / 2;

  // baza platformy
  const baseR = canvasSize * 0.38;
  const outerR = canvasSize * 0.46;
  const innerR = canvasSize * 0.18;
  const glowGrad = ctxPlatform.createRadialGradient(center, center, innerR, center, center, outerR);
  glowGrad.addColorStop(0, 'rgba(120,180,255,0.4)');
  glowGrad.addColorStop(1, 'rgba(0,20,40,0.02)');
  ctxPlatform.fillStyle = glowGrad;
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, outerR, 0, Math.PI*2); ctxPlatform.fill();

  ctxPlatform.fillStyle = '#1c2338';
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR, 0, Math.PI*2); ctxPlatform.fill();

  const plateGrad = ctxPlatform.createRadialGradient(center, center, innerR*0.4, center, center, baseR);
  plateGrad.addColorStop(0, '#6f87c8');
  plateGrad.addColorStop(0.6, '#3c4f7a');
  plateGrad.addColorStop(1, '#2a3556');
  ctxPlatform.fillStyle = plateGrad;
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR*0.88, 0, Math.PI*2); ctxPlatform.fill();

  ctxPlatform.strokeStyle = 'rgba(184,196,255,0.28)';
  ctxPlatform.lineWidth = Math.max(1.5, canvasSize * 0.02);
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR*0.72, 0, Math.PI*2); ctxPlatform.stroke();

  ctxPlatform.strokeStyle = 'rgba(62,112,182,0.65)';
  ctxPlatform.lineWidth = Math.max(1.2, canvasSize * 0.015);
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR*0.52, 0, Math.PI*2); ctxPlatform.stroke();

  ctxPlatform.fillStyle = '#182030';
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, innerR, 0, Math.PI*2); ctxPlatform.fill();

  ctxPlatform.fillStyle = '#93b6ff';
  for(let i=0;i<6;i++){
    const a = (i/6) * Math.PI*2;
    const slotR = innerR * 1.35;
    const px = center + Math.cos(a) * slotR;
    const py = center + Math.sin(a) * slotR;
    ctxPlatform.save();
    ctxPlatform.translate(px, py);
    ctxPlatform.rotate(a);
    ctxPlatform.fillRect(-canvasSize*0.02, -canvasSize*0.09, canvasSize*0.04, canvasSize*0.18);
    ctxPlatform.restore();
  }

  ctxPlatform.strokeStyle = 'rgba(255,255,255,0.35)';
  ctxPlatform.lineWidth = Math.max(1.0, canvasSize * 0.01);
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, innerR*0.65, 0, Math.PI*2); ctxPlatform.stroke();

  const orbitRadius = config.orbitRadius ?? (station.r + 220 + Math.random()*120);
  const orbitSpeed = config.orbitSpeed ?? ((Math.random() < 0.5 ? -1 : 1) * (0.14 + Math.random()*0.07));
  const angle = config.angle ?? (Math.random() * Math.PI * 2);
  const hpMax = config.hp ?? 1800;
  const shieldMax = (config.shield && config.shield.max) || config.shieldMax || 720;
  const shieldRegen = (config.shield && config.shield.regenRate) || config.shieldRegen || 240;
  const shieldDelay = (config.shield && config.shield.regenDelay) || config.shieldDelay || 3.5;
  const missileCd = config.missileCd ?? (3.2 + Math.random()*0.6);
  const railCd = config.railCd ?? (1.2 + Math.random()*0.4);

  const platform = {
    id: config.id || uid(),
    type: 'weapon_platform',
    label: config.label || 'Platforma',
    station,
    radius,
    canvas,
    orbitRadius,
    orbitSpeed,
    angle,
    rotation: Math.random() * Math.PI * 2,
    spin: config.spin ?? (Math.random()*0.6 - 0.3),
    hp: hpMax,
    maxHp: hpMax,
    shield: (shieldMax > 0) ? { max: shieldMax, val: shieldMax, regenRate: shieldRegen, regenDelay: shieldDelay, regenTimer: 0 } : null,
    rail: { cd: railCd * Math.random(), cdMax: railCd, scatter: config.railScatter ?? 0.04, damage: config.railDamage ?? 60 },
    missile: { cd: missileCd * Math.random(), cdMax: missileCd, damage: config.missileDamage ?? SIDE_BULLET_DAMAGE },
    hitFlash: 0,
    destroyed: false,
    deathTimer: 0,
    removed: false
  };

  platform.x = station.x + Math.cos(angle) * orbitRadius;
  platform.y = station.y + Math.sin(angle) * orbitRadius;

  return platform;
}

function resetMercMission(){
  if(!mercMission) return;
  if(mercMission.weaponPlatforms){
    mercMission.weaponPlatforms.length = 0;
  }
  mercMission = null;
}
function startTerritoryWarMission(){ toast('Dołączono do wojny terytorialnej'); }

function renderOptions(){
  if(!OPTIONS_OPEN) return;
  hudBeginPanel();
  uiTitle('Opcje');
  
  // --- NOWE: Wybór jakości tła ---
  uiQualitySelector();
  // ------------------------------
  slider('VFX: temperatura (K)', 1000, 20000, 500, OPTIONS.vfx, 'colorTempK');
  slider('VFX: bloom', 0.2, 2.5, 0.05, OPTIONS.vfx, 'bloomGain');
  slider('VFX: silnik (głośność)', 0, 1.5, 0.05, OPTIONS.vfx, 'engineGain');
  slider('Audio: master', 0, 1, 0.05, OPTIONS.audio, 'master');
  slider('Audio: SFX', 0, 1, 0.05, OPTIONS.audio, 'sfx');
  slider('Audio: muzyka', 0, 1, 0.05, OPTIONS.audio, 'music');
  slider('Mysz: czułość', 0.3, 2.0, 0.05, OPTIONS.controls, 'mouseSensitivity');
  // brak opcji odwrócenia osi zgodnie z prośbą
  hudEndPanel();
}

function renderMissionJournal(){
  if(!MISSIONS.show) return;
  const w = 420, h = 260;
  const x = (W - w)/2, y = 60;
  hudBeginPanel(x, y, w, h);
  uiTitle('Dziennik misji [J]');
  if(MISSIONS.active.length === 0){
    uiText('Brak przyjętych misji.');
  } else {
    for(const m of MISSIONS.active){
      const status = m.status === 'active' ? 'AKTYWNA' : 'ZAKOŃCZONA';
      uiText(`${m.title} — ${status}`);
    }
  }
  hudEndPanel();
}

function spawnLaserBeam(start, end, width, opts={}){
  const p = particlePool[nextParticleIndex];
  p.pos.x = start.x;
  p.pos.y = start.y;
  p.vel.x = 0;
  p.vel.y = 0;
  p.life = (opts && opts.life != null) ? opts.life : 0.12;
  p.age = 0;
  p.flash = false;
  p.beam = true;
  p.start.x = start.x;
  p.start.y = start.y;
  p.end.x = end.x;
  p.end.y = end.y;
  p.width = width;
  p.alpha = opts?.alpha ?? 1;
  p.fadeWithLife = (opts && Object.prototype.hasOwnProperty.call(opts, 'fadeWithLife')) ? opts.fadeWithLife : undefined;
  p.colorOuter = opts?.colorOuter ?? null;
  p.colorInner = opts?.colorInner ?? null;
  p.glowColor = opts?.glowColor ?? null;
  p.glowBlur = opts?.glowBlur ?? 0;
  p.outerWidthMul = opts?.outerWidthMul ?? 1;
  p.innerWidthMul = opts?.innerWidthMul ?? 1;
  p.size = 0;
  p.color = '#fff';
  p.active = true;
  nextParticleIndex = (nextParticleIndex + 1) % MAX_PARTICLES;
}

// =============== Input ===============
const input = { main:0, leftSide:0, rightSide:0, torque:0 };
const keys = {};
let showMap = false;
let shiftBinding = null;
const mapView = {
  zoom: 1,
  targetZoom: 1,
  minZoom: 0.6,
  maxZoom: 6,
  viewX: null,
  viewY: null,
  smoothness: 0.15,
  followShip: true,
  dragging: false,
  layout: null,
};
let PAUSED = false;
let lastCameraModeBeforePause = null;

function setPaused(state){
  const next = !!state;
  if(next === PAUSED) return;
  PAUSED = next;
  if(PAUSED){
    lastCameraModeBeforePause = camera.mode;
    if(camera.mode !== 'free') camera.enterFreeMode();
  } else {
    if(lastCameraModeBeforePause && lastCameraModeBeforePause !== 'free'){
      camera.exitFreeMode();
    }
    lastCameraModeBeforePause = null;
  }
}

function togglePause(){
  setPaused(!PAUSED);
}

window.addEventListener('keydown', e => {
  if (e.code !== 'Escape') return;
  if (stationUI.open) return;
  if (!gameStarted) {
    showMainMenu('home');
    return;
  }
  toggleMainMenu();
});

function currentShiftMode(){
  return isPlanetOrbitZoneId(zoneState.current?.id) ? 'boost' : 'warp';
}

function activateBoostIfAllowed(){
  if (!isPlanetOrbitZoneId(zoneState.current?.id)) return false;
  if (boost.fuel > 0) {
    boost.state = 'active';
    return true;
  }
  return false;
}

function stopBoost(){
  if (boost.state === 'active') {
    boost.state = 'idle';
  }
}

function playerHasManualInput(){
  return keys['w'] || keys['a'] || keys['d'] || keys['q'] || keys['e'];
}

function updatePlayerCommand(dt){
  if (ship.destroyed) return;
  const cmd = ship.command;
  if(!cmd || !cmd.target) return;
  if (PAUSED || warp.state !== 'idle') return;
  if (playerHasManualInput()){ ship.command = null; return; }

  const dx = cmd.target.x - ship.pos.x;
  const dy = cmd.target.y - ship.pos.y;
  const dist = Math.hypot(dx, dy);
  const arrival = cmd.arrival || 90;
  if (dist <= arrival){
    ship.command = null;
    applyPlayerInput(ship, { controller:'player', main:0, thrustY:0, torque:0, leftSide:0, rightSide:0 }, input);
    return;
  }

  const desiredAng = Math.atan2(dy, dx);
  const angDiff = wrapAngle(desiredAng - ship.angle);
  const torque = clamp(angDiff * 2.2, -1, 1);
  const main = clamp(dist / 800, 0, 1);

  applyPlayerInput(ship, {
    controller: 'player',
    thrustY: main,
    main,
    torque,
    leftSide: 0,
    rightSide: 0
  }, input);
}

function handleWarpKeyDown(){
  if(warp.state==='idle' && (DevFlags.unlimitedWarp || warp.fuel>0)){
    warp.state='charging';
    warp.charge=0;
  }
}

function handleWarpKeyUp(){
  if(warp.state==='charging'){ warp.state='idle'; warp.charge=0; }
  else if(warp.state==='active'){ warp.state='idle'; exitWarp(); }
}

function handleShiftDown(){
  if (ship.destroyed) return;
  shiftBinding = currentShiftMode();
  if (shiftBinding === 'boost') {
    activateBoostIfAllowed();
  } else {
    handleWarpKeyDown();
  }
}

function handleShiftUp(){
  if (ship.destroyed) return;
  const mode = shiftBinding || currentShiftMode();
  if (mode === 'boost') {
    stopBoost();
  } else {
    handleWarpKeyUp();
  }
  shiftBinding = null;
}
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(e.code==='Space'){ e.preventDefault(); }
  if(e.code==='ShiftLeft' || e.code==='ShiftRight'){ e.preventDefault(); }
  if (isMainMenuVisible()) return;
  const k = e.key.toLowerCase();
  keys[k] = true;
  if (k === 'shift') {
    handleShiftDown();
  }
  if(k === 'm'){
    showMap = !showMap;
    if (showMap) {
      mapView.targetZoom = clamp(mapView.targetZoom, mapView.minZoom, mapView.maxZoom);
      mapView.viewX = null;
      mapView.viewY = null;
      mapView.followShip = true;
      mapView.dragging = false;
    } else {
      mapView.dragging = false;
    }
  }
  if(k === 'j') MISSIONS.show = !MISSIONS.show;
  if(k === 'g' && !stationUI.open){
    camera.toggleFreeMode();
    pushZoneMessage(camera.mode === 'free' ? 'Free camera mode ON' : 'Free camera mode OFF');
  }
  if(k === ' '){
    togglePause();
    updateInput();
    return;
  }
  if(k === 'x'){
    triggerScanWave();
    hudPingNpcStations();
    togglePlanetRadarVisibility();
  }
  if (k === 'z') {
    if(!(Game.player.weapons?.[HP.HANGAR]?.length)) { toast('Brak dostępnych hangarów.'); return; }
    if (SQUAD.order === 'idle' || SQUAD.list.length === 0) {
      // start + ESKORTA
      SQUAD.list = [];
      for (let i = 0; i < FIGHTERS_PER_LAUNCH; i++) {
        const f = spawnFighter();
        f.formIndex = i;              // <- indeks w formacji
        SQUAD.list.push(f);
      }
      SQUAD.order = 'escort';
      SQUAD.targets = [];
      toast('Myśliwce: ESKORTA');
    } else if (SQUAD.order === 'escort') {
      SQUAD.targets = pickSquadTargets();
      SQUAD.order = 'attack';
      toast(SQUAD.targets.length ? 'Myśliwce: ATAK' : 'Myśliwce: ATAK (brak oznaczeń — wybiorą najbliższych)');
    } else if (SQUAD.order === 'attack') {
      SQUAD.order = 'return';
      toast('Myśliwce: POWRÓT');
    } else if (SQUAD.order === 'return') {
      SQUAD.order = 'escort';
      SQUAD.targets = [];
      toast('Myśliwce: ESKORTA');
    }
  }
  if(k === 'r'){
    if(highlightedEnemies.length){
      lockedTargets = highlightedEnemies.filter(isHostileNpc)
        .sort((a,b)=>Math.hypot(a.x-ship.pos.x,a.y-ship.pos.y) - Math.hypot(b.x-ship.pos.x,b.y-ship.pos.y));
      highlightTimer = 0;
      highlightedEnemies = [];
    } else if (scan.scanned && isHostileNpc(scan.scanned)) {
      lockedTarget = scan.scanned;
    } else {
      lockedTarget = null;
    }
  }
  updateInput();
});
window.addEventListener('keyup', e=>{
  const k = e.key.toLowerCase();
  keys[k] = false;
  if (k === 'shift') {
    handleShiftUp();
  }
  updateInput();
});
function updateInput(){
  if (ship.destroyed) {
    applyPlayerInput(ship, { controller:'player', main:0, thrustX:0, thrustY:0, leftSide:0, rightSide:0, torque:0 }, input);
    return;
  }
  const main = keys['w'] ? 1 : 0;
  const leftSide = keys['e'] ? 1 : 0;
  const rightSide = keys['q'] ? 1 : 0;
  let torque = 0; if(keys['a']) torque -= 1; if(keys['d']) torque += 1;
  applyPlayerInput(ship, {
    controller: 'player',
    thrustX: torque,
    thrustY: main,
    main,
    leftSide,
    rightSide,
    torque
  }, input);
  if(keys['f']) tryFireSpecial();
}

// targeting / scanning
const SCAN_RANGE = 10000;
const SCAN_VFX_SPEED = 4000;
const SCAN_ARROW_LIFE = 1.5;
const scan = { target:null, scanned:null, targetType:null };
let lockedTarget = null;
let lockedTargets = [];
let highlightedEnemies = [];
let highlightTimer = 0;
const HIGHLIGHT_TIME = 3;
const HIGHLIGHT_RANGE = 2000;
const radarPings = [];
const scanWaves = [];
const scanArrows = [];

function isHostileNpc(n){
  return !!(n && !n.dead && !n.friendly);
}

function isPirateScanTarget(n){
  if (!isHostileNpc(n)) return false;
  if (!n.isPirate) return false;
  const type = String(n.type || '').toLowerCase();
  if (type === 'destroyer' || type === 'battleship') return false;
  if (n.isCapitalShip) return false;
  return true;
}
const NPC_DESPAWN_RADIUS = 20000;
function spawnRadarPing(x,y){ radarPings.push({x,y,age:0,life:1}); }
function triggerScanWave(){
  const wave = {x:ship.pos.x,y:ship.pos.y,r:0,speed:SCAN_VFX_SPEED,max:SCAN_RANGE,hit:new Set()};
  scanWaves.push(wave);
  scanArrows.length = 0;
 // Merge of branches:
  // 1) codex/add-various-npc-types-and-groups → prefer enemies that have weapons
  // 2) main → only highlight those within HIGHLIGHT_RANGE
  const inRange = (n) => Math.hypot(n.x - ship.pos.x, n.y - ship.pos.y) <= HIGHLIGHT_RANGE;
  highlightedEnemies = npcs.filter(n => isPirateScanTarget(n) && inRange(n));
  highlightTimer = HIGHLIGHT_TIME;
  for(const st of stations){
    const dist = Math.hypot(st.x - ship.pos.x, st.y - ship.pos.y);
    spawnRadarPing(st.x, st.y);
    if(dist <= SCAN_RANGE){
      scanArrows.push({target:st,age:0,life:SCAN_ARROW_LIFE});
      wave.hit.add(st);
    }
  }
}

const mouse = { x: W/2, y: H/2, left:false, right:false, click:false, overCanvas:false, dx:0, dy:0 };
const Selection = { active: false, rect: null, units: new Set() };

function clearSelection(){
  Selection.active = false;
  Selection.rect = null;
  Selection.units.clear();
}

function startSelection(worldPoint){
  Selection.active = true;
  Selection.rect = { x0: worldPoint.x, y0: worldPoint.y, x1: worldPoint.x, y1: worldPoint.y };
}

function updateSelectionRect(worldPoint){
  if(!Selection.active || !Selection.rect) return;
  Selection.rect.x1 = worldPoint.x;
  Selection.rect.y1 = worldPoint.y;
}

function selectableAllies(){
  const allies = [];
  if (ship) allies.push(ship);
  for (const npc of npcs){
    if (!npc || npc.dead || !npc.friendly) continue;
    allies.push(npc);
  }
  return allies;
}

function finishSelection(){
  if(!Selection.rect) { clearSelection(); return; }
  const x0 = Math.min(Selection.rect.x0, Selection.rect.x1);
  const y0 = Math.min(Selection.rect.y0, Selection.rect.y1);
  const x1 = Math.max(Selection.rect.x0, Selection.rect.x1);
  const y1 = Math.max(Selection.rect.y0, Selection.rect.y1);
  Selection.units.clear();
  for(const unit of selectableAllies()){
    const ux = unit.pos ? unit.pos.x : unit.x;
    const uy = unit.pos ? unit.pos.y : unit.y;
    if(ux >= x0 && ux <= x1 && uy >= y0 && uy <= y1){
      Selection.units.add(unit);
    }
  }
  Selection.active = false;
}

function categorizeUnit(unit){
  if(unit === ship) return 'player';
  if(unit.fighter || unit.type === 'fighter') return 'fighter';
  if(unit.type && String(unit.type).includes('frigate')) return 'frigate';
  if(unit.type === 'destroyer') return 'destroyer';
  if(unit.type === 'battleship' || unit.isCapitalShip) return 'battleship';
  return 'other';
}

function formationTargets(units, anchor){
  const fighters = [];
  const frigates = [];
  const destroyers = [];
  const battleships = [];
  const others = [];
  for(const u of units){
    const cat = categorizeUnit(u);
    if(cat === 'fighter') fighters.push(u);
    else if(cat === 'frigate') frigates.push(u);
    else if(cat === 'destroyer' || cat === 'player') destroyers.push(u);
    else if(cat === 'battleship') battleships.push(u);
    else others.push(u);
  }
  const enemy = npcs.find(n=>n && !n.dead && !n.friendly) || null;
  const ang = enemy ? Math.atan2(enemy.y - anchor.y, enemy.x - anchor.x) : ship.angle;
  const forward = { x: Math.cos(ang), y: Math.sin(ang) };
  const right = { x: -forward.y, y: forward.x };

  const result = new Map();
  let depth = 0;
  const placeLine = (list, spacing)=>{
    if(!list.length) return;
    const sorted = [...list].sort((a,b)=>String(a.id||'').localeCompare(String(b.id||'')));
    const totalW = (sorted.length - 1) * spacing;
    const cx = anchor.x + forward.x * depth;
    const cy = anchor.y + forward.y * depth;
    const startX = cx - right.x * totalW / 2;
    const startY = cy - right.y * totalW / 2;
    sorted.forEach((u,i)=>{
      result.set(u, {
        x: startX + right.x * (i * spacing),
        y: startY + right.y * (i * spacing)
      });
    });
    depth += spacing * 0.9;
  };

  placeLine(fighters, 200);
  depth += fighters.length ? 60 : 0;
  placeLine(frigates, 150);
  placeLine(destroyers, 200);
  placeLine(battleships, 230);
  placeLine(others, 170);
  return result;
}

function issueMoveOrder(point, opts={}){
  const units = [...Selection.units].filter(u=>u && !u.dead);
  if(!units.length) return;
  const targets = formationTargets(units, point);
  for(const unit of units){
    const t = targets.get(unit) || point;
    const arrival = (unit.radius || unit.w || 30) + 25;
    unit.command = { type: opts.attackMove ? 'attack-move' : 'move', target: { x: t.x, y: t.y }, arrival };
  }
}

function handleSelectionCommand(event){
  if(!Selection.units.size) return true;
  const rect = canvas.getBoundingClientRect();
  const pt = screenToWorld(event.clientX - rect.left, event.clientY - rect.top);
  let clickedEnemy = null;
  let bestDistSq = Infinity;
  for(const npc of npcs){
    if(!npc || npc.dead || npc.friendly) continue;
    const dx = npc.x - pt.x;
    const dy = npc.y - pt.y;
    const distSq = dx*dx + dy*dy;
    const hitR = (npc.radius || 20) + 20;
    if(distSq < hitR*hitR && distSq < bestDistSq){
      bestDistSq = distSq;
      clickedEnemy = npc;
    }
  }
  issueMoveOrder(clickedEnemy ? { x: clickedEnemy.x, y: clickedEnemy.y } : pt, { attackMove: !!clickedEnemy });
  return true;
}

canvas.addEventListener('mousemove', e=>{
  mouse.x = e.clientX; mouse.y = e.clientY;
  mouse.overCanvas = true;
  const hasMovement = typeof e.movementX === 'number' && typeof e.movementY === 'number';
  const movementX = hasMovement ? e.movementX : ((camera.lastPointerX == null) ? 0 : e.clientX - camera.lastPointerX);
  const movementY = hasMovement ? e.movementY : ((camera.lastPointerY == null) ? 0 : e.clientY - camera.lastPointerY);
  mouse.dx += movementX;
  mouse.dy += movementY;
  camera.lastPointerX = e.clientX;
  camera.lastPointerY = e.clientY;
  if (showMap && mapView.dragging){
    mapView.followShip = false;
    mapView.viewX = (mapView.viewX ?? 0) + movementX;
    mapView.viewY = (mapView.viewY ?? 0) + movementY;
    const clamped = clampMapViewPosition(mapView.viewX, mapView.viewY);
    mapView.viewX = clamped.x;
    mapView.viewY = clamped.y;
    return;
  }
  if (PAUSED && Selection.active){
    const rect = canvas.getBoundingClientRect();
    const cur = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
    updateSelectionRect(cur);
  }
  if(stationUI.open && stationUI.dragging){
    stationUI.x = mouse.x - stationUI.dragDX;
    stationUI.y = mouse.y - stationUI.dragDY;
    stationUI.autoPosition = false;
  }
});
canvas.addEventListener('mouseenter', e=>{
  mouse.overCanvas = true;
  if(e){
    camera.lastPointerX = e.clientX;
    camera.lastPointerY = e.clientY;
  }
});
canvas.addEventListener('dragover', handleInfrastructureCanvasDragOver);
canvas.addEventListener('drop', handleInfrastructureCanvasDrop);
canvas.addEventListener('dragleave', handleInfrastructureCanvasDragLeave);
canvas.addEventListener('mouseleave', ()=>{
  mouse.overCanvas = false;
  mouse.left = false;
  mouse.right = false;
  mouse.click = false;
  mapView.dragging = false;
  scan.target = null;
  scan.scanned = null;
  scan.targetType = null;
  hideHoverInfo();
  camera.lastPointerX = null;
  camera.lastPointerY = null;
});
canvas.addEventListener('mousedown', e=>{
  if (showMap && e.button === 0) {
    mapView.dragging = true;
    mapView.followShip = false;
    const layout = syncMapViewLayout();
    if (mapView.viewX == null || mapView.viewY == null) {
      mapView.viewX = layout.targetX0;
      mapView.viewY = layout.targetY0;
    }
    const clamped = clampMapViewPosition(mapView.viewX, mapView.viewY);
    mapView.viewX = clamped.x;
    mapView.viewY = clamped.y;
    return;
  }
  if (PAUSED && !stationUI.open && e.button === 0){
    const rect = canvas.getBoundingClientRect();
    const start = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
    startSelection(start);
    return;
  }
  if(e.button===0){
    if(stationUI.open){
      const interactive = stationUI.visible && !stationUI.awaitingCamera && stationUI.appear > 0.05;
      if(interactive){
        const inX = mouse.x >= stationUI.x && mouse.x <= stationUI.x + stationUI.w;
        const inY = mouse.y >= stationUI.y && mouse.y <= stationUI.y + stationUI.h;
        if(inX && inY && mouse.y <= stationUI.y + 24){
          stationUI.dragging = true;
          stationUI.dragDX = mouse.x - stationUI.x;
          stationUI.dragDY = mouse.y - stationUI.y;
          stationUI.autoPosition = false;
        }
      }
      return;
    }
    mouse.left=true;
    if(scan.targetType === 'station' && mouse.overCanvas){
      return;
    }
    if(!stationUI.open && !warp.isBusy()) triggerRailVolley();
  }
  if(e.button===2){
    e.preventDefault();
    if (PAUSED && Selection.units.size && !stationUI.open) return;
    if(stationUI.open) return;
    mouse.right=true;
    if(!stationUI.open && !warp.isBusy()){
      const mouseWorld = screenToWorld(mouse.x, mouse.y);
      const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
      const side = (local.x >= 0) ? 'right' : 'left';
      fireRocket(side);
      rocketCooldown = ROCKET_FIRE_INTERVAL;
    }
  }
  if(e.button===1){
    e.preventDefault();
    camera.zoom = Math.abs(camera.zoom - camera.defaultZoom) < 0.03 ? camera.altZoom : camera.defaultZoom;
    camera.targetZoom = camera.zoom;
    camera.manualZoom = true;
    if(camera.transition && camera.transition.kind === 'ship') camera.transition = null;
    zoomIndicator.show(camera.zoom);
  }
});
canvas.addEventListener('mouseup', e=>{
  if (showMap && e.button === 0) {
    mapView.dragging = false;
    mouse.left = false;
    mouse.click = false;
    return;
  }
  if(e.button===0){
    if (PAUSED && Selection.active){
      finishSelection();
      return;
    }
    const wasDragging = stationUI.dragging;
    if(stationUI.dragging){
      stationUI.dragging=false;
    }
    if(stationUI.open){
      if(!wasDragging){
        mouse.click=true;
      }
      return;
    }
    mouse.left=false;
    if(!wasDragging){
      mouse.click=true;
    }
  }
  if(e.button===2){
    if (PAUSED && Selection.units.size && !stationUI.open){
      handleSelectionCommand(e);
      mouse.right=false;
      return;
    }
    if(stationUI.open) return;
    mouse.right=false;
  }
});
canvas.addEventListener('contextmenu', e=>e.preventDefault());
canvas.addEventListener('wheel', e=>{
  if (stationUI.open) return;
  e.preventDefault();
  if (showMap) {
    const zoomFactor = 1 - e.deltaY * 0.0016;
    mapView.targetZoom = clamp(mapView.targetZoom * zoomFactor, mapView.minZoom, mapView.maxZoom);
    return;
  }
  const f = 1 - e.deltaY * camera.wheelSpeed;
  camera.zoom = clamp(camera.zoom * f, camera.minZoom, camera.maxZoom);
  camera.targetZoom = camera.zoom;
  camera.manualZoom = true;
  if(camera.transition && camera.transition.kind === 'ship') camera.transition = null;
  zoomIndicator.show(camera.zoom);
}, {passive:false});

const GAMEPAD = { enabled:true, dead:0.15, last:{} };

function applyGamepad(){
  const pads = navigator.getGamepads?.() || [];
  const p = pads[0];
  if(!p) return;
  const ax = (v)=> (Math.abs(v)<GAMEPAD.dead?0:v);
  const lx = ax(p.axes[0]||0), ly = ax(p.axes[1]||0);
  const rx = ax(p.axes[2]||0), ry = ax(p.axes[3]||0);
  const forward = ly * -1;
  applyPlayerInput(ship, {
    controller: 'player',
    thrustX: lx,
    thrustY: forward,
    aimX: rx,
    aimY: ry * -1,
    main: Math.max(0, forward),
    torque: lx,
    leftSide: 0,
    rightSide: 0
  }, input);
  // przyciski
  const btn = (i)=>!!(p.buttons[i]&&p.buttons[i].pressed);
  if(btn(0)) triggerRailVolley();      // A / Cross
  if(btn(1)) fireRocket();             // B / Circle
  if(btn(2)){
    activateBoostIfAllowed();
  } else if(boost.state==='active' && !btn(2)){
    stopBoost();
  }
  if(btn(3)) attemptWarp();            // Y / Triangle
  if(btn(9)) togglePause();            // START
}

// =============== Side rockets ===============
const ROCKET_FIRE_INTERVAL = 0.11;
let rocketCooldown = 0;
let nextRocketIndexLeft = 0, nextRocketIndexRight = 0;
const SIDE_BULLET_SPEED = 760, SIDE_BULLET_DAMAGE = 20;
const SIDE_PLASMA_EXPLODE_RADIUS = 48;
const SIDE_ROCKET_TURN_RATE = 6;
const SIDE_ROCKET_HOMING_DELAY = 0.25;
const SPECIAL_COOLDOWN = 10; ship.special.cooldownTimer = 0;
const SPECIAL_DAMAGE = 1500;

function selectMissileLoadout(side){
  const entries = Game.player.weapons?.[HP.MISSILE] || [];
  const available = entries.filter(entry => entry.hp.mount && (entry.hp.ammo === null || entry.hp.ammo > 0));
  if(!available.length) return null;
  let preferred = null;
  if(side === 'left'){
    preferred = available.find(entry => (entry.hp.pos?.x || 0) <= 0);
  } else if(side === 'right'){
    preferred = available.find(entry => (entry.hp.pos?.x || 0) >= 0);
  }
  return preferred || available[0];
}

function consumeMissileAmmo(loadout){
  const hp = loadout?.hp;
  if(!hp) return false;
  if(typeof hp.ammo === 'number'){
    hp.ammo = Math.max(0, hp.ammo - 1);
  }
  rocketAmmo = missileAmmoTotal();
  saveLoadout();
  return true;
}

function getMissileStats(loadout){
  const weapon = loadout?.weapon;
  if(weapon?.missileStats) return weapon.missileStats;
  if(weapon?.aispaceMissileId) return AISPACE_MISSILES[weapon.aispaceMissileId];
  return null;
}

function fireRocket(side){
  if(!(Game.player.weapons?.[HP.MISSILE]?.length)) return;
  if(rocketAmmoMax > 0 && rocketAmmo <= 0) return;
  const loadout = selectMissileLoadout(side);
  if(!loadout) return;
  const guns = side === 'left' ? ship.sideGunsLeft : ship.sideGunsRight;
  const idx = side === 'left' ? nextRocketIndexLeft : nextRocketIndexRight;
  const gunOff = guns[idx % guns.length];
  const target = (lockedTarget && !lockedTarget.dead) ? lockedTarget : null;
  if(!consumeMissileAmmo(loadout)) return;
  const missileDef = getMissileStats(loadout);
  fireSideGunAtOffset(gunOff, side, target, missileDef);
  if(side === 'left') nextRocketIndexLeft = (idx + 1) % guns.length;
  else nextRocketIndexRight = (idx + 1) % guns.length;
}

function fireSideGunAtOffset(gunOff, side, target=null, missileDef=null){
  const gunWorld = add(ship.pos, rotate(gunOff, ship.angle));
  const dl = side === 'left' ? -1 : 1;
  const baseDir = rotate({x:dl, y:0}, ship.angle);
  const speed = missileDef?.speed || SIDE_BULLET_SPEED;
  const damage = missileDef?.dmg ?? missileDef?.damage ?? SIDE_BULLET_DAMAGE;
  const life = missileDef?.life ?? ((missileDef?.range && missileDef.speed) ? (missileDef.range / missileDef.speed) : 2.4);
  const turnRate = ((missileDef?.turn || SIDE_ROCKET_TURN_RATE) * Math.PI) / 180;
  const explodeRadius = missileDef?.radius ?? SIDE_PLASMA_EXPLODE_RADIUS;
  const homingDelay = missileDef?.homingDelay ?? SIDE_ROCKET_HOMING_DELAY;
  const swarmCount = missileDef?.swarm || 1;
  const spread = ((missileDef?.spread || 0) * Math.PI) / 180;

  for(let n=0;n<swarmCount;n++){
    const offsetAng = spread ? (Math.random() - 0.5) * spread : 0;
    const dir = rotate(baseDir, offsetAng);
    window.bullets.push({ x: gunWorld.x, y: gunWorld.y, px: gunWorld.x, py: gunWorld.y,
      vx: dir.x*speed + ship.vel.x, vy: dir.y*speed + ship.vel.y,
      life: life || 2.4, r:5, owner:'player', damage, penetration:0, type:'rocket',
      explodeRadius, homingDelay, target,
      color: missileDef?.color,
      turnRate,
      source: ship, spawnGrace: 0.08 });
  }
  spawnParticle({x:gunWorld.x, y:gunWorld.y}, {x:baseDir.x*120 + ship.vel.x*0.1, y:baseDir.y*120 + ship.vel.y*0.1}, 0.14, '#b4ffb4', 3.2, true);
  for(let k=0;k<6;k++){
    const aa = Math.atan2(baseDir.y, baseDir.x) + (Math.random()-0.5)*0.9;
    spawnParticle({x:gunWorld.x + Math.cos(aa)*6, y:gunWorld.y + Math.sin(aa)*6}, {x:Math.cos(aa)*160, y:Math.sin(aa)*160}, 0.14 + Math.random()*0.06, '#a8ff9a', 1.1, true);
  }
}

// =============== Fighters ===============
const FIGHTER_ORBIT_RADIUS = 200;  // były zbyt blisko
const FIGHTER_ORBIT_SPEED = 1.8;
const FIGHTER_ATTACK_RANGE = 1000;
const FIGHTERS_PER_LAUNCH = 10;
const FIGHTER_ACCEL = 880;
const FIGHTER_MAX_SPEED = 1180;
const FIGHTER_TURN_RATE = 9.6;
const FIGHTER_DRAG_COEFF = 2.6;
const FIGHTER_ESCORT_POSITION_GAIN = 3.0;
const FIGHTER_ESCORT_FOLLOW_GAIN = 7.5;

// Bliska eskorta - lokalne offsety względem kadłuba (w pikselach)
const FIGHTER_FORMATION = [
  {x:-150, y:-120}, {x:150, y:-120},
  {x:-190, y:-70},  {x:190, y:-70},
  {x:-190, y:-10},  {x:190, y:-10},
  {x:-150, y: 60},  {x:150, y: 60},
  {x:-100, y:-180}, {x:100, y:-180}
];


const SQUAD = {
  id: 'player_squad',
  list: [],      
  order: 'idle', 
  targets: []    
};
window.SQUAD = SQUAD;
function pickSquadTargets() {
  // Zwraca wszystkich żywych wrogów (nie-friendly)
  return npcs.filter(n => !n.friendly && !n.dead);
}
window.pickSquadTargets = pickSquadTargets;
window.spawnFighter = function() {
  // 1. Sprawdź czy statek i hangar istnieją
  if (!window.ship) return;
  
  const hasHangar = Game.player.weapons && Game.player.weapons.hangar && Game.player.weapons.hangar.length > 0;
  if(!hasHangar) { 
      if(typeof toast === 'function') toast('Brak modułu hangaru!'); 
      return; 
  }

  // 2. Definicja 2 Hangarów (Lewy i Prawy)
  const halfW = (ship.w || 60) * 0.5; 
  const halfH = (ship.h || 120) * 0.1; // Lekko przesunięte do tyłu względem środka

  const hangarSlots = [
      { x: -halfW, y: halfH, side: -1 }, // Lewa burta
      { x:  halfW, y: halfH, side:  1 }  // Prawa burta
  ];

  const createdFighters = [];

  // 3. PĘTLA: Generuj oba myśliwce natychmiast
  for (const slot of hangarSlots) {
      
      // Obliczanie pozycji w świecie (Rotacja)
      const c = Math.cos(ship.angle);
      const s = Math.sin(ship.angle);
      
      const spawnX = ship.pos.x + (slot.x * c - slot.y * s);
      const spawnY = ship.pos.y + (slot.x * s + slot.y * c);

      // Stworzenie obiektu
      const f = makeNPCBase({x: spawnX, y: spawnY}, {
        hp: 80, 
        accel: 350, 
        maxSpeed: 650, 
        turn: 7.0, 
        radius: 12
      });
      
      f.friendly = true;
      f.mission = true; 
      f.fighter = true;
      f.color = '#7cff91'; 
      
      // Fizyka Wyrzutni (Wyrzut na boki)
      const launchSpeed = 180; // Trochę mocniejszy wyrzut
      // Wektor boczny (prostopadły do kadłuba)
      const sideDirX = c; 
      const sideDirY = s;
      
      f.vx = ship.vel.x + (sideDirX * launchSpeed * slot.side);
      f.vy = ship.vel.y + (sideDirY * launchSpeed * slot.side);
      f.angle = ship.angle; 

      // Uzbrojenie
      f.gun = 'laserS'; 
      f.msl = 'AF'; f.mslAmmo = 4;
      f.gunCD = 0.5; 

      // Zarządzanie eskadrą
      if (!window.SQUAD) window.SQUAD = { list: [], order: 'idle', targets: [] };
      
      // WAŻNE: Pobieramy aktualną długość listy dla KAŻDEGO myśliwca z osobna,
      // żeby zajęły różne miejsca w formacji
      const idx = window.SQUAD.list.length;
      f.formIndex = idx;
      
      // Pozycja w formacji "V"
      const row = Math.floor((idx + 1) / 2);
      const formSide = (idx % 2 === 0) ? 1 : -1;
      f.formationOffset = { x: -140 - (row * 50), y: formSide * (60 + row * 30) };

      f.squad = { leader: ship, type: 'fighter' }; 
      
      // AI
      f.ai = (dt) => { if(window.runAdvancedFighterAI) window.runAdvancedFighterAI(f, dt); };

      // Dodanie do gry
      window.SQUAD.list.push(f);
      npcs.push(f);
      createdFighters.push(f);

      // Efekt dymu przy wylocie
      if(window.spawnParticle) {
          for(let i=0; i<4; i++) {
              window.spawnParticle(
                  {x: spawnX, y: spawnY}, 
                  {x: ship.vel.x + (Math.random()-0.5)*40, y: ship.vel.y + (Math.random()-0.5)*40}, 
                  0.3, '#ffffff', 2 + Math.random()*2, false
              );
          }
      }
  }
  
  return createdFighters;
};
 


function lineOffsets(count, spacing){
  const start = -((count - 1) * spacing) / 2;
  const arr = [];
  for(let i=0;i<count;i++) arr.push(start + i * spacing);
  return arr;
}

function buildMercSwarmQueue(station){
  if(!station) return [];
  const toPlayer = norm({ x: ship.pos.x - station.x, y: ship.pos.y - station.y });
  const right = { x: -toPlayer.y, y: toPlayer.x };
  const baseDist = station.r + 220;
  const rowSpacing = 200;
  const queue = [];

  const addRow = (kinds, dist, spacing) => {
    const offsets = lineOffsets(kinds.length, spacing);
    kinds.forEach((kind, idx) => {
      const offset = offsets[idx];
      queue.push({
        kind,
        pos: {
          x: station.x + toPlayer.x * dist + right.x * offset,
          y: station.y + toPlayer.y * dist + right.y * offset
        },
        offset,
        right,
        forward: toPlayer
      });
    });
  };

  addRow(new Array(10).fill('fighter_squad'), baseDist + rowSpacing * 3, 180);
  addRow([...new Array(5).fill('frigate_pd'), ...new Array(2).fill('frigate_laser')], baseDist + rowSpacing * 2, 210);
  addRow(new Array(5).fill('destroyer'), baseDist + rowSpacing, 240);
  addRow(new Array(3).fill('battleship'), baseDist, 300);
  return queue;
}

function resetSwarmQueue(){
  if(!mercMission || !mercMission.swarm) return;
  mercMission.swarm.timer = 0.5;
  const st = mercMission.station;
  const formationQueue = buildMercSwarmQueue(st);
  if(formationQueue.length){
    mercMission.swarm.queue = formationQueue;
    return;
  }
  // Fallback jeśli nie da się zbudować formacji
  const types = ['fighter_squad', 'interceptor', 'frigate_pd'];
  mercMission.swarm.queue = [];
  for(let i=0; i<5; i++){
     mercMission.swarm.queue.push(types[Math.floor(Math.random()*types.length)]);
  }
}
window.resetSwarmQueue = resetSwarmQueue;



function enterPirateInnerOrbit(){
  if (!mercMission || !mercMission.station) return;
  if (mercMission.alertStage !== 'engage') {
    mercMission.alertStage = 'engage';
  }
  if (!mercMission.aggro) triggerMercAggro('player_inner_orbit');
}

function triggerMercAggro(reason){
  if(!mercMission) return;
  mercMission.aggro = true;
  mercMission.aggroReason = mercMission.aggroReason || reason;
  mercMission.alertStage = 'engage';

  // --- ZMIANA: Zamiast clearPirateGuardState(), robimy to ręcznie dla nowego AI ---
  for(const npc of npcs){
    if(npc.mission && npc.isPirate && !npc.dead){
      // Przełącz w tryb ataku
      npc.state = 'engage_formation';
      // Odłącz od stacji (przestań orbitować)
      npc.guardStation = null;
      // Reset celu
      npc.forceTarget = null;
      npc.target = null;
    }
  }

  if(mercMission.swarm){
    mercMission.swarm.active = true;
    if(!mercMission.swarm.queue || !mercMission.swarm.queue.length) resetSwarmQueue();
    if(!mercMission.swarm.timer || mercMission.swarm.timer > 1.2) mercMission.swarm.timer = 1.2;
  }
}


// =============== Rail (2 lufy: serie A→B, A→B) ===============
const RAIL_SPEED = 2600, RAIL_PEN = 3, RAIL_DAMAGE = 60;
const ARMATA_SPLASH_RADIUS = 140;
const ARMATA_SPLASH_FALLOFF_MIN = 0.2;
const BASE_MAIN_BEHAVIOR = {
  id: 'default',
  priority: 1,
  cooldown: 0.38,
  burstsPerClick: 2,
  shotGap: 0.07,
  burstGap: 0.18,
  recoilKick: 14,
  recoilMax: 12,
  barrelsPerShot: 2,
  muzzleFx: spawnRailMuzzle,
  hitFx: spawnRailHitEffect,
  projectile: {
    type: 'rail',
    speed: RAIL_SPEED,
    life: 2.0,
    radius: 4,
    penetration: RAIL_PEN,
    effectScale: 1.0,
    vfxKey: 'rail'
  },
};

function createMainWeaponBehavior(overrides = {}) {
  const projectileOverrides = overrides.projectile || {};
  const behavior = {
    ...BASE_MAIN_BEHAVIOR,
    ...overrides,
    projectile: {
      ...BASE_MAIN_BEHAVIOR.projectile,
      ...projectileOverrides,
    },
    muzzleFx: overrides.muzzleFx || BASE_MAIN_BEHAVIOR.muzzleFx,
    hitFx: overrides.hitFx || BASE_MAIN_BEHAVIOR.hitFx,
  };
  behavior.id = overrides.id || behavior.id;
  behavior.priority = overrides.priority ?? behavior.priority ?? BASE_MAIN_BEHAVIOR.priority;
  behavior.barrelsPerShot = overrides.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot;
  return behavior;
}

const MAIN_WEAPON_BEHAVIOR = {
  default: createMainWeaponBehavior(),
  railgun_mk2: createMainWeaponBehavior({ id: 'railgun_mk2', priority: 2 }),
  armata_mk1: createMainWeaponBehavior({
    id: 'armata_mk1',
    priority: 3,
    cooldown: 1.8,
    burstsPerClick: 1,
    shotGap: 0,
    burstGap: 0.32,
    recoilKick: 20,
    recoilMax: 18,
    barrelsPerShot: 1,
    muzzleFx: spawnArmataMuzzle,
    hitFx: spawnArmataHitEffect,
    projectile: {
      type: 'armata',
      speed: RAIL_SPEED * 0.78,
      life: 2.6,
      radius: 6,
      penetration: 0,
      explodeRadius: ARMATA_SPLASH_RADIUS,
      effectScale: 1.4,
      vfxKey: 'armata'
    },
  }),
  heavy_autocannon: createMainWeaponBehavior({
    id: 'heavy_autocannon',
    priority: 4,
    cooldown: 0.16,
    burstsPerClick: 1,
    shotGap: 0.045,
    burstGap: 0.1,
    recoilKick: 8,
    recoilMax: 10,
    barrelsPerShot: 1,
    projectile: {
      type: 'autocannon',
      speed: RAIL_SPEED * 0.82,
      life: 1.6,
      radius: 3,
      penetration: 1,
      effectScale: 0.9,
      vfxKey: 'autocannon'
    },
    muzzleFx: spawnAutocannonMuzzle,
    hitFx: spawnAutocannonHitEffect,
  }),
};
function fireAispaceMainShot(def, context){
  const target = (context.target && !context.target.dead) ? context.target
    : ((lockedTarget && !lockedTarget.dead) ? lockedTarget : null);
  spawnBulletAdapter(ship, target, def, {
    type: def.isBeam ? 'beam' : undefined,
    origin: context.muzzle.pos,
    originVel: context.muzzle.baseVel,
    angleOverride: context.turret.angle
  });
  return {
    cooldown: def.rps ? 1 / def.rps : undefined,
    recoilKick: def.isBeam ? 6 : undefined,
    recoilMax: def.isBeam ? 10 : undefined
  };
}
function createAispaceMainBehavior(id, def){
  const projectileType = def.isBeam ? 'beam'
    : (def.name?.toLowerCase().includes('rail') ? 'rail'
    : (def.name?.toLowerCase().includes('auto') || def.name?.toLowerCase().includes('gatling')) ? 'autocannon'
    : 'plasma');
  const projectileLife = (def.range && def.speed) ? (def.range / def.speed) : BASE_MAIN_BEHAVIOR.projectile.life;
  return createMainWeaponBehavior({
    id,
    priority: 5,
    cooldown: def.rps ? 1 / def.rps : BASE_MAIN_BEHAVIOR.cooldown,
    burstsPerClick: 1,
    shotGap: 0,
    burstGap: 0,
    recoilKick: def.isBeam ? 6 : 10,
    recoilMax: def.isBeam ? 10 : 14,
    barrelsPerShot: 1,
    projectile: {
      type: projectileType,
      speed: def.speed || BASE_MAIN_BEHAVIOR.projectile.speed,
      life: projectileLife,
      radius: def.isBeam ? 5 : 4,
      penetration: projectileType === 'rail' ? 2 : 0,
      effectScale: 1.0,
      color: def.color,
      vfxKey: id
    },
    customFire: ctx => fireAispaceMainShot(def, ctx)
  });
}
for (const [weaponId, weapon] of Object.entries(AISPACE_HARDPOINT_WEAPONS)) {
  if (weapon.type === HP.MAIN && weapon.aispaceDef) {
    MAIN_WEAPON_BEHAVIOR[weaponId] = createAispaceMainBehavior(weaponId, weapon.aispaceDef);
  }
}
MAIN_WEAPON_BEHAVIOR.railgun_mk1 = MAIN_WEAPON_BEHAVIOR.default;

const rail = {
  cd: [0, 0],
  cdMax: MAIN_WEAPON_BEHAVIOR.default.cooldown,
  shotGap: MAIN_WEAPON_BEHAVIOR.default.shotGap,
  burstGap: MAIN_WEAPON_BEHAVIOR.default.burstGap,
  burstsPerClick: MAIN_WEAPON_BEHAVIOR.default.burstsPerClick,
  barrelsPerShot: MAIN_WEAPON_BEHAVIOR.default.barrelsPerShot,
  queue: [],
  nextStart: 0,
  behaviorId: MAIN_WEAPON_BEHAVIOR.default.id,
};
let railTimer = 0;

rebuildHardpointsForFrame();
loadLoadout();

function computeTurretMuzzle(turret, barIndex, barrelsPerShot){
  const spriteScale = ship.visual?.spriteScale || 1;
  const forwardLen = Math.min((ship.h * spriteScale) * 0.40, 52 * spriteScale);
  const gap = 10 * spriteScale;
  const normalizedIndex = Math.min(barIndex, barrelsPerShot - 1);
  const offsetFrac = barrelsPerShot === 1 ? 0 : (normalizedIndex / (barrelsPerShot - 1) - 0.5) * 2;
  const lateralOffset = (gap * 0.5) * offsetFrac;
  const a = turret.angle;
  const f = {x:Math.cos(a), y:Math.sin(a)};
  const p = {x:-Math.sin(a), y:Math.cos(a)};
  const off = rotate(turret.offset, ship.angle);
  const pos = {
    x: ship.pos.x + off.x + f.x * forwardLen + p.x * lateralOffset,
    y: ship.pos.y + off.y + f.y * forwardLen + p.y * lateralOffset
  };
  return {
    pos,
    dir: f,
    baseVel: { x: ship.vel.x, y: ship.vel.y }
  };
}

function triggerRailVolley(){
  if(!(Game.player.weapons?.[HP.MAIN]?.length)) return;
  if(rail.queue.length) return;
  const start = rail.nextStart; rail.nextStart ^= 1;
  const barrels = Math.max(1, rail.barrelsPerShot || 2);
  const orderPair = barrels === 1 ? [0] : [start, 1 - start];
  for(let b=0;b<rail.burstsPerClick;b++){
    const baseDelay = b * (orderPair.length * rail.shotGap + rail.burstGap);
    for(let idx = 0; idx < orderPair.length; idx++){
      rail.queue.push({ timer: baseDelay + idx * rail.shotGap, barrel: orderPair[idx] });
    }
  }
}
function fireRailBarrel(barIndex){
  const mainWeapons = Game.player.weapons?.[HP.MAIN] || [];
  if(!mainWeapons.length) return;
  const turrets = [ship.turret, ship.turret2, ship.turret3, ship.turret4];
  const activeCount = Math.min(mainWeapons.length, turrets.length);
  let maxCooldown = 0;
  for(let i=0;i<activeCount;i++){
    const t = turrets[i];
    const weaponData = mainWeapons[i]?.weapon;
    const behavior = getMainWeaponBehaviorForWeaponId(weaponData?.id);
    const projectile = behavior.projectile || BASE_MAIN_BEHAVIOR.projectile;
    const barrelsPerShot = Math.max(1, behavior.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot);
    const muzzle = computeTurretMuzzle(t, barIndex, barrelsPerShot);
    let fireResult = null;
    if (behavior.customFire) {
      fireResult = behavior.customFire({ turret: t, muzzle, weapon: weaponData, target: lockedTarget, behavior });
    } else {
      const damage = weaponData?.damage ?? weaponData?.dps ?? RAIL_DAMAGE;
      const vfxKey = projectile.vfxKey || weaponData?.id || projectile.type;
      const vfxColor = projectile.color || weaponData?.color;
      window.bullets.push({
        x: muzzle.pos.x,
        y: muzzle.pos.y,
        vx: muzzle.dir.x * (projectile.speed ?? RAIL_SPEED) + ship.vel.x,
        vy: muzzle.dir.y * (projectile.speed ?? RAIL_SPEED) + ship.vel.y,
        life: projectile.life ?? 2.0,
        r: projectile.radius ?? 4,
        owner: 'player',
        damage,
        penetration: (projectile.penetration != null) ? projectile.penetration : RAIL_PEN,
        type: projectile.type || 'rail',
        weaponId: weaponData?.id,
        color: projectile.color,
        effectScale: projectile.effectScale ?? 1.0,
        explodeRadius: projectile.explodeRadius,
        vfxKey,
        vfxColor,
        hitFx: projectile.type === 'beam'
          ? null
          : (behavior.hitFx
            ? (x, y, scale) => behavior.hitFx(x, y, scale)
            : (x, y, scale) => spawnWeaponImpactFromPreset(resolveBulletVfxKey(vfxKey, projectile.type), vfxColor, scale, x, y)),
      });
    }
    const recoilKick = fireResult?.recoilKick ?? behavior.recoilKick ?? t.recoilKick;
    const recoilMax = fireResult?.recoilMax ?? behavior.recoilMax ?? t.recoilMax;
    t.recoil = Math.min(t.recoil + recoilKick, recoilMax);
    const muzzleFx = behavior.muzzleFx || spawnRailMuzzle;
    if (muzzleFx && projectile.type !== 'beam') {
      muzzleFx(muzzle.pos, muzzle.dir, ship.vel, projectile.effectScale ?? 1.0);
    }
    maxCooldown = Math.max(maxCooldown, fireResult?.cooldown ?? behavior.cooldown ?? rail.cdMax);
  }
  rail.cd[barIndex] = maxCooldown || rail.cdMax;
}

// =============== CIWS (point-defence) ===============
const CIWS_FIRE_INTERVAL = 0.06;
const CIWS_BULLET_SPEED = 900;
const CIWS_DAMAGE = 8;
const CIWS_RANGE = 600;

const SIEGE_CANNON_COOLDOWN = 5.2;
const SIEGE_CANNON_DAMAGE = 200;
const SIEGE_CANNON_SPEED = 1700;
const SIEGE_CANNON_RANGE = 1800;
const SIEGE_CANNON_SPREAD = 0.0045;
const SIEGE_CANNON_LIFE = 1.1 * (SIEGE_CANNON_RANGE / SIEGE_CANNON_SPEED);

const LASER_PD_FIRE_INTERVAL = 0.18;
const LASER_PD_DAMAGE = 16;
const LASER_PD_RANGE = 620;
const LASER_PD_BEAM_WIDTH = 6;

function ciwsStep(dt){
  const auxWeapons = Game.player.weapons?.[HP.AUX] || [];
  for(let i=0;i<ship.ciws.length;i++){
    if(i >= auxWeapons.length) break;
    const loadout = auxWeapons[i];
    if(!loadout || !loadout.weapon) continue;
    const weaponId = loadout.weapon.id;
    const pdDef = loadout.weapon.aispacePdId ? AISPACE_PD[loadout.weapon.aispacePdId] : null;
    const flakDef = loadout.weapon.aispaceFlakId ? AISPACE_FLAK[loadout.weapon.aispaceFlakId] : null;
    const isLaser = weaponId === 'laser_pd_mk1' || loadout.weapon.aispacePdId === 'pd_laser';
    const stats = pdDef || flakDef;
    const gun = ship.ciws[i];
    gun.cd = Math.max(0, gun.cd - dt);
    const off = rotate(gun.offset, ship.angle);
    const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
    const baseVel = { x: ship.vel.x - ship.angVel * off.y, y: ship.vel.y + ship.angVel * off.x };
    const range = stats?.range || (isLaser ? LASER_PD_RANGE : CIWS_RANGE);
    let target = null; let dist = range;
    for(const npc of npcs){
      if(npc.dead || npc.friendly || !npc.isPirate) continue;
      const d = Math.hypot(npc.x - base.x, npc.y - base.y);
      if(d < dist){ dist = d; target = npc; }
    }
    if(!target) continue;

    const aimPoint = isLaser ? { x: target.x, y: target.y }
                             : leadTarget(base, baseVel, target, stats?.speed || CIWS_BULLET_SPEED);
    const desired = Math.atan2(aimPoint.y - base.y, aimPoint.x - base.x);
    let diff = wrapAngle(desired - gun.angle);
    const aimStrength = isLaser ? 9 : 8;
    const maxVel = isLaser ? 6.5 : 6;
    let desiredVel = clamp(diff * aimStrength, -maxVel, maxVel);
    const velDelta = desiredVel - gun.angVel;
    const maxDelta = 40 * dt;
    gun.angVel += clamp(velDelta, -maxDelta, maxDelta);
    gun.angVel *= Math.exp(-8 * dt);
    gun.angVel = clamp(gun.angVel, -maxVel, maxVel);
    gun.angle = wrapAngle(gun.angle + gun.angVel * dt);

    const aimTolerance = isLaser ? 0.1 : 0.15;
    if(Math.abs(diff) >= aimTolerance || gun.cd > 0) continue;

    const fireInterval = stats?.rps ? (1 / stats.rps) : (isLaser ? LASER_PD_FIRE_INTERVAL : CIWS_FIRE_INTERVAL);
    if(flakDef){
      fireAispaceFlakShell(gun, base, baseVel, target, flakDef, fireInterval);
    } else if(isLaser){
      firePointDefenseLaser(gun, base, baseVel, target, pdDef, fireInterval);
    } else {
      fireCIWSGun(gun, base, baseVel, pdDef, fireInterval);
    }
  }
}

function fireCIWSGun(gun, base, baseVel, stats, fireInterval){
  const dir = { x: Math.cos(gun.angle), y: Math.sin(gun.angle) };
  const px = base.x + dir.x * 6;
  const py = base.y + dir.y * 6;
  const damage = stats?.dmg ?? stats?.damage ?? CIWS_DAMAGE;
  const speed = stats?.speed ?? CIWS_BULLET_SPEED;
  window.bullets.push({
    x:px,
    y:py,
    vx: dir.x*speed + baseVel.x,
    vy: dir.y*speed + baseVel.y,
    life:1.2,
    r:2,
    owner:'player',
    damage,
    color: stats?.color,
    type:'ciws'
  });
  spawnParticle(
    {x:px, y:py},
    {x:dir.x*120 + baseVel.x*0.1, y:dir.y*120 + baseVel.y*0.1},
    0.06,
    '#ffdf9e',
    2.0,
    true
  );
  gun.cd = fireInterval ?? CIWS_FIRE_INTERVAL;
}

function firePointDefenseLaser(gun, base, baseVel, target, stats, fireInterval){
  const dir = { x: Math.cos(gun.angle), y: Math.sin(gun.angle) };
  const muzzle = { x: base.x + dir.x * 6, y: base.y + dir.y * 6 };
  const toTarget = { x: target.x - muzzle.x, y: target.y - muzzle.y };
  const range = stats?.range ?? LASER_PD_RANGE;
  const damage = stats?.dmg ?? LASER_PD_DAMAGE;
  const distance = clamp(Math.hypot(toTarget.x, toTarget.y), 0, range);
  const beamEnd = { x: muzzle.x + dir.x * distance, y: muzzle.y + dir.y * distance };

  spawnLaserBeam(muzzle, beamEnd, LASER_PD_BEAM_WIDTH, {
    life: 0.09,
    colorOuter: stats?.color || 'rgba(110,200,255,0.9)',
    colorInner: 'rgba(250,255,255,1.0)',
    glowColor: stats?.color || 'rgba(90,180,255,0.95)',
    glowBlur: 22,
    outerWidthMul: 1.05,
    innerWidthMul: 0.45
  });
  spawnPointDefenseLaserMuzzle(muzzle, dir, baseVel);
  spawnPointDefenseLaserHit(beamEnd.x, beamEnd.y);
  applyDamageToNPC(target, damage, 'laser_pd');
  gun.cd = fireInterval ?? LASER_PD_FIRE_INTERVAL;
}

function fireAispaceFlakShell(gun, base, baseVel, target, flakDef, fireInterval){
  spawnBulletAdapter(ship, target, flakDef, {
    type: 'armata',
    origin: base,
    originVel: baseVel,
    angleOverride: gun.angle
  });
  gun.cd = fireInterval ?? (flakDef?.rps ? 1 / flakDef.rps : CIWS_FIRE_INTERVAL);
}

function spawnPointDefenseLaserMuzzle(pos, dir, baseVel){
  const tangential = { x: -dir.y, y: dir.x };
  for(let i=0;i<3;i++){
    const spread = (Math.random()-0.5) * 0.6;
    const vel = {
      x: dir.x * (220 + Math.random()*80) + tangential.x * spread * 80 + baseVel.x * 0.1,
      y: dir.y * (220 + Math.random()*80) + tangential.y * spread * 80 + baseVel.y * 0.1
    };
    spawnParticle(
      { x: pos.x, y: pos.y },
      vel,
      0.08 + Math.random()*0.05,
      '#8fe4ff',
      2.2 + Math.random()*0.8,
      true
    );
  }
}

function spawnPointDefenseLaserHit(x, y){
  for(let i=0;i<12;i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 160 + Math.random() * 200;
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.16 + Math.random()*0.14,
      '#78d9ff',
      1.4 + Math.random()*1.6,
      true
    );
  }
  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.05, '#ffffff', 4.4, true);
  spawnShockwave(x, y, { r: 5, maxR: 70, w: 2.4, maxLife: 0.35, color: 'rgba(110,200,255,' });
}

// =============== Specjal & dmg ===============
function tryFireSpecial(){
  if(!(Game.player.weapons?.[HP.SPECIAL]?.length)) return;
  if(ship.special.cooldownTimer>0) return;
  ship.special.cooldownTimer = SPECIAL_COOLDOWN;
  const dir = rotate({x:0,y:-1}, ship.angle);
  const start = add(ship.pos, rotate({x:0, y:-ship.h/2}, ship.angle));
  const length = 2000;
  const end = { x: start.x + dir.x*length, y: start.y + dir.y*length };
  const width = ship.w;
  const npcsInRange = npcs.filter(npc => !npc.dead && Math.hypot(npc.x - start.x, npc.y - start.y) < length + npc.radius);
  let hits = 0;
  const HIT_CAP = 80; // wystarczająco dużo, by czuć „miotłę”, ale bez zgonu CPU
  for (const npc of npcsInRange){
    if (hits >= HIT_CAP) break;
    const vx = npc.x - start.x, vy = npc.y - start.y;
    const proj = vx*dir.x + vy*dir.y;
    if (proj < 0 || proj > length) continue;
    const perp = Math.abs(vx*dir.y - vy*dir.x);
    if (perp <= npc.radius + width*0.5){
      applyDamageToNPC(npc, SPECIAL_DAMAGE, 'none');
      if ((hits & 1) === 0) spawnParticle({x:npc.x, y:npc.y}, {x:0,y:0}, 0.10, '#9ccfff', 5, true);
      hits++;
    }
  }
  spawnLaserBeam(start, end, width);
  for(let i=0;i<8;i++){
    const t = i/7;
    const px = start.x + dir.x*length*t + (Math.random()-0.5)*width*0.3;
    const py = start.y + dir.y*length*t + (Math.random()-0.5)*width*0.3;
    spawnParticle({x:px, y:py}, {x:(Math.random()-0.5)*120, y:(Math.random()-0.5)*120}, 0.2, '#9ccfff', 2.5, true);
  }
}

function handlePlayerDestroyed(){
  if (ship.destroyed) return;
  ship.destroyed = true;
  input.main = input.leftSide = input.rightSide = input.torque = 0;
  applyPlayerInput(ship, { controller:'player', main:0, thrustX:0, thrustY:0, leftSide:0, rightSide:0, torque:0 }, input);
  ship.command = null;
  stopBoost();
  if (warp.state !== 'idle') {
    warp.state = 'idle';
    warp.charge = 0;
  }

  const reactorY = ship.pos.y + ship.h * 0.08;
  triggerReactorBlow3D(ship.pos.x, reactorY, ship.h * 0.35);
}

function applyDamageToPlayer(amount){
  const prevHull = ship.hull.val;
  if(ship.shield.val>0){ const s = Math.min(ship.shield.val, amount); ship.shield.val -= s; amount -= s; ship.shield.regenTimer = ship.shield.regenDelay; }
  if(amount>0) ship.hull.val = Math.max(0, ship.hull.val - amount);
  if (!ship.destroyed && prevHull > 0 && ship.hull.val <= 0) {
    handlePlayerDestroyed();
  }
  hudSpawnDMG(ship.pos.x, ship.pos.y - ship.h*0.4, amount, 'player');
}
function applyDamageToNPC(npc, dmg, cause='default'){
  if(npc.dead) return;
  if(!Number.isFinite(dmg) || dmg <= 0) return;
  npc.hitFlash = 0.12;
  npc.damageHue = (npc.damageHue || 0) + dmg;

  let remaining = dmg;
  if (npc.shield && npc.shield.max > 0){
    npc.shield.regenTimer = npc.shield.regenDelay ?? 0;
    const absorbed = Math.min(npc.shield.val, remaining);
    if (absorbed > 0){
      npc.shield.val -= absorbed;
      remaining -= absorbed;
      if (npc.fleetEntry){
        npc.fleetEntry.status.shield = npc.shield.val;
        markFleetDirty();
      }
    }
  }

  if(remaining <= 0){
    return;
  }

  npc.hp -= remaining;
  hudSpawnDMG(npc.x, npc.y - (npc.radius||20)*0.8, remaining, 'npc');
  if (npc.fleetEntry){
    npc.fleetEntry.status.hull = npc.hp;
    markFleetDirty();
  }
  if(npc.hp<=0){
    npc.dead = true; npc.respawnTimer = 3 + Math.random()*6;
    if(cause === 'plasma'){ spawnExplosionPlasma(npc.x, npc.y, 1.2); }
    else if(cause === 'default'){ spawnDefaultHit(npc.x, npc.y, 1.2); }
  }
}

function applyDamageToStation(station, amount){
  let dmg = amount || 0;
  if(dmg <= 0) return 0;
  if(station.shield){
    station.shield.regenTimer = station.shield.regenDelay;
    const absorbed = Math.min(station.shield.val, dmg);
    station.shield.val -= absorbed;
    dmg -= absorbed;
  }
  if(dmg > 0){
    station.hp = Math.max(0, station.hp - dmg);
  }
  return dmg;
}

function applyDamageToPlatform(platform, amount){
  if(!platform || platform.destroyed) return 0;
  let dmg = amount || 0;
  if(dmg <= 0) return 0;
  if(platform.shield){
    platform.shield.regenTimer = platform.shield.regenDelay;
    const absorbed = Math.min(platform.shield.val, dmg);
    platform.shield.val -= absorbed;
    dmg -= absorbed;
  }
  if(dmg > 0){
    platform.hp = Math.max(0, platform.hp - dmg);
  }
  platform.hitFlash = 0.18;
  hudSpawnDMG(platform.x, platform.y - platform.radius * 0.65, amount, 'npc');
  if(platform.hp <= 0 && !platform.destroyed){
    platform.destroyed = true;
    platform.deathTimer = 0;
    spawnExplosionPlasma(platform.x, platform.y, 1.4);
    spawnShockwave(platform.x, platform.y, { maxR: 420, maxLife: 0.6, color: 'rgba(255,140,120,' });
  }
  return dmg;
}

function bulletsAndCollisionsStep(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.px = b.x; b.py = b.y;
    b.x += b.vx * dt; b.y += b.vy * dt;
    b.life -= dt;
    b.age = (b.age || 0) + dt; // krótki „grace” po wystrzale

    if(b.type === 'plasma' || b.type === 'rocket'){
      const trailVel = { x: -b.vx*0.02 + (Math.random()-0.5)*10, y: -b.vy*0.02 + (Math.random()-0.5)*10 };
      spawnParticle({x:b.x + (Math.random()-0.5)*3, y:b.y + (Math.random()-0.5)*3}, trailVel, 0.28, '#8cff8c', 1.0, false);
      if(b.type === 'rocket'){
        if(b.homingDelay > 0){
          b.homingDelay -= dt;
        } else {
          // HOMING: NPC -> gracz, player -> cele (NPC)
          let target = null;

          if (b.owner !== 'player') {
            // rakiety piratów zawsze gonią gracza
            target = { x: ship.pos.x, y: ship.pos.y };
          } else if (b.target && !b.target.dead) {
            target = { x: b.target.x, y: b.target.y };
          } else if (lockedTargets.length){
            let dist = Infinity, chosen = null;
            for(const t of lockedTargets){
              if(t.dead) continue;
              const d = Math.hypot(t.x - b.x, t.y - b.y);
              if(d < dist){ dist = d; chosen = t; }
            }
            if(chosen) target = { x: chosen.x, y: chosen.y };
          } else if (lockedTarget && !lockedTarget.dead){
            target = { x: lockedTarget.x, y: lockedTarget.y };
          } else {
            let dist = Infinity;
            for(const npc of npcs){
              if(npc.dead) continue;
              // graczowe rakiety nie strzelają w sojusznicze (friendly) cele
              if (b.owner==='player' && npc.friendly) continue;
              const d = Math.hypot(npc.x - b.x, npc.y - b.y);
              if(d < dist){ dist = d; target = {x:npc.x, y:npc.y}; }
            }
            if(!target){
              const mouseWorld = screenToWorld(mouse.x, mouse.y);
              target = { x: mouseWorld.x, y: mouseWorld.y };
            }
          }

          const speed = Math.hypot(b.vx, b.vy);
          const dir = norm({x:target.x - b.x, y:target.y - b.y});
          const current = Math.atan2(b.vy, b.vx);
          const desired = Math.atan2(dir.y, dir.x);
          const diff = wrapAngle(desired - current);
          const turnRate = (b.turnRate != null) ? b.turnRate : SIDE_ROCKET_TURN_RATE;
          const maxTurn = turnRate * dt;
          const turn = Math.abs(diff) < maxTurn ? diff : Math.sign(diff) * maxTurn;
          const newAng = current + turn;
          b.vx = Math.cos(newAng) * speed;
          b.vy = Math.sin(newAng) * speed;
        }
      }
    } else if(b.type === 'autocannon'){
      const trailVel = {
        x: -b.vx * 0.015 + (Math.random() - 0.5) * 28,
        y: -b.vy * 0.015 + (Math.random() - 0.5) * 28
      };
      const color = (Math.random() < 0.45) ? '#ffdca8' : '#ffb86b';
      spawnParticle(
        { x: b.x + (Math.random() - 0.5) * 2, y: b.y + (Math.random() - 0.5) * 2 },
        trailVel,
        0.18,
        color,
        1.1,
        true
      );
      if(Math.random() < 0.35){
        spawnParticle(
          { x: b.x, y: b.y },
          { x: -trailVel.x * 0.4, y: -trailVel.y * 0.4 },
          0.26,
          'rgba(90,110,180,0.4)',
          1.8,
          false
        );
      }
    }

    if(b.life <= 0){ bullets.splice(i,1); continue; }

    // hit NPC (z pominięciem własnego źródła w czasie grace)
    let hitNPC = null;
    for (const npc of npcs){
      if (npc.dead || npc.isCollidable === false) continue;
      
      // --- FIX FRIENDLY FIRE ---
      // Gracz nie trafia sojuszników
      if (b.owner === 'player' && npc.friendly) continue;
      // NPC (pirat) nie trafia innych piratów
      if (b.owner === 'npc' && !npc.friendly) continue; 
      // -------------------------

      if (b.source && b.source === npc && b.age < (b.spawnGrace || 0)) continue;
      const d = Math.hypot(npc.x - b.x, npc.y - b.y);
      if (d < npc.radius + b.r){ hitNPC = npc; break; }
    }

    if(hitNPC){
      const npcDamage = Number.isFinite(b.damage) ? b.damage : 0;
      const npcShieldVal = hitNPC.shield?.val || 0;
      const npcImpactDamage = Math.max(0, npcDamage - npcShieldVal);
      let hexHit = false;
      if (npcImpactDamage > 0 && hitNPC.hexGrid) {
          hexHit = DestructorSystem.applyImpact(hitNPC, b.x, b.y, npcImpactDamage, {x: b.vx, y: b.vy});
      }

      if(b.owner === 'player' && hitNPC.mission && hitNPC.isPirate){
        triggerMercAggro('pirate_hit');
      }

      if (hitNPC.shield && hitNPC.shield.val > 0) {
        registerShieldImpact(hitNPC, b.x, b.y, npcDamage);
      }

      // --- FIX: OBSŁUGA RÓŻNYCH TYPÓW TRAFIEŃ ---

      if(b.type === 'plasma' || b.type === 'rocket'){
        // Zielona plazma LUB Rakieta -> Wybuch obszarowy
        const ex = b.x, ey = b.y;
        spawnExplosionPlasma(ex, ey, b.type==='rocket' ? 1.5 : 1.0); // Rakiety większe

        // Splash damage
        for(const npc of npcs){
          if(npc.dead || (b.owner==='player' && npc.friendly)) continue;
          // Friendly fire check dla NPC
          if(b.owner==='npc' && !npc.friendly) continue;

          const d2 = Math.hypot(npc.x - ex, npc.y - ey);
          if(d2 <= b.explodeRadius + npc.radius){
            const falloff = 1 - (d2 / (b.explodeRadius + npc.radius));
            const splashDmg = Math.round(b.damage * (0.9 * falloff + 0.1));

            if (npc.hexGrid) {
                const splashVx = (npc.x - ex);
                const splashVy = (npc.y - ey);
                const splashImpactDamage = Math.max(0, splashDmg - (npc.shield?.val || 0));
                if (splashImpactDamage > 0) {
                    DestructorSystem.applyImpact(npc, npc.x, npc.y, splashImpactDamage, {x: splashVx*5, y: splashVy*5});
                }
            }

            applyDamageToNPC(npc, splashDmg, 'plasma');
          }
        }
        bullets.splice(i,1);
        continue;
      }
      else if(b.type === 'armata'){
        applyDamageToNPC(hitNPC, b.damage, 'armata');
        spawnArmataHitEffect(b.x, b.y, 1.0);
        bullets.splice(i,1);
        continue;
      }
      else {
        if (!hexHit) {
            if(b.type === 'rail'){
              applyDamageToNPC(hitNPC, b.damage, 'rail');
              spawnRailHitEffect(b.x, b.y, 1.0);
            }
            else if(b.type === 'autocannon'){
              applyDamageToNPC(hitNPC, b.damage, 'autocannon');
              spawnAutocannonHitEffect(b.x, b.y, 1.0);
            }
            else {
              applyDamageToNPC(hitNPC, b.damage, 'default');
              spawnDefaultHit(b.x, b.y, 1.0);
            }
        } else {
            applyDamageToNPC(hitNPC, b.damage, 'none');
        }

        if(b.type === 'rail') {
           b.penetration = (b.penetration !== undefined) ? b.penetration - 1 : 1;
           if(b.penetration <= 0){ bullets.splice(i,1); }
        } else {
           bullets.splice(i,1);
        }
        continue;
      }
    }

    if(mercMission && mercMission.weaponPlatforms && mercMission.weaponPlatforms.length){
      let hitPlatform = false;
      for(const platform of mercMission.weaponPlatforms){
        if(!platform || platform.destroyed) continue;
        if (b.source && b.source === platform && b.age < (b.spawnGrace || 0)) continue;
        const d = Math.hypot(platform.x - b.x, platform.y - b.y);
        if(d < platform.radius + b.r){
          applyDamageToPlatform(platform, b.damage || 0);
          triggerMercAggro('platform_hit');
          if(b.hitFx){ b.hitFx(b.x, b.y, b.effectScale || 1.0, b); }
          else if(b.type === 'armata'){
            spawnArmataHitEffect(b.x, b.y, b.effectScale || 1.0);
          } else if(b.type === 'rail'){
            spawnRailHitEffect(b.x, b.y, 1.0);
          } else if(b.type === 'autocannon'){
            spawnAutocannonHitEffect(b.x, b.y, b.effectScale || 1.0);
          } else {
            spawnExplosionPlasma(b.x, b.y, 1.0);
          }
          bullets.splice(i,1);
          hitPlatform = true;
          break;
        }
      }
      if(hitPlatform) continue;
    }

    // hit mission station
    for(const st of stations){
      if(!st.hp) continue;
      if (b.source && b.source === st && b.age < (b.spawnGrace || 0)) continue;
      const d = Math.hypot(st.x - b.x, st.y - b.y);
      if(d < st.r + b.r){
        applyDamageToStation(st, b.damage || 0);
        if(mercMission && mercMission.station === st){
          triggerMercAggro('station_hit');
        }
        if(st.hp <= 0){
          if(mercMission && mercMission.station === st){
            PLAYER.credits += 10000;
            stations.splice(stations.indexOf(st),1);
            if (typeof window.dettachPirateStation3D === 'function') {
              window.dettachPirateStation3D(mainScene3D);
            }
            const m = MISSIONS.active.find(mm => mm.id === 'merc_pirate_station' && mm.status === 'active');
            if(m) m.status = 'completed';

            missionCompleteBanner.trigger('misja zakończona');
            toast('Misja zakończona: +10000 cr');
            resetMercMission();
          }
        }
        if(b.hitFx){ b.hitFx(b.x, b.y, b.effectScale || 1.0, b); }
        else if(b.type === 'armata'){
          spawnArmataHitEffect(b.x, b.y, b.effectScale || 1.0);
        } else if(b.type === 'rail'){
          spawnRailHitEffect(b.x, b.y, 1.0);
        } else if(b.type === 'autocannon'){
          spawnAutocannonHitEffect(b.x, b.y, b.effectScale || 1.0);
        } else if(b.type === 'siege'){
          spawnSiegeHitEffect(b.x, b.y, b.effectScale || 1.0);
        } else {
          spawnExplosionPlasma(b.x, b.y, 1.0);
        }
        bullets.splice(i,1);
        break;
      }
    }

    // hit player
    if(b.owner !== 'player'){
      const hitR = Math.max(ship.w, ship.h) * 0.45;
      const d = Math.hypot(ship.pos.x - b.x, ship.pos.y - b.y);
      if(d < hitR + b.r){
        const playerDamage = Number.isFinite(b.damage) ? b.damage : 0;
        const playerShieldVal = ship.shield?.val || 0;
        const playerImpactDamage = Math.max(0, playerDamage - playerShieldVal);
        if (ship.shield && ship.shield.val > 0) {
          registerShieldImpact(ship, b.x, b.y, playerDamage);
          AudioSys.playSound('shieldHit');
        }
        let hexHit = false;
        if (playerImpactDamage > 0 && ship.hexGrid) {
            hexHit = DestructorSystem.applyImpact(ship, b.x, b.y, playerImpactDamage, {x: b.vx, y: b.vy});
        }
        applyDamageToPlayer(playerDamage);
        if(!hexHit){
          if(b.hitFx){ b.hitFx(b.x, b.y, b.effectScale || 1.0, b); }
          else if(b.type === 'siege'){
            spawnSiegeHitEffect(b.x, b.y, b.effectScale || 1.0);
          } else if(b.type === 'armata'){
            spawnArmataHitEffect(b.x, b.y, b.effectScale || 1.0);
          } else if(b.type === 'rail'){
            spawnRailHitEffect(b.x, b.y, 1.0);
          } else if(b.type === 'autocannon'){
            spawnAutocannonHitEffect(b.x, b.y, b.effectScale || 1.0);
          } else {
            spawnDefaultHit(b.x, b.y, 1.0);
          }
        }
        bullets.splice(i,1);
        continue;
      }
    }
  }
}
// =============== NPC movement/shooting ===============
let npcFireTimer = 0;
function npcShootingStep(dt){
  npcFireTimer -= dt;
  if(npcFireTimer <= 0){
    npcFireTimer = 0.45 + Math.random()*0.8;
    const candidates = npcs.filter(n=>!n.dead && n.weapon && !n.friendly && Math.hypot(n.x-ship.pos.x, n.y-ship.pos.y) < 900);
    if(candidates.length){
      const shooter = candidates[Math.floor(Math.random()*candidates.length)];
      const dir = norm({x: ship.pos.x - shooter.x, y: ship.pos.y - shooter.y});
      const bx = shooter.x + dir.x*(shooter.radius+6), by = shooter.y + dir.y*(shooter.radius+6);
      if(shooter.weapon === 'railgun'){
        window.bullets.push({ x:bx, y:by, vx: dir.x*600 + shooter.vx, vy: dir.y*600 + shooter.vy, life: 2.0, r:4, owner:'npc', damage:40, type:'rail', penetration:1 });
      } else {
        window.bullets.push({ x:bx, y:by, vx: dir.x*220 + shooter.vx, vy: dir.y*220 + shooter.vy, life: 4, r:3, owner:'npc', damage:12 });
      }
    }
  }
}
function npcStep(dt){
  const DESPAWN_RADIUS_SQ = NPC_DESPAWN_RADIUS * NPC_DESPAWN_RADIUS;
  for(const npc of npcs){
    if (npc.hitFlash) npc.hitFlash = Math.max(0, npc.hitFlash - dt);
    updateShieldFx(npc, dt);

    if (npc.shield && npc.shield.max > 0){
      if (npc.shield.regenTimer > 0){
        npc.shield.regenTimer = Math.max(0, npc.shield.regenTimer - dt);
      } else if (npc.shield.val < npc.shield.max){
        npc.shield.val = Math.min(npc.shield.max, npc.shield.val + (npc.shield.regenRate || 0) * dt);
      }
    }

    // Despawn logic (poza misją)
    if(!npc.mission){
      const dx = npc.x - ship.pos.x;
      const dy = npc.y - ship.pos.y;
      if(dx*dx + dy*dy > DESPAWN_RADIUS_SQ){
        npc.dead = true;
        npc.respawnTimer = 5;
        continue;
      }
    }

    // --- LOGIKA MISJI I WALKI ---
    if(npc.mission){
      if(npc.dead) continue;
      
      // 1. Komendy RTS (priorytet)
      if (handleCommandedNpc(npc, dt)) {
        npc.vx *= (npc.friction || 0.99);
        npc.vy *= (npc.friction || 0.99);
        npc.x += (npc.vx||0)*dt;
        npc.y += (npc.vy||0)*dt;
        npc.angle = Math.atan2(npc.vy || 0, npc.vx || 0);
        continue;
      }

      // 2. AI
      if(npc.ai) npc.ai(dt);

      // 3. Fizyka (Ruch)
      npc.x += (npc.vx||0)*dt;
      npc.y += (npc.vy||0)*dt;

      // --- FIZYKA PĘDU (FRICTION) ---
      // Używamy friction z szablonu (np. 0.995 dla Destroyera - płynie długo)
      // lub domyślnego 0.92 dla małych/lekkich obiektów, żeby nie latały jak mydło.
      const friction = npc.friction || 1.0; 
      
      npc.vx *= friction;
      npc.vy *= friction;

      // 4. Obrót
      if (npc.keepAngle){
        if (typeof npc.desiredAngle === 'number') npc.angle = npc.desiredAngle;
      } else if (!npc.fighter) {
        // Myśliwce obracają się w AI, reszta tutaj
        const speed = Math.hypot(npc.vx, npc.vy);
        if(speed > 1) npc.angle = Math.atan2(npc.vy, npc.vx);
      }
      continue;
    }

    // --- LOGIKA CYWILNA (Reszta funkcji bez zmian) ---
    if(npc.dead){
      npc.respawnTimer -= dt;
      if(npc.respawnTimer<=0){
        const base = stations.find(s=>s.id===npc.lastStation) || stations[0];
        const group = stations.filter(s=>s.inner === base.inner);
        const start = group[Math.floor(Math.random()*group.length)];
        const targetId = pickNextStation(start.id, npc.type);
        const startPort = Math.floor(Math.random()*start.ports.length);
        const spawnPos = stationPortWorld(start, startPort);
        npc.x = spawnPos.x; npc.y = spawnPos.y; npc.vx = 0; npc.vy = 0;
        npc.hp = npc.maxHp; npc.dead=false; npc.target = targetId; npc.fade = 1; npc.docking=false; npc.lastStation=start.id;
        const target = stations.find(s=>s.id===targetId);
        npc.dockPort = target ? Math.floor(Math.random()*target.ports.length) : 0;
        if(target && start.inner === target.inner){
          const route = getWarpRoute(start.id, targetId);
          if(route){ npc.warpRoute = route; npc.phase = 'toGate'; npc.lane = Math.floor(Math.random()*2); }
          else { npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0; }
        } else {
          npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0;
        }
      }
      continue;
    }
    if(npc.docking){
      const st = stations.find(s=>s.id===npc.lastStation);
      if(st){ const portPos = stationPortWorld(st, npc.dockPort || 0); npc.x = portPos.x; npc.y = portPos.y; }
      npc.fade -= dt / 0.6;
      if(npc.fade <= 0 && st){
        const targetId = pickNextStation(npc.lastStation, npc.type);
        const startPort = Math.floor(Math.random()*st.ports.length);
        const spawnPos = stationPortWorld(st, startPort);
        npc.x = spawnPos.x; npc.y = spawnPos.y; npc.vx = 0; npc.vy = 0;
        npc.target = targetId; npc.fade = 1; npc.docking=false; npc.lastStation=st.id;
        const target = stations.find(s=>s.id===targetId);
        npc.dockPort = target ? Math.floor(Math.random()*target.ports.length) : 0;
        if(target && st.inner === target.inner){
          const route = getWarpRoute(st.id, targetId);
          if(route){ npc.warpRoute = route; npc.phase = 'toGate'; npc.lane = Math.floor(Math.random()*2); }
          else { npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0; }
        } else { npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0; }
      }
      continue;
    }
    if(npc.phase === 'warping'){
      npc.x += npc.vx*dt; npc.y += npc.vy*dt;
      npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
      const route = npc.warpRoute;
      const traveled = (npc.x - route.start.x) * route.dir.x + (npc.y - route.start.y) * route.dir.y;
      if(traveled >= route.length){ npc.phase = 'toStation'; npc.x = route.end.x; npc.y = route.end.y; }
      continue;
    }
    if(npc.phase === 'toGate'){
      const gate = npc.warpRoute.start;
      const start = stations.find(s=>s.id===npc.lastStation);
      const gv = { x: gate.x - start.x, y: gate.y - start.y };
      const gd = Math.hypot(gv.x, gv.y) || 1;
      const dirToGate = { x: gv.x/gd, y: gv.y/gd };
      const perp = { x: -dirToGate.y, y: dirToGate.x };
      const laneOffset = npc.lane ? 20 : -20;
      const gatePos = { x: gate.x + perp.x*laneOffset, y: gate.y + perp.y*laneOffset };
      const queue = gate.queues[npc.lane];
      let idx = queue.indexOf(npc);
      if(idx === -1){ queue.push(npc); idx = queue.length-1; }
      const spacing = 30;
      const targetPos = { x: gatePos.x - dirToGate.x * idx * spacing, y: gatePos.y - dirToGate.y * idx * spacing };
      const distGate = Math.hypot(npc.x - gatePos.x, npc.y - gatePos.y);
      if(idx === 0 && distGate < 5){
        queue.shift(); npc.phase = 'warping';
        npc.vx = npc.warpRoute.dir.x * 4000; npc.vy = npc.warpRoute.dir.y * 4000;
        npc.x = gatePos.x; npc.y = gatePos.y;
        continue;
      }
      const to = { x: targetPos.x - npc.x, y: targetPos.y - npc.y };
      const d = Math.hypot(to.x, to.y);
      if(d < 1){ npc.vx = 0; npc.vy = 0; continue; }
      const dir = { x: to.x/d, y: to.y/d };
      const desiredV = { x: dir.x*npc.speed, y: dir.y*npc.speed };
      npc.vx += (desiredV.x - (npc.vx||0)) * clamp(1.5*dt,0,1);
      npc.vy += (desiredV.y - (npc.vy||0)) * clamp(1.5*dt,0,1);
      npc.x += npc.vx*dt; npc.y += npc.vy*dt; npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
      continue;
    }
    let targetPos, st = null;
    if(npc.leader != null){
      const leader = npcs.find(n=>n.id===npc.leader && !n.dead);
      if(leader){
        targetPos = { x: leader.x + Math.cos(npc.orbitAngle) * npc.orbitRadius, y: leader.y + Math.sin(npc.orbitAngle) * npc.orbitRadius };
      } else { npc.leader = null; }
    }
    if(!targetPos){
      st = stations.find(s=>s.id===npc.target);
      if(!st){
        npc.target = pickNextStation(npc.lastStation, npc.type);
        continue;
      }
      if(npc.phase === 'toStation' || npc.phase === 'direct'){ targetPos = stationPortWorld(st, npc.dockPort || 0); }
      else { targetPos = { x: st.x, y: st.y }; }
    }
    const to = { x: targetPos.x - npc.x, y: targetPos.y - npc.y };
    const d = Math.hypot(to.x,to.y);
    const dir = d?{x:to.x/d,y:to.y/d}:{x:0,y:0};
    const desiredSpeed = npc.leader != null ? npc.speed : npc.speed * (d < 120 ? (d/120) : 1);
    const desiredV = { x: dir.x*desiredSpeed, y: dir.y*desiredSpeed };
    npc.vx += (desiredV.x - (npc.vx||0)) * clamp(1.5*dt,0,1);
    npc.vy += (desiredV.y - (npc.vy||0)) * clamp(1.5*dt,0,1);
    const toP = { x: ship.pos.x - npc.x, y: ship.pos.y - npc.y }; const dp = Math.hypot(toP.x,toP.y);
    if(dp < 120){ npc.vx -= (toP.x/dp) * 40*dt; npc.vy -= (toP.y/dp) * 40*dt; }
    npc.x += npc.vx*dt; npc.y += npc.vy*dt; npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
    const portPos = st ? stationPortWorld(st, npc.dockPort || 0) : null;
    const distToStation = portPos ? Math.hypot(portPos.x - npc.x, portPos.y - npc.y) : Infinity;
    if(npc.leader == null && st && distToStation < 20){
      npc.docking = true; npc.x = portPos.x; npc.y = portPos.y; npc.vx = 0; npc.vy = 0; npc.lastStation = st.id;
    }
  }
}
function pirateMissionStep(dt){
  if(!mercMission) return;
  const st = mercMission.station;
  if(!st) return;

  const orbitRadii = pirateOrbitRadii();
  const aggroRadius = mercMission.aggroRadius || orbitRadii.inner || (st.r + 1200);
  mercMission.aggroRadius = aggroRadius;
  const distToPlayer = Math.hypot(ship.pos.x - st.x, ship.pos.y - st.y);
  const zoneId = zoneState.current?.id;

  // --- ZMIANA: Usunięto enterPirateOuterOrbit (nie resetujemy już formacji starym kodem) ---

  if (zoneId === 'pirate_inner') {
    enterPirateInnerOrbit();
  }
  
  const shouldAggro = zoneId === 'pirate_inner' || distToPlayer < aggroRadius;
  if(!mercMission.aggro && shouldAggro){
    triggerMercAggro(zoneId === 'pirate_inner' ? 'player_inner_orbit' : 'player_inside_zone');
  }

  // --- ZMIANA: Usunięto updatePirateGuardBehavior ---
  // To naprawia konflikt sterowników. Teraz tylko runAdvancedFighterAI steruje ruchem.

  // --- Platformy Obronne ---
  PirateSim.time = (PirateSim.time || 0) + dt;

  const platforms = mercMission.weaponPlatforms || [];
  const target = { x: ship.pos.x, y: ship.pos.y, vx: ship.vel.x, vy: ship.vel.y };
  for(const platform of platforms){
    if(!platform) continue;
    platform.hitFlash = Math.max(0, platform.hitFlash - dt);
    if(platform.destroyed){
      platform.deathTimer += dt;
      if(platform.deathTimer > 3){
        platform.removed = true;
      }
      continue;
    }

    platform.angle += platform.orbitSpeed * dt;
    platform.rotation = wrapAngle(platform.rotation + platform.spin * dt);
    platform.x = st.x + Math.cos(platform.angle) * platform.orbitRadius;
    platform.y = st.y + Math.sin(platform.angle) * platform.orbitRadius;

    const tangentialVel = {
      x: -Math.sin(platform.angle) * platform.orbitRadius * platform.orbitSpeed,
      y:  Math.cos(platform.angle) * platform.orbitRadius * platform.orbitSpeed
    };

    if(platform.shield){
      if(platform.shield.regenTimer > 0){
        platform.shield.regenTimer = Math.max(0, platform.shield.regenTimer - dt);
      } else {
        platform.shield.val = clamp(platform.shield.val + platform.shield.regenRate * dt, 0, platform.shield.max);
      }
    }

    platform.rail.cd = Math.max(0, platform.rail.cd - dt);
    platform.missile.cd = Math.max(0, platform.missile.cd - dt);

    const distToPlayerPlat = Math.hypot(target.x - platform.x, target.y - platform.y);

    if(platform.rail.cd === 0 && distToPlayerPlat < 2200){
      const lead = leadTarget({ x: platform.x, y: platform.y }, tangentialVel, target, RAIL_SPEED * 0.9);
      const aim = Math.atan2(lead.y - platform.y, lead.x - platform.x);
      const jitter = (Math.random() - 0.5) * platform.rail.scatter;
      const dir = { x: Math.cos(aim + jitter), y: Math.sin(aim + jitter) };
      const muzzle = muzzlePosFor(platform, dir, 14);
      window.bullets.push({
        x:muzzle.x, y:muzzle.y,
        vx: dir.x*(RAIL_SPEED*0.9), vy: dir.y*(RAIL_SPEED*0.9),
        life:2.0, r:4, owner:'npc', damage:platform.rail.damage, type:'rail', penetration:2,
        source: platform, spawnGrace: 0.08
      });
      spawnParticle({x:muzzle.x,y:muzzle.y}, {x:0,y:0}, 0.10, '#bfe7ff', 6, true);
      platform.rail.cd = platform.rail.cdMax;
    }

    if(platform.missile.cd === 0 && distToPlayerPlat < 2600){
      const lead = leadTarget({ x: platform.x, y: platform.y }, tangentialVel, target, SIDE_BULLET_SPEED);
      const aim = Math.atan2(lead.y - platform.y, lead.x - platform.x);
      const dir = {x:Math.cos(aim), y:Math.sin(aim)};
      const muzzleR = muzzlePosFor(platform, dir, 16);
      window.bullets.push({
        x:muzzleR.x, y:muzzleR.y, px:muzzleR.x, py:muzzleR.y,
        vx: dir.x*SIDE_BULLET_SPEED, vy: dir.y*SIDE_BULLET_SPEED,
        life:2.6, r:5, owner:'npc', damage:platform.missile.damage,
        type:'rocket', explodeRadius:SIDE_PLASMA_EXPLODE_RADIUS,
        homingDelay:SIDE_ROCKET_HOMING_DELAY,
        source: platform, spawnGrace: 0.12
      });
      platform.missile.cd = platform.missile.cdMax;
    }
  }
  if(platforms.length){
    mercMission.weaponPlatforms = platforms.filter(p => p && !p.removed);
  }

  if (mercMission.alertStage !== 'engage') return;

  // --- SWARM (Fale wrogów) ---
  const swarm = mercMission.swarm;
  if(!swarm) return;
  if(!swarm.active) return;

  // Liczba żywych piratów
  const alive = npcs.reduce((a,n)=>a + (n.mission && !n.friendly && !n.dead ? 1:0), 0);
  
  swarm.timer -= dt;
  
  // Jeśli mało wrogów i upłynął czas -> spawnuj
  if(swarm.timer <= 0 && alive < swarm.maxAlive){
    // Reset timera (dłuższy odstęp po spawnie fali)
    swarm.timer = 8.0;

    // Pobierz typ z kolejki
    const queued = Array.isArray(swarm.queue) ? swarm.queue.shift() : null;
    const descriptor = (queued && typeof queued === 'object') ? queued : { kind: queued };
    let kind = descriptor.kind || ((Math.random()<0.6)?'fighter_squad':'frigate_pd');
    
    const spawnPos = descriptor.pos;
    const angleToPlayer = spawnPos 
      ? Math.atan2(ship.pos.y - spawnPos.y, ship.pos.x - spawnPos.x) 
      : Math.atan2(ship.pos.y - st.y, ship.pos.x - st.x);

    // 1. MYŚLIWCE: Używamy spawnPirateSquad w trybie 'attack'
    // Tworzy eskadrę 7 interceptorów, które od razu lecą na gracza
    if(kind === 'fighter' || kind === 'interceptor' || kind === 'fighter_squad'){
        spawnPirateSquad(st, 'interceptor', 7, 'attack');
    }
    // 2. DUŻE STATKI: Spawnujemy pojedynczo przez spawnPirate
    else {
        const npc = spawnPirate(kind, st);
        
        // Jeśli w kolejce była zdefiniowana pozycja (np. dla formacji capitali)
        if(spawnPos){
          npc.x = spawnPos.x; npc.y = spawnPos.y;
          npc.formationSlot = { x: descriptor.offset || 0, y: 0 };
          npc.angle = angleToPlayer;
          
          // KLUCZOWE: Nadaj pęd początkowy, żeby nie stały w miejscu przy spawnie
          npc.vx += Math.cos(angleToPlayer) * 80;
          npc.vy += Math.sin(angleToPlayer) * 80;
        }
        
        // Ważne: Ustaw stan na atak, żeby nie weszły w tryb Guard/Orbit
        npc.state = 'engage_formation';
        npc.guardStation = null;
        
        // Reset celów dla AI (niech aiPickBestTarget wybierze gracza lub jego myśliwce)
        npc.forceTarget = null;
        npc.target = null;
    }

    // Jeśli kolejka pusta, odnów ją
    if(swarm.queue && swarm.queue.length === 0) resetSwarmQueue();
  }
}
// =============== Warp (jak wcześniej) ===============
const warp = {
  state:'idle', // idle | charging | active
  charge:0, chargeTime:0.8,
  orientTolerance: Math.PI/30,
  speed:5000,
  fuelMax:60, fuel:60, consumeRate:1.0, regenRate:5,
  dir:{x:0,y:0},
  turnRate: Math.PI / 5, // maksymalna prędkość skrętu w rad/s podczas warpa
  alignRate: Math.PI / 2.5, // szybkość zgrywania kadłuba do kierunku lotu
  entryProgress:0,
  entryDuration:0.9,
  entryBaseSpeed:0,
  isBusy(){ return this.state!=='idle'; }
};

function exitWarp(){
  spawnShockwave(ship.pos.x, ship.pos.y, { maxR: 1200, maxLife: 0.7 });
  camera.addShake(18, 0.22);
  
  warp.entryProgress = 0;
  
  // TO JEST NAJWAŻNIEJSZE:
  // Ustawiamy timer na czas trwania efektu hamowania (np. 0.8 sekundy)
  warpBrakeTimer = 0.8; 
  
  // Zachowujemy ostatni kierunek warpa, aby efekt hamowania wiedział, w którą stronę rysować kreski
  // (Jeśli warp.dir się zeruje gdzieś indziej, to tu go "zamrażamy" dla efektu)
  if (!warp.lastDir) warp.lastDir = { x: warp.dir.x, y: warp.dir.y };
  warp.lastDir.x = warp.dir.x;
  warp.lastDir.y = warp.dir.y;
}

const boost = {
  state:'idle',
  fuelMax:45, fuel:45,
  regenRate:1.5,
  consumeRate:1.0,
  extraThrustMul:1.2,
  handlingMultiplier:1.35,
  dampingFactor:0.55,
  angularDampingFactor:0.65,
  effectTime:0, effectDuration:0.25, effectDir:{x:0,y:-1}
};

function attemptWarp(){
  if (warp.state === 'idle' && (DevFlags.unlimitedWarp || warp.fuel > 0)) {
    warp.state = 'charging';
    warp.charge = 0;
    return;
  }
  if (warp.state === 'charging') {
    warp.state = 'idle';
    warp.charge = 0;
    return;
  }
  if (warp.state === 'active') {
    warp.state = 'idle';
    exitWarp();
  }
}

function engageWarp(dir){
  const ndir = norm(dir);
  warp.dir.x = ndir.x;
  warp.dir.y = ndir.y;
  ship.angle = Math.atan2(ndir.y, ndir.x) + Math.PI/2;
  ship.angVel = 0;
  warp.state='active';
  warp.entryProgress = 0;
  warp.entryBaseSpeed = Math.hypot(ship.vel.x, ship.vel.y);
  if (DevFlags.unlimitedWarp) {
    warp.fuel = warp.fuelMax;
  }
  spawnParticle({x:ship.pos.x, y:ship.pos.y}, {x:0,y:0}, 0.14, '#bfe7ff', 8, true);
  for(let i=0;i<18;i++){
    const a = Math.random()*Math.PI*2;
    spawnParticle({x:ship.pos.x, y:ship.pos.y}, {x:Math.cos(a)*320, y:Math.sin(a)*320}, 0.18+Math.random()*0.18, '#cce6ff', 1.4, false);
  }
}

// =============== Fizyk ===============
function physicsStep(dt){
  updateCameraTarget(dt);
  updateStationUIState(dt);
  updateInfrastructureEditorState(dt);
  updateInfrastructureState(dt);
  if(window.updateInfrastructureAnimations) {
    window.updateInfrastructureAnimations(dt);
  }
  // czas gry
  gameTime = (gameTime + dt * TIME_SCALE) % (24*3600);
  // aktualizacja orbit planet i stacji
  for(const pl of planets){
    pl.angle += pl.speed * dt * TIME_SCALE;
    const R = pl.devOrbitOverrideR ?? pl.orbitRadius ?? pl.orbit?.radius ?? pl.orbitR ?? BASE_ORBIT;
    if ('orbitRadius' in pl) pl.orbitRadius = R;
    if (pl.orbit && 'radius' in pl.orbit) pl.orbit.radius = R;
    if ('orbitR' in pl) pl.orbitR = R;
    pl.x = SUN.x + Math.cos(pl.angle) * R;
    pl.y = SUN.y + Math.sin(pl.angle) * R;
  }
  for(const st of stations){
    if(st.static) continue;
    st.angle += st.speed * dt * TIME_SCALE;
    st.x = st.planet.x + Math.cos(st.angle) * st.orbitRadius;
    st.y = st.planet.y + Math.sin(st.angle) * st.orbitRadius;
  }
  for(const st of stations){
    if(!st.warpGate) continue;
    const off = st.warpGate.offset;
    const ox = off && typeof off.x === 'number' ? off.x : 0;
    const oy = off && typeof off.y === 'number' ? off.y : 0;
    st.warpGate.x = st.x + ox;
    st.warpGate.y = st.y + oy;
  }
  for(const key in warpRoutes){
    const route = warpRoutes[key];
    if(!route) continue;
    const from = route.fromRef;
    const to = route.toRef;
    if(!from || !to) continue;
    const sx = from.warpGate?.x ?? from.x;
    const sy = from.warpGate?.y ?? from.y;
    const ex = to.warpGate?.x ?? to.x;
    const ey = to.warpGate?.y ?? to.y;
    route.start.x = sx;
    route.start.y = sy;
    route.end.x = ex;
    route.end.y = ey;
    const dx = ex - sx;
    const dy = ey - sy;
    const dist = Math.hypot(dx, dy) || 1;
    route.dir.x = dx / dist;
    route.dir.y = dy / dist;
    route.length = dist;
  }
  syncInfrastructureWorldPositions();
  for(const st of stations){
    if(!st.shield) continue;
    if(st.shield.regenTimer > 0){
      st.shield.regenTimer = Math.max(0, st.shield.regenTimer - dt);
    } else {
      st.shield.val = clamp(st.shield.val + st.shield.regenRate * dt, 0, st.shield.max);
    }
  }
  for (const st of stations) {
    if (st.baseR == null) st.baseR = st.r;
    const scale = stationScaleFor(st);
    st.r = (st.baseR || st.r) * scale;
  }
  updateZoneState(dt);
  if (boost.state === 'active' && !isPlanetOrbitZoneId(zoneState.current?.id)) {
    boost.state = 'idle';
  }
  if(typeof warpBrakeTimer !== 'undefined' && warpBrakeTimer > 0) {
      warpBrakeTimer -= dt;
  }
  // regen paliwa gdy nie warpuje
  if(warp.state!=='active'){
    warp.fuel = clamp(warp.fuel + warp.regenRate*dt, 0, warp.fuelMax);
    if(DevFlags.unlimitedWarp) warp.fuel = warp.fuelMax;
    warp.entryProgress = 0;
  }
  if (ship.controller === 'ai'){
    const aiControl = runShipAI(ship, dt);
    if (aiControl){
      applyPlayerInput(ship, aiControl, input);
    }
  }
  const boostAllowed = isPlanetOrbitZoneId(zoneState.current?.id);
  let boostActive = boost.state === 'active' && boostAllowed;
  if(boost.state === 'active'){
    boost.fuel = clamp(boost.fuel - boost.consumeRate*dt, 0, boost.fuelMax);
    if(boost.fuel <= 0){
      boost.state = 'idle';
      boostActive = false;
    } else {
      boostActive = true;
    }
  } else {
    boostActive = false;
    if(boost.effectTime <= 0){
      boost.fuel = clamp(boost.fuel + boost.regenRate*dt, 0, boost.fuelMax);
    }
  }
  if(!boostActive && boost.effectTime>0) boost.effectTime = Math.max(0, boost.effectTime - dt);

  // rail queue/cd
  rail.cd[0] = Math.max(0, rail.cd[0]-dt);
  rail.cd[1] = Math.max(0, rail.cd[1]-dt);
  const requiredBarrels = Math.max(1, rail.barrelsPerShot || 2);
  const secondaryReady = requiredBarrels < 2 || rail.cd[1] <= 0;
  if (!stationUI.open && mouse.left  && rail.queue.length===0 && rail.cd[0]<=0 && secondaryReady && !warp.isBusy()) { triggerRailVolley(); }
  for(const q of rail.queue) q.timer -= dt;
  let firedSomething = true;
  while(firedSomething){
    firedSomething = false;
    for(let i=0;i<rail.queue.length;i++){
      const q = rail.queue[i];
      if(q.timer <= 0 && rail.cd[q.barrel] <= 0 && !warp.isBusy()){
        fireRailBarrel(q.barrel);
        rail.queue.splice(i,1);
        firedSomething = true;
        break;
      }
    }
  }
  railTimer = (requiredBarrels > 1) ? Math.min(rail.cd[0], rail.cd[1]) : rail.cd[0];

  ship.special.cooldownTimer = Math.max(0, ship.special.cooldownTimer - dt);
  if(ship.shield.regenTimer > 0) ship.shield.regenTimer -= dt;
  else ship.shield.val = clamp(ship.shield.val + ship.shield.regenRate * dt, 0, ship.shield.max);
  updateShieldFx(ship, dt);
  rocketCooldown = Math.max(0, rocketCooldown - dt);
  // mouse world position
  const mouseWorld = screenToWorld(mouse.x, mouse.y);
  const hasMissilesEquipped = (Game.player.weapons?.[HP.MISSILE]?.length || 0) > 0;
  if (!stationUI.open && mouse.right && !warp.isBusy() && hasMissilesEquipped && (rocketAmmoMax === 0 || rocketAmmo > 0) && rocketCooldown<=0) {
    const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
    const side = (local.x >= 0) ? 'right' : 'left';
    fireRocket(side);
    rocketCooldown = ROCKET_FIRE_INTERVAL;
  }

  // hover scanning
  let hover = null;
  let hoverType = null;
  if(mouse.overCanvas){
    let bestDistSq = Infinity;
    const npcMargin = 20;
    for(const npc of npcs){
      if(npc.dead) continue;
      const radius = (npc.radius || 0) + npcMargin;
      const dx = npc.x - mouseWorld.x;
      const dy = npc.y - mouseWorld.y;
      const distSq = dx*dx + dy*dy;
      if(distSq <= radius*radius && distSq < bestDistSq){
        bestDistSq = distSq;
        hover = npc;
        hoverType = 'npc';
      }
    }
    const stationMargin = 24;
    for(const st of stations){
      const baseR = ((st.r ?? st.baseR) || 120) + stationMargin;
      const dx = st.x - mouseWorld.x;
      const dy = st.y - mouseWorld.y;
      const distSq = dx*dx + dy*dy;
      if(distSq <= baseR*baseR && distSq < bestDistSq){
        bestDistSq = distSq;
        hover = st;
        hoverType = 'station';
      }
    }
    if(mercMission && mercMission.weaponPlatforms){
      const platformMargin = 18;
      for(const platform of mercMission.weaponPlatforms){
        if(!platform || platform.removed) continue;
        const radius = (platform.radius || 0) + platformMargin;
        const dx = platform.x - mouseWorld.x;
        const dy = platform.y - mouseWorld.y;
        const distSq = dx*dx + dy*dy;
        if(distSq <= radius*radius && distSq < bestDistSq){
          bestDistSq = distSq;
          hover = platform;
          hoverType = 'platform';
        }
      }
    }
  }

  if(hover){
    scan.target = hover;
    scan.targetType = hoverType;
    scan.scanned = hover;
    updateHoverInfo(hover, hoverType);
    if(!stationUI.open && mouse.click && hoverType === 'station'){
      openStationUI(hover);
      mouse.click = false;
    }
  } else {
    if(scan.target || scan.scanned || scan.targetType){
      scan.target = null;
      scan.scanned = null;
      scan.targetType = null;
    }
    hideHoverInfo();
  }
  if(lockedTarget && (!isHostileNpc(lockedTarget) || lockedTarget.dead)) lockedTarget = null;
  lockedTargets = lockedTargets.filter(isHostileNpc);
  if(highlightTimer > 0){
    highlightTimer -= dt;
    if(highlightTimer <= 0){ highlightTimer = 0; highlightedEnemies = []; }
  }

  // update radar pings
  for(let i=radarPings.length-1;i>=0;i--){
    const p = radarPings[i];
    p.age += dt; if(p.age>p.life) radarPings.splice(i,1);
  }
  // update scan waves
  for(let i=scanWaves.length-1;i>=0;i--){
    const w = scanWaves[i];
    w.r += w.speed*dt;
    for(const npc of npcs){
      if(npc.dead) continue;
      if(!w.hit.has(npc) && Math.hypot(npc.x-w.x, npc.y-w.y) <= w.r){ w.hit.add(npc); spawnRadarPing(npc.x,npc.y); }
    }
    for(const st of stations){
      if(!w.hit.has(st) && Math.hypot(st.x-w.x, st.y-w.y) <= w.r){ w.hit.add(st); spawnRadarPing(st.x,st.y); }
    }
    if(mercMission && mercMission.weaponPlatforms){
      for(const platform of mercMission.weaponPlatforms){
        if(!platform || platform.destroyed || platform.removed) continue;
        if(!w.hit.has(platform) && Math.hypot(platform.x - w.x, platform.y - w.y) <= w.r){
          w.hit.add(platform);
          spawnRadarPing(platform.x, platform.y);
        }
      }
    }
    if(w.r > w.max) scanWaves.splice(i,1);
  }

  // update scan arrows
  for(let i=scanArrows.length-1;i>=0;i--){
    const a = scanArrows[i];
    if(warp.state !== 'active') a.age += dt;
    if(a.age > a.life) scanArrows.splice(i,1);
  }

  // turret aim (poza warp active)
  if(warp.state!=='active'){
    for(const t of [ship.turret, ship.turret2, ship.turret3, ship.turret4]){
      const off = rotate(t.offset, ship.angle);
      const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
      const aimPos = (lockedTarget && !lockedTarget.dead)
        ? leadTarget(base, ship.vel, lockedTarget, RAIL_SPEED)
        : mouseWorld;
      let diffT = wrapAngle(Math.atan2(aimPos.y - base.y, aimPos.x - base.x) - t.angle);
      let desiredVel = clamp(diffT * 6.5, -t.maxSpeed, t.maxSpeed);
      const velDelta = desiredVel - t.angVel;
      const maxDelta = t.maxAccel * dt;
      t.angVel += clamp(velDelta, -maxDelta, maxDelta);
      t.angVel *= Math.exp(-t.damping * dt);
      t.angVel = clamp(t.angVel, -t.maxSpeed, t.maxSpeed);
      t.angle = wrapAngle(t.angle + t.angVel * dt);
    }
  }
  for(const t of [ship.turret, ship.turret2, ship.turret3, ship.turret4]){
    t.recoil = Math.max(0, t.recoil - t.recoilRecover * dt);
  }

  updatePlayerCommand(dt);

  // siły
  let totalF = {x:0,y:0}, totalTorque = 0;
  const forwardLocal = {x:0, y:-1};

  if(warp.state==='active'){
    const turnInput = clamp(input.torque, -1, 1);
    if(Math.abs(turnInput) > 1e-3){
      const currentAngle = Math.atan2(warp.dir.y, warp.dir.x);
      const maxTurn = warp.turnRate * dt;
      const delta = clamp(turnInput * warp.turnRate * dt, -maxTurn, maxTurn);
      const newAngle = currentAngle + delta;
      warp.dir.x = Math.cos(newAngle);
      warp.dir.y = Math.sin(newAngle);
    }
    const desiredBodyAngle = Math.atan2(warp.dir.y, warp.dir.x) + Math.PI/2;
    const diffBody = wrapAngle(desiredBodyAngle - ship.angle);
    const maxAlign = warp.alignRate * dt;
    ship.angle = wrapAngle(ship.angle + clamp(diffBody, -maxAlign, maxAlign));
    ship.angVel = 0;

    warp.entryProgress = Math.min(1, warp.entryProgress + dt / Math.max(0.001, warp.entryDuration));
    const entryEase = smoothstep01(warp.entryProgress);
    const zoneWarpMul = zoneState.current?.warpMultiplier ?? 1;
    const maxWarpSpeed = warp.speed * zoneWarpMul;
    const entryStartSpeed = Math.min(warp.entryBaseSpeed, maxWarpSpeed);
    const targetSpeed = entryStartSpeed + (maxWarpSpeed - entryStartSpeed) * entryEase;
    const targetV = { x: warp.dir.x*targetSpeed, y: warp.dir.y*targetSpeed };
    ship.vel.x += (targetV.x - ship.vel.x) * clamp(6*dt,0,1);
    ship.vel.y += (targetV.y - ship.vel.y) * clamp(6*dt,0,1);
    if(!DevFlags.unlimitedWarp){
      warp.fuel = Math.max(0, warp.fuel - warp.consumeRate*dt);
      if(warp.fuel<=0){ warp.state='idle'; exitWarp(); }
    } else {
      warp.fuel = warp.fuelMax;
    }
  }
 else if(warp.state==='charging'){
    const dirToMouse = norm({x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y});
    warp.dir.x = dirToMouse.x;
    warp.dir.y = dirToMouse.y;
    const desiredBodyAngle = Math.atan2(dirToMouse.y, dirToMouse.x) + Math.PI/2;
    const kp = 5.5, maxSpin=2.5, accel=8.0;
    const diffB = wrapAngle(desiredBodyAngle - ship.angle);
    const desiredSpin = clamp(diffB * kp, -maxSpin, maxSpin);
    const delta = clamp(desiredSpin - ship.angVel, -accel*dt, accel*dt);
    ship.angVel += delta;
    if(warp.charge < warp.chargeTime) warp.charge += dt;
    if(warp.charge >= warp.chargeTime && Math.abs(diffB) <= warp.orientTolerance && (DevFlags.unlimitedWarp || warp.fuel>0)){
      engageWarp(dirToMouse);
    }
  }
  else {
    const handlingMul = boostActive ? boost.handlingMultiplier : 1;
    const forwardWorld = rotate(forwardLocal, ship.angle);

    if(boostActive){
      boost.effectTime = boost.effectDuration;
      boost.effectDir = {x: forwardWorld.x, y: forwardWorld.y};
    }

    // GŁÓWNY DUŻY SILNIK — ciąg do przodu
    if(input.main>0){
      const e = ship.engines.main;
      const wo = rotate(e.offset, ship.angle);
      const wf = forwardWorld;
      let thrust = e.maxThrust * input.main;
      if(boostActive){
        thrust *= (1 + boost.extraThrustMul);
      }
      totalF.x += wf.x * thrust; totalF.y += wf.y * thrust;
      totalTorque += (wo.x * (wf.y * thrust) - wo.y * (wf.x * thrust));
    }
    // mały krótki ślad przy poruszaniu (bez gazu)
    const spd = len(ship.vel);
    if(spd > 60){
      const e = ship.engines.main;
      const wo = rotate(e.offset, ship.angle);
      const backDir = norm({x:-ship.vel.x, y:-ship.vel.y});
      spawnParticle({x: ship.pos.x + wo.x, y: ship.pos.y + wo.y},
                    {x: backDir.x*50 + (Math.random()-0.5)*20, y: backDir.y*50 + (Math.random()-0.5)*20},
                    0.18, '#bfe7ff', 1.2, false);
    }

    // boczne i moment
    if(input.leftSide>0){
      const e = ship.engines.sideLeft;
      const thrust = e.maxThrust * input.leftSide * handlingMul;
      const wo = rotate(e.offset, ship.angle);
      const lateral = rotate({x:1,y:0}, ship.angle);
      const worldForce = {x: lateral.x * thrust, y: lateral.y * thrust};
      totalF.x += worldForce.x; totalF.y += worldForce.y;
      totalTorque += (wo.x * worldForce.y - wo.y * worldForce.x);
      spawnParticle(add(ship.pos, wo), add(ship.vel, mul(worldForce,-0.002)), 0.30, '#cfe7ff', 1.0);
    }
    if(input.rightSide>0){
      const e = ship.engines.sideRight;
      const thrust = e.maxThrust * input.rightSide * handlingMul * 3.0;
      const wo = rotate(e.offset, ship.angle);
      const lateral = rotate({x:-1,y:0}, ship.angle);
      const worldForce = {x: lateral.x * thrust, y: lateral.y * thrust};
      totalF.x += worldForce.x; totalF.y += worldForce.y;
      totalTorque += (wo.x * worldForce.y - wo.y * worldForce.x);
      spawnParticle(add(ship.pos, wo), add(ship.vel, mul(worldForce,-0.002)), 0.30, '#cfe7ff', 1.0);
    }
    if(input.torque !== 0){
      const sign = Math.sign(input.torque);
      const left = ship.engines.torqueLeft; const right = ship.engines.torqueRight;
      const thrust = left.maxThrust * Math.abs(input.torque) * handlingMul;
      const o1 = rotate(left.offset, ship.angle), o2 = rotate(right.offset, ship.angle);
      const lateral1 = rotate({x:1,y:0}, ship.angle), lateral2 = rotate({x:-1,y:0}, ship.angle);
      const f1 = mul(lateral1, thrust * sign), f2 = mul(lateral2, thrust * sign);
      totalF.x += f1.x + f2.x; totalF.y += f1.y + f2.y;
      totalTorque += (o1.x * f1.y - o1.y * f1.x) + (o2.x * f2.y - o2.y * f2.x);
      spawnParticle(add(ship.pos, o1), add(ship.vel, mul(f1,-0.002)), 0.22, '#cfe7ff',1.0);
      spawnParticle(add(ship.pos, o2), add(ship.vel, mul(f2,-0.002)), 0.22, '#cfe7ff',1.0);
    }
  }

  // integracja ruchu
  const ax = totalF.x / ship.mass, ay = totalF.y / ship.mass;
  ship.vel.x += ax*dt; ship.vel.y += ay*dt;
  const linDamp = Math.exp(-ship.linearDamping * (boostActive ? boost.dampingFactor : 1) * dt);
  if(warp.state!=='active'){ ship.vel.x *= linDamp; ship.vel.y *= linDamp; }
  if (boostActive && warp.state !== 'active') {
    const zoneId = zoneState.current?.id;
    const boostCap = (zoneId === 'planet_outer' || zoneId === 'pirate_outer')
      ? warp.speed * 0.4
      : (zoneId === 'planet_inner' || zoneId === 'pirate_inner')
        ? warp.speed * 0.3
        : null;
    if (boostCap) {
      const speed = len(ship.vel);
      if (speed > boostCap) {
        const scale = boostCap / speed;
        ship.vel.x *= scale;
        ship.vel.y *= scale;
      }
    }
  }
    ship.pos.x += ship.vel.x*dt;
    ship.pos.y += ship.vel.y*dt;

    // granice
    const margin = Math.max(50, getAuToWorldUnits() * WORLD_EDGE_MARGIN_AU);
    ship.pos.x = clamp(ship.pos.x, margin, WORLD.w - margin);
    ship.pos.y = clamp(ship.pos.y, margin, WORLD.h - margin);

    ship.x = ship.pos.x;
    ship.y = ship.pos.y;

    // obrót
    const angAcc = totalTorque / ship.inertia;
  ship.angVel += angAcc*dt;
  ship.angVel *= Math.exp(-ship.angularDamping * (boostActive ? boost.angularDampingFactor : 1) * dt);
  ship.angle += ship.angVel*dt;
  ship.angle = wrapAngle(ship.angle);
  // Aktualizacja wraków
  for (let i = wrecks.length - 1; i >= 0; i--) {
    const w = wrecks[i];

    // Fizyka ruchu
    w.x += w.vx * dt;
    w.y += w.vy * dt;
    w.angle += w.angVel * dt;
    w.vx *= w.friction;
    w.vy *= w.friction;
    w.angVel *= w.friction;

    // Despawn jeśli wyleci za daleko lub minie czas
    // (możesz dodać timer życia)
    const distToPlayer = Math.hypot(w.x - ship.pos.x, w.y - ship.pos.y);
    if (distToPlayer > 15000) {
      wrecks.splice(i, 1);
    }
  }
  // Aktualizacja logiki eskadr
  SQUADS.forEach(s => s.update());
  updateSupportWing(dt);
  npcStep(dt);
  pirateMissionStep(dt);
  ciwsStep(dt);
  bulletsAndCollisionsStep(dt);
  npcShootingStep(dt);
  hudUpdateDMG(dt);
  hudUpdateNav(dt);
}

// ======= Efekty VFX =======
let _engineVFX = null;
let _engineVFXLoading = false;

function getEngineVFX() {
  if (_engineVFX) return _engineVFX;

  if (typeof THREE === "undefined") return null;

  // 1) Upewnij się, że mamy konstruktory efektów
  if (typeof window.createShortNeedleExhaust !== "function") {
    if (!_engineVFXLoading) {
      _engineVFXLoading = true;
      import("./Engineeffects.js").then(mod => {
        window.createShortNeedleExhaust = mod.createShortNeedleExhaust;
        window.createWarpExhaustBlue   = mod.createWarpExhaustBlue;
      }).catch(err => console.warn("Engineeffects.js failed to load", err))
        .finally(() => { _engineVFXLoading = false; });
    }
    return null;
  }

  // 2) Offscreen canvas i scena
  const canvas = document.createElement("canvas");
  // więcej miejsca, żeby ogon nie był ścinany
  canvas.width = 128;
  canvas.height = 256;
  const ctx2d = canvas.getContext("2d");

  const scene = new THREE.Scene();
  scene.background = null;

  const camera = new THREE.OrthographicCamera(-64, 64, 64, -192, -1000, 1000);
  camera.position.z = 10;
  camera.lookAt(0, 0, 0);

  const exhaust = window.createShortNeedleExhaust();
  exhaust.group.position.y = 0; // zero — unikamy clipu przy obrocie
  scene.add(exhaust.group);

  // 3) Renderer: użyj współdzielonego jeśli jest, w przeciwnym razie lokalnego
  let localRenderer = null;
  function pickRenderer(w, h) {
    if (typeof window.getSharedRenderer === "function") {
      const r = window.getSharedRenderer(w, h);
      return r || null;
    }
    if (!localRenderer) {
      localRenderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
        premultipliedAlpha: true,
        preserveDrawingBuffer: true
      });
      localRenderer.setPixelRatio(1);
    }
    // dopasuj rozmiar jeśli się zmienił
    const d = localRenderer.getSize(new THREE.Vector2());
    if (d.x !== w || d.y !== h) localRenderer.setSize(w, h, false);
    return localRenderer;
  }

  function resetRendererForVFX(renderer, width, height) {
    if (!renderer) return;
    if (typeof renderer.setRenderTarget === 'function') renderer.setRenderTarget(null);
    if (typeof renderer.setPixelRatio === 'function') renderer.setPixelRatio(1);
    if (typeof renderer.setSize === 'function') renderer.setSize(width, height, false);
    if (typeof renderer.setViewport === 'function') renderer.setViewport(0, 0, width, height);
    if (renderer.state && typeof renderer.state.reset === 'function') renderer.state.reset();
    if (typeof renderer.setScissorTest === 'function') renderer.setScissorTest(false);
    if (typeof renderer.setClearColor === 'function') renderer.setClearColor(0x000000, 0);
    if (typeof renderer.clear === 'function') renderer.clear(true, true, false);
  }

  _engineVFX = {
    canvas, ctx2d, camera, scene, exhaust,
    render(time, overrides = null) {
      const r = pickRenderer(canvas.width, canvas.height);
      if (!r) return;
      // pełny reset i przezroczyste czyszczenie
      resetRendererForVFX(r, canvas.width, canvas.height);

      // dynamiczny throttle
      const spd = Math.hypot(ship.vel.x, ship.vel.y);
      const moveGlowBase = Math.min(spd / 900, 0.6);
      const thrust = input.main > 0 ? input.main : 0;
      const boostAmpBase = (boost.effectDuration > 0)
        ? clamp(boost.effectTime / boost.effectDuration, 0, 1)
        : 0;
      const warpActiveAmp = (warp.state === 'active') ? smoothstep01(warp.entryProgress) : 0;
      const warpChargeAmp = (warp.state === 'charging')
        ? smoothstep01(Math.min(1, warp.charge/warp.chargeTime)) * 0.6
        : 0;
      const warpAmpBase  = Math.max(warpActiveAmp, warpChargeAmp);
      const moveGlow = (overrides && typeof overrides.moveGlowOverride === 'number')
        ? clamp(overrides.moveGlowOverride, 0, 1)
        : moveGlowBase;
      const throttleBase = Math.max(thrust, moveGlow * 0.8);
      const throttle = (overrides && typeof overrides.throttleOverride === 'number')
        ? clamp(overrides.throttleOverride, 0, 1)
        : throttleBase;
      const boostAmp = (overrides && typeof overrides.boostOverride === 'number')
        ? clamp(overrides.boostOverride, 0, 1)
        : boostAmpBase;
      const warpAmp = (overrides && typeof overrides.warpOverride === 'number')
        ? clamp(overrides.warpOverride, 0, 1)
        : warpAmpBase;

      exhaust.setThrottle(throttle);
      exhaust.setWarpBoost(Math.max(boostAmp, warpAmp));
      // Możesz dopasować temperaturę i bloom z poziomu opcji (D3):
      exhaust.setColorTemp(OPTIONS.vfx.colorTempK);
      exhaust.setBloomGain(OPTIONS.vfx.bloomGain);

      exhaust.update(time);
      r.render(scene, camera);

      // skopiuj do 2D
      ctx2d.clearRect(0, 0, canvas.width, canvas.height);
      ctx2d.drawImage(r.domElement, 0, 0, canvas.width, canvas.height);
    }
  };

  return _engineVFX;
}

// Prosty fallback 2D — żeby ZAWSZE coś było widać, gdy evfx==null
function drawEngineFallback2D() {
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  const g = ctx.createLinearGradient(0, 0, 0, 90);
  g.addColorStop(0, 'rgba(170,210,255,0.55)');
  g.addColorStop(1, 'rgba(170,210,255,0)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(-14, 0);
  ctx.quadraticCurveTo(0, 70, 14, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawWarpChargeEffectLocal(progress, radius, spriteScale){
  if(progress <= 0) return;
  const eased = smoothstep01(progress);
  const baseAlpha = 0.3 + 0.5 * eased;
  const glowR = radius * (0.65 + 0.25 * eased);
  const ringR = radius * (0.9 + 0.35 * eased);
  const lineBase = (6 + 22 * eased) * spriteScale;
  const arcLine = (10 + 18 * eased) * spriteScale;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';

  const glow = ctx.createRadialGradient(0, 0, glowR * 0.35, 0, 0, glowR);
  glow.addColorStop(0, `rgba(186,232,255,${baseAlpha})`);
  glow.addColorStop(1, 'rgba(125,211,252,0)');
  ctx.fillStyle = glow;
  ctx.beginPath(); ctx.arc(0, 0, glowR, 0, Math.PI * 2); ctx.fill();

  ctx.lineWidth = lineBase;
  ctx.strokeStyle = `rgba(125,211,252,${0.35 + 0.4 * eased})`;
  ctx.beginPath(); ctx.arc(0, 0, ringR, 0, Math.PI * 2); ctx.stroke();

  const segments = 4;
  const arcLen = Math.PI * (0.22 + 0.4 * eased);
  ctx.lineWidth = arcLine;
  ctx.strokeStyle = `rgba(206,244,255,${0.45 + 0.45 * eased})`;
  for(let i=0;i<segments;i++){
    const offset = (vfxTime * 1.4 + i / segments) * Math.PI * 2;
    ctx.beginPath();
    ctx.arc(0, 0, ringR, offset, offset + arcLen);
    ctx.stroke();
  }

  ctx.restore();
}

function drawNeedleEngineVfxLocal(localPos, forward, options = {}) {
  const {
    widthScale = 1.5,
    lengthScale = 0.6,
    yNudge = -68,
    alpha = 1,
    overrides = null,
    fallback = true
  } = options || {};

  const safeWidth = Math.max(0.0001, widthScale);
  const safeLength = Math.max(0.0001, lengthScale);

  ctx.save();
  ctx.translate(localPos.x, localPos.y);
  ctx.scale(safeWidth, safeLength);
  ctx.rotate(Math.atan2(forward.y, forward.x) + Math.PI/2);
  ctx.globalCompositeOperation = 'lighter';
  const prevAlpha = ctx.globalAlpha;
  const engineGain = clamp(OPTIONS?.vfx?.engineGain ?? 1, 0, 1.5);
  ctx.globalAlpha = prevAlpha * alpha * engineGain;

  const evfx = getEngineVFX();
  if (evfx) {
    evfx.render(vfxTime, overrides);
    const w = evfx.canvas.width, h = evfx.canvas.height;
    ctx.drawImage(evfx.canvas, -w / 2, yNudge / safeLength, w, h);
  } else if (fallback) {
    drawEngineFallback2D();
  }

  ctx.globalAlpha = prevAlpha;
  ctx.restore();
}
function updateParticles(dt) {
  for (const p of particlePool) {
    if (!p.active) continue;

    p.age += dt;
    if (p.age >= p.life) {
      p.active = false;
      continue;
    }

    if (p.beam) continue;
    
    // Prosta fizyka cząsteczek
    p.vel.x *= 0.98; // Tarcie
    p.vel.y *= 0.98; 
    p.vel.y += 8 * dt; // Grawitacja (jeśli używana)
    p.pos.x += p.vel.x * dt;
    p.pos.y += p.vel.y * dt;
  }
}
// =============== Main loop ===============
let lastTime = performance.now();
const PHYS_DT = 1/120;
let acc = 0;
let vfxTime = 0;
let prevState = null;
let firstFrameResolver = null;
function saveState(){ prevState = { pos:{...ship.pos}, angle: ship.angle, turretAngle: ship.turret.angle, turretAngle2: ship.turret2.angle, turretAngle3: ship.turret3.angle, turretAngle4: ship.turret4.angle, ciwsAngles: ship.ciws.map(c=>c.angle) }; }
saveState();
function loop(now){
  const frame = Math.min(0.033, (now - lastTime)/1000);
  lastTime = now;
  applyGamepad();
  if(PAUSED){
    saveState();
    updateCameraTarget(frame);
    zoomIndicator.update(frame);
    render(0, frame);
    if (overlay3D) {
      overlay3D.tick(frame);
    }
    if (firstFrameResolver) {
      firstFrameResolver();
      firstFrameResolver = null;
    }
    requestAnimationFrame(loop);
    return;
  }
  acc += frame;
  vfxTime += frame;
  saveState();
  let steps = 0;
  while(acc >= PHYS_DT && steps < 10){
    physicsStep(PHYS_DT);
    acc -= PHYS_DT; steps++;
  }

  const allDestructibles = [ship, ...npcs, ...wrecks];
  DestructorSystem.update(frame, allDestructibles);

  // >>> TO JEST KLUCZOWE - ODDZIELNA AKTUALIZACJA WIZUALIÓW <<<
  updateParticles(frame);
  // >>> BEZ TEGO CZĄSTECZKI STOJĄ W MIEJSCU <<<

  const alpha = acc / PHYS_DT;
  frameId++;
  missionCompleteBanner.update(frame);
  // Shockwaves
  for(let i=shockwaves.length-1;i>=0;i--){
    const s = shockwaves[i];
    s.life += frame;
    const k = Math.min(1, s.life/s.maxLife);
    s.r = s.maxR * k;
    s.w = Math.max(1, (1-k) * (s.maxR*0.06));
    if(s.life >= s.maxLife) shockwaves.splice(i,1);
  }
  if(camera.shakeTime > 0){
    camera.shakeTime -= frame;
    if(camera.shakeTime <= 0) camera.shakeMag = 0;
  }
  zoomIndicator.update(frame);

  // --- AUDIO UPDATE ---
  if (ship && ship.engineSound) {
      if (!ship.destroyed) {
          // input.main to wartość 0 lub 1 (z klawisza W)
          let throttle = input.main;
          
          // Jeśli masz BOOST (Shift), dodajemy kopa do dźwięku (+0.5 do pitcha)
          if (typeof boost !== 'undefined' && boost.state === 'active') {
              throttle += 0.5;
          }
          
          // Aktualizuj dźwięk
          ship.engineSound.update(throttle);
      } else {
          // Jeśli statek zniszczony - wycisz natychmiast
          ship.engineSound.gain.gain.setTargetAtTime(0, AudioSys.ctx.currentTime, 0.1);
      }
  }
  // --------------------

  render(alpha, frame);
  if (overlay3D) {
    overlay3D.tick(frame);
  }
  if (firstFrameResolver) {
    firstFrameResolver();
    firstFrameResolver = null;
  }
  requestAnimationFrame(loop);
}

// =============== Render ===============
function worldToScreen(wx,wy,cam){ return { x: (wx - cam.x)*camera.zoom + W/2, y: (wy - cam.y)*camera.zoom + H/2 }; }

function stationPortWorld(st, idx){
  const off = st.ports[idx % st.ports.length];
  return { x: st.x + off.x, y: st.y + off.y };
}

function glowCircle(ctx, x, y, r, color){
  ctx.save();
  ctx.shadowColor = color;
  ctx.shadowBlur = r*0.5;
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawStationShadow(ctx, st, cam){
  const s = worldToScreen(st.x, st.y, cam);
  const toSun = { x: (SUN.x - st.x), y: (SUN.y - st.y) };
  const ang = Math.atan2(toSun.y, toSun.x) + Math.PI; // cień „od” Słońca
  const scale = stationScaleFor(st);
  const base = (st.baseR || st.r || 120) * scale;
  const off  = base * 1.2 * cam.zoom;
  const w = base * 1.6 * cam.zoom;
  const h = base * 0.7 * cam.zoom;

  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.rotate(ang);
  const g = ctx.createRadialGradient(off, 0, 0, off, 0, w);
  g.addColorStop(0.00, 'rgba(0,0,0,0.35)');
  g.addColorStop(1.00, 'rgba(0,0,0,0.00)');
  ctx.globalCompositeOperation = 'multiply';
  ctx.beginPath();
  ctx.ellipse(off, 0, w, h, 0, 0, Math.PI*2);
  ctx.fillStyle = g;
  ctx.fill();
  ctx.restore();
}

function drawStationVFX(ctx, st, x, y, r, t){
  ctx.save();
  ctx.translate(x, y);
  switch(st.style){
    case 'ringGate':
      ctx.strokeStyle = '#273447';
      ctx.lineWidth = Math.max(1, r*0.2);
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
      ctx.save(); ctx.rotate(t*0.6);
      for(let i=0;i<6;i++){ ctx.rotate(Math.PI/3); glowCircle(ctx, r*0.6, 0, r*0.12, '#6dd6ff'); }
      ctx.restore();
      glowCircle(ctx,0,0,r*0.3,'#6dd6ff');
      break;
    case 'hexHub':
      ctx.strokeStyle = '#273447';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<6;i++){ const a=i*Math.PI/3; const px=Math.cos(a)*r*0.6; const py=Math.sin(a)*r*0.6; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); }
      ctx.closePath(); ctx.stroke();
      break;
    case 'triRing':
      ctx.strokeStyle = '#273447'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0,0,r*0.9,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,r*0.6,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,r*0.3,0,Math.PI*2); ctx.stroke();
      break;
    case 'solarPetals':
      ctx.save(); ctx.rotate(t*0.5);
      for(let i=0;i<8;i++){ ctx.rotate(Math.PI/4); ctx.fillStyle='#274a7d'; ctx.fillRect(r*0.3,-r*0.1,r*0.4,r*0.2); }
      ctx.restore();
      glowCircle(ctx,0,0,r*0.25,'#8fd0ff');
      break;
    case 'shipyard':
      ctx.save();
      for(let i=0;i<4;i++){ ctx.rotate(Math.PI/2); ctx.fillStyle='#344a74'; ctx.fillRect(r*0.2,-r*0.05,r*0.8,r*0.1); }
      ctx.restore();
      break;
    case 'tradeSpindle':
      ctx.fillStyle='#3b517d'; ctx.fillRect(-r*0.1,-r,r*0.2,r*2);
      for(let i=-3;i<=3;i++){ ctx.fillStyle='#6ea0ff'; ctx.fillRect(r*0.3, i*r*0.2 - r*0.05, r*0.3, r*0.1); ctx.fillRect(-r*0.6, i*r*0.2 - r*0.05, r*0.3, r*0.1); }
      break;
    default:
      ctx.fillStyle = '#273447';
      ctx.beginPath(); ctx.arc(0,0,r*0.6,0,Math.PI*2); ctx.fill();
      break;
  }

  if(st.shield && st.shield.val > 0){
    const frac = clamp(st.shield.val / st.shield.max, 0, 1);
    const pulse = (Math.sin(t * 1.6) + 1) * 0.5;
    const shieldR = r * (1.18 + 0.04 * pulse);
    const fresnel = ctx.createRadialGradient(0, 0, shieldR * 0.72, 0, 0, shieldR);
    fresnel.addColorStop(0, 'rgba(120,200,255,0)');
    fresnel.addColorStop(1, `rgba(120,200,255,${0.22 + 0.25 * frac})`);
    ctx.save();
    ctx.fillStyle = fresnel;
    ctx.globalAlpha = 0.45 + 0.25 * pulse * frac;
    ctx.beginPath(); ctx.arc(0,0, shieldR, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.lineWidth = Math.max(3, r * 0.08);
    ctx.strokeStyle = `rgba(120,200,255,${0.32 + 0.4 * frac})`;
    ctx.beginPath(); ctx.arc(0,0, shieldR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  ctx.restore();
  ctx.strokeStyle = 'rgba(175,210,255,0.12)';
  ctx.lineWidth = Math.max(1, 2);
  ctx.beginPath(); ctx.arc(x, y, r*1.05, 0, Math.PI*2); ctx.stroke();
}

function drawPlanetLabels(ctx, cam){
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  const fontSize = Math.round(clamp(18 * camera.zoom, 12, 30));
  ctx.font = `600 ${fontSize}px Inter,system-ui,monospace`;
  ctx.lineJoin = 'round';
  for(const pl of planets){
    if(!pl || !pl.label) continue;
    const screen = worldToScreen(pl.x, pl.y, cam);
    if(screen.x < -160 || screen.x > W + 160 || screen.y < -160 || screen.y > H + 160) continue;
    const offset = ((pl.r || 0) + 40) * camera.zoom;
    const y = screen.y - offset;
    ctx.save();
    ctx.shadowColor = 'rgba(12, 22, 42, 0.7)';
    ctx.shadowBlur = fontSize * 0.4;
    ctx.lineWidth = Math.max(2, fontSize * 0.18);
    ctx.strokeStyle = 'rgba(10, 20, 36, 0.85)';
    ctx.fillStyle = 'rgba(223, 231, 255, 0.95)';
    ctx.strokeText(pl.label, screen.x, y);
    ctx.fillText(pl.label, screen.x, y);
    ctx.restore();
  }
  ctx.restore();
}

function drawStars(cam){
  // --- KONFIGURACJA EFEKTU WARP ---
  const STEADY_LENGTH = 60; // Długość kresek podczas stabilnego lotu (nie kropki, ale linie)
  const KICK_STRENGTH = 4.0; // Mnożnik przy starcie (np. 60 * 4 = 240px przy uderzeniu)
  const BRAKE_STRENGTH = 5.0; // Mnożnik przy hamowaniu (np. 60 * 5 = 300px przy wyjściu)
  // --------------------------------

  const zoom = cam?.zoom ?? camera.zoom ?? 1;
  const marginW = (W/2)/zoom + 2000;
  const marginH = (H/2)/zoom + 2000;
  const minX = Math.floor((cam.x - marginW)/STAR_CELL);
  const maxX = Math.floor((cam.x + marginW)/STAR_CELL);
  const minY = Math.floor((cam.y - marginH)/STAR_CELL);
  const maxY = Math.floor((cam.y + marginH)/STAR_CELL);

  for(let iy=minY; iy<=maxY; iy++){
    for(let ix=minX; ix<=maxX; ix++){
      const cell = getCell(ix,iy);
      for(const s of cell.stars){
        const sx = (s.x - cam.x) * zoom + W/2;
        const sy = (s.y - cam.y) * zoom + H/2;
        if(sx < -50 || sx > W+50 || sy < -50 || sy > H+50) continue;

        // 1. FAZA LOTU I STARTU (Active)
        if(warp.state==='active'){
          
          let currentStretch = 1.0; // Domyślnie 1.0 = STEADY_LENGTH

          // Jeśli dopiero wchodzimy w warp (entryProgress < 1), dodajemy "kopa"
          if (warp.entryProgress < 1.0) {
             // Sinusoida daje płynny skok w górę i powrót
             const kick = Math.sin(warp.entryProgress * Math.PI); 
             currentStretch = 1.0 + (kick * KICK_STRENGTH);
          }

          // Obliczamy finalną długość dla tej klatki
          // Dodajemy też mały wpływ paliwa (opcjonalnie), żeby smugi słabły jak brakuje energii
          const L = STEADY_LENGTH * currentStretch * (0.8 + 0.2*(warp.fuel/warp.fuelMax));
          
          // Kierunek smug (przeciwny do lotu)
          const dx = -warp.dir.x * L * zoom;
          const dy = -warp.dir.y * L * zoom;
          
          ctx.strokeStyle = 'rgba(200,220,255,0.35)';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(sx+dx, sy+dy); ctx.lineTo(sx, sy); ctx.stroke();
        } 
        
        // 2. FAZA HAMOWANIA LUB SPOCZYNKU
        else {
          
          // Jeśli timer hamowania jest aktywny
          if (typeof warpBrakeTimer !== 'undefined' && warpBrakeTimer > 0) {
             // t schodzi od 1.0 do 0.0
             const t = warpBrakeTimer / 0.8; 
             
             // Używamy t^3, aby długość malała bardzo szybko (dynamiczny "snap back")
             const tCubed = t * t * t;
             
             // Długość: Mnożymy przez BRAKE_STRENGTH
             const brakeLen = STEADY_LENGTH * BRAKE_STRENGTH * tCubed;

             // Kierunek
             let dirX = 1, dirY = 0;
             if (warp.lastDir) {
                 dirX = warp.lastDir.x;
                 dirY = warp.lastDir.y;
             } else if (ship.vel.x || ship.vel.y) {
                 const vLen = Math.hypot(ship.vel.x, ship.vel.y) || 1;
                 dirX = ship.vel.x / vLen;
                 dirY = ship.vel.y / vLen;
             }

             const dx = -dirX * brakeLen * zoom;
             const dy = -dirY * brakeLen * zoom;

             // --- POPRAWKA JASNOŚCI ---
             // Wcześniej było: 0.2 + 0.6*t (Max 0.8 -> zbyt jasne!)
             // Teraz: Max 0.3 (delikatna smuga, która nie przepala ekranu)
             const alpha = 0.05 + 0.25 * t;

             ctx.strokeStyle = `rgba(200,220,255,${alpha})`;
             ctx.lineWidth = 2; // Możesz zmienić na 1.5 dla cieńszych linii
             
             ctx.beginPath(); 
             ctx.moveTo(sx+dx, sy+dy); 
             ctx.lineTo(sx, sy); 
             ctx.stroke();
             
             // USUNIĘTO: ctx.fillRect(...) 
             // Nie rysujemy kropki na końcu smugi podczas hamowania, 
             // bo nakładanie się smugi i kropki powodowało "białe punkty".

          } 
          
          // 3. ZWYKŁY STAN (Spoczynek - rysujemy tylko kropki)
          else {
            ctx.globalAlpha = s.bright;
            ctx.fillStyle = '#ffffff';
            const flicker = 0.8 + 0.2 * Math.random();
            const baseSize = s.size * flicker * zoom;
            const minSize = 0.6 * zoom;
            const sz = Math.max(minSize, baseSize);
            const drawSize = Math.max(1, Math.ceil(sz));
            
            ctx.fillRect(Math.round(sx), Math.round(sy), drawSize, drawSize);
            ctx.globalAlpha = 1;
          }
        }
      }
    }
  }
  pruneStarCells();
}

function drawRangeRuler(ctx, cam){
  if (!DevFlags.showRuler) return;

  const cx = W / 2;
  const cy = H / 2;
  const zoom = cam?.zoom ?? camera.zoom ?? 1;

  ctx.save();
  ctx.globalAlpha = 0.5;
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#6db6ff';

  const step = 500;
  const maxWorldR = Math.min(W, H) / zoom * 0.5 * 0.95;

  for (let r = step; r < maxWorldR; r += step) {
    const rr = r * zoom;
    ctx.beginPath();
    ctx.arc(cx, cy, rr, 0, Math.PI * 2);
    ctx.stroke();

    if (r % 1000 === 0) {
      ctx.fillStyle = '#cfe6ff';
      ctx.font = '11px monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${r}`, cx + rr + 4, cy);
    }
  }

  ctx.globalAlpha = 0.25;
  const axisR = maxWorldR * zoom;
  ctx.beginPath(); ctx.moveTo(cx - axisR, cy); ctx.lineTo(cx + axisR, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, cy - axisR); ctx.lineTo(cx, cy + axisR); ctx.stroke();

  ctx.restore();
}

function drawFrigateHull(ctx, npc, screenPos){
  const hullSprite = getHullSpriteForNpc(npc);
  if (hullSprite) {
    const targetH = Math.max(4, (npc.radius || 28) * 2 * (camera.zoom || 1));
    const aspect = hullSprite.width / hullSprite.height;
    const targetW = targetH * (Number.isFinite(aspect) && aspect > 0 ? aspect : 1);
    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);
    ctx.rotate(npc.angle || 0);
    ctx.globalAlpha = npc.fade ?? 1;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(hullSprite.image, -targetW * 0.5, -targetH * 0.5, targetW, targetH);
    ctx.restore();
    return;
  }

  const w = (npc.size?.w || npc.radius*2.2) * (camera.zoom || 1);
  const h = (npc.size?.h || npc.radius*0.9) * (camera.zoom || 1);
  ctx.save();
  ctx.globalAlpha = npc.fade ?? 1;
  ctx.translate(screenPos.x, screenPos.y);
  ctx.rotate(npc.angle || 0);
  ctx.fillStyle = npc.subType === 'laser' ? '#3c2d54' : '#284b36';
  ctx.strokeStyle = npc.friendly ? '#7cff91' : '#ff5c7c';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.rect(-w*0.5,-h*0.5,w,h);
  ctx.fill(); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0,0); ctx.lineTo(w*0.6,0);
  ctx.stroke();
  if(npc.subType==='laser'){
    ctx.strokeStyle='#f0f';
    ctx.beginPath();
    ctx.moveTo(w*0.1,-h*0.25); ctx.lineTo(w*0.5,-h*0.25);
    ctx.moveTo(w*0.1,h*0.25);  ctx.lineTo(w*0.5,h*0.25);
    ctx.stroke();
  }
  ctx.restore();
}

function drawDestroyer(ctx, npc, screenPos){
  const hullSprite = getHullSpriteForNpc(npc);
  if (hullSprite) {
    const targetH = Math.max(6, (npc.radius || 45) * 2 * camera.zoom);
    const aspect = hullSprite.width / hullSprite.height;
    const targetW = targetH * (Number.isFinite(aspect) && aspect > 0 ? aspect : 1);
    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);
    ctx.rotate(npc.angle);
    ctx.globalAlpha = npc.fade ?? 1;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(hullSprite.image, -targetW * 0.5, -targetH * 0.5, targetW, targetH);
    ctx.restore();
    return;
  }

  const zoomScale = camera.zoom;
  const baseRadius = npc.radius || 70;
  const w = (npc.size?.w || baseRadius * 1.6) * zoomScale;
  const h = (npc.size?.h || baseRadius * 0.49) * zoomScale;
  ctx.save();
  ctx.translate(screenPos.x, screenPos.y);
  ctx.rotate(npc.angle);
  ctx.fillStyle = '#563c2c'; // Brązowy (Pirat)
  ctx.strokeStyle = '#ff5c7c';
  ctx.lineWidth = 2;
  
  // Kadłub
  ctx.beginPath();
  ctx.rect(-w*0.5, -h*0.5, w*0.8, h); 
  ctx.fill(); ctx.stroke();
  
  // Nadbudówka
  ctx.fillStyle = '#6e4d3d';
  ctx.beginPath();
  ctx.moveTo(w*0.1, -h*0.3); 
  ctx.lineTo(w*0.4, 0); 
  ctx.lineTo(w*0.1, h*0.3);
  ctx.fill();
  
  ctx.restore();
}

function drawBattleship(ctx, npc, screenPos){
  const hullSprite = getHullSpriteForNpc(npc);
  if (hullSprite) {
    const targetH = Math.max(8, (npc.radius || 70) * 2 * camera.zoom);
    const aspect = hullSprite.width / hullSprite.height;
    const targetW = targetH * (Number.isFinite(aspect) && aspect > 0 ? aspect : 1);
    ctx.save();
    ctx.translate(screenPos.x, screenPos.y);
    ctx.rotate(npc.angle);
    ctx.globalAlpha = npc.fade ?? 1;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(hullSprite.image, -targetW * 0.5, -targetH * 0.5, targetW, targetH);
    ctx.restore();
    return;
  }

  const zoomScale = camera.zoom;
  const baseRadius = npc.radius || 140;
  const w = (npc.size?.w || baseRadius * 1.72) * zoomScale;
  const h = (npc.size?.h || baseRadius * 0.6) * zoomScale;
  ctx.save();
  ctx.translate(screenPos.x, screenPos.y);
  ctx.rotate(npc.angle);
  ctx.fillStyle = '#462c1c'; // Ciemny brąz
  ctx.strokeStyle = '#ff5c7c'; // Czerwony obrys
  ctx.lineWidth = 3;

  // Główny kadłub (agresywny kształt)
  ctx.beginPath();
  ctx.moveTo(w*0.5, 0); 
  ctx.lineTo(w*0.3, h*0.5); 
  ctx.lineTo(-w*0.5, h*0.5);
  ctx.lineTo(-w*0.4, 0); 
  ctx.lineTo(-w*0.5, -h*0.5); 
  ctx.lineTo(w*0.3, -h*0.5);
  ctx.closePath();
  ctx.fill(); ctx.stroke();

  // Wieżyczki boczne (symboliczne)
  ctx.fillStyle = '#ff9b4b'; // Pomarańczowe
  ctx.fillRect(-w*0.2, -h*0.6, w*0.1, h*0.2); // Lewa burta
  ctx.fillRect(-w*0.2, h*0.4, w*0.1, h*0.2);  // Prawa burta

  ctx.restore();
}





  
function drawCapitalShipSprite(ctx, npc, screenPos, pixR){
  ctx.imageSmoothingEnabled = false;

  const profile = npc.capitalProfile || {};
  const lengthScale = Number.isFinite(profile.lengthScale) ? profile.lengthScale : 3.2;
  const widthScale = Number.isFinite(profile.widthScale) ? profile.widthScale : 1.2;
  
  // Obliczamy wymiary na ekranie
  const length = Math.max(1, pixR * lengthScale);
  const width = Math.max(1, pixR * widthScale);
  
  const dims = { length, width, halfL: length * 0.5, halfW: width * 0.5 };
  
  const hullColor = profile.hullColor || (npc.friendly ? '#5477bf' : '#c85a5a');
  const deckColor = profile.deckColor || '#1f2a46';
  const accentColor = profile.accentColor || '#9dc5ff';
  const engineColor = profile.engineColor || 'rgba(130,200,255,0.85)';
  const hangarGlow = profile.hangarGlow || 'rgba(160,200,255,0.35)';
  
  const spriteInfo = npc.capitalSprite || (profile.spriteSrc ? getCapitalShipSprite(profile.spriteSrc) : null);
  if (!npc.capitalSprite && spriteInfo) {
    npc.capitalSprite = spriteInfo;
  }
  const useSprite = !!(spriteInfo && spriteInfo.ready && !spriteInfo.error);

  ctx.save();
  ctx.globalAlpha = npc.fade ?? 1;
  ctx.translate(screenPos.x, screenPos.y);
  
  const spriteRotation = Number.isFinite(profile.spriteRotation) ? profile.spriteRotation : 0;
  ctx.rotate((npc.angle || 0) + spriteRotation);

  const halfL = length * 0.5;
  const halfW = width * 0.5;

  // --- POPRAWKA: Dynamiczny promień, nigdy większy niż sam statek ---
  // Zamiast sztywnych pixeli, bierzemy procent wymiaru.
  // To zapobiega "wykręcaniu" się kształtu przy oddalaniu kamery.
  const radius = Math.min(width, length) * 0.15; 
  
  let drawHullPath = null;

  const traceHullShape = (margin = 1.0) => {
      const mLen = length * margin;
      const mWid = width * margin;
      roundRect(ctx, -mLen/2, -mWid/2, mLen, mWid, radius);
  };

  if (useSprite) {
    const img = spriteInfo.image;
    const spriteScale = Number.isFinite(profile.spriteScale) ? profile.spriteScale : 1;
    const naturalW = spriteInfo.width || img.naturalWidth || 1;
    const naturalH = spriteInfo.height || img.naturalHeight || 1;
    
    // Logika skalowania
    const rawRotation = Number.isFinite(profile.spriteRotation) ? profile.spriteRotation : 0;
    const halfPi = Math.PI / 2;
    const approxSteps = Math.round(rawRotation / halfPi);
    const alignedToStep = Math.abs(rawRotation - approxSteps * halfPi) < 0.0001;
    const usesHeightForLength = alignedToStep && (Math.abs(approxSteps) % 2 === 1);
    
    const targetLength = length * spriteScale;
    const targetWidth = width * spriteScale;

    let scale;
    if (usesHeightForLength){
      scale = targetLength / Math.max(1, naturalH);
    } else {
      scale = targetLength / Math.max(1, naturalW);
    }
    let drawW = naturalW * scale;
    let drawH = naturalH * scale;

    if (targetWidth > 0){
      const crossSize = usesHeightForLength ? drawW : drawH;
      if (crossSize > targetWidth){
        const adjust = targetWidth / crossSize;
        drawW *= adjust;
        drawH *= adjust;
      }
    }

    const offset = profile.spriteOffset || { x: 0, y: 0 };
    const sc = drawW / naturalW; 
    ctx.drawImage(img, -drawW * 0.5 + (offset.x * sc), -drawH * 0.5 + (offset.y * sc), drawW, drawH);
  } else {
    // Proceduralny fallback (rysowanie prostokątów)
    ctx.fillStyle = hullColor;
    drawHullPath = () => traceHullShape(1.0);
    drawHullPath();
    ctx.fill();

    // Detale rysujemy TYLKO jeśli statek jest widoczny (większy niż kropka)
    if (length > 4 && width > 4) {
        ctx.fillStyle = deckColor;
        roundRect(ctx, -halfL * 0.78, -halfW * 0.55, length * 0.82, width * 0.58, radius * 0.7);
        ctx.fill();

        ctx.fillStyle = hangarGlow;
        roundRect(ctx, -length * 0.18, -halfW * 0.45, length * 0.36, width * 0.9, width * 0.18);
        ctx.fill();

        ctx.fillStyle = accentColor;
        ctx.fillRect(-halfL * 0.2, -halfW * 0.05, length * 0.4, width * 0.1);
    }
  }

  // --- SILNIKI (tylko jeśli statek jest wystarczająco duży) ---
  const engineOffsets = Array.isArray(profile.engineOffsets) ? profile.engineOffsets : null;
  if (engineOffsets && engineOffsets.length){
    const speed = Math.hypot(npc.vx || 0, npc.vy || 0);
    const thrust = clamp(speed / Math.max(1, npc.maxSpeed || 1), 0, 1);
    
    // Optymalizacja: nie rysuj glowa silników, jeśli statek to < 2px na ekranie
    if (width > 2) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.globalAlpha = 0.45 + thrust * 0.4;
        ctx.fillStyle = engineColor;
        const glowSize = profile.engineGlowSize || 0.26;
        for (const offset of engineOffsets){
          const local = capitalLocalFromNormalized(offset, dims);
          ctx.beginPath();
          ctx.ellipse(local.x, local.y, width * glowSize * 0.45, width * glowSize * 0.75, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
    }
  }

  // --- EFEKT TRAFIENIA ---
  if (npc.hitFlash > 0){
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = clamp(npc.hitFlash * 6, 0, 1);
    ctx.fillStyle = 'rgba(255,190,150,0.8)';
    
    if (drawHullPath){
      drawHullPath();
      ctx.fill();
    } else {
      // Fallback kształtu
      ctx.beginPath();
      traceHullShape(1.0);
      ctx.fill();
    }
    ctx.restore();
  }

  ctx.restore();
}
function drawNPCPretty(ctx, npc, s) {
  if (npc.hexGrid) {
      drawHexBody(ctx, npc, camera, worldToScreen);
      if (npc.hp < npc.maxHp) {
        const zoom = camera.zoom;
        const size = (npc.radius || 20) * zoom;
        const hpPct = Math.max(0, npc.hp / npc.maxHp);
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(-size, -size - 10, size * 2, 4);
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(-size, -size - 10, size * 2 * hpPct, 4);
        ctx.restore();
      }
      return;
  }

  if ((npc.type === 'destroyer' || npc.type === 'battleship' || npc.isCapitalShip) && !npc.hexGrid) {
      const sprite = getHullSpriteForNpc(npc) || (npc.capitalSprite && npc.capitalSprite.ready ? npc.capitalSprite : null);
      if (sprite && sprite.ready && !sprite.error) {
          initHexBody(npc, sprite.image);
          drawNPCPretty(ctx, npc, s);
          return;
      }
  }

  // 1. NAJPIERW sprawdź konkretne typy (Destroyer, Battleship, Frigate)
  // Dzięki temu użyją one Twoich nowych sprite'ów z HULL_SPRITE_PATHS
  if (npc.type === 'destroyer') {
    drawDestroyer(ctx, npc, s);
    return;
  }
  if (npc.type === 'battleship') {
    drawBattleship(ctx, npc, s);
    return;
  }
  if (npc.type && (npc.type.includes('frigate') || npc.subType === 'laser')) {
    drawFrigateHull(ctx, npc, s);
    return;
  }

  // 2. DOPIERO POTEM sprawdź czy to ogólny Capital Ship (np. Carrier gracza)
  // Jeśli to duży statek, który nie jest destroyerem/battleshipem, użyje systemu profili/sprite'ów capital
  if (npc.isCapitalShip) {
    const pixR = (npc.radius || 20) * camera.zoom;
    drawCapitalShipSprite(ctx, npc, s, pixR);
    return;
  }

  // 3. Domyślny rysunek dla myśliwców (Fighter/Interceptor)
  const zoom = camera.zoom;
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.rotate(npc.angle);

  const isFighter = npc.fighter || npc.type === 'fighter' || npc.type === 'interceptor';

  // Kolor zależny od nastawienia
  ctx.fillStyle = npc.color || (npc.friendly ? '#7cff91' : '#ff5c7c');

  // Rysowanie trójkąta (myśliwiec)
  const size = (npc.radius || 12) * zoom;
  if (isFighter && fighterSpriteState.ready && !fighterSpriteState.error) {
    const targetH = size * 2;
    const aspect = fighterSpriteState.width / fighterSpriteState.height;
    const targetW = targetH * (Number.isFinite(aspect) && aspect > 0 ? aspect : 1);
    ctx.drawImage(fighterSprite, -targetW / 2, -targetH / 2, targetW, targetH);
  } else {
    ctx.beginPath();
    ctx.moveTo(size, 0);
    ctx.lineTo(-size * 0.6, size * 0.7);
    ctx.lineTo(-size * 0.3, 0);
    ctx.lineTo(-size * 0.6, -size * 0.7);
    ctx.closePath();
    ctx.fill();

    // Obrys
    ctx.lineWidth = 1.5;
    ctx.strokeStyle = 'rgba(0,0,0,0.4)';
    ctx.stroke();
  }

  // Pasek HP nad jednostką
  if (npc.hp < npc.maxHp) {
    const hpPct = Math.max(0, npc.hp / npc.maxHp);
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(-size, -size - 6, size * 2, 3);
    ctx.fillStyle = '#22c55e';
    ctx.fillRect(-size, -size - 6, size * 2 * hpPct, 3);
  }

  ctx.restore();
}
function render(alpha, frameDt){
  canvas.style.cursor = 'default';
  //  cheats (np. nielimitowany warp)
  if (window.ApplyCheats) ApplyCheats();
  // Interpolacja stanu
  const interpPos = {
    x: prevState.pos.x + (ship.pos.x - prevState.pos.x) * alpha,
    y: prevState.pos.y + (ship.pos.y - prevState.pos.y) * alpha
  };
  const interpAngle = interpAngleShort(prevState.angle, ship.angle, alpha);
  const interpTurretAngle = interpAngleShort(prevState.turretAngle, ship.turret.angle, alpha);
  const interpTurretAngle2 = interpAngleShort(prevState.turretAngle2, ship.turret2.angle, alpha);
  const interpTurretAngle3 = interpAngleShort(prevState.turretAngle3, ship.turret3.angle, alpha);
  const interpTurretAngle4 = interpAngleShort(prevState.turretAngle4, ship.turret4.angle, alpha);
  const interpCIWSAngles = ship.ciws.map((c,i)=>interpAngleShort(prevState.ciwsAngles[i], c.angle, alpha));

  // Kamera
  if(camera.mode === 'ship'){
    camera.x = interpPos.x;
    camera.y = interpPos.y;
  } else if(camera.mode === 'focus'){
    const st = camera.focusStation;
    if(st){
      camera.x = st.x;
      camera.y = st.y;
    } else {
      camera.clearFocus();
      camera.x = interpPos.x;
      camera.y = interpPos.y;
    }
  } else if(camera.mode === 'infrastructure'){
    const st = camera.focusStation;
    if(!st){
      camera.clearFocus();
      camera.x = interpPos.x;
      camera.y = interpPos.y;
    }
  }
  const cam = { x: camera.x, y: camera.y, zoom: camera.zoom };
  if(!DevFlags.disableCameraShake && camera.shakeMag > 0){
    const t = camera.shakeTime / camera.shakeDur;
    const mag = camera.shakeMag * Math.max(0, t);
    cam.x += (Math.random()*2 - 1) * mag;
    cam.y += (Math.random()*2 - 1) * mag;
  }

  overlayView.center.x = cam.x;
  overlayView.center.y = cam.y;
  overlayView.viewport.w = W;
  overlayView.viewport.h = H;
  overlayView.zoom = cam.zoom;

  // aktualizuj wyświetlanie czasu
  gameTimeEl.textContent = formatGameTime(gameTime);
  updatePlayerStatusUI();
  updateFleetUI();
  updatePlanetRadar(ship, cam);

  // Czyścimy ekran
  ctx.clearRect(0,0,W,H);
  spaceBg?.drawSpaceBg?.(ctx, cam);
  if (warpBlackHoleFX) {
    configureWarpLensSource();
  }
  ensurePlanetStationsInit(stations);
  if (window.updatePlanets3D) updatePlanets3D(frameDt);
  // najpierw zaktualizuj pozycje stacji 3D...
  if (window.updateStations3D) window.updateStations3D(stations);
  // ...a potem wyrenderuj overlay sceny 3D
  if (window.updateWorld3D) updateWorld3D(frameDt, vfxTime);

  // Gwiazdy (proceduralne kafelki na całej mapie)
  drawStars(cam);

  // scan waves
  for(const w of scanWaves){
    const s = worldToScreen(w.x, w.y, cam);
    ctx.strokeStyle = 'rgba(120,200,255,0.18)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, w.r * camera.zoom, 0, Math.PI*2); ctx.stroke();
  }

  ctx.globalCompositeOperation = 'source-over';
  ctx.imageSmoothingEnabled = true;
  if (window.drawPlanets3D)   drawPlanets3D(ctx, cam);      // planety
  if (window.drawStations3D)  drawStations3D(ctx, cam, worldToScreen); // STACJE 3D NAD PLANETAMI (sprite per-stacja)
  if (window.drawWorld3D)     drawWorld3D(ctx, cam, worldToScreen); // np. piracka stacja (spotlight)
  if(stationUI.editorMode && stationUI.station){
    const infraState = ensureInfrastructureState(stationUI.station);
    if(infraState) drawInfrastructureGrid(ctx, cam, stationUI.station, infraState);
  }
  drawInfrastructureInstances(ctx, cam);
  drawPlanetLabels(ctx, cam);
  drawRangeRuler(ctx, cam);
  if (window.drawSunDirection) drawSunDirection(ctx, cam);

  // Warp gates
  for(const key in warpRoutes){
    const route = warpRoutes[key];
    const perp = { x: -route.dir.y, y: route.dir.x };
    const w = 6*camera.zoom;
    const s1 = worldToScreen(route.start.x, route.start.y, cam);
    const s2 = worldToScreen(route.end.x, route.end.y, cam);
    ctx.strokeStyle = '#88aaff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(s1.x - perp.x*w, s1.y - perp.y*w);
    ctx.lineTo(s1.x + perp.x*w, s1.y + perp.y*w);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(s2.x - perp.x*w, s2.y - perp.y*w);
    ctx.lineTo(s2.x + perp.x*w, s2.y + perp.y*w);
    ctx.stroke();
  }

  // Shockwaves (na warstwie świata, pod HUD)
  for(const s of shockwaves){
    const sw = worldToScreen(s.x, s.y, cam);
    ctx.beginPath();
    ctx.lineWidth = s.w * camera.zoom;
    ctx.strokeStyle = s.color + (1 - s.life/s.maxLife) + ')';
    ctx.arc(sw.x, sw.y, s.r * camera.zoom, 0, Math.PI*2);
    ctx.stroke();
  }

  if (!window.USE_STATION_3D) {
    for (const st of stations){
      const s = worldToScreen(st.x, st.y, cam);
      const visR = (st.baseR || st.r) * stationScaleFor(st);
      const rr = visR * camera.zoom;

      drawStationShadow(ctx, st, cam);
      drawStationVFX(ctx, st, s.x, s.y, rr, gameTime);

      for (let i=0;i<st.ports.length;i++){
        const pw = stationPortWorld(st, i);
        const ps = worldToScreen(pw.x, pw.y, cam);
        ctx.fillStyle = '#60a5fa';
        ctx.beginPath(); ctx.arc(ps.x, ps.y, 4*camera.zoom, 0, Math.PI*2); ctx.fill();
      }
      ctx.fillStyle = '#dfe7ff'; ctx.font = `${12*camera.zoom}px monospace`;
      ctx.fillText('ST'+st.id, s.x - rr*0.35, s.y + 4*camera.zoom);
    }
  }

  if(mercMission && mercMission.weaponPlatforms){
    for(const platform of mercMission.weaponPlatforms){
      if(!platform || platform.removed) continue;
      const s = worldToScreen(platform.x, platform.y, cam);
      const size = platform.radius * 2 * camera.zoom;
      const baseAlpha = platform.destroyed ? Math.max(0, 1 - platform.deathTimer / 1.5) : 1;
      if(baseAlpha <= 0) continue;
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(platform.rotation);
      ctx.globalAlpha = baseAlpha;
      ctx.drawImage(platform.canvas, -size/2, -size/2, size, size);
      if(platform.hitFlash > 0){
        const flash = clamp(platform.hitFlash / 0.18, 0, 1);
        ctx.globalAlpha = flash * baseAlpha;
        const flashR = size * 0.34;
        ctx.fillStyle = 'rgba(255,215,150,0.6)';
        ctx.beginPath(); ctx.arc(0, 0, flashR, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();

      if(platform.shield && !platform.destroyed && platform.shield.val > 0){
        const frac = clamp(platform.shield.val / platform.shield.max, 0, 1);
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.globalAlpha = 0.45 + 0.35 * frac;
        ctx.lineWidth = Math.max(1.2, 2.4 * camera.zoom);
        ctx.strokeStyle = 'rgba(120,200,255,0.8)';
        ctx.beginPath(); ctx.arc(0, 0, size*0.62, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }
    }
  }

  // Rysowanie wraków (hex-grid)
  for (const w of wrecks) {
    if (window.drawHexBody) {
      window.drawHexBody(ctx, w, camera, worldToScreen);
    }
  }

  // NPC
  const npcDrawList = [];
  for (const npc of npcs){
    if (!npc || npc.dead) continue;
    npcDrawList.push(npc);
  }
  npcDrawList.sort((a, b) => (a.drawLayer || 0) - (b.drawLayer || 0));
  for (const npc of npcDrawList){
    const s = worldToScreen(npc.x, npc.y, cam);
    drawNPCPretty(ctx, npc, s);
  }

  if (Selection.units.size){
    ctx.save();
    ctx.strokeStyle = '#4a9eff';
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.9;
    for (const unit of [...Selection.units]){
      if(!unit || unit.dead){ Selection.units.delete(unit); continue; }
      const pos = unit.pos || unit;
      const baseR = unit.radius || unit.w || 30;
      const screen = worldToScreen(pos.x, pos.y, cam);
      ctx.beginPath();
      ctx.arc(screen.x, screen.y, Math.max(20, baseR + 12) * camera.zoom, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();
  }

  if (PAUSED && Selection.active && Selection.rect){
    const x0 = Math.min(Selection.rect.x0, Selection.rect.x1);
    const y0 = Math.min(Selection.rect.y0, Selection.rect.y1);
    const x1 = Math.max(Selection.rect.x0, Selection.rect.x1);
    const y1 = Math.max(Selection.rect.y0, Selection.rect.y1);
    const s0 = worldToScreen(x0, y0, cam);
    const s1 = worldToScreen(x1, y1, cam);
    ctx.save();
    ctx.strokeStyle = '#7aa8ff';
    ctx.globalAlpha = 0.8;
    ctx.lineWidth = 2;
    ctx.strokeRect(Math.min(s0.x, s1.x), Math.min(s0.y, s1.y), Math.abs(s1.x - s0.x), Math.abs(s1.y - s0.y));
    ctx.restore();
  }

  // === Warp Lens Pass (rysowany pod statkiem i tarczą) ===
  let warpLensShouldDraw = false;
  let warpLensOutputCanvas = null;

  if (warpBlackHoleFX) {
    const isWarpActive   = (warp.state === 'active');
    const entryProgress  = isWarpActive ? clamp(warp.entryProgress, 0, 1) : 0;
    const warpIntensity  = isWarpActive ? smoothstep01(entryProgress) : 0;

    const lensThreshold  = getWarpLensThreshold();
    const desiredLensMode = (warpIntensity >= lensThreshold) ? 'full' : 'background';
    if (desiredLensMode !== warpLensMode) {
      warpLensMode  = desiredLensMode;
      warpLensSource = null;
    }
    if (!warpLensSource) {
      configureWarpLensSource();
    }

    const zoneAllowsWarpLens = zoneState.current?.wormholeVfx ?? false;
    const shouldRenderWarpLens = isWarpActive && warpIntensity > 0.001 && zoneAllowsWarpLens;
    warpBlackHoleFX.setEnabled(shouldRenderWarpLens && !!warpLensSource);

    if (shouldRenderWarpLens && warpLensSource) {
      const engineTail     = ship.visual?.mainEngine?.y ?? (ship.h * 0.5);
      const tailDepthExtra = warpLensParam('tailDepthExtra');
      const warpDepth      = engineTail + ship.h * tailDepthExtra;

      const tailOffset = rotate({ x: 0, y: warpDepth }, interpAngle);

      const s = {
        x: W / 2 + tailOffset.x * camera.zoom,
        y: H / 2 + tailOffset.y * camera.zoom
      };

      const radiusBase    = warpLensParam('radiusBase');
      const radiusScale   = warpLensParam('radiusScale');
      const massBase      = warpLensParam('massBase');
      const massScale     = warpLensParam('massScale');
      const softness      = Math.min(1, Math.max(0, warpLensParam('softness')));
      const opacityBase   = warpLensParam('opacityBase');
      const opacityScale  = warpLensParam('opacityScale');

      const baseRadius    = Math.max(0.01, radiusBase + radiusScale * warpIntensity);
      const referenceZoom = Math.max(0.0001, camera.defaultZoom || 1);
      const zoomFactor    = camera.zoom / referenceZoom;
      const radius        = Math.min(1, baseRadius * zoomFactor);

      const baseMass      = Math.max(0, (massBase + massScale * warpIntensity) * warpIntensity);
      const mass          = Math.min(0.6, baseMass * zoomFactor * zoomFactor);
      const opacity       = Math.min(1, Math.max(0, (opacityBase + opacityScale * warpIntensity) * warpIntensity));

      const forwardStretchParam  = warpLensParam('forwardStretch');
      const forwardStretchMajor  = forwardStretchParam >= 1
        ? forwardStretchParam
        : 1 + (1 - forwardStretchParam);

      const lensStretchFactor = 1 + (forwardStretchMajor - 1) * warpIntensity;
      const lensAngle = ship.angle || 0;

      warpBlackHoleFX.render({
        centerX: s.x,
        centerY: s.y,
        mass,
        radius,
        softness,
        rotation: lensAngle,
        opacity,
        lensStretchForward: lensStretchFactor
      });

      let updated = false;
      if (typeof warpBlackHoleFX.updateOutputBuffer === 'function') {
        updated = warpBlackHoleFX.updateOutputBuffer();
      }

      warpLensOutputCanvas = (typeof warpBlackHoleFX.getOutputCanvas === 'function')
        ? warpBlackHoleFX.getOutputCanvas()
        : null;

      warpLensShouldDraw = !!(
        updated &&
        warpLensOutputCanvas &&
        warpLensOutputCanvas.width &&
        warpLensOutputCanvas.height
      );
    }
  }

  if (warpLensShouldDraw && warpLensOutputCanvas && warpLensOutputCanvas.width && warpLensOutputCanvas.height) {
    ctx.save();
    ctx.globalCompositeOperation = 'source-over';
    ctx.drawImage(
      warpLensOutputCanvas,
      0, 0, warpLensOutputCanvas.width, warpLensOutputCanvas.height,
      0, 0, canvas.width, canvas.height
    );
    ctx.restore();
  }

  // ======= STATEK =======
  const shipS = worldToScreen(interpPos.x, interpPos.y, cam);
  const spriteScale = ship.visual?.spriteScale || 1;
  const visualW = ship.w * spriteScale;
  const visualH = ship.h * spriteScale;
  
  ctx.save(); 
  ctx.translate(shipS.x, shipS.y); 
  ctx.scale(camera.zoom, camera.zoom); 
  ctx.rotate(interpAngle);

  // --- 1. OBLICZANIE ACTIVE THRUSTERS (Przeniesione na górę - FIX BŁĘDU) ---
  const activeThrusters = [];
  let overrides = null;

  if (ship.visual?.torqueThrusters?.length) {
    const thrusters = ship.visual.torqueThrusters;
    const strafeLeft = clamp(input.leftSide ?? 0, 0, 1);
    const strafeRight = clamp(input.rightSide ?? 0, 0, 1);
    const torqueInput = clamp(input.torque ?? 0, -1, 1);
    const torqueIntensity = Math.abs(torqueInput);
    let globalIntensity = 0;

    for (const thruster of thrusters) {
      const strafeIntensity = thruster.side === 'left' ? strafeLeft : strafeRight;
      let thrusterIntensity = strafeIntensity;

      if (torqueIntensity > 0) {
        const isTop = thruster.offset.y < 0;
        const isBottom = thruster.offset.y > 0;
        if (torqueInput < 0) {
          const shouldFire = (thruster.side === 'right' && isTop) || (thruster.side === 'left' && isBottom);
          if (shouldFire) thrusterIntensity = Math.max(thrusterIntensity, torqueIntensity);
        } else if (torqueInput > 0) {
          const shouldFire = (thruster.side === 'left' && isTop) || (thruster.side === 'right' && isBottom);
          if (shouldFire) thrusterIntensity = Math.max(thrusterIntensity, torqueIntensity);
        }
      }

      thrusterIntensity = clamp(thrusterIntensity, 0, 1);
      if (thrusterIntensity > 0) {
        activeThrusters.push({ thruster, intensity: thrusterIntensity });
        globalIntensity = Math.max(globalIntensity, thrusterIntensity);
      }
    }

    if (globalIntensity > 0) {
      overrides = {
        throttleOverride: globalIntensity,
        warpOverride: 0,
        boostOverride: 0,
        moveGlowOverride: 0
      };
    }
  }

  // --- 5. VFX SILNIKÓW (Przeniesione na górę) ---
  // A. Boczne silniki (Strafe/Torque)
  if (activeThrusters.length) {
      for (const { thruster, intensity } of activeThrusters) {
        const tuneW = window.VFX_TUNE?.sideW ?? 1.0;
        const tuneL = window.VFX_TUNE?.sideL ?? 1.0;

        const widthPxMin = thruster.vfxWidthMin != null ? thruster.vfxWidthMin : spriteScale * 128 * 1.0;
        const widthPxMax = thruster.vfxWidthMax != null ? thruster.vfxWidthMax : spriteScale * 128 * 1.10;
        const lengthPxMin = thruster.vfxLengthMin != null ? thruster.vfxLengthMin : spriteScale * 256 * 0.2;
        const lengthPxMax = thruster.vfxLengthMax != null ? thruster.vfxLengthMax : spriteScale * 256 * 0.4;

        const widthPx = lerp(widthPxMin, widthPxMax, intensity);
        const lengthPx = lerp(lengthPxMin, lengthPxMax, intensity);

        const widthScale = Math.max(0.0001, (widthPx / 128) * tuneW);
        const lengthScale = Math.max(0.0001, (lengthPx / 256) * tuneL);
        const alpha = 0.55 + intensity * 0.35;

        drawNeedleEngineVfxLocal(thruster.offset, thruster.forward, {
          widthScale,
          lengthScale,
          yNudge: thruster.yNudge,
          alpha,
          overrides
        });
      }
  }

  // B. Główny silnik
  {
    const e = ship.engines.main;
    const visualOffset = e.visualOffset || e.offset;
    const forward = { x: 0, y: -1 };
    const spd = Math.hypot(ship.vel.x, ship.vel.y);
    const moveGlow = Math.min(spd / 900, 0.6) * 0.8;
    const throttle = Math.max(input.main || 0, moveGlow);

    const mainW = window.VFX_TUNE?.mainW ?? 1.0;
    const mainL = window.VFX_TUNE?.mainL ?? 1.0;

    const widen = (2.4 + 0.6 * throttle) * mainW;
    const lenBase = 1.0 * mainL;

    drawNeedleEngineVfxLocal(visualOffset, forward, {
      widthScale: widen,
      lengthScale: lenBase,
      yNudge: -68 * spriteScale,
      alpha: 1
    });
  }

  // --- 2. Rysowanie Warp Glow (ładowanie) ---
  let warpGlowProgress = 0;
  if(warp.state === 'charging'){
    warpGlowProgress = clamp(warp.charge / warp.chargeTime, 0, 1);
  } else if(warp.state === 'active' && warp.entryProgress < 1){
    warpGlowProgress = 1 - smoothstep01(warp.entryProgress);
  }
  if(warpGlowProgress > 0){
    const chargeRadius = Math.max(visualW, visualH) * 0.7;
    drawWarpChargeEffectLocal(warpGlowProgress, chargeRadius, spriteScale);
  }

  // --- 3. Rysowanie KADŁUBA ---
  if (ship.hexGrid) {
      drawHexBodyLocal(ctx, ship);
  if (ship.hp < ship.maxHp) {
        const zoom = camera.zoom;
        const size = (ship.radius || 20); // Usunąłem * zoom, bo ctx jest już wyskalowany w linii 2010
        const hpPct = Math.max(0, ship.hp / ship.maxHp);
        ctx.save();
        // Rysujemy lokalnie względem statku
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(-size, -size - 10, size * 2, 4);
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(-size, -size - 10, size * 2 * hpPct, 4);
        ctx.restore();
      }
      // Nie robimy return, żeby silniki i efekty (rysowane dalej) się wykonały
  }
  else if (USE_SHIP_SPRITE && ship.spriteReady) {
    const scale = (ship.h / ship.spriteH) * spriteScale;
    const drawW = ship.spriteW * scale;
    const drawH = ship.spriteH * scale;

    ctx.save();
    ctx.globalAlpha = 0.33;
    ctx.filter = 'blur(2px)';
    ctx.drawImage(shipSprite, -drawW/2 + 6, -drawH/2 + 8, drawW, drawH);
    ctx.restore();

    ctx.drawImage(shipSprite, -drawW/2, -drawH/2, drawW, drawH);
  } else {
    // Fallback proceduralny (gdy brak sprite'a)
    ctx.fillStyle = 'rgba(3,8,18,0.8)';
    ctx.fillRect(-visualW/2 + 6*spriteScale, -visualH/2 + 8*spriteScale, visualW, visualH);
    const g = ctx.createLinearGradient(-visualW/2, -visualH/2, visualW/2, visualH/2);
    g.addColorStop(0, '#1d2740'); g.addColorStop(1, '#2d3b55');
    ctx.fillStyle = g;
    roundRect(ctx, -visualW/2, -visualH/2, visualW, visualH, 10 * spriteScale);
    ctx.fill();

    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1.5;
    roundRect(ctx, -visualW/2, -visualH/2, visualW, visualH, 10 * spriteScale);
    ctx.stroke();
    ctx.globalAlpha = 0.25;
    ctx.beginPath();
    ctx.moveTo(-visualW*0.35, -visualH*0.20); ctx.lineTo(visualW*0.35, -visualH*0.20);
    ctx.moveTo(-visualW*0.35,  visualH*0.20); ctx.lineTo(visualW*0.35,  visualH*0.20);
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();

    ctx.fillStyle = '#a8d1ff';
    ctx.beginPath();
    ctx.ellipse(0, -6*spriteScale, visualW*0.22, visualH*0.22, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.save();
    ctx.rotate(-interpAngle);
    const glare = ctx.createRadialGradient(0, -visualH*0.18, 6*spriteScale, 0, -visualH*0.18, visualW*0.5);
    glare.addColorStop(0, 'rgba(255,255,255,0.25)');
    glare.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = glare;
    ctx.beginPath();
    ctx.ellipse(0, -6*spriteScale, visualW*0.22, visualH*0.22, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  // --- 4. Rysowanie ELEMENTÓW PROCEDURALNYCH (gdy brak sprite'a) ---
  if (!(USE_SHIP_SPRITE && ship.spriteReady)) {
    for (const pod of ship.pods) {
      ctx.save();
      ctx.translate(pod.offset.x, pod.offset.y);
      const pg = ctx.createLinearGradient(-pod.w/2, -pod.h/2, pod.w/2, pod.h/2);
      pg.addColorStop(0, '#1d2740'); pg.addColorStop(1, '#2d3b55');
      ctx.fillStyle = pg;
      roundRect(ctx, -pod.w/2, -pod.h/2, pod.w, pod.h, 6 * spriteScale);
      ctx.fill();
      ctx.restore();
    }

    const mainE = ship.engines.main;
    ctx.save();
    const mainVisual = mainE.visualOffset || mainE.offset;
    ctx.translate(mainVisual.x, mainVisual.y);
    ctx.fillStyle = '#2a3a56';
    roundRect(ctx, -14*spriteScale, -9*spriteScale, 28*spriteScale, 18*spriteScale, 6*spriteScale);
    ctx.fill();
    ctx.save();
    ctx.globalAlpha = 0.8;
    ctx.shadowBlur = 20;
    ctx.shadowColor = 'rgba(150,200,255,0.9)';
    ctx.fillStyle = 'rgba(160,210,255,0.75)';
    roundRect(ctx, -8*spriteScale, -6*spriteScale, 16*spriteScale, 12*spriteScale, 4*spriteScale);
    ctx.fill();
    ctx.restore();
    ctx.restore();

    for (const k of ['sideLeft','sideRight','torqueLeft','torqueRight']) {
      const e = ship.engines[k];
      ctx.save();
      const vis = e.visualOffset || e.offset;
      ctx.translate(vis.x, vis.y);
      ctx.fillStyle = '#2f3b57';
      roundRect(ctx, -6*spriteScale, -6*spriteScale, 12*spriteScale, 12*spriteScale, 3*spriteScale);
      ctx.fill();
      ctx.restore();
    }

    // Działka boczne
    ctx.fillStyle = '#cbd6ff';
    for (const off of ship.sideGunsLeft) {
      ctx.save();
      ctx.translate(off.x, off.y);
      roundRect(ctx, -12*spriteScale, -3*spriteScale, 8*spriteScale, 6*spriteScale, 3*spriteScale);
      ctx.fill();
      ctx.restore();
    }
    for (const off of ship.sideGunsRight) {
      ctx.save();
      ctx.translate(off.x, off.y);
      roundRect(ctx, 4*spriteScale, -3*spriteScale, 8*spriteScale, 6*spriteScale, 3*spriteScale);
      ctx.fill();
      ctx.restore();
    }
  }

  // --- 6. WIEŻYCZKI I CIWS ---
  // CIWS
  const ciwsBase = 8 * spriteScale, ciwsBarrelLen = 12 * spriteScale, ciwsBarrelH = 4 * spriteScale;
  const activeCIWS = (Game.player.weapons?.[HP.AUX]?.length || 0);
  ship.ciws.forEach((c,i)=>{
    if(i >= activeCIWS) return;
    const ang = interpCIWSAngles[i];
    const loadout = Game.player.weapons?.[HP.AUX]?.[i];
    const isLaser = loadout?.weapon?.id === 'laser_pd_mk1';
    const baseColor = isLaser ? '#7cc6ff' : '#b8bcc6';
    const barrelColor = isLaser ? '#e6f6ff' : '#d0d0d0';
    ctx.save();
    ctx.translate(c.offset.x, c.offset.y);
    ctx.rotate(ang - interpAngle);
    if(isLaser){
      ctx.shadowColor = 'rgba(90,180,255,0.4)';
      ctx.shadowBlur = 8 * spriteScale;
    }
    ctx.fillStyle = baseColor;
    roundRect(ctx, -ciwsBase/2, -ciwsBase/2, ciwsBase, ciwsBase, 2); ctx.fill();
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(30,50,90,0.45)'; ctx.stroke();
    ctx.fillStyle = barrelColor;
    roundRect(ctx, ciwsBase/2, -ciwsBarrelH/2, ciwsBarrelLen, ciwsBarrelH, 2); ctx.fill(); ctx.stroke();
    ctx.restore();
  });

  // Główne wieżyczki
  const baseW = 16 * spriteScale,
        baseH = 24 * spriteScale,
        barrelLen = Math.max(14 * spriteScale, Math.round(visualH * 0.16)) / 2,
        barrelH = 6 * spriteScale,
        gap = 10 * spriteScale; 
  const turrets = [
    { t: ship.turret,  ang: interpTurretAngle },
    { t: ship.turret2, ang: interpTurretAngle2 },
    { t: ship.turret3, ang: interpTurretAngle3 },
    { t: ship.turret4, ang: interpTurretAngle4 }
  ];
  const mainWeaponLoadouts = Game.player.weapons?.[HP.MAIN] || [];
  turrets.forEach(({ t, ang }, index) => {
    ctx.save();
    ctx.translate(t.offset.x, t.offset.y);
    ctx.rotate(ang - interpAngle);
    const recoil = t.recoil * spriteScale;
    const loadout = mainWeaponLoadouts[index];
    const behavior = getMainWeaponBehaviorForWeaponId(loadout?.weapon?.id);
    const barrelsPerShot = Math.max(1, behavior.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot);

    if(barrelsPerShot === 1){
      const weaponId = loadout?.weapon?.id;
      if(weaponId === 'heavy_autocannon' && heavyAutocannonSpriteReady){
        const naturalW = heavyAutocannonSprite.naturalWidth || 180;
        const naturalH = heavyAutocannonSprite.naturalHeight || 120;
        const scaleMul = spriteScale * 0.32;
        const drawW = naturalW * scaleMul;
        const drawH = naturalH * scaleMul;
        const pivotOffset = drawW * 0.52;
        const recoilOffset = recoil * 0.9;
        ctx.save();
        ctx.translate(-pivotOffset - recoilOffset, -drawH / 2);
        ctx.drawImage(heavyAutocannonSprite, 0, 0, drawW, drawH);
        ctx.restore();

        const glowRadius = drawH * 0.34;
        const glowLength = drawW * 0.32;
        ctx.save();
        ctx.translate(drawW * 0.36 - recoil * 0.55, 0);
        const gradient = ctx.createRadialGradient(0, 0, glowRadius * 0.2, 0, 0, glowRadius);
        gradient.addColorStop(0, 'rgba(255,214,160,0.55)');
        gradient.addColorStop(1, 'rgba(255,166,70,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, glowLength, glowRadius * 0.55, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.fillStyle = 'rgba(255,194,120,0.22)';
        ctx.beginPath();
        ctx.moveTo(drawW * 0.34 - recoil * 0.4, -drawH * 0.18);
        ctx.lineTo(drawW * 0.58 - recoil * 0.3, 0);
        ctx.lineTo(drawW * 0.34 - recoil * 0.4, drawH * 0.18);
        ctx.closePath();
        ctx.fill();
      } else {
        const housingW = 20 * spriteScale;
        const housingH = 30 * spriteScale;
        ctx.fillStyle = '#7f8fb7';
        roundRect(ctx, -housingW/2, -housingH/2, housingW, housingH, 6 * spriteScale); ctx.fill();
        ctx.lineWidth = 1.4; ctx.strokeStyle = 'rgba(24,38,68,0.55)'; ctx.stroke();
        ctx.fillStyle = '#aebce0';
        roundRect(ctx, -housingW/2 + 3 * spriteScale, -housingH/2 + 4 * spriteScale, housingW - 6 * spriteScale, housingH - 8 * spriteScale, 5 * spriteScale); ctx.fill();
        ctx.fillStyle = 'rgba(255,180,110,0.8)';
        roundRect(ctx, -housingW/2 + 2.5 * spriteScale, -2 * spriteScale, housingW * 0.42, 4 * spriteScale, 2 * spriteScale); ctx.fill();
        ctx.strokeStyle = 'rgba(24,38,68,0.55)';
        ctx.fillStyle = '#d9dde9';
        const barrelThickness = 8 * spriteScale;
        const barrelL = Math.max(20 * spriteScale, Math.round(visualH * 0.22));
        roundRect(ctx, 8 * spriteScale - recoil, -barrelThickness/2, barrelL, barrelThickness, 3 * spriteScale); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#f0b97a';
        ctx.beginPath();
        ctx.moveTo(8 * spriteScale - recoil + barrelL, -barrelThickness/2);
        ctx.lineTo(8 * spriteScale - recoil + barrelL + 6 * spriteScale, 0);
        ctx.lineTo(8 * spriteScale - recoil + barrelL, barrelThickness/2);
        ctx.closePath();
        ctx.fill();
      }
    } else {
      ctx.fillStyle = '#9ab7ff'; roundRect(ctx, -baseW/2, -baseH/2, baseW, baseH, 5 * spriteScale); ctx.fill();
      ctx.lineWidth = 1.2; ctx.strokeStyle = 'rgba(30,50,90,0.45)'; ctx.stroke();
      ctx.fillStyle = '#c0c0c0';
      roundRect(ctx, 6*spriteScale - recoil, -gap/2 - barrelH/2, barrelLen, barrelH, 3 * spriteScale); ctx.fill(); ctx.stroke();
      roundRect(ctx, 6*spriteScale - recoil,  gap/2 - barrelH/2, barrelLen, barrelH, 3 * spriteScale); ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  });
  ctx.restore(); // ship

  // === Projectile Pass ===
  for(const b of bullets){
    drawBulletVisual(ctx, b, cam);
  }

  // === VFX Pass ===
  for(const p of particlePool){
    if(!p.active || !p.beam) continue;
    const s1 = worldToScreen(p.start.x, p.start.y, cam);
    const s2 = worldToScreen(p.end.x, p.end.y, cam);
    const alphaFactor = clamp(1 - p.age/Math.max(p.life, 0.0001), 0, 1);
    const baseAlpha = (p.alpha != null) ? p.alpha : 1;
    const fade = (p.fadeWithLife === false) ? baseAlpha : baseAlpha * alphaFactor;
    if(fade <= 0) continue;
    const outerWidthMul = (p.outerWidthMul != null) ? p.outerWidthMul : 1.4;
    const innerWidthMul = (p.innerWidthMul != null) ? p.innerWidthMul : 0.6;
    const glowBlur = ((p.glowBlur != null) ? p.glowBlur : 30) * camera.zoom;
    const glowColor = p.glowColor || 'rgba(120,180,255,0.9)';
    const colorOuter = p.colorOuter || 'rgba(160,210,255,0.7)';
    const colorInner = p.colorInner || 'rgba(220,240,255,1.0)';

    ctx.save();
    ctx.globalAlpha = fade;
    ctx.lineCap = 'round';
    ctx.shadowBlur = glowBlur;
    ctx.shadowColor = glowColor;
    ctx.strokeStyle = colorOuter;
    ctx.lineWidth = p.width * camera.zoom * outerWidthMul;
    ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = fade;
    ctx.lineCap = 'butt';
    ctx.strokeStyle = colorInner;
    ctx.lineWidth = p.width * camera.zoom * innerWidthMul;
    ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    ctx.restore();
  }

  {
    ctx.save();

    let drawn = 0;
    for (const p of particlePool) {
      if (!p.active || p.flash || p.beam) continue;
      if (drawn >= MAX_PARTICLES_DRAW) break;
      drawn++;

      // Pomijanie cząsteczek poza ekranem (Frustum culling)
      const s = worldToScreen(p.pos.x, p.pos.y, cam);
      if (s.x < -10 || s.x > W + 10 || s.y < -10 || s.y > H + 10) continue;

      const size = p.size * camera.zoom;
      if (size < 0.5) continue; // Nie rysuj sub-pikselowych śmieci

      const t = 1 - p.age/p.life; // Alpha

      ctx.globalAlpha = clamp(t, 0, 1);
      ctx.fillStyle = p.color;

      if (size < 4) {
          // Dla małych cząsteczek rysujemy kwadrat (znacznie szybsze niż arc)
          ctx.fillRect(s.x - size/2, s.y - size/2, size, size);
      } else {
          ctx.beginPath();
          ctx.arc(s.x, s.y, size, 0, Math.PI*2);
          ctx.fill();
      }
    }
    ctx.restore(); // Przywróć stan raz na koniec
  }

  DestructorSystem.draw(ctx, cam, worldToScreen);

  // === Shield Pass ===
  for (const npc of npcDrawList){
    if (!npc.shield) continue;
    drawShield(ctx, npc, cam);
  }
  if(ship.shield){
    drawShield(ctx, ship, cam);
  }

  // === UI / HUD Pass ===
  hudRenderNav(ship, cam);
  hudRenderDMG(cam);
  hudRenderFloatingBars(ship, cam);
  for(const ping of radarPings){
    const s = worldToScreen(ping.x, ping.y, cam);
    const t = ping.age/ping.life;
    ctx.strokeStyle = `rgba(120,200,255,${1-t})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, 40 * t * camera.zoom, 0, Math.PI*2); ctx.stroke();
  }

  if(scan.target && scan.targetType && mouse.overCanvas){
    const obj = scan.target;
    const s = worldToScreen(obj.x, obj.y, cam);
    const base = (obj.radius || obj.r || 60);
    const outerExtra = scan.targetType === 'station' ? 28 : 14;
    const innerExtra = scan.targetType === 'station' ? 12 : 8;
    const outerR = (base + outerExtra) * camera.zoom;
    const innerR = Math.max(2, (base + innerExtra) * camera.zoom);
    const color = scan.targetType === 'station'
      ? 'rgba(143,181,255,0.95)'
      : (obj.friendly ? 'rgba(96,192,255,0.95)' : 'rgba(255,160,122,0.95)');

    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(2, 2.5 * Math.sqrt(camera.zoom));
    ctx.shadowBlur = 18 * camera.zoom;
    ctx.shadowColor = color;
    ctx.globalAlpha = 0.9;
    ctx.beginPath(); ctx.arc(s.x, s.y, outerR, 0, Math.PI*2); ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.55;
    ctx.setLineDash([6 * camera.zoom, 6 * camera.zoom]);
    ctx.beginPath(); ctx.arc(s.x, s.y, innerR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();

    if(scan.targetType === 'station' && !stationUI.open){
      canvas.style.cursor = 'pointer';
    }
  }
  if(highlightedEnemies.length){
    for(const obj of highlightedEnemies){
      if(obj.dead) continue;
      const s = worldToScreen(obj.x, obj.y, cam);
      const rad = ((obj.radius||obj.r) + 12) * camera.zoom;
      ctx.strokeStyle = 'rgba(255,255,0,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
    }
  }
  if(lockedTargets.length){
    for(const obj of lockedTargets){
      if(obj.dead) continue;
      const s = worldToScreen(obj.x, obj.y, cam);
      const rad = ((obj.radius||obj.r) + 14) * camera.zoom;
      ctx.strokeStyle = 'rgba(255,80,80,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
    }
  } else if(lockedTarget){
    const obj = lockedTarget;
    const s = worldToScreen(obj.x, obj.y, cam);
    const rad = ((obj.radius||obj.r) + 14) * camera.zoom;
    ctx.strokeStyle = 'rgba(255,80,80,0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
  }

  // scan arrows pointing to stations
  if(warp.state !== 'active'){
    const shieldR = Math.max(visualW, visualH) * 0.6;
    for(const a of scanArrows){
      const st = a.target;
      const dx = st.x - ship.pos.x;
      const dy = st.y - ship.pos.y;
      const ang = Math.atan2(dy, dx);
      const baseR = shieldR + 10;
      const ax = ship.pos.x + Math.cos(ang) * baseR;
      const ay = ship.pos.y + Math.sin(ang) * baseR;
      const s = worldToScreen(ax, ay, cam);
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(ang);
      const size = 18 * camera.zoom;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(120,200,255,0.9)';
      ctx.moveTo(0, -size*0.5);
      ctx.lineTo(size, 0);
      ctx.lineTo(0, size*0.5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      const tx = ship.pos.x + Math.cos(ang) * (baseR + 14);
      const ty = ship.pos.y + Math.sin(ang) * (baseR + 14);
      const ts = worldToScreen(tx, ty, cam);
      ctx.save();
      ctx.fillStyle = '#dfe7ff';
      ctx.font = `${12*camera.zoom}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${Math.round(Math.hypot(dx,dy))}u`, ts.x, ts.y);
      ctx.restore();
    }
  }

  // --- ZOPTYMALIZOWANE RYSOWANIE FLASH (NA WIERZCHU) ---
  {
    ctx.save();
    
    let drawn = 0;
    for (const p of particlePool) {
      if (!p.active || !p.flash) continue;
      if (drawn >= MAX_PARTICLES_DRAW) break;
      drawn++;

      const s = worldToScreen(p.pos.x, p.pos.y, cam);
      // Cull offscreen
      if (s.x < -50 || s.x > W + 50 || s.y < -50 || s.y > H + 50) continue;

      const t = clamp(1 - p.age/p.life, 0, 1);
      const size = p.size * camera.zoom;

      // Glow (duże, słabe kółko)
      ctx.globalAlpha = t * 0.3;
      ctx.fillStyle = p.color;
      ctx.beginPath(); 
      ctx.arc(s.x, s.y, size * 4, 0, Math.PI*2); 
      ctx.fill();

      // Core (małe, jasne kółko)
      ctx.globalAlpha = t;
      ctx.beginPath(); 
      ctx.arc(s.x, s.y, size, 0, Math.PI*2); 
      ctx.fill();
    }
    ctx.restore();
  }

  if (HUD_SHOW_LEGACY) {
    // HUD
    ctx.fillStyle = '#dfe7ff'; ctx.font = '12px monospace';
    ctx.fillText(`HP: ${Math.round(ship.hull.val)}/${ship.hull.max}`, 12, H-100);
    ctx.fillText(`Shield: ${Math.round(ship.shield.val)}/${ship.shield.max}`, 12, H-84);
    const warpText = warp.state==='active' ? `ACTIVE`
                    : warp.state==='charging' ? `CHARGING ${(Math.min(1,warp.charge/warp.chargeTime)*100).toFixed(0)}%`
                    : 'READY';
    ctx.fillText(`Warp: ${warpText}`, 12, H-68);
    const fw = 200, fh = 10, ffrac = warp.fuel/warp.fuelMax;
    ctx.strokeStyle = 'rgba(255,255,255,0.14)'; ctx.strokeRect(12-1, H-52-fh, fw+2, fh+2);
    ctx.fillStyle = '#60a5fa'; ctx.fillRect(12, H-52-fh, fw*ffrac, fh);
    ctx.fillStyle = '#dfe7ff'; ctx.fillText(`${warp.fuel.toFixed(1)}s / ${warp.fuelMax}s`, 12 + fw + 8, H-42-fh);
    const boosting = boost.state==='active' && boost.fuel > 0;
    const fullyCharged = boost.fuel >= boost.fuelMax - 0.01;
    const boostText = boosting ? 'ACTIVE' : (fullyCharged ? 'READY' : 'REFILLING');
    ctx.fillText(`Boost: ${boostText} (${boost.fuel.toFixed(1)}/${boost.fuelMax})`, 12, H-44);
    const railTimerHUD = (Math.max(1, rail.barrelsPerShot || 2) > 1)
      ? Math.min(rail.cd[0], rail.cd[1])
      : rail.cd[0];
    ctx.fillText(`Rail: ${railTimerHUD>0?railTimerHUD.toFixed(2)+'s':'READY'}  Special: ${ship.special.cooldownTimer>0?ship.special.cooldownTimer.toFixed(1)+'s':'READY'}`, 12, H-28);

    // rocket ammo
    const bw = 160, bh = 10;
    const ammoFrac = rocketAmmoMax > 0 ? rocketAmmo / rocketAmmoMax : 0;
    ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.strokeRect(12-1, H-12-bh-12, bw+2, bh+2);
    ctx.fillStyle = '#3b82f6'; ctx.fillRect(12, H-12-bh-12, bw*ammoFrac, bh);
    ctx.fillStyle = '#dfe7ff'; ctx.fillText(`Rockets: ${rocketAmmo}`, 12 + bw + 8, H-12-bh-6-12);
  }

  if(mercMission && mercMission.station){
    const st = mercMission.station;
    const panelPadding = 24;
    const barW = 220;
    const barH = 10;
    let y = 36;
    const xRight = W - panelPadding;
    ctx.save();
    ctx.textAlign = 'right';
    ctx.fillStyle = '#ffd1d1';
    ctx.fillText('Piracka stacja', xRight, y);
    ctx.fillStyle = '#dfe7ff';
    y += 8;
    if(st.shield){
      const shieldFrac = clamp(st.shield.val / st.shield.max, 0, 1);
      ctx.fillText(`Osłony: ${Math.round(st.shield.val)}/${st.shield.max}`, xRight, y + 10);
      const bx = xRight - barW;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.strokeRect(bx - 1, y + 14, barW + 2, barH + 2);
      ctx.fillStyle = '#60a5fa';
      ctx.fillRect(bx, y + 15, barW * shieldFrac, barH);
      ctx.fillStyle = '#dfe7ff';
      y += 32;
    }
    const hullFrac = clamp(st.hp / st.maxHp, 0, 1);
    ctx.fillText(`Kadłub: ${Math.round(st.hp)}/${st.maxHp}`, xRight, y + 10);
    const bx = xRight - barW;
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.strokeRect(bx - 1, y + 14, barW + 2, barH + 2);
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(bx, y + 15, barW * hullFrac, barH);
    y += 32;
    const platforms = mercMission.weaponPlatforms || [];
    if(platforms.length){
      ctx.fillStyle = '#ffd1d1';
      ctx.fillText('Platformy obronne', xRight, y);
      y += 8;
      for(const platform of platforms){
        const label = platform.label || 'Platforma';
        const entryBx = xRight - barW;
        if(platform.shield && platform.shield.max > 0){
          const shieldFrac = clamp(platform.shield.val / platform.shield.max, 0, 1);
          ctx.fillStyle = '#dfe7ff';
          ctx.fillText(`${label}: osłony ${Math.round(platform.shield.val)}/${platform.shield.max}`, xRight, y + 10);
          ctx.strokeStyle = 'rgba(255,255,255,0.12)';
          ctx.strokeRect(entryBx - 1, y + 14, barW + 2, barH + 2);
          ctx.fillStyle = '#60a5fa';
          ctx.fillRect(entryBx, y + 15, barW * shieldFrac, barH);
          y += 26;
        }
        const hpFrac = (platform.maxHp > 0) ? clamp(Math.max(0, platform.hp) / platform.maxHp, 0, 1) : 0;
        ctx.fillStyle = '#dfe7ff';
        ctx.fillText(`${label}: kadłub ${Math.max(0, Math.round(platform.hp))}/${platform.maxHp}`, xRight, y + 10);
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.strokeRect(entryBx - 1, y + 14, barW + 2, barH + 2);
        ctx.fillStyle = platform.destroyed ? '#4b5563' : '#f97316';
        ctx.fillRect(entryBx, y + 15, barW * hpFrac, barH);
        y += 28;
      }
    }
    ctx.restore();
  }

  if(showMap) drawSectorMap();
  renderStationUI();
  renderOptions();
  renderMissionJournal();
  renderZoneMessages();
  renderMissionCompleteBanner();
  mouse.click=false;
}

function renderZoneMessages(){
  if (!zoneState.messages.length) return;

  ctx.save();
  ctx.resetTransform();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const baseY = 70;
  const lineH = 32;

  zoneState.messages.forEach((msg, i) => {
    const progress = msg.maxLife - msg.life;
    const fadeIn = clamp(progress / 0.35, 0, 1);
    const fadeOut = clamp(msg.life / 0.5, 0, 1);
    const alpha = Math.min(fadeIn, fadeOut);
    if (alpha <= 0) return;

    const fontSize = 22;
    const y = baseY + i * lineH;
    ctx.font = `600 ${fontSize}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 12;
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(12, 20, 36, 0.7)';
    ctx.fillStyle = '#e5ecff';
    ctx.globalAlpha = alpha;

    ctx.strokeText(msg.text, W/2, y);
    ctx.fillText(msg.text, W/2, y);
  });

  ctx.restore();
}

function renderMissionCompleteBanner(){
  if(!missionCompleteBanner.active) return;
  const alpha = missionCompleteBanner.alpha();
  if(alpha <= 0) return;

  ctx.save();
  ctx.resetTransform();
  ctx.translate(W/2, H*0.32);
  const scale = 1 + 0.08 * Math.sin(missionCompleteBanner.progress() * Math.PI);
  ctx.scale(scale, scale);
  ctx.globalAlpha = alpha;

  const fontSize = Math.round(Math.min(W, H) * 0.08);
  ctx.font = `700 ${fontSize}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = 'rgba(80,180,255,0.85)';
  ctx.shadowBlur = Math.max(14, fontSize * 0.2);
  ctx.lineJoin = 'round';

  const strokeWidth = Math.max(2, fontSize * 0.05);
  ctx.lineWidth = strokeWidth;
  ctx.strokeStyle = 'rgba(10,20,40,0.6)';
  ctx.strokeText(missionCompleteBanner.text, 0, 0);

  ctx.fillStyle = '#ffffff';
  ctx.fillText(missionCompleteBanner.text, 0, 0);

  ctx.restore();
}

function clampMapViewPosition(x, y){
  const layout = mapView.layout;
  if(!layout) return { x, y };
  const minX = W - layout.mapW - layout.padding;
  const minY = H - layout.mapH - layout.padding;
  const maxX = layout.padding;
  const maxY = layout.padding;
  return {
    x: clamp(x, minX, maxX),
    y: clamp(y, minY, maxY),
  };
}

function syncMapViewLayout(){
  const padding = Math.max(28, Math.min(W, H) * 0.05);
  const baseScale = Math.min((W - padding * 2) / WORLD.w, (H - padding * 2) / WORLD.h);
  const scale = baseScale * mapView.zoom;
  const mapW = WORLD.w * scale;
  const mapH = WORLD.h * scale;
  mapView.layout = { padding, mapW, mapH };

  const clampPos = (value, content, view) => {
    if (content <= view - padding * 2) return (view - content) / 2;
    const min = view - content - padding;
    const max = padding;
    return clamp(value, min, max);
  };

  const targetX0 = clampPos(W / 2 - ship.pos.x * scale, mapW, W);
  const targetY0 = clampPos(H / 2 - ship.pos.y * scale, mapH, H);

  return { padding, scale, mapW, mapH, targetX0, targetY0 };
}

function drawSectorMap(){
  mapView.zoom += (mapView.targetZoom - mapView.zoom) * mapView.smoothness;

  const { padding, scale, mapW, mapH, targetX0, targetY0 } = syncMapViewLayout();

  if (mapView.viewX == null || mapView.viewY == null) {
    mapView.viewX = targetX0;
    mapView.viewY = targetY0;
  } else if (mapView.followShip) {
    mapView.viewX += (targetX0 - mapView.viewX) * 0.18;
    mapView.viewY += (targetY0 - mapView.viewY) * 0.18;
  }

  const clampedView = clampMapViewPosition(mapView.viewX, mapView.viewY);
  mapView.viewX = clampedView.x;
  mapView.viewY = clampedView.y;

  const toScreen = (x, y) => ({
    x: mapView.viewX + x * scale,
    y: mapView.viewY + y * scale,
  });

  ctx.save();
  ctx.resetTransform();

  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, 'rgba(32, 74, 129, 0.95)');
  bg.addColorStop(0.55, 'rgba(10, 44, 86, 0.9)');
  bg.addColorStop(1, 'rgba(4, 18, 36, 0.92)');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  const glow = ctx.createRadialGradient(W * 0.6, H * 0.34, Math.min(W, H) * 0.08, W * 0.4, H * 0.66, Math.max(W, H) * 0.9);
  glow.addColorStop(0, 'rgba(108, 227, 255, 0.35)');
  glow.addColorStop(0.45, 'rgba(78, 196, 255, 0.16)');
  glow.addColorStop(1, 'rgba(48, 168, 255, 0)');
  ctx.fillStyle = glow;
  ctx.fillRect(0, 0, W, H);

  ctx.save();
  ctx.globalAlpha = 0.8;
  const glass = ctx.createLinearGradient(0, padding, 0, H - padding);
  glass.addColorStop(0, 'rgba(255,255,255,0.08)');
  glass.addColorStop(0.5, 'rgba(255,255,255,0.02)');
  glass.addColorStop(1, 'rgba(255,255,255,0.07)');
  ctx.fillStyle = glass;
  ctx.fillRect(padding * 0.5, padding * 0.5, W - padding, H - padding);
  ctx.restore();

  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  const gridStep = 4000;
  const startX = Math.floor(-mapView.viewX / (gridStep * scale)) * gridStep;
  const startY = Math.floor(-mapView.viewY / (gridStep * scale)) * gridStep;
  ctx.save();
  ctx.beginPath();
  for (let gx = startX; gx < WORLD.w; gx += gridStep) {
    const px = toScreen(gx, 0).x;
    if (px < padding || px > W - padding) continue;
    ctx.moveTo(px, padding);
    ctx.lineTo(px, H - padding);
  }
  for (let gy = startY; gy < WORLD.h; gy += gridStep) {
    const py = toScreen(0, gy).y;
    if (py < padding || py > H - padding) continue;
    ctx.moveTo(padding, py);
    ctx.lineTo(W - padding, py);
  }
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.stroke();
  ctx.restore();

  const frame = ctx.createLinearGradient(mapView.viewX, mapView.viewY, mapView.viewX, mapView.viewY + mapH);
  frame.addColorStop(0, 'rgba(132, 228, 255, 0.9)');
  frame.addColorStop(1, 'rgba(52, 142, 255, 0.8)');
  ctx.strokeStyle = frame;
  ctx.lineWidth = 2.5;
  ctx.shadowColor = 'rgba(80, 200, 255, 0.4)';
  ctx.shadowBlur = 14;
  ctx.strokeRect(mapView.viewX, mapView.viewY, mapW, mapH);
  ctx.shadowBlur = 0;

  const drawGlowDot = (pos, radius, fill, stroke) => {
    ctx.save();
    ctx.shadowColor = fill;
    ctx.shadowBlur = radius * 2;
    ctx.fillStyle = fill;
    ctx.strokeStyle = stroke || fill;
    ctx.lineWidth = Math.max(1.5, radius * 0.25);
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  };

  const sunPos = toScreen(SUN.x, SUN.y);
  const sunRadius = Math.max(10, 12 * mapView.zoom);
  drawGlowDot(sunPos, sunRadius, 'rgba(255, 200, 92, 0.9)', 'rgba(255, 243, 191, 0.9)');

  if (ASTEROID_BELT) {
    const cx = sunPos.x;
    const cy = sunPos.y;
    const outerRx = ASTEROID_BELT.outer * scale;
    const outerRy = ASTEROID_BELT.outer * scale;
    const innerRx = ASTEROID_BELT.inner * scale;
    const innerRy = ASTEROID_BELT.inner * scale;
    ctx.save();
    ctx.strokeStyle = 'rgba(168, 182, 204, 0.55)';
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.7;
    ctx.beginPath(); ctx.ellipse(cx, cy, outerRx, outerRy, 0, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(cx, cy, innerRx, innerRy, 0, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  const planetMarkerRadius = Math.max(8, 10 * Math.sqrt(mapView.zoom));
  const labelFont = Math.max(12, Math.round(Math.min(W, H) * 0.022));

  if (Array.isArray(planets) && planets.length) {
    ctx.save();

    ctx.fillStyle = '#a5ebff';
    for (const planet of planets) {
      const pos = toScreen(planet.x, planet.y);
      drawGlowDot(pos, planetMarkerRadius, 'rgba(140, 227, 255, 0.92)', 'rgba(214, 244, 255, 0.9)');
    }

    ctx.font = `600 ${labelFont}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.lineWidth = Math.max(2, labelFont * 0.14);
    ctx.strokeStyle = 'rgba(6, 10, 22, 0.85)';
    ctx.fillStyle = '#e8f7ff';

    for (const planet of planets) {
      const name = typeof planet.label === 'string' ? planet.label.trim() : '';
      if (!name) continue;
      const pos = toScreen(planet.x, planet.y);
      const labelY = pos.y + planetMarkerRadius + 8;
      ctx.strokeText(name, pos.x, labelY);
      ctx.fillText(name, pos.x, labelY);
    }

    ctx.restore();
  }

  ctx.save();
  ctx.fillStyle = '#9df0ff';
  ctx.strokeStyle = 'rgba(71, 191, 255, 0.65)';
  ctx.lineWidth = 2.4;
  for(const st of stations){
    const pos = toScreen(st.x, st.y);
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
  }
  ctx.restore();

  if (mercMission?.station) {
    const piratePos = toScreen(mercMission.station.x, mercMission.station.y);
    const labelY = piratePos.y + planetMarkerRadius + 8;
    ctx.save();
    ctx.font = `600 ${labelFont}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.lineWidth = Math.max(2, labelFont * 0.14);
    ctx.strokeStyle = 'rgba(46, 4, 4, 0.85)';
    ctx.fillStyle = '#ffb3b3';
    ctx.strokeText('Pirate Station', piratePos.x, labelY);
    ctx.fillText('Pirate Station', piratePos.x, labelY);
    ctx.restore();
  }

  ctx.save();
  const shipPos = toScreen(ship.pos.x, ship.pos.y);
  const shipRadius = Math.max(7, 9 * Math.pow(mapView.zoom, 0.35));
  const angle = ship.angle || 0;
  ctx.translate(shipPos.x, shipPos.y);
  ctx.rotate(angle);
  ctx.fillStyle = '#e9fbff';
  ctx.strokeStyle = 'rgba(126, 233, 255, 0.95)';
  ctx.shadowColor = 'rgba(120, 230, 255, 0.6)';
  ctx.shadowBlur = 10;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(shipRadius * 1.6, 0);
  ctx.lineTo(-shipRadius * 0.9, shipRadius * 0.9);
  ctx.lineTo(-shipRadius * 0.9, -shipRadius * 0.9);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  ctx.strokeStyle = '#ff9cc2';
  ctx.lineWidth = 3.2;
  for(const m of MISSIONS.active){
    if(m.status !== 'active' || !m.pos) continue;
    const pos = toScreen(m.pos.x, m.pos.y);
    const s = Math.max(9, 10 * Math.sqrt(mapView.zoom));
    ctx.beginPath();
    ctx.moveTo(pos.x - s, pos.y - s); ctx.lineTo(pos.x + s, pos.y + s);
    ctx.moveTo(pos.x - s, pos.y + s); ctx.lineTo(pos.x + s, pos.y - s);
    ctx.stroke();
  }

  ctx.save();
  const titleY = padding * 0.7;
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.font = `700 ${Math.max(18, Math.min(W, H) * 0.03)}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
  ctx.fillStyle = '#f2f8ff';
  ctx.shadowColor = 'rgba(72, 192, 255, 0.75)';
  ctx.shadowBlur = 18;
  ctx.fillText('Mapa Sektora', padding, titleY);

  ctx.font = `500 ${Math.max(13, Math.min(W, H) * 0.018)}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(232, 241, 255, 0.85)';
  ctx.fillText('LPM — przesuwanie · Scroll — powiększenie · M — zamknij', padding, titleY + 28);
  ctx.restore();

  ctx.restore();
}

// =============== Helpers (POPRAWIONE) ===============
function roundRect(ctx, x, y, w, h, r) {
  // Zabezpieczenie: promień nie może być większy niż połowa krótszego boku
  if (w < 2 * r) r = w / 2;
  if (h < 2 * r) r = h / 2;
  if (r < 0) r = 0;
  
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
}


function roundRectScreen(x, y, w, h, r) {
  roundRect(ctx, x, y, w, h, r); 
}

function screenToWorld(sx, sy){
  return { x: camera.x + (sx - W/2)/camera.zoom, y: camera.y + (sy - H/2)/camera.zoom };
}

// --- MINI UI HELPERS (HUD) ---
let hudOffset = {x:40, y:46};
function hudBeginPanel(x=24, y=24, w=450, h=520){
  ctx.save();
  ctx.resetTransform();
  ctx.fillStyle='rgba(0,0,0,0.55)';
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle='rgba(255,255,255,0.08)';
  ctx.fillRect(x, y, w, 24);
  ctx.translate(x+16, y+46);
  hudOffset.x = x+16;
  hudOffset.y = y+46;
  ctx.fillStyle='#E6F2FF';
  ctx.font='16px monospace';
}
function hudEndPanel(){ ctx.restore(); }
function uiTitle(t){ ctx.font='20px monospace'; ctx.fillText(t,0,0); ctx.translate(0,28); ctx.font='16px monospace'; }
function section(t){ ctx.translate(0,12); ctx.globalAlpha=0.8; ctx.fillText('— '+t,0,0); ctx.globalAlpha=1; ctx.translate(0,18); }
function uiText(t){ ctx.fillText(t,0,0); ctx.translate(0,18); }
function hudTabs(names, active){
  let x = 0, clicked = null;
  for (let i = 0; i < names.length; i++) {
    const key = names[i];
    const label = '[' + toTitleCaseFromKey(key) + ']';
    const w = ctx.measureText(label).width;
    const t = ctx.getTransform();
    const L = t.e + x, T = t.f - 14, R = L + w, B = T + 20;

    ctx.fillStyle = key===active ? '#fff' : '#a8c0ff';
    ctx.fillText(label, x, 0);

    const over = mouse.x>L && mouse.x<R && mouse.y>T && mouse.y<B;
    if (over) canvas.style.cursor = 'pointer';
    if (over && mouse.click) clicked = key;

    x += ctx.measureText(label+'  ').width;
  }
  ctx.translate(0, 28);
  ctx.fillStyle = '#E6F2FF';
  if (clicked){ stationUI.tab = clicked; mouse.click = false; }
}

// --- NOWA FUNKCJA UI DO WYBORU JAKOŚCI ---
function uiQualitySelector(){
  if(!window.Nebula) return;
  const cfg = window.Nebula.getConfig();
  const current = cfg.quality;
  const opts = ['2k','4k','8k'];

  ctx.fillText('Jakość tła:', 0, 0);

  let x = 180;
  const y = -14;
  const w = 40;
  const h = 20;

  for(const opt of opts){
    const isActive = (current === opt);
    
    // Rysowanie przycisku
    ctx.strokeStyle = isActive ? '#fff' : 'rgba(100,150,255,0.4)';
    ctx.fillStyle = isActive ? '#3b82f6' : 'rgba(10,20,40,0.5)';
    ctx.fillRect(x, y, w, h);
    ctx.strokeRect(x, y, w, h);
    
    // Tekst
    ctx.fillStyle = isActive ? '#fff' : '#8fb5ff';
    ctx.fillText(opt.toUpperCase(), x + 8, 0);

    // Obsługa myszy (Canvas Immediate Mode GUI)
    const t = ctx.getTransform();
    const L = t.e + x;
    const T = t.f + y;
    const R = L + w;
    const B = T + h;
    
    const over = mouse.x > L && mouse.x < R && mouse.y > T && mouse.y < B;
    if(over){
        canvas.style.cursor = 'pointer';
        if(mouse.click){
            window.Nebula.setQuality(opt);
            mouse.click = false; // "zjedz" kliknięcie
        }
    }
    
    x += w + 8; // odstęp
  }
  ctx.translate(0, 24); // nowa linia w panelu
}

function uiRowButton(label, btn){
  ctx.fillText(label, 0, 0);
  const w=96,h=20,x=320,y=-14;
  ctx.strokeStyle='#cfe3ff'; ctx.strokeRect(x,y,w,h); ctx.fillText(btn, x+10, 0);

  const t = ctx.getTransform();
  const L=t.e+x, T=t.f+y, R=L+w, B=T+h;
  const over = mouse.x>L && mouse.x<R && mouse.y>T && mouse.y<B;
  if (over) canvas.style.cursor = 'pointer';
  const clicked = over && mouse.click;

  ctx.translate(0,22);
  if (clicked) mouse.click = false;
  return clicked;
}
function slider(label, min,max, step, obj, key){
  ctx.fillText(`${label}: ${obj[key].toFixed(2)}`,0,0); ctx.translate(0,18);
  // do prostoty – klawiszami [ i ] zmieniasz ostatni slider; lub klik + ruch (opcjonalnie)
  // Możesz podpiąć realny input według swojej architektury.
}
function toast(t){ /* opcjonalnie dopisz do kolejki komunikatów HUD */ }
function applyShipStats(s){
  ship.hull.max = Math.round(ship.hull.max * s.hp);
  ship.hull.val = Math.min(ship.hull.val, ship.hull.max);

  const speedMul = s.speed;
  ship.engines.main.maxThrust      = Math.round(ship.engines.main.maxThrust * speedMul);
  ship.engines.sideLeft.maxThrust  = Math.round(ship.engines.sideLeft.maxThrust * speedMul);
  ship.engines.sideRight.maxThrust = Math.round(ship.engines.sideRight.maxThrust * speedMul);
  ship.engines.torqueLeft.maxThrust  = Math.round(ship.engines.torqueLeft.maxThrust * speedMul);
  ship.engines.torqueRight.maxThrust = Math.round(ship.engines.torqueRight.maxThrust * speedMul);

  ship.cargoCap = Math.round((ship.cargoCap || 20) * s.cargo);
}

function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1, y2-y1); }
function limitSpeed(n, max){
  const vx = n.vel ? n.vel.x : n.vx;
  const vy = n.vel ? n.vel.y : n.vy;
  const v = Math.hypot(vx, vy);
  if(v>max){
    const s = max/v;
    if(n.vel){ n.vel.x*=s; n.vel.y*=s; }
    else { n.vx*=s; n.vy*=s; }
  }
}
// --- POPRAWIONE AI MYŚLIWCA (bez podwójnego tarcia i z fallbackiem na aiPickTarget) ---
function runAdvancedFighterAI(npc, dt) {
  // --- KONFIGURACJA ---
  const isSupport = npc.isSupportWing || !!npc.supportData;
  let order = 'engage';

  if (isSupport && typeof SupportWing !== 'undefined') {
      order = SupportWing.order || 'guard';
  }

  const SEARCH_RANGE = (order === 'engage' || npc.isPirate) ? 30000 : 6000;
  const DOGFIGHT_ENTER_DIST = 600;
  const DOGFIGHT_EXIT_DIST = 1100;

  npc.gunCD = Math.max(0, (npc.gunCD || 0) - dt);
  npc.mslCD = Math.max(0, (npc.mslCD || 0) - dt);
  npc.breakOffTimer = Math.max(0, (npc.breakOffTimer || 0) - dt);

  // 1. ZNAJDOWANIE CELU
  npc.retargetTimer = (npc.retargetTimer || 0) - dt;
  let target = (npc.forceTarget && !npc.forceTarget.dead) ? npc.forceTarget : npc.target;

  if (target && target.dead) target = null;

  if (!target && npc.retargetTimer <= 0) {

      // TU: bezpiecznie korzystamy z aiPickBestTarget / aiPickTarget
      if (window.aiPickBestTarget) {
        target = window.aiPickBestTarget(npc, SEARCH_RANGE);
      } else if (window.aiPickTarget) {
        target = window.aiPickTarget(npc);
        if (target) {
          const tx = (target.pos && target.pos.x !== undefined) ? target.pos.x : target.x;
          const ty = (target.pos && target.pos.y !== undefined) ? target.pos.y : target.y;
          const dx = tx - npc.x;
          const dy = ty - npc.y;
          if (dx*dx + dy*dy > SEARCH_RANGE * SEARCH_RANGE) {
            target = null;
          }
        }
      }

      npc.target = target || null;
      npc.retargetTimer = 1.0 + Math.random() * 0.5;
  }

  const isSquadWingman = (npc.squad && npc.squad.leader && npc.squad.leader !== npc);
  if (!target && npc.isPirate && !npc.guardStation && !isSquadWingman) {
      target = window.ship;
      npc.target = target;
  }

  let tx = 0, ty = 0;
  let distToTarget = Infinity;
  let targetKind = 'unknown';

  if (target) {
      tx = (target.pos && target.pos.x !== undefined) ? target.pos.x : target.x;
      ty = (target.pos && target.pos.y !== undefined) ? target.pos.y : target.y;
      distToTarget = Math.hypot(tx - npc.x, ty - npc.y);
      targetKind = getUnitKind(target);
  }

  // 2. MASZYNA STANÓW
  if (target) {
      // A. FIGHTER vs FIGHTER
      if (targetKind === 'fighter') {
          if (npc.state === 'dogfight3D') {
              if (distToTarget > DOGFIGHT_EXIT_DIST) npc.state = 'engage_formation';
          } else {
              if (distToTarget < DOGFIGHT_ENTER_DIST) {
                  npc.state = 'dogfight3D';
                  npc.sub = 'merge';
                  npc.subT = 0;
                  npc._mergeInit = false;
              } else {
                  npc.state = 'engage_formation';
              }
          }
      }
      // B. ATAK NA DUŻY STATEK
      else {
          if (npc.state === 'bombing') {
              if (distToTarget > 2500) npc.state = 'engage_formation';
          } else {
              if (distToTarget < 1500) npc.state = 'bombing';
              else npc.state = 'engage_formation';
          }
      }
  } else {
      npc.state = 'guard';
  }

  const smoothRotateToVelocity = (turnSpeed = 8.0) => {
      const speed = Math.hypot(npc.vx, npc.vy);
      if (speed > 10) {
          const desiredAngle = Math.atan2(npc.vy, npc.vx);
          npc.angle = clampTurnAngle(npc.angle, desiredAngle, turnSpeed, dt);
      }
  };

  // 3. FIZYKA RUCHU

  // --- CASE 1: DOLOT BOJOWY ---
  if (npc.state === 'engage_formation' && target) {
      const dirX = tx - npc.x;
      const dirY = ty - npc.y;
      const len = Math.hypot(dirX, dirY) || 1;

      const wantVx = (dirX / len) * npc.maxSpeed;
      const wantVy = (dirY / len) * npc.maxSpeed;

      const turned = clampTurnVec(npc.vx, npc.vy, wantVx, wantVy, dt, 300);
      npc.vx = turned.vx;
      npc.vy = turned.vy;

      // Separacja (żeby nie wlatywały w siebie w roju)
      const sep = applySeparationForces(npc, 0, 0);
      npc.vx += sep.ax * dt;
      npc.vy += sep.ay * dt;

      smoothRotateToVelocity(10.0);

      if (distToTarget < 1400) tryFireFighter(npc, target, dt);
      return;
  }

  // --- CASE 2: DOGFIGHT ---
  if (npc.state === 'dogfight3D' && target) {
      if (!npc.sub) npc.sub = 'merge';

      if (npc.sub === 'merge') {
          if (!npc._mergeInit) { npc._mergeInit = true; npc.subT = 0.7 + Math.random() * 0.5; }
          const lead = getLeadAim(npc, target, 500);
          const dx = lead.x - npc.x, dy = lead.y - npc.y;
          const len = Math.hypot(dx, dy) || 1;
          const wantVx = (dx/len) * npc.maxSpeed * 1.15;
          const wantVy = (dy/len) * npc.maxSpeed * 1.15;
          const turned = clampTurnVec(npc.vx, npc.vy, wantVx, wantVy, dt, 400);
          npc.vx = turned.vx; npc.vy = turned.vy;
          npc.subT -= dt;
          if (npc.subT <= 0 || distToTarget < 120) {
              npc.sub = 'slash'; npc.subT = 0.6; npc._slashSign = Math.random() > 0.5 ? 1 : -1;
          }
      }
      else if (npc.sub === 'slash') {
          const dx = tx - npc.x;
          const dy = ty - npc.y;
          const len = Math.hypot(dx, dy) || 1;
          const nx = dx/len, ny = dy/len;
          const px = -ny * npc._slashSign, py = nx * npc._slashSign;

          const wantVx = (nx * 0.3 + px * 1.2) * npc.maxSpeed;
          const wantVy = (ny * 0.3 + py * 1.2) * npc.maxSpeed;

          const turned = clampTurnVec(npc.vx, npc.vy, wantVx, wantVy, dt, 450);
          npc.vx = turned.vx; npc.vy = turned.vy;
          npc.subT -= dt;
          if (npc.subT <= 0) { npc.sub = 'merge'; npc._mergeInit = false; }
      }

      smoothRotateToVelocity(12.0);
      tryFireFighter(npc, target, dt);
      return;
  }

  // --- CASE 3: BOMBING ---
  if (npc.state === 'bombing' && target) {
      if (!npc.bombardVec || npc.lastTargetId !== target.id) {
          const a = Math.random() * 6.28;
          npc.bombardVec = { x: Math.cos(a), y: Math.sin(a) };
          npc.bombardSide = 1;
          npc.lastTargetId = target.id;
      }
      const lineLen = 1400;
      const wayX = tx + npc.bombardVec.x * lineLen * npc.bombardSide;
      const wayY = ty + npc.bombardVec.y * lineLen * npc.bombardSide;

      if (Math.hypot(wayX - npc.x, wayY - npc.y) < 250) npc.bombardSide *= -1;

      const dx = wayX - npc.x, dy = wayY - npc.y;
      const len = Math.hypot(dx, dy) || 1;

      const wantVx = (dx / len) * npc.maxSpeed * 1.1;
      const wantVy = (dy / len) * npc.maxSpeed * 1.1;

      const turned = clampTurnVec(npc.vx, npc.vy, wantVx, wantVy, dt, 280);
      npc.vx = turned.vx;
      npc.vy = turned.vy;

      if (distToTarget < 1000) {
          const aimX = tx - npc.x;
          const aimY = ty - npc.y;
          const desiredAngle = Math.atan2(aimY, aimX);
          npc.angle = clampTurnAngle(npc.angle, desiredAngle, 10.0, dt);
      } else {
          smoothRotateToVelocity(8.0);
      }

      tryFireFighter(npc, target, dt);
      return;
  }

  // 4. GUARD / IDLE (Logika formacji)
  let leader = null;
  if (npc.squad && npc.squad.leader && !npc.squad.leader.dead) {
      leader = npc.squad.leader;
  } else if (npc.supportData) {
      leader = npc.supportData.leader;
  }

  if (!leader && !npc.guardStation) {
      npc.vx *= 0.98; npc.vy *= 0.98;
      return;
  }

  const isLeader = (leader === npc);
  let targetPos = null;

  if (isLeader && npc.isPirate && npc.guardStation) {
      const time = performance.now() / 1000;
      const radius = npc.guardOrbitRadius || 350;
      const speed = npc.guardOrbitSpeed || 0.3;
      const phase = npc.guardPhase || 0;
      const angle = phase + (time * speed);
      targetPos = {
          x: npc.guardStation.x + Math.cos(angle) * radius,
          y: npc.guardStation.y + Math.sin(angle) * radius
      };
      const tangentAngle = angle + (speed > 0 ? Math.PI/2 : -Math.PI/2);
      npc.desiredAngle = tangentAngle;
  }
  else if (leader && !isLeader) {
      let offset = npc.formationOffset || {x:0, y:0};
      const la = leader.angle || 0;
      const c = Math.cos(la);
      const s = Math.sin(la);
      targetPos = {
          x: leader.x + (offset.x * c - offset.y * s),
          y: leader.y + (offset.x * s + offset.y * c)
      };
  }
  else if (isLeader) {
      const pdx = window.ship.pos.x - npc.x;
      const pdy = window.ship.pos.y - npc.y;
      const plen = Math.hypot(pdx, pdy) || 1;
      npc.vx = (pdx/plen) * 150;
      npc.vy = (pdy/plen) * 150;
      smoothRotateToVelocity(5.0);
      return;
  }

  if (targetPos) {
      const dx = targetPos.x - npc.x;
      const dy = targetPos.y - npc.y;
      const distToSpot = Math.hypot(dx, dy);
      const kp = isLeader ? 2.0 : 3.0;
      let wantVx = dx * kp;
      let wantVy = dy * kp;
      const currentMax = isLeader ? (npc.maxSpeed * 0.6) : (npc.maxSpeed * 1.1);
      const speed = Math.hypot(wantVx, wantVy);
      if (speed > currentMax) {
          const scale = currentMax / speed;
          wantVx *= scale;
          wantVy *= scale;
      }
      npc.vx += (wantVx - npc.vx) * 4.0 * dt;
      npc.vy += (wantVy - npc.vy) * 4.0 * dt;

      // Separacja w formacji
      const sep = applySeparationForces(npc, 0, 0);
      npc.vx += sep.ax * dt;
      npc.vy += sep.ay * dt;

      if (!npc.desiredAngle) {
          if (distToSpot > 50) smoothRotateToVelocity(6.0);
          else if (leader && !isLeader) npc.angle = clampTurnAngle(npc.angle, leader.angle, 6.0, dt);
      } else {
          npc.angle = clampTurnAngle(npc.angle, npc.desiredAngle, 4.0, dt);
          npc.desiredAngle = null;
      }
  }
}

// Przypisanie do window na końcu
window.runAdvancedFighterAI = runAdvancedFighterAI;
  
function useRailPair(n, target){ /* sprawdź kąt i cooldown, odpal pary */ }
function useRocketsPair(n, target){ /* salwy */ }
function useCIWSPair(n, target){ /* krótka seria */ }
function maybeFireRockets(n, target){ /* warunkowo */ }
Object.defineProperty(PirateSim, 'units', {
  get: function() {
    // Zwraca tablicę: [Gracz, ...Wszystkie żywe NPC]
    // Dzięki temu AI może iterować po 'sim.units' i szukać celów
    return [ship, ...npcs.filter(n => !n.dead)];
  }
});



// 2. Podłącz funkcję strzelania AI do silnika gry
// Kiedy AI wywoła spawnBullet, my przekierujemy to do adaptera, który doda pocisk do gry
window.spawnBullet = function(sim, from, to, weapon) {
  if (window.spawnBulletAdapter) {
     window.spawnBulletAdapter(from, to, weapon);
  } else if (window.aiSpawnBullet) {
     window.aiSpawnBullet(sim, from, to, weapon);
  }
};
// NOWE: Funkcja do obsługi paska w UI gry
function updateLiveBackgroundProgress(progress) {
    const el = document.getElementById('bg-gen-status');
    const txt = document.getElementById('bg-gen-percent');
    if (!el || !txt) return;

    if (progress < 1.0) {
        el.style.display = 'block';
        txt.textContent = Math.round(progress * 100) + '%';
    } else {
        el.style.display = 'none'; // Ukryj po zakończeniu
    }
}

async function startGame(){
  if (gameStarted) return;
  
  // --- AUDIO START ---
  AudioSys.init();
  // Ładujemy pliki dźwiękowe potrzebne na starcie gry
  await Promise.all([
    AudioSys.loadSound('engine', '/sounds/engine/thruster_loop.wav'),
    AudioSys.loadSound('shieldHit', '/sounds/465540__steaq__sci-fi-shield-hit-wav.wav')
  ]);
  
  // Podpinamy instancję dźwięku pod statek gracza
  if (typeof ship !== 'undefined') {
    ship.engineSound = AudioSys.createEngineLoop('engine');
  }
  // --- AUDIO END ---

  gameStarted = true;
  fadeOutMenuMusic();
  if (continueButton) continueButton.classList.remove('hidden');
  if (optionsButton) optionsButton.disabled = false;
  setMenuView('home');
  hideMainMenu();

  showLoadingOverlay(0, 'Przygotowanie świata');
  initStars(true);
  setLoadingProgress(20, 'Inicjalizacja systemów');
  await nextFrame();

  initNPCs();
  setLoadingProgress(40, 'Symulacja tras NPC');
  await nextFrame();

  initFleet();
  setLoadingProgress(60, 'Kalibracja floty');
  await nextFrame();

  // Wstępna symulacja fizyki
  for(let i=0;i<60;i++) npcStep(PHYS_DT);
  setLoadingProgress(80, 'Rozruch silników');

  await waitForPlanetsReady();
  
  // Ukrywamy loading screen ZANIM tło będzie gotowe
  setLoadingProgress(100, 'Start!');
  await nextFrame();
  
  // Uruchomienie pętli gry
  const firstFramePromise = new Promise(resolve => { firstFrameResolver = resolve; });
  lastTime = performance.now();
  acc = 0;
  vfxTime = 0;
  
  uiRoot?.classList.remove('hidden');
  hudTopbarRoot?.classList.remove('hidden');
  if (shieldControlsRoot) shieldControlsRoot.classList.remove('hidden');
  initShieldSystem(W, H);
  
  requestAnimationFrame(loop);
  await firstFramePromise;

  // Ukryj loading overlay
  hideLoadingOverlay();

  console.log("[System] Gra uruchomiona. Tło statyczne.");
}

if (newGameButton) {
  newGameButton.addEventListener('click', () => {
    setMenuView('home');
    startGame();
  });
}
if (continueButton) {
  continueButton.addEventListener('click', () => {
    if (!gameStarted) return;
    hideMainMenu();
  });
}
if (loadGameButton) {
  loadGameButton.title = 'Wkrótce dostępne';
}
if (optionsButton) {
  optionsButton.title = 'Dostosuj jakość tła';
  optionsButton.addEventListener('click', () => showMainMenu('options'));
}
if (optionsBackButton) {
  optionsBackButton.addEventListener('click', () => setMenuView('home'));
}
if (qualityButtons && qualityButtons.length) {
  qualityButtons.forEach(btn => {
    btn.addEventListener('click', () => setBackgroundQuality(btn.dataset.quality));
  });
  applyQualitySelection();
}
if (supportGuardBtn) {
  supportGuardBtn.addEventListener('click', () => setSupportOrder('guard', { force: true }));
}
if (supportEngageBtn) {
  supportEngageBtn.addEventListener('click', () => setSupportOrder('engage', { force: true }));
}
if (supportSpawnButtons && supportSpawnButtons.forEach) {
  supportSpawnButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const key = btn.dataset.supportSpawn;
      if (key === 'carrier_capital'){
        const carrier = spawnFriendlyCarrier();
        if (!carrier) return;
      } else if (key === 'carrier_fighter'){
        const carrier = getFriendlyCarrierEntity();
        if (!carrier) return;
        spawnSupportShip('fighter', { anchor: carrier });
      } else {
        spawnSupportShip(key);
      }
      setSupportOrder('guard', { force: true });
    });
  });
}
if (energyShotBtn) {
  energyShotBtn.addEventListener('click', () => triggerEnergyShot());
}

function wireDevTools(){
  const saveLS = () => { window.__devtoolsSaveLS?.(); };
  const elUnlimited = document.getElementById('dt-unlimited-warp') || document.getElementById('toggleUnlimitedWarp');
  const elRuler     = document.getElementById('dt-show-ruler') || document.getElementById('toggleRuler');
  const elScale     = document.getElementById('dt-pirate-scale') || document.getElementById('pirScale');
  const elScaleVal  = document.getElementById('dt-pirate-scale-value') || document.getElementById('pirScaleVal');
  const elStation3DScale = document.getElementById('dt-station3d-scale') || document.getElementById('station3DScale');
  const elStation3DScaleVal = document.getElementById('dt-station3d-scale-value') || document.getElementById('station3DScaleVal');
  const elPlanet3D  = document.getElementById('dt-use-planet-stations');
  const elPir3D     = document.getElementById('dt-use-3d-pirate');
  const elSunDir    = document.getElementById('dt-show-sundir');

  if (elUnlimited) {
    elUnlimited.checked = !!DevFlags.unlimitedWarp;
    elUnlimited.addEventListener('change', e => {
      DevFlags.unlimitedWarp = e.target.checked;
      if (DevFlags.unlimitedWarp) warp.fuel = warp.fuelMax;
      const legacyUnlimited = document.getElementById('toggleUnlimitedWarp');
      if (legacyUnlimited) legacyUnlimited.checked = DevFlags.unlimitedWarp;
    });
  }
  if (elRuler) {
    elRuler.checked = !!DevFlags.showRuler;
    elRuler.addEventListener('change', e => {
      DevFlags.showRuler = e.target.checked;
      const legacyRuler = document.getElementById('toggleRuler');
      if (legacyRuler) legacyRuler.checked = DevFlags.showRuler;
    });
  }

  if (elSunDir) {
    elSunDir.checked = !!(window.DevFlags && DevFlags.showSunDir);
    elSunDir.addEventListener('change', e => {
      if (!window.DevFlags) window.DevFlags = {};
      DevFlags.showSunDir = !!e.target.checked;
      if (typeof scheduleRebuild3D === 'function') scheduleRebuild3D();
      saveLS();
    });
  }

  const applyScale = () => {
    if (!elScale) return;
    const v = parseFloat(elScale.value);
    DevTuning.pirateStationScale = isFinite(v) ? v : 1.0;
    if (window.DevConfig) {
      window.DevConfig.pirateScale = DevTuning.pirateStationScale;
    }
    const legacyScale = document.getElementById('pirScale');
    if (legacyScale) legacyScale.value = String(DevTuning.pirateStationScale);
    const legacyScaleVal = document.getElementById('pirScaleVal');
    if (legacyScaleVal) legacyScaleVal.textContent = '×' + DevTuning.pirateStationScale.toFixed(2);
    if (elScaleVal) elScaleVal.textContent = DevTuning.pirateStationScale.toFixed(2);
  };

  const applyStation3DScale = (inputValue) => {
    const parsed = Number(inputValue);
    const fallback = (Number.isFinite(parsed) && parsed > 0)
      ? parsed
      : DEFAULT_STATION_3D_SCALE;
    const value = fallback;
    DevTuning.pirateStationScale = value;
    Dev.station3DScale = value;
    if (window.DevConfig) {
      window.DevConfig.station3DScale = value;
    }
    if (window.USE_STATION_3D && typeof window.__setStation3DScale === 'function') {
      __setStation3DScale(value);
    }
    if (elStation3DScaleVal) elStation3DScaleVal.textContent = value.toFixed(2);
    const legacy = document.getElementById('station3DScale');
    const legacyVal = document.getElementById('station3DScaleVal');
    if (legacy) legacy.value = String(value);
    if (legacyVal) legacyVal.textContent = '×' + value.toFixed(2);
  };

  // Ustaw wartość z DevConfig (jeśli jest) i natychmiast zastosuj na starcie
  if (elStation3DScale) {
    const initialRaw =
      (window.DevConfig && Number.isFinite(DevConfig.station3DScale) && DevConfig.station3DScale) ||
      (Number.isFinite(+elStation3DScale.value) ? +elStation3DScale.value : NaN);
    const initial = (Number.isFinite(initialRaw) && initialRaw > 0)
      ? initialRaw
      : DEFAULT_STATION_3D_SCALE;
    elStation3DScale.value = String(initial);
    applyStation3DScale(initial);
    if (typeof scheduleRebuild3D === 'function') scheduleRebuild3D();
  }

  if (elScale) {
    if (!isFinite(parseFloat(elScale.value))) {
      elScale.value = String(DevTuning.pirateStationScale);
    }
    elScale.addEventListener('input', applyScale);
    elScale.addEventListener('change', applyScale);
    applyScale();
  } else if (elScaleVal) {
    elScaleVal.textContent = DevTuning.pirateStationScale.toFixed(2);
  }

  if (elStation3DScale) {
    if (!isFinite(parseFloat(elStation3DScale.value)) || parseFloat(elStation3DScale.value) <= 0) {
      elStation3DScale.value = String(DevTuning.pirateStationScale);
    }
    applyStation3DScale(elStation3DScale.value);
    elStation3DScale.addEventListener('input', e => applyStation3DScale(e.target.value));
    elStation3DScale.addEventListener('change', e => applyStation3DScale(e.target.value));
  } else if (elStation3DScaleVal) {
    elStation3DScaleVal.textContent = DevTuning.pirateStationScale.toFixed(2);
  }

    if (elPlanet3D) {
      const stored = typeof DevFlags.usePlanetStations3D === 'boolean'
        ? DevFlags.usePlanetStations3D
        : window.USE_PLANET_STATIONS_3D !== false;
      const enabled = stored !== false;
      DevFlags.usePlanetStations3D = enabled;
      window.USE_PLANET_STATIONS_3D = enabled;
      elPlanet3D.checked = enabled;
      elPlanet3D.addEventListener('change', (e) => {
        const value = !!e.target.checked;
        DevFlags.usePlanetStations3D = value;
        window.USE_PLANET_STATIONS_3D = value;
        if (Array.isArray(window.stations) && typeof window.updateStations3D === 'function') {
          window.updateStations3D(window.stations);
        }
        saveLS();
      });
    }

    if (elPir3D){
      if (typeof DevFlags.use3DPirateStation === 'boolean') {
        window.USE_STATION_3D = DevFlags.use3DPirateStation;
      }
      elPir3D.checked = window.USE_STATION_3D !== false;
      elPir3D.addEventListener('change', e=>{
        if (!window.DevFlags) window.DevFlags = {};
        DevFlags.use3DPirateStation = e.target.checked;
        window.USE_STATION_3D = e.target.checked;
        if (window.USE_STATION_3D && window.__setStation3DScale && typeof Dev.station3DScale === 'number') {
          __setStation3DScale(Dev.station3DScale);
        }
      });
    }
  }
  window.wireDevTools = wireDevTools;
  </script>

<!-- === DEVTOOLS (F10) =================================================== -->
<style>
  #devtools{position:fixed; right:16px; top:16px; width:340px; max-height:80vh;
    overflow:auto; padding:14px; border-radius:12px; background:rgba(10,14,25,.92);
    border:1px solid #1b2337; color:#dfe7ff; z-index:1000; font-family:Inter, system-ui, Segoe UI, Roboto, Arial; display:none}
  #devtools h3{margin:0 0 8px 0; font-size:16px; letter-spacing:.04em; text-transform:uppercase; color:#8fb5ff}
  #devtools .group{margin:12px 0; padding:10px; background:#0b0f1a; border:1px solid #1b2337; border-radius:10px}
  #devtools .row{display:flex; align-items:center; gap:8px; margin:6px 0}
  #devtools .row label{flex:1}
  #devtools input[type=range]{width:180px}
  #devtools .val{min-width:64px; text-align:right; font-variant-numeric: tabular-nums}
  #devtools .small{opacity:.7; font-size:12px}
  #devtools .pill{display:inline-block; padding:2px 8px; border:1px solid #2a3a5a; border-radius:999px; background:#0a1020}
  #devtools textarea{width:100%; height:90px; background:#0b1224; color:#dfe7ff; border:1px solid #2a3a5a; border-radius:8px; padding:8px}
  #devtools .muted{color:#9fb0d8}
  #devtools .dt-row{display:flex; gap:8px; margin-top:6px}
  #devtools .dt-col{display:flex; flex-direction:column}
  #devtools .dt-stack{display:flex; flex-direction:column}
  #devtools .dt-btn{padding:4px 8px; border:1px solid #2a3a5a; border-radius:8px; background:#0a1020; color:#dfe7ff; cursor:pointer}
  #devtools .dt-btn:hover{background:#18233c}
  #devtools .dt-label{font-size:12px; font-weight:600; letter-spacing:.04em; text-transform:uppercase; color:#9fb0d8}
</style>

<div id="devtools">
  <h3>DevTools</h3>

  <div class="group">
    <div class="row"><strong>Wszechświat</strong></div>
    <div class="row">
      <label>Słońce – promień 2D (R)</label>
      <input id="sunR2D" type="range" min="50" max="1500" step="1" value="823">
      <div class="val" id="sunR2DVal"></div>
    </div>
    <div class="row">
      <label>Słońce – promień 3D (R)</label>
      <input id="sunR3D" type="range" min="50" max="1500" step="1" value="399">
      <div class="val" id="sunR3DVal"></div>
    </div>
    <div class="row">
      <label>Planety – skala globalna (×)</label>
      <input id="planetScaleAll" type="range" min="0.5" max="3" step="0.01" value="1">
      <div class="val" id="planetScaleAllVal"></div>
    </div>
  </div>

  <div class="group" id="planetsGroup">
    <div class="row"><strong>Planety (R)</strong> <span class="small muted">(per-planeta)</span></div>
    <!-- Tu JS doda po 1 wierszu na planetę -->
  </div>

  <!-- === Dystanse od Słońca (AU → promień orbity) ======================== -->
  <div class="group" id="distancesGroup">
    <div class="row">
      <strong>Dystanse od Słońca</strong>
      <span class="small muted">(AU → promień orbity)</span>
    </div>
    <!-- Wiersze z suwakami będą dodane przez buildDistancesUI() -->
  </div>

  <div class="group">
    <div class="row"><strong>Stacje</strong></div>
    <div class="row">
      <label>Skala stacji pirackiej (×)</label>
      <input id="pirScale" type="range" min="0.4" max="12" step="0.01" value="6">
      <div class="val" id="pirScaleVal"></div>
    </div>
    <div class="row">
      <label>Skala stacji 3D (×)</label>
      <input id="station3DScale" type="range" min="0.2" max="12.0" step="0.05" value="2.70">
      <div class="val" id="station3DScaleVal"></div>
    </div>
    <div class="row">
      <label>Stacja 3D – rozmiar sprite (px)</label>
      <input id="stationSpritePx" type="number" min="64" max="4096" step="32" value="1024" style="width:96px;">
    </div>
    <div class="dt-row">
      <div class="dt-col">
        <div class="dt-label" style="margin-top:6px;">Skala per stacja</div>
        <div id="dt-stations-per-scale" class="dt-stack" style="gap:6px;"></div>
        <button id="dt-reset-station-scales" class="dt-btn" style="margin-top:6px;">Reset per stacja</button>
      </div>
    </div>
    <label style="display:flex;gap:6px;align-items:center;margin-top:8px">
      <input id="dt-use-planet-stations" type="checkbox" />
      Planet Stations 3D (overlay)
    </label>
    <label style="display:flex;gap:6px;align-items:center;margin-top:8px">
      <input id="dt-use-3d-pirate" type="checkbox" />
      3D Pirate Station (hide 2D)
    </label>
  </div>

  <div class="group" id="stationsFramesGroup">
    <div class="row"><strong>Stacje (kadr per stacja)</strong></div>
    <!-- Wiersze z suwakami per stacja będą dodane dynamicznie przez buildStationFramesUI() -->
  </div>

  <div class="group" id="warpVfxGroup">
    <div class="row"><strong>Warp Wormhole VFX</strong> <span class="small muted">(soczewka statku)</span></div>
    <div class="row">
      <label>Próg trybu pełnego</label>
      <input id="warpLensThreshold" type="range" min="0" max="1" step="0.01">
      <input id="warpLensThresholdNum" type="number" min="0" max="1" step="0.01" style="width:72px;">
      <div class="val" id="warpLensThresholdVal"></div>
    </div>
    <div class="row">
      <label>Promień bazowy</label>
      <input id="warpRadiusBase" type="range" min="0.05" max="0.6" step="0.005">
      <input id="warpRadiusBaseNum" type="number" min="0.05" max="0.6" step="0.005" style="width:72px;">
      <div class="val" id="warpRadiusBaseVal"></div>
    </div>
    <div class="row">
      <label>Promień — skala</label>
      <input id="warpRadiusScale" type="range" min="0" max="0.3" step="0.005">
      <input id="warpRadiusScaleNum" type="number" min="0" max="0.3" step="0.005" style="width:72px;">
      <div class="val" id="warpRadiusScaleVal"></div>
    </div>
    <div class="row">
      <label>Masa bazowa</label>
      <input id="warpMassBase" type="range" min="0" max="0.5" step="0.005">
      <input id="warpMassBaseNum" type="number" min="0" max="0.5" step="0.005" style="width:72px;">
      <div class="val" id="warpMassBaseVal"></div>
    </div>
    <div class="row">
      <label>Masa — skala</label>
      <input id="warpMassScale" type="range" min="0" max="0.6" step="0.005">
      <input id="warpMassScaleNum" type="number" min="0" max="0.6" step="0.005" style="width:72px;">
      <div class="val" id="warpMassScaleVal"></div>
    </div>
    <div class="row">
      <label>Miękkość krawędzi</label>
      <input id="warpSoftness" type="range" min="0" max="1" step="0.01">
      <input id="warpSoftnessNum" type="number" min="0" max="1" step="0.01" style="width:72px;">
      <div class="val" id="warpSoftnessVal"></div>
    </div>
    <div class="row">
      <label>Przezroczystość bazowa</label>
      <input id="warpOpacityBase" type="range" min="0" max="1" step="0.01">
      <input id="warpOpacityBaseNum" type="number" min="0" max="1" step="0.01" style="width:72px;">
      <div class="val" id="warpOpacityBaseVal"></div>
    </div>
    <div class="row">
      <label>Przezroczystość — skala</label>
      <input id="warpOpacityScale" type="range" min="0" max="1" step="0.01">
      <input id="warpOpacityScaleNum" type="number" min="0" max="1" step="0.01" style="width:72px;">
      <div class="val" id="warpOpacityScaleVal"></div>
    </div>
    <div class="row">
      <label>Wydłużenie wzdłuż lotu</label>
      <input id="warpLensForwardStretch" type="range" min="0.1" max="2" step="0.01">
      <input id="warpLensForwardStretchNum" type="number" min="0.1" max="2" step="0.01" style="width:72px;">
      <div class="val" id="warpLensForwardStretchVal"></div>
    </div>
    <div class="row">
      <label>Offset wzdłuż kadłuba</label>
      <input id="warpTailDepthExtra" type="range" min="-0.2" max="0.8" step="0.01">
      <input id="warpTailDepthExtraNum" type="number" min="-0.2" max="0.8" step="0.01" style="width:72px;">
      <div class="val" id="warpTailDepthExtraVal"></div>
    </div>
  </div>

  <div class="group">
    <div class="row">
      <label><input id="toggleRuler" type="checkbox"> Miarka (okręgi dystansu)</label>
    </div>
    <div class="row">
      <label><input id="toggleUnlimitedWarp" type="checkbox"> Nielimitowany warp <span class="pill">F9</span></label>
    </div>
    <div class="row">
      <label><input id="dt-show-sundir" type="checkbox"> Pokaż kierunek słońca</label>
    </div>
    <div class="row">
      <label><input id="dt-disable-shake" type="checkbox"> Wyłącz wstrząsy kamery</label>
    </div>
  </div>

  <div class="group">
    <div class="row"><strong>Konfiguracja</strong></div>
    <div class="row">
      <button id="btnCopy">Kopiuj aktualną konfigurację</button>
      <button id="btnReset" style="margin-left:auto">Reset</button>
    </div>
    <div class="row"><textarea id="cfgOut" readonly></textarea></div>
    <div class="small muted">Skopiuj JSON i wklej do kodu (np. stałe R), gdy chcesz utrwalić w repo.</div>
  </div>

  <div class="small muted">F10 — pokaż/ukryj panel</div>
</div>
<!-- ====================================================================== -->

<script>
(function(){
  // Nie nadpisuj obiektu! Zachowaj referencję, bo gameplay trzyma do niej const.
  const __devtoolsDefaults = {
    showRuler: false,
    unlimitedWarp: false,
    showSunDir: false,
    use3DPirateStation: true,
    usePlanetStations3D: true,
    disableCameraShake: false
  };
  if (!window.DevFlags) window.DevFlags = {};
  for (const k in __devtoolsDefaults) {
    if (!(k in window.DevFlags)) window.DevFlags[k] = __devtoolsDefaults[k];
  }
  const DevFlags = window.DevFlags; // lokalny skrót do TEGO SAMEGO obiektu
  const DEFAULT_PIRATE_SCALE = (
    typeof window !== 'undefined' && typeof window.DEFAULT_STATION_SCALE === 'number'
  ) ? window.DEFAULT_STATION_SCALE : 6;
  const DEFAULT_STATION3D_SCALE = (
    typeof window !== 'undefined' && typeof window.DEFAULT_STATION_3D_SCALE === 'number'
  ) ? window.DEFAULT_STATION_3D_SCALE : 2.70;

  const Dev = window.Dev = window.Dev || {};
  const DevTuning = window.DevTuning = Object.assign({
    pirateStationScale: DEFAULT_PIRATE_SCALE
  }, window.DevTuning || {});

  if (!Number.isFinite(Dev.station3DScale) || Dev.station3DScale <= 0) {
    Dev.station3DScale = DEFAULT_STATION3D_SCALE;
  }

  // Klasyczny skrypt nie widzi stałych z ESM — korzystaj z window.* w runtime.
  // === Wczytaj podstawowe obiekty gry (muszą już istnieć globalnie): SUN, planets, initPlanets3D ===
  // Zakładamy: let SUN = {...}, let planets = [...]; render pętla już działa.

  // ---- Stan & persistencja ------------------------------------------------
  const DevConfig = {
    sunR2D: 823,               // liczba — promień Słońca (warstwa 2D)
    sunR3D: 399,               // liczba — promień Słońca (warstwa 3D)
    planetRById: {},           // { [id or name]: R }
    planetOrbitAUById: {
      mercury: 0.84,
      venus: 1.41,
      earth: 2.07,
      mars: 2.86,
      jupiter: 5.2,
      saturn: 9.58,
      uranus: 19.2,
      neptune: 30
    },      // { [id or name]: AU }
    // Nie zależ od momentu ładowania modułów – czytaj z window w runtime.
    planetScaleAll: (typeof window.DEFAULT_PLANET_SCALE === 'number' ? window.DEFAULT_PLANET_SCALE : 1),                  // mnożnik globalny ×R
    pirateScale: DEFAULT_PIRATE_SCALE,           // mnożnik rysowania stacji pirackiej
    station3DScale: DEFAULT_STATION3D_SCALE,     // mnożnik nakładki 3D
    stationSpriteSize: 1024,
    stationSpriteFrame: 3.00,
    stationSpriteFrameById: {},
    stationScaleById: { earth: 1.10 },
  };
  window.DevConfig = DevConfig;

  const WarpLensDefaults = (window.__WARP_LENS_DEFAULTS && typeof window.__WARP_LENS_DEFAULTS === 'object')
    ? window.__WARP_LENS_DEFAULTS
    : {
        threshold: 0,
        radiusBase: 0.6,
        radiusScale: 0.3,
        massBase: 0,
        massScale: 0.035,
        softness: 0.6,
        opacityBase: 0.55,
        opacityScale: 0.73,
        tailDepthExtra: -0.2,
        forwardStretch: 1.0
      };
  if (!window.__WARP_LENS_DEFAULTS) {
    window.__WARP_LENS_DEFAULTS = WarpLensDefaults;
  }
  const DevVFX = window.DevVFX = window.DevVFX || {};
  DevVFX.warpLens = Object.assign({}, WarpLensDefaults, DevVFX.warpLens || {});

  // ---- Elementy UI --------------------------------------------------------
  const el = (id)=>document.getElementById(id);
  const ui = {};
  const uiIds = {
    root: 'devtools',
    sunR2D: 'sunR2D',
    sunR2DVal: 'sunR2DVal',
    sunR3D: 'sunR3D',
    sunR3DVal: 'sunR3DVal',
    planetScaleAll: 'planetScaleAll',
    planetScaleAllVal: 'planetScaleAllVal',
    pirScale: 'pirScale',
    pirScaleVal: 'pirScaleVal',
    station3DScale: 'station3DScale',
    station3DScaleVal: 'station3DScaleVal',
    stationSpritePx: 'stationSpritePx',
    stationsFramesGroup: 'stationsFramesGroup',
    planetsGroup: 'planetsGroup',
    distancesGroup: 'distancesGroup',
    cbRuler: 'toggleRuler',
    cbUnlimited: 'toggleUnlimitedWarp',
    cbSunDir: 'dt-show-sundir',
    cbShake: 'dt-disable-shake',
    cbPlanetStations3D: 'dt-use-planet-stations',
    cbPirate3D: 'dt-use-3d-pirate',
    btnCopy: 'btnCopy',
    btnReset: 'btnReset',
    cfgOut: 'cfgOut'
  };

  function refreshUIRefs(){
    for (const [key, id] of Object.entries(uiIds)) {
      ui[key] = el(id);
    }
  }

  refreshUIRefs();
  window.__refreshDevUIRefs = refreshUIRefs;

  const warpLensUI = {
    threshold: { slider: el('warpLensThreshold'), number: el('warpLensThresholdNum'), label: el('warpLensThresholdVal'), decimals: 2 },
    radiusBase: { slider: el('warpRadiusBase'), number: el('warpRadiusBaseNum'), label: el('warpRadiusBaseVal'), decimals: 3 },
    radiusScale: { slider: el('warpRadiusScale'), number: el('warpRadiusScaleNum'), label: el('warpRadiusScaleVal'), decimals: 3 },
    massBase: { slider: el('warpMassBase'), number: el('warpMassBaseNum'), label: el('warpMassBaseVal'), decimals: 3 },
    massScale: { slider: el('warpMassScale'), number: el('warpMassScaleNum'), label: el('warpMassScaleVal'), decimals: 3 },
    softness: { slider: el('warpSoftness'), number: el('warpSoftnessNum'), label: el('warpSoftnessVal'), decimals: 2 },
    opacityBase: { slider: el('warpOpacityBase'), number: el('warpOpacityBaseNum'), label: el('warpOpacityBaseVal'), decimals: 2 },
    opacityScale: { slider: el('warpOpacityScale'), number: el('warpOpacityScaleNum'), label: el('warpOpacityScaleVal'), decimals: 2 },
    forwardStretch: { slider: el('warpLensForwardStretch'), number: el('warpLensForwardStretchNum'), label: el('warpLensForwardStretchVal'), decimals: 2 },
    tailDepthExtra: { slider: el('warpTailDepthExtra'), number: el('warpTailDepthExtraNum'), label: el('warpTailDepthExtraVal'), decimals: 2 }
  };
  ui.warpLens = warpLensUI;

  const warpLensRanges = {
    threshold: { min: 0, max: 1 },
    radiusBase: { min: 0.01, max: 1 },
    radiusScale: { min: 0, max: 0.6 },
    massBase: { min: 0, max: 1 },
    massScale: { min: 0, max: 1 },
    softness: { min: 0, max: 1 },
    opacityBase: { min: 0, max: 1 },
    opacityScale: { min: 0, max: 1 },
    forwardStretch: { min: 0.1, max: 3 },
    tailDepthExtra: { min: -1, max: 1 }
  };

  function sanitizeWarpLensValue(key, raw){
    const defaults = WarpLensDefaults;
    const range = warpLensRanges[key] || {};
    let v = Number(raw);
    if (!Number.isFinite(v)) v = defaults[key];
    if (typeof range.min === 'number') v = Math.max(range.min, v);
    if (typeof range.max === 'number') v = Math.min(range.max, v);
    return v;
  }

  function setWarpLensField(key, value){
    const ctrl = warpLensUI[key];
    if (!ctrl) return;
    const decimals = typeof ctrl.decimals === 'number' ? ctrl.decimals : 2;
    const formatted = value.toFixed(decimals);
    if (ctrl.slider) ctrl.slider.value = String(value);
    if (ctrl.number) ctrl.number.value = formatted;
    if (ctrl.label) ctrl.label.textContent = formatted;
  }

  function reflectWarpLensToUI(){
    for (const key in warpLensUI){
      const value = DevVFX.warpLens?.[key];
      const defaults = WarpLensDefaults;
      const v = Number.isFinite(value) ? value : defaults[key];
      setWarpLensField(key, v);
    }
  }

  function applyWarpLensValue(key, raw){
    const value = sanitizeWarpLensValue(key, raw);
    if (!DevVFX.warpLens) DevVFX.warpLens = {};
    DevVFX.warpLens[key] = value;
    setWarpLensField(key, value);
    saveLS();
    reflectToCfg();
  }

  // ---- Inicjalne odczyty z gry -------------------------------------------
  function bootstrapFromGame(){
    const sun = window.SUN;
    if (sun) {
      if (DevConfig.sunR2D == null) DevConfig.sunR2D = sun.r;
      if (DevConfig.sunR3D == null) {
        const base3D = (typeof sun.r3D === 'number') ? sun.r3D : sun.r;
        DevConfig.sunR3D = base3D;
      }
    }
    // domyślne per-planeta (key = name lub id)
    const planetList = Array.isArray(window.planets) ? window.planets : [];
    for (const p of planetList) {
      const key = (p.name || p.id || String(p.index)||'').toString().toLowerCase();
      const baseR = p.baseR ?? p.r;
      if (baseR != null && !Number.isFinite(DevConfig.planetRById[key])) {
        DevConfig.planetRById[key] = baseR;
      }
    }
  }

  function stationKey(st) {
    if (!st) return null;
    if (st.id != null) return String(st.id).toLowerCase();
    if (st.name) return String(st.name).toLowerCase();
    return null;
  }

  // ---- Persistencja -------------------------------------------------------
  function loadLS(){
    try {
      const cfg = JSON.parse(localStorage.getItem('devConfig')||'null');
      if (cfg && typeof cfg==='object'){
        Object.assign(DevConfig, cfg);
        if (typeof DevConfig.pirateScale === 'number') {
          DevTuning.pirateStationScale = DevConfig.pirateScale;
        }
        if (typeof DevConfig.station3DScale === 'number') {
          if (DevConfig.station3DScale > 0) {
            Dev.station3DScale = DevConfig.station3DScale;
          } else {
            DevConfig.station3DScale = DEFAULT_STATION3D_SCALE;
            Dev.station3DScale = DEFAULT_STATION3D_SCALE;
          }
        }
      }
    } catch {}
    // devFlags w osobnym bloku – defensywnie:
    let saved = null;
    try { saved = JSON.parse(localStorage.getItem('devFlags') || 'null'); } catch {}
    if (saved && typeof saved === 'object') {
      // Mutacja ISTNIEJĄCEGO obiektu, bez utraty referencji
      Object.assign(window.DevFlags, saved);
    }
    if (typeof DevFlags.usePlanetStations3D !== 'boolean') {
      DevFlags.usePlanetStations3D = true;
    }
    if (typeof DevFlags.disableCameraShake !== 'boolean') {
      DevFlags.disableCameraShake = false;
    }
    try {
      const savedVfx = JSON.parse(localStorage.getItem('devVfx') || 'null');
      if (savedVfx && typeof savedVfx === 'object') {
        const savedLens = savedVfx.warpLens;
        if (savedLens && typeof savedLens === 'object') {
          DevVFX.warpLens = Object.assign({}, WarpLensDefaults, savedLens);
        }
      }
    } catch {}
    if (typeof window !== 'undefined') {
      window.USE_PLANET_STATIONS_3D = DevFlags.usePlanetStations3D !== false;
    }
    if (!DevConfig.planetOrbitAUById || typeof DevConfig.planetOrbitAUById !== 'object') {
      DevConfig.planetOrbitAUById = {};
    }
    if (typeof DevConfig.planetScaleAll !== 'number') {
      DevConfig.planetScaleAll = (typeof window.DEFAULT_PLANET_SCALE === 'number' ? window.DEFAULT_PLANET_SCALE : 1);
    }
    if (typeof DevConfig.pirateScale !== 'number') {
      DevConfig.pirateScale = DevTuning.pirateStationScale;
    }
    if (typeof DevConfig.station3DScale !== 'number' || DevConfig.station3DScale <= 0) {
      const fallback = (Dev.station3DScale > 0) ? Dev.station3DScale : DEFAULT_STATION3D_SCALE;
      DevConfig.station3DScale = fallback;
    }
    if (typeof DevConfig.stationSpriteSize !== 'number') {
      let saved = NaN;
      try {
        saved = Number(localStorage.getItem('stationSpriteSize'));
      } catch {}
      DevConfig.stationSpriteSize = Number.isFinite(saved) ? saved : 512;
    }
    if (typeof DevConfig.stationSpriteFrame !== 'number') {
      let saved = NaN;
      try {
        saved = Number(localStorage.getItem('stationSpriteFrame'));
      } catch {}
      DevConfig.stationSpriteFrame = Number.isFinite(saved) ? saved : 3.00;
    }
    if (!DevConfig.stationSpriteFrameById || typeof DevConfig.stationSpriteFrameById !== 'object') {
      try {
        DevConfig.stationSpriteFrameById = JSON.parse(localStorage.getItem('stationSpriteFrameById') || '{}') || {};
      } catch {
        DevConfig.stationSpriteFrameById = {};
      }
    }
    if (!DevConfig.stationScaleById || typeof DevConfig.stationScaleById !== 'object') {
      DevConfig.stationScaleById = {};
    }
    const legacySun = Number.isFinite(DevConfig.sunR) ? +DevConfig.sunR : null;
    if (!Number.isFinite(DevConfig.sunR2D) && legacySun != null) {
      DevConfig.sunR2D = legacySun;
    }
    if (!Number.isFinite(DevConfig.sunR3D) && legacySun != null) {
      DevConfig.sunR3D = legacySun;
    }
    if (!Number.isFinite(DevConfig.sunR2D)) {
      DevConfig.sunR2D = null;
    }
    if (!Number.isFinite(DevConfig.sunR3D) && Number.isFinite(DevConfig.sunR2D)) {
      DevConfig.sunR3D = DevConfig.sunR2D;
    }
    delete DevConfig.sunR;
    if (window.__setStation3DScale && window.USE_STATION_3D) {
      window.__lastStationScale = 1;
      __setStation3DScale(Dev.station3DScale);
    }
  }
  function saveLS(){
    localStorage.setItem('devConfig', JSON.stringify(DevConfig));
    localStorage.setItem('devFlags', JSON.stringify(DevFlags));
    try { localStorage.setItem('devVfx', JSON.stringify({ warpLens: DevVFX.warpLens })); } catch {}
  }
  window.__devtoolsSaveLS = saveLS;

  // ---- Rebuild 3D (throttle) ---------------------------------------------
  let rebuildTimer = null;
  function scheduleRebuild3D(){
    if (rebuildTimer) cancelAnimationFrame(rebuildTimer);
    rebuildTimer = requestAnimationFrame(()=> {
      // aktualizujemy struktury gry na podstawie DevConfig
      const gameSun = window.SUN || { r: 823, r3D: 399 }; 

const numericSun2D = Number.isFinite(DevConfig.sunR2D) ? DevConfig.sunR2D : gameSun.r;
      const appliedSun2D = Math.max(1, Math.round(numericSun2D || 0));
      SUN.r = appliedSun2D;
      const numericSun3D = Number.isFinite(DevConfig.sunR3D) ? DevConfig.sunR3D : appliedSun2D;
      const appliedSun3D = Math.max(1, Math.round(numericSun3D || 0));
      SUN.r3D = appliedSun3D;
      const defaultScale = (typeof window.DEFAULT_PLANET_SCALE === 'number' ? window.DEFAULT_PLANET_SCALE : 1);
      const scaleAll = Number.isFinite(+DevConfig.planetScaleAll) && +DevConfig.planetScaleAll > 0
        ? +DevConfig.planetScaleAll
        : defaultScale;
      const planetList = Array.isArray(window.planets) ? window.planets : [];
      for (const p of planetList) {
        const key = (p.name || p.id || String(p.index)||'').toString().toLowerCase();
        const base = DevConfig.planetRById[key] ?? p.baseR ?? p.r;
        if (base != null) {
          p.baseR = base;
          p.r = Math.max(1, Math.round(base * scaleAll));
        }
      }
      // Odbudowa warstwy 3D
      if (typeof initPlanets3D === 'function') {
        const sunFor3D = Object.assign({}, SUN, { r: appliedSun3D });
        if (!Number.isFinite(sunFor3D.r3D)) sunFor3D.r3D = appliedSun3D;
        initPlanets3D(planetList, sunFor3D);
      }
    });
  }

  // ---- Rysowanie miarki ---------------------------------------------------
  window.drawRangeRings = function drawRangeRings(ctx, cam){
    drawRangeRuler(ctx, cam);
  };

  function drawSunDirection(ctx, cam){
    if (!DevFlags.showSunDir) return;
    const planets = Array.isArray(window.planets) ? window.planets : null;
    const sun = (window.SUN || SUN);
    if (!planets || !sun) return;

    const camX = cam?.x ?? 0;
    const camY = cam?.y ?? 0;
    const zoom = cam?.zoom ?? 1;
    const halfW = canvas.width / 2;
    const halfH = canvas.height / 2;

    ctx.save();
    ctx.strokeStyle = '#66c2ff';
    ctx.fillStyle = '#cfe3ff';
    ctx.lineWidth = Math.max(1, 2 * zoom);
    ctx.font = `${Math.max(10, Math.round(12 * zoom))}px monospace`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';

    const dash = Math.max(6, 12 * zoom);
    const labelOffset = 6 * zoom;
    const arrowSize = Math.max(8, 14 * zoom);

    for (const planet of planets) {
      if (!planet || typeof planet.x !== 'number' || typeof planet.y !== 'number') continue;

      const dx = (sun.x ?? 0) - planet.x;
      const dy = (sun.y ?? 0) - planet.y;
      const dist = Math.hypot(dx, dy);
      if (!isFinite(dist) || dist <= 0.0001) continue;

      const ux = dx / dist;
      const uy = dy / dist;

      const sx = (planet.x - camX) * zoom + halfW;
      const sy = (planet.y - camY) * zoom + halfH;

      const segWorld = Math.min(Math.max(dist * 0.25, 80), 240);
      const len = segWorld * zoom;
      const ex = sx + ux * len;
      const ey = sy + uy * len;

      ctx.setLineDash([dash, dash]);
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(ex, ey);
      ctx.stroke();

      ctx.setLineDash([]);

      const ang = Math.atan2(uy, ux);
      ctx.beginPath();
      ctx.moveTo(ex, ey);
      ctx.lineTo(ex - Math.cos(ang - 0.4) * arrowSize, ey - Math.sin(ang - 0.4) * arrowSize);
      ctx.lineTo(ex - Math.cos(ang + 0.4) * arrowSize, ey - Math.sin(ang + 0.4) * arrowSize);
      ctx.closePath();
      ctx.fillStyle = '#66c2ff';
      ctx.fill();

      ctx.fillStyle = '#cfe3ff';
      ctx.fillText('Sun →', ex + labelOffset, ey - labelOffset);
    }

    ctx.restore();
  }
  window.drawSunDirection = drawSunDirection;

  // ---- Cheat: unlimited warp ---------------------------------------------
  window.devtoolsApplyCheats = function devtoolsApplyCheats(){
    const f = window.DevFlags || {};
    if (!f.unlimitedWarp) return;
    const s = window.ship;
    if (s && s.warp){
      if ('cooldown' in s.warp) s.warp.cooldown = 0;
      if ('charge'   in s.warp) s.warp.charge   = s.warp.chargeMax ?? s.warp.maxCharge ?? 1;
      if ('energy'   in s.warp) s.warp.energy   = s.warp.energyMax ?? s.warp.maxEnergy ?? 1;
    }
    if (typeof window.warpCooldown === 'number') window.warpCooldown = 0;
    if (typeof window.warpEnergy === 'number' && typeof window.warpEnergyMax === 'number'){
      window.warpEnergy = window.warpEnergyMax;
    }
  };

  // ---- Hook na stację piracką (rysowanie) --------------------------------
  // W drawStation*(...) gdzie skalujesz sprite/canvas po st.r — zamień na:
  //   const R = st.r * (st.style==='pirate' || st.name?.toLowerCase().includes('pir') ? DevConfig.pirateScale : 1);
  // Jeśli jest osobna funkcja wyliczająca promień — użyj jej (patrz Krok 4: „diff”).

  // ---- UI init ------------------------------------------------------------
  function buildPlanetsUI(){
    refreshUIRefs();
    const root = ui.planetsGroup;
    if (!root) return;
    // wyczyść stare
    root.querySelectorAll('.row.p').forEach(n=>n.remove());

    const planetList = Array.isArray(window.planets) ? window.planets : null;
    if (!planetList || planetList.length === 0){
      if (!buildPlanetsUI._retryTimer){
        buildPlanetsUI._retryTimer = setTimeout(()=>{
          buildPlanetsUI._retryTimer = null;
          buildPlanetsUI();
        }, 500);
      }
      return;
    }
    if (buildPlanetsUI._retryTimer){
      clearTimeout(buildPlanetsUI._retryTimer);
      buildPlanetsUI._retryTimer = null;
    }

    // wylicz bazowe promienie dla UI i dołóż po 1 wierszu per planeta
    const planetDefaults = new Map();
    for (const p of planetList){
      const key = (p.name || p.id || String(p.index)||'').toString().toLowerCase();
      const stored = DevConfig.planetRById[key];
      const base = Number.isFinite(stored)
        ? stored
        : (Number.isFinite(p.baseR)
          ? p.baseR
          : (Number.isFinite(p.r) ? p.r : 100));
      planetDefaults.set(key, base);
      if (!Number.isFinite(stored)) {
        DevConfig.planetRById[key] = base;
      }
      const row = document.createElement('div');
      row.className = 'row p';
      row.innerHTML = `
        <label>${p.name||('Planet '+(p.id??''))}</label>
        <input data-k="${key}" class="plR" type="range" min="20" max="10000" step="1">
        <div class="val" id="val_${key}"></div>
      `;
      root.appendChild(row);
    }
    // podpinki
    root.querySelectorAll('input.plR').forEach(inp=>{
      const k = inp.dataset.k;
      const initial = planetDefaults.get(k);
      const value = Number.isFinite(initial) ? initial : 100;
      inp.value = value;
      el('val_'+k).textContent = value;
      inp.addEventListener('input', ()=>{
        DevConfig.planetRById[k] = +inp.value;
        el('val_'+k).textContent = inp.value;
        saveLS(); scheduleRebuild3D(); reflectToCfg();
      });
    });
  }

  function reflectToUI(){
    refreshUIRefs();
    DevConfig.pirateScale = DevTuning.pirateStationScale;
    DevConfig.station3DScale = Dev.station3DScale;
    if (ui.sunR2D) {
      const value2D = Number.isFinite(DevConfig.sunR2D) ? DevConfig.sunR2D|0 : SUN.r|0;
      ui.sunR2D.value = value2D;
      if (ui.sunR2DVal) ui.sunR2DVal.textContent = value2D;
    }
    if (ui.sunR3D) {
      const fallback3D = Number.isFinite(DevConfig.sunR2D) ? DevConfig.sunR2D : gameSun.r;
      const value3D = Number.isFinite(DevConfig.sunR3D) ? DevConfig.sunR3D|0 : fallback3D|0;
      ui.sunR3D.value = value3D;
      if (ui.sunR3DVal) ui.sunR3DVal.textContent = value3D;
    }
    ui.planetScaleAll.value = DevConfig.planetScaleAll; ui.planetScaleAllVal.textContent = '×'+(+DevConfig.planetScaleAll).toFixed(2);
    ui.pirScale.value = DevConfig.pirateScale; ui.pirScaleVal.textContent = '×'+(+DevConfig.pirateScale).toFixed(2);
    if (ui.station3DScale) {
      ui.station3DScale.value = DevConfig.station3DScale;
      if (ui.station3DScaleVal) ui.station3DScaleVal.textContent = '×'+(+DevConfig.station3DScale).toFixed(2);
    }
    if (ui.stationSpritePx) ui.stationSpritePx.value = DevConfig.stationSpriteSize|0;
    ui.cbRuler.checked = DevFlags.showRuler;
    ui.cbUnlimited.checked = DevFlags.unlimitedWarp;
    if (ui.cbSunDir) ui.cbSunDir.checked = DevFlags.showSunDir;
    if (ui.cbShake) ui.cbShake.checked = DevFlags.disableCameraShake;
    if (ui.cbPlanetStations3D) ui.cbPlanetStations3D.checked = DevFlags.usePlanetStations3D !== false;
    if (ui.cbPirate3D) ui.cbPirate3D.checked = DevFlags.use3DPirateStation;
    reflectWarpLensToUI();
  }
  function reflectToCfg(){
    const out = {
      sunR2D: Number.isFinite(DevConfig.sunR2D) ? DevConfig.sunR2D|0 : SUN.r|0,
      sunR3D: Number.isFinite(DevConfig.sunR3D)
        ? DevConfig.sunR3D|0
        : (Number.isFinite(DevConfig.sunR2D) ? DevConfig.sunR2D|0 : SUN.r|0),
      planetRById: DevConfig.planetRById,
      planetScaleAll: +DevConfig.planetScaleAll,
      pirateScale: +DevConfig.pirateScale,
      station3DScale: +DevConfig.station3DScale,
      stationSpriteSize: +DevConfig.stationSpriteSize,
      stationSpriteFrame: +DevConfig.stationSpriteFrame,
      stationSpriteFrameById: DevConfig.stationSpriteFrameById,
      planetOrbitAUById: collectAUForExport(),
      stationScaleById: DevConfig.stationScaleById,
      warpLens: collectWarpLensForExport()
    };
    ui.cfgOut.value = JSON.stringify(out, null, 2);
  }
  window.__devtoolsReflectToCfg = reflectToCfg;

  function collectWarpLensForExport(){
    const out = {};
    const defaults = WarpLensDefaults;
    const lens = DevVFX.warpLens || {};
    for (const key in defaults){
      const raw = lens[key];
      const value = Number.isFinite(raw) ? raw : defaults[key];
      out[key] = +value;
    }
    return out;
  }

  function getBaseOrbit(){
    const winOrbit = (typeof window !== 'undefined' && typeof window.BASE_ORBIT === 'number')
      ? window.BASE_ORBIT
      : NaN;
    if (Number.isFinite(winOrbit) && winOrbit > 0) {
      return winOrbit;
    }
    const localOrbit = (typeof BASE_ORBIT === 'number') ? BASE_ORBIT : NaN;
    if (Number.isFinite(localOrbit) && localOrbit > 0) {
      return localOrbit;
    }
    return NaN;
  }

  function fmtU(worldDist){
    if (typeof worldDist !== 'number' || !Number.isFinite(worldDist)) return '?';
    const abs = Math.abs(worldDist);
    if (abs >= 100000) return worldDist.toFixed(0);
    if (abs >= 10000)  return worldDist.toFixed(1);
    if (abs >= 1000)   return worldDist.toFixed(1);
    if (abs >= 100)    return worldDist.toFixed(2);
    if (abs >= 1)      return worldDist.toFixed(2);
    if (abs >= 0.01)   return worldDist.toFixed(2);
    return worldDist.toExponential(2).replace('+', '');
  }
  function keyFor(p){
    return (p.name || p.id || String(p.index) || '').toString().toLowerCase();
  }
  function formatAUValue(worldDist){
    const baseOrbit = getBaseOrbit();
    if (!Number.isFinite(baseOrbit) || baseOrbit <= 0) return 0;
    return worldDist / baseOrbit;
  }
  function collectAUForExport(){
    const map = {};
    if (!Array.isArray(window.planets) || !window.SUN) return map;
    const sun = window.SUN;
    const sx = +sun.x || 0, sy = +sun.y || 0;
    for (const p of window.planets){
      const k = keyFor(p);
      let au = DevConfig.planetOrbitAUById?.[k];
      if (!(au > 0)) {
        const dWorld = Math.hypot((p.x||0)-sx, (p.y||0)-sy);
        au = formatAUValue(dWorld);
      }
      map[k] = +(+au).toFixed(2);
    }
    return map;
  }
  function buildStationFramesUI() {
    refreshUIRefs();
    const root = ui.stationsFramesGroup;
    if (!root) return;
    root.querySelectorAll('.row.sf').forEach(n => n.remove());

    const list = Array.isArray(window.stations) ? window.stations : [];
    for (const st of list) {
      const name = st?.name || `Stacja ${st?.id ?? ''}`;
      const key = stationKey(st);
      if (!key) continue;
      const isPirate = (String(st?.style || '').toLowerCase() === 'pirate') ||
        /pir(?:ate)?/i.test(String(st?.name || '')) ||
        st?.isPirate === true;
      if (isPirate) continue;

      const row = document.createElement('div');
      row.className = 'row sf';
      row.style.alignItems = 'center';
      const initial = Number(DevConfig.stationSpriteFrameById[key]);
      const value = Number.isFinite(initial) ? initial : (Number(DevConfig.stationSpriteFrame) || 1.25);
      const safeValue = Math.max(0.1, Math.min(3.0, value));
      row.innerHTML = `
      <label style="min-width:140px">${name}</label>
      <input class="sfSlider" data-k="${key}" type="range" min="0.1" max="3.0" step="0.01" value="${safeValue}">
      <input class="sfNum" data-k="${key}" type="number" min="0.1" max="3.0" step="0.01" value="${safeValue}"
             style="width:72px; margin-left:8px">
      <span class="val" style="min-width:60px; text-align:right">×${(+safeValue).toFixed(2)}</span>
    `;
      root.appendChild(row);

      const slider = row.querySelector('input.sfSlider');
      const num = row.querySelector('input.sfNum');
      const val = row.querySelector('.val');
      const apply = (vRaw) => {
        let v = Number(vRaw);
        if (!Number.isFinite(v)) v = 1.25;
        v = Math.max(0.1, Math.min(3.0, v));
        DevConfig.stationSpriteFrameById[key] = v;
        if (num) num.value = String(v);
        if (slider) slider.value = String(v);
        if (val) val.textContent = '×' + v.toFixed(2);
        try { localStorage.setItem('stationSpriteFrameById', JSON.stringify(DevConfig.stationSpriteFrameById)); } catch {}
        __devtoolsReflectToCfg?.();
        __devtoolsSaveLS?.();
      };
      slider?.addEventListener('input', e => apply(e.target.value));
      slider?.addEventListener('change', e => apply(e.target.value));
      num?.addEventListener('input', e => apply(e.target.value));
      num?.addEventListener('change', e => apply(e.target.value));
    }
  }
  function buildDistancesUI(){
    refreshUIRefs();
    const root = ui.distancesGroup;
    if (!root) return;
    root.querySelectorAll('.row.dist').forEach(n => n.remove());
    if (!Array.isArray(window.planets) || !window.SUN) return;
    for (const p of window.planets){
      const k = keyFor(p);
      const dWorld = Math.hypot((p.x||0)-SUN.x, (p.y||0)-SUN.y);
      const dAU = (DevConfig.planetOrbitAUById?.[k] ?? formatAUValue(dWorld));
      const row = document.createElement('div');
      row.className = 'row dist';
      row.innerHTML = `
        <label style="min-width:80px">${p.name||('Planet '+(p.id??''))}</label>
        <input data-k="${k}" class="plAU" type="range" min="0" max="60" step="0.01">
        <input data-k="${k}" class="plAUVal" type="number" min="0" max="60" step="0.01" style="width:72px; margin:0 6px;">
        <div class="val" id="au_val_${k}" style="min-width:160px; text-align:right; font-variant-numeric: tabular-nums;"></div>
      `;
      root.appendChild(row);
      const inp = row.querySelector('input.plAU');
      const inpVal = row.querySelector('input.plAUVal');
      if (!DevConfig.planetOrbitAUById) DevConfig.planetOrbitAUById = {};
      inp.value = dAU;
      if (inpVal) inpVal.value = (+dAU).toFixed(2);
      const slot = document.getElementById('au_val_'+k);
      const renderVal = (au)=>{
        let num = Number(au);
        if (!Number.isFinite(num)) num = 0;
        const baseOrbit = getBaseOrbit();
        const worldR = Number.isFinite(baseOrbit) ? num * baseOrbit : NaN;
        if (slot) slot.textContent = `${num.toFixed(2)} AU (${fmtU(worldR)} u)`;
        if (inpVal) inpVal.value = num.toFixed(2);
      };
      renderVal(dAU);
      inp.addEventListener('input', ()=>{
        const au = +inp.value;
        setPlanetOrbitAU(k, au);
        renderVal(au);
        saveLS();
        reflectToCfg();
        if (inpVal) inpVal.value = au.toFixed(2);
      });
      if (inpVal) {
        const applyAU = ()=>{
          let au = Number(inpVal.value);
          if (!Number.isFinite(au)) return;
          au = Math.max(0, Math.min(60, au));
          inp.value = String(au);
          setPlanetOrbitAU(k, au);
          renderVal(au);
          saveLS();
          reflectToCfg();
        };
        inpVal.addEventListener('change', applyAU);
        inpVal.addEventListener('keyup', (e)=>{ if (e.key === 'Enter') applyAU(); });
      }
    }
  }
  function setPlanetOrbitAU(key, au){
    DevConfig.planetOrbitAUById = DevConfig.planetOrbitAUById || {};
    DevConfig.planetOrbitAUById[key] = +au;
    applyOrbitOverrides();
  }
  function applyOrbitOverrides(){
    if (!Array.isArray(window.planets) || !window.SUN) return;
    const baseOrbit = getBaseOrbit();
    const Sx = +window.SUN.x||0, Sy = +window.SUN.y||0;
    const map = DevConfig.planetOrbitAUById || {};
    for (const p of window.planets){
      const k = keyFor(p);
      const au = +map[k];
      if (!(au>0)) continue;
      const R = Number.isFinite(baseOrbit) ? au * baseOrbit : au;
      const ang = Math.atan2((p.y||0)-Sy, (p.x||0)-Sx);
      p.devOrbitOverrideR = R;
      if ('orbitRadius' in p) p.orbitRadius = R;
      if (p.orbit && 'radius' in p.orbit) p.orbit.radius = R;
      if ('orbitR' in p) p.orbitR = R;
      p.x = Sx + Math.cos(ang)*R;
      p.y = Sy + Math.sin(ang)*R;
    }
    if (typeof scheduleRebuild3D === 'function') scheduleRebuild3D();
  }
  function refreshDistancesReadout(){
    if (!Array.isArray(window.planets) || !window.SUN) return;
    const baseOrbit = getBaseOrbit();
    for (const p of window.planets){
      const k = keyFor(p);
      const slot = document.getElementById('au_val_'+k);
      if (!slot) continue;
      const dWorld = Math.hypot((p.x||0)-SUN.x, (p.y||0)-SUN.y);
      const au = DevConfig.planetOrbitAUById?.[k] ?? formatAUValue(dWorld);
      const distWorld = Number.isFinite(baseOrbit) ? au * baseOrbit : NaN;
      slot.textContent = `${(+au).toFixed(2)} AU (${fmtU(distWorld)} u)`;
    }
  }

  // listeners
  if (ui.sunR2D) {
    ui.sunR2D.addEventListener('input', () => {
      const val = +ui.sunR2D.value;
      DevConfig.sunR2D = val;
      if (ui.sunR2DVal) ui.sunR2DVal.textContent = ui.sunR2D.value;
      saveLS();
      scheduleRebuild3D();
      reflectToCfg();
    });
  }
  if (ui.sunR3D) {
    ui.sunR3D.addEventListener('input', () => {
      const val = +ui.sunR3D.value;
      DevConfig.sunR3D = val;
      if (ui.sunR3DVal) ui.sunR3DVal.textContent = ui.sunR3D.value;
      saveLS();
      scheduleRebuild3D();
      reflectToCfg();
    });
  }
  ui.planetScaleAll.addEventListener('input', ()=>{ DevConfig.planetScaleAll = +ui.planetScaleAll.value; ui.planetScaleAllVal.textContent = '×'+(+DevConfig.planetScaleAll).toFixed(2); saveLS(); scheduleRebuild3D(); reflectToCfg(); });
  ui.pirScale.addEventListener('input', ()=>{
    DevTuning.pirateStationScale = +ui.pirScale.value;
    DevConfig.pirateScale = DevTuning.pirateStationScale;
    ui.pirScaleVal.textContent = '×'+(+DevConfig.pirateScale).toFixed(2);
    saveLS();
    reflectToCfg();
  });
  if (ui.stationSpritePx) {
    const applySpriteSize = () => {
      let v = Math.round(Number(ui.stationSpritePx.value));
      if (!Number.isFinite(v)) v = 512;
      v = Math.max(64, Math.min(4096, v));
      ui.stationSpritePx.value = String(v);
      DevConfig.stationSpriteSize = v;
      try { localStorage.setItem('stationSpriteSize', String(v)); } catch {}
      saveLS();
      reflectToCfg();
    };
    ui.stationSpritePx.addEventListener('change', applySpriteSize);
    ui.stationSpritePx.addEventListener('input', applySpriteSize);
  }
  for (const [key, ctrl] of Object.entries(warpLensUI)) {
    if (!ctrl) continue;
    if (ctrl.slider) {
      ctrl.slider.addEventListener('input', () => applyWarpLensValue(key, ctrl.slider.value));
      ctrl.slider.addEventListener('change', () => applyWarpLensValue(key, ctrl.slider.value));
    }
    if (ctrl.number) {
      const commit = () => applyWarpLensValue(key, ctrl.number.value);
      ctrl.number.addEventListener('change', commit);
      ctrl.number.addEventListener('keyup', (e)=>{ if (e.key === 'Enter') commit(); });
    }
  }
  ui.cbRuler.addEventListener('change', ()=>{ DevFlags.showRuler = ui.cbRuler.checked; saveLS(); });
  ui.cbUnlimited.addEventListener('change', ()=>{ DevFlags.unlimitedWarp = ui.cbUnlimited.checked; saveLS(); });
  if (ui.cbSunDir) {
    ui.cbSunDir.addEventListener('change', ()=>{
      DevFlags.showSunDir = ui.cbSunDir.checked;
      saveLS();
    });
  }
  if (ui.cbShake) {
    ui.cbShake.addEventListener('change', ()=>{
      DevFlags.disableCameraShake = ui.cbShake.checked;
      if (DevFlags.disableCameraShake) {
        camera.shakeMag = 0;
        camera.shakeTime = 0;
        camera.shakeDur = 0;
      }
      saveLS();
    });
  }
  if (ui.cbPlanetStations3D) {
    ui.cbPlanetStations3D.addEventListener('change', () => {
      DevFlags.usePlanetStations3D = ui.cbPlanetStations3D.checked;
      window.USE_PLANET_STATIONS_3D = ui.cbPlanetStations3D.checked;
      if (Array.isArray(window.stations) && typeof window.updateStations3D === 'function') {
        window.updateStations3D(window.stations);
      }
      saveLS();
    });
  }
  if (ui.cbPirate3D) {
    ui.cbPirate3D.addEventListener('change', ()=>{
      DevFlags.use3DPirateStation = ui.cbPirate3D.checked;
      window.USE_STATION_3D = ui.cbPirate3D.checked;
      if (window.USE_STATION_3D && window.__setStation3DScale && typeof Dev.station3DScale === 'number') {
        __setStation3DScale(Dev.station3DScale);
      }
      saveLS();
    });
  }

  ui.btnCopy.addEventListener('click', async ()=>{
    try { await navigator.clipboard.writeText(ui.cfgOut.value); ui.btnCopy.textContent='Skopiowano!'; setTimeout(()=>ui.btnCopy.textContent='Kopiuj aktualną konfigurację', 1200); } catch{}
  });
  ui.btnReset.addEventListener('click', ()=>{
    localStorage.removeItem('devConfig'); localStorage.removeItem('devFlags'); localStorage.removeItem('stationSpriteSize');
    localStorage.removeItem('stationSpriteFrame'); localStorage.removeItem('stationSpriteFrameById');
    localStorage.removeItem('devVfx');
    location.reload();
  });

  // skróty klawiaturowe
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'F10'){ ui.root.style.display = (ui.root.style.display==='none' || !ui.root.style.display) ? 'block' : 'none'; }
    if (e.key === 'F9' ){ DevFlags.unlimitedWarp = !DevFlags.unlimitedWarp; ui.cbUnlimited.checked = DevFlags.unlimitedWarp; saveLS(); }
    if (e.key === 'F8' ){
      DevFlags.showSunDir = !DevFlags.showSunDir;
      if (ui.cbSunDir) ui.cbSunDir.checked = DevFlags.showSunDir; 
      const el = document.getElementById('dt-show-sundir'); 
      if (el) el.checked = DevFlags.showSunDir; 
      saveLS(); 
    }
  });

  // boot
  loadLS();
  bootstrapFromGame();
  if (!DevConfig.planetOrbitAUById || typeof DevConfig.planetOrbitAUById !== 'object') {
    DevConfig.planetOrbitAUById = {};
  }

  refreshUIRefs();

  // Planety (R)
  buildPlanetsUI();

  // Sekcja: Dystanse od Słońca (AU → promień orbity)
  buildDistancesUI();

  // Sekcja: Kadr sprite per stacja
  buildStationFramesUI();

  // Odbicie stanu
  reflectToUI();
  reflectToCfg();

  // Rebuild 3D po zmianach
  scheduleRebuild3D();

  // Przywróć zapisane AU i przelicz promienie orbit
  applyOrbitOverrides();

  // Aktualizuj readout AU/world-units w panelu
  refreshDistancesReadout();
  setInterval(refreshDistancesReadout, 250);
  setInterval(buildStationFramesUI, 2000);

  // Upewnij się, że panel można włączyć na starcie (dev wygoda)
  // ui.root.style.display = 'block';


if (document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', wireDevTools);
    } else {
      wireDevTools();
    }
  })();
  </script>

<script>
  // === DevTools: API + handler skali stacji 3D ===
  (function(){
    const DEFAULT_STATION3D_SCALE = (
      typeof window.DEFAULT_STATION_3D_SCALE === 'number' && window.DEFAULT_STATION_3D_SCALE > 0
    ) ? window.DEFAULT_STATION_3D_SCALE : 2.70;

    // API dostępne globalnie — zapisuje skalę w dwóch miejscach, aby
    // 1) logika 3D miała natychmiastową wartość, 2) devtools mógł ją odczytać.
    if (!window.__setStation3DScale) {
      window.__setStation3DScale = (v) => {
        const raw = Number(v);
        const fallback = DEFAULT_STATION3D_SCALE;
        const n = (Number.isFinite(raw) && raw > 0) ? raw : fallback;
        window.Dev       = window.Dev       || {};
        window.DevTuning = window.DevTuning || {};
        window.Dev.station3DScale           = n;
        window.DevTuning.pirateStationScale = n;
        const cfg = window.DevConfig;
        if (cfg && typeof cfg === 'object') cfg.station3DScale = n;
        try { localStorage.setItem('station3DScale', String(n)); } catch {}
      };
    }

    // Podpięcie suwaka i wyświetlacza wartości (×1.00, ×1.25 itd.)
    const s  = document.getElementById('station3DScale');
    const sv = document.getElementById('station3DScaleVal');
    if (s) {
      // inicjalizacja z LS (opcjonalnie)
      const saved = Number(localStorage.getItem('station3DScale'));
      if (Number.isFinite(saved) && saved > 0) {
        s.value = String(saved);
        if (sv) sv.textContent = '×' + saved.toFixed(2);
        window.__setStation3DScale(saved);
      } else {
        const def = DEFAULT_STATION3D_SCALE;
        s.value = String(def);
        if (sv) sv.textContent = '×' + def.toFixed(2);
        window.__setStation3DScale(def);
      }

      s.addEventListener('input', () => {
        const v = +s.value;
        window.__setStation3DScale(v);
        if (sv) sv.textContent = '×' + v.toFixed(2);
        if (window.DevConfig && typeof window.DevConfig === 'object') {
          window.DevConfig.station3DScale = v;
        }
        window.__devtoolsSaveLS?.();
        window.__devtoolsReflectToCfg?.();
      });
    }
  })();

  (function setupPerStationScales(){
    const root = document.getElementById('dt-stations-per-scale');
    if (!root) return;

    if (!window.DevConfig) window.DevConfig = {};
    if (!window.DevConfig.stationScaleById || typeof window.DevConfig.stationScaleById !== 'object') {
      window.DevConfig.stationScaleById = {};
    }

    function currentStations() {
      if (Array.isArray(window.stations) && window.stations.length) return window.stations;
      if (Array.isArray(window.planets)) {
        return window.planets.map((pl) => ({ id: pl.id || pl.name || '', planet: pl }));
      }
      return [];
    }

    function makeRow(st) {
      const id = String(st?.id || st?.planet?.id || st?.planet?.name || '').toLowerCase();
      if (!id) return null;

      const map = typeof window.getStationScales === 'function' ? window.getStationScales() : null;
      const rawInitial = (window.DevConfig.stationScaleById && window.DevConfig.stationScaleById[id])
        ?? (map ? map[id] : undefined)
        ?? 1;
      const initial = Number(rawInitial) || 1;

      const wrap = document.createElement('div');
      wrap.className = 'dt-row';
      wrap.style.alignItems = 'center';

      const label = document.createElement('div');
      label.className = 'dt-col';
      label.style.minWidth = '120px';
      label.textContent = id[0].toUpperCase() + id.slice(1);

      const col = document.createElement('div');
      col.className = 'dt-col';
      col.style.flex = '1';

      const range = document.createElement('input');
      range.type = 'range';
      range.min = '0.2';
      range.max = '5';
      range.step = '0.01';
      range.value = String(initial);
      range.id = `dt-scale-station-${id}`;

      const val = document.createElement('span');
      val.style.marginLeft = '8px';
      val.textContent = initial.toFixed(2);

      const num = document.createElement('input');
      num.type = 'number';
      num.min = '0.2';
      num.max = '5';
      num.step = '0.01';
      num.value = String(initial);
      num.id = `dt-scale-station-${id}-num`;
      num.style.width = '72px';
      num.style.marginLeft = '8px';

      const apply = (vRaw) => {
        let v = Number(vRaw);
        if (!Number.isFinite(v)) v = 1;
        v = Math.max(0.2, Math.min(5, v));
        if (!window.DevConfig || typeof window.DevConfig !== 'object') window.DevConfig = {};
        if (!window.DevConfig.stationScaleById || typeof window.DevConfig.stationScaleById !== 'object') {
          window.DevConfig.stationScaleById = {};
        }
        window.DevConfig.stationScaleById[id] = v;
        range.value = String(v);
        num.value = String(v);
        val.textContent = v.toFixed(2);
        if (typeof window.setStationScale === 'function') window.setStationScale(id, v);
        window.__devtoolsSaveLS?.();
      };

      range.addEventListener('input', () => apply(range.value));
      num.addEventListener('input', () => apply(num.value));
      num.addEventListener('change', () => apply(num.value));
      num.addEventListener('keyup', (e) => { if (e.key === 'Enter') apply(num.value); });

      col.appendChild(range);
      col.appendChild(num);
      col.appendChild(val);
      wrap.appendChild(label);
      wrap.appendChild(col);
      return wrap;
    }

    function rebuild() {
      root.innerHTML = '';
      const list = currentStations();
      const seen = new Set();
      for (const st of list) {
        const row = makeRow(st);
        if (!row) continue;
        const input = row.querySelector('input[type="range"]');
        const key = input ? input.id : null;
        if (!key || seen.has(key)) continue;
        seen.add(key);
        root.appendChild(row);
      }
    }

    const btnReset = document.getElementById('dt-reset-station-scales');
    if (btnReset) {
      btnReset.addEventListener('click', () => {
        if (!window.DevConfig) window.DevConfig = {};
        window.DevConfig.stationScaleById = {};
        window.__devtoolsSaveLS?.();
        if (typeof window.__saveDevLS === 'function') window.__saveDevLS();
        rebuild();
        if (Array.isArray(window.stations) && typeof window.updateStations3D === 'function') {
          window.updateStations3D(window.stations);
        }
      });
    }

    rebuild();
    let tries = 0;
    const t = setInterval(() => {
      tries++;
      const count = root.querySelectorAll('input[type="range"]').length;
      const stationCount = Array.isArray(window.stations) ? window.stations.length : 0;
      if (stationCount > count || (count === 0 && tries < 120)) {
        rebuild();
      }
      if (tries >= 120) clearInterval(t);
    }, 500);

   if (typeof window.__saveDevLS !== 'function') {
      window.__saveDevLS = function __saveDevLSFallback(){
        try {
          const data = { DevFlags: window.DevFlags, DevTuning: window.DevTuning, DevConfig: window.DevConfig };
          localStorage.setItem('#__dev', JSON.stringify(data));
        } catch (err) {
          console.warn('DevTools: failed to persist station scales', err);
        }
      };
    }

  })();
</script>

</body>
</html>
