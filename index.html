<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Space Survivors — gwiazdy na całej mapie + duży silnik plazmowy</title>
<style>
  :root{
    --fa-font: 'Segoe UI','Frutiger','Inter',system-ui,-apple-system,sans-serif;
    --fa-text: #e8f6ff;
    --fa-muted: #b8d6f3;
    --fa-border: rgba(129,203,255,0.45);
    --fa-strong-border: rgba(129,203,255,0.75);
    --fa-panel: linear-gradient(160deg,rgba(255,255,255,0.08),rgba(62,142,206,0.18));
    --fa-panel-strong: linear-gradient(160deg,rgba(255,255,255,0.10),rgba(36,111,185,0.26));
    --fa-glow: 0 18px 44px rgba(5,32,74,0.55);
    --fa-accent: #6ddcff;
    --fa-accent-2: #3aa1ff;
    --fa-surface-dark: rgba(9,18,38,0.8);
    --fa-surface-gloss: linear-gradient(180deg,rgba(255,255,255,0.08),rgba(255,255,255,0));
  }
  html,body{height:100%;margin:0;background:radial-gradient(circle at 25% 20%,rgba(123,214,255,0.12),transparent 32%),radial-gradient(circle at 70% 10%,rgba(140,196,255,0.14),transparent 36%),linear-gradient(135deg,#041226 0%,#061a32 40%,#07243f 100%);color:var(--fa-text);font-family:var(--fa-font)}
  body,button,input,select,option{font-family:var(--fa-font);}
  body::before{content:'';position:fixed;inset:0;pointer-events:none;background:radial-gradient(circle at 50% 30%,rgba(255,255,255,0.05),transparent 35%);mix-blend-mode:screen;opacity:0.8;z-index:1}
  #ui{position:absolute;left:12px;top:12px;z-index:120;background:var(--fa-panel);padding:12px 14px;border-radius:12px;backdrop-filter:blur(10px);border:1px solid var(--fa-border);box-shadow:var(--fa-glow)}
  #side-panels{position:absolute;left:12px;top:160px;width:280px;z-index:120;display:flex;flex-direction:column;gap:12px;}
  #fleet-ui{width:100%;display:flex;flex-direction:column;gap:10px;background:var(--fa-panel-strong);padding:14px 16px;border-radius:14px;border:1px solid var(--fa-border);backdrop-filter:blur(10px);color:var(--fa-text);font-family:var(--fa-font);box-shadow:var(--fa-glow)}
  #fleet-ui.hidden{display:none !important;}
  #fleet-ui h3{margin:0;font-size:15px;letter-spacing:0.08em;text-transform:uppercase;color:#aee3ff;text-shadow:0 0 12px rgba(99,208,255,0.45);}
  #fleet-list{list-style:none;margin:0;padding:0;display:flex;flex-direction:column;gap:10px;}
  .fleet-ship{padding:10px 12px;background:linear-gradient(160deg,rgba(10,26,48,0.82),rgba(12,32,58,0.9));border:1px solid var(--fa-border);border-radius:12px;display:flex;flex-direction:column;gap:8px;box-shadow:0 10px 24px rgba(0,0,0,0.35)}
  .fleet-ship-header{display:flex;flex-direction:column;gap:2px;}
  .fleet-ship-name{font-weight:700;font-size:15px;color:#f6fbff;letter-spacing:0.02em;}
  .fleet-ship-meta{font-size:11px;letter-spacing:0.12em;text-transform:uppercase;color:var(--fa-muted);}
  .fleet-bars{display:flex;flex-direction:column;gap:6px;}
  .fleet-bar-label{font-size:11px;color:var(--fa-muted);display:flex;justify-content:space-between;}
  .fleet-bar{height:9px;border-radius:999px;background:rgba(56,92,138,0.65);overflow:hidden;position:relative;box-shadow:inset 0 1px 0 rgba(255,255,255,0.08);}
  .fleet-bar-fill{position:absolute;left:0;top:0;height:100%;border-radius:999px;transition:width 0.25s ease-out;filter:drop-shadow(0 0 6px rgba(109,220,255,0.5));}
  .fleet-bar-fill.hull{background:linear-gradient(90deg,#ffb866,#ffd56b);} 
  .fleet-bar-fill.shield{background:linear-gradient(90deg,#5be0ff,#7ea7ff);} 
  .fleet-fighters{font-size:12px;color:var(--fa-text);text-shadow:0 0 8px rgba(109,220,255,0.45);}
  .fleet-hardpoints{display:flex;gap:8px;font-size:11px;color:#cde7ff;flex-wrap:wrap;}
  .fleet-hardpoints span{padding:2px 8px;border-radius:999px;background:rgba(99,167,238,0.2);border:1px solid var(--fa-border);box-shadow:0 6px 16px rgba(0,0,0,0.25);}
  .fleet-controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px;}
  .fleet-order-btn{flex:1 1 30%;padding:8px 9px;border-radius:10px;border:1px solid var(--fa-border);background:linear-gradient(150deg,rgba(66,142,210,0.25),rgba(55,116,186,0.35));color:var(--fa-text);font-size:11px;letter-spacing:0.08em;text-transform:uppercase;cursor:pointer;transition:background 0.18s ease,border-color 0.18s ease,color 0.18s ease,transform 0.18s ease;box-shadow:0 10px 20px rgba(0,0,0,0.22);}
  .fleet-order-btn:hover{background:linear-gradient(150deg,rgba(96,188,255,0.35),rgba(55,116,186,0.45));border-color:var(--fa-strong-border);transform:translateY(-1px);}
  .fleet-order-btn.active{background:linear-gradient(150deg,rgba(109,220,255,0.4),rgba(58,161,255,0.42));border-color:var(--fa-strong-border);color:#f1f7ff;box-shadow:0 0 0 1px rgba(96,165,250,0.35) inset,0 12px 26px rgba(3,92,160,0.35);}
  #support-ui{width:100%;display:flex;flex-direction:column;gap:10px;background:var(--fa-panel-strong);padding:14px 16px;border-radius:14px;border:1px solid var(--fa-border);backdrop-filter:blur(10px);color:var(--fa-text);font-family:var(--fa-font);box-shadow:var(--fa-glow)}
  #support-ui.hidden{display:none !important;}
  #support-ui h3{margin:0;font-size:15px;letter-spacing:0.08em;text-transform:uppercase;color:#aee3ff;text-shadow:0 0 12px rgba(99,208,255,0.45);}
  .support-row{display:flex;flex-wrap:wrap;gap:8px;}
  .support-btn{flex:1 1 48%;padding:9px 11px;border-radius:10px;border:1px solid var(--fa-border);background:linear-gradient(150deg,rgba(66,142,210,0.25),rgba(55,116,186,0.35));color:var(--fa-text);font-size:12px;letter-spacing:0.06em;text-transform:uppercase;cursor:pointer;transition:background 0.18s ease,border-color 0.18s ease,color 0.18s ease,transform 0.18s ease;box-shadow:0 10px 20px rgba(0,0,0,0.22);}
  .support-btn:hover{background:linear-gradient(150deg,rgba(96,188,255,0.35),rgba(55,116,186,0.45));border-color:var(--fa-strong-border);transform:translateY(-1px);}
  .support-order-btn{flex:1 1 48%;padding:9px 11px;border-radius:10px;border:1px solid var(--fa-border);background:linear-gradient(150deg,rgba(66,142,210,0.28),rgba(55,116,186,0.38));color:var(--fa-text);font-size:12px;letter-spacing:0.08em;text-transform:uppercase;cursor:pointer;transition:background 0.18s ease,border-color 0.18s ease,color 0.18s ease,transform 0.18s ease;box-shadow:0 12px 24px rgba(0,0,0,0.25);}
  .support-order-btn.active{background:linear-gradient(150deg,rgba(109,220,255,0.4),rgba(58,161,255,0.42));border-color:var(--fa-strong-border);color:#f1f7ff;box-shadow:0 0 0 1px rgba(96,165,250,0.35) inset,0 12px 26px rgba(3,92,160,0.35);}
  canvas{display:block;width:100vw;height:100vh}
  #game-root{position:relative;width:100vw;height:100vh;}
  #game-root>canvas{display:block;width:100%;height:100%;}
  #c { position: relative; z-index: 10; }
  /* nie obejmuj overlayu 3D */
  canvas:not(#c):not(.overlay3d) {
    pointer-events: none !important;
    position: absolute;
    inset: 0;
    z-index: 0;
  }
  .stat{font-family:monospace;font-size:13px}
  small{color:#a8b4d9}
  #main-menu{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 50% 30%,rgba(77,190,255,0.14),rgba(3,4,23,0.9));backdrop-filter:blur(12px);z-index:70;color:var(--fa-text);padding:20px;}
  .menu-panel{width:min(460px,calc(100% - 24px));background:var(--fa-panel-strong);border:1px solid var(--fa-border);border-radius:20px;box-shadow:var(--fa-glow);padding:32px 34px;display:flex;flex-direction:column;gap:16px;position:relative;overflow:hidden;}
  .menu-panel::after{content:'';position:absolute;inset:0;background:var(--fa-surface-gloss);pointer-events:none;}
  .menu-panel h1{margin:0;font-size:28px;letter-spacing:0.08em;text-transform:uppercase;color:#c1e8ff;text-shadow:0 0 18px rgba(109,220,255,0.6);}
  .menu-subtitle{margin:0;color:var(--fa-muted);font-size:15px;line-height:1.5;}
  .menu-actions{display:flex;flex-direction:column;gap:12px;}
  .menu-actions button{width:100%;padding:13px 15px;font-size:15px;letter-spacing:0.08em;text-transform:uppercase;border-radius:14px;border:1px solid var(--fa-border);cursor:pointer;transition:background 0.18s ease,border-color 0.18s ease,transform 0.18s ease,box-shadow 0.18s ease;box-shadow:0 12px 28px rgba(0,0,0,0.28);background:linear-gradient(150deg,rgba(66,142,210,0.32),rgba(55,116,186,0.42));color:var(--fa-text);}
  .menu-actions button:disabled{opacity:0.55;cursor:not-allowed;}
  .menu-actions button:not(:disabled):hover{transform:translateY(-1px);border-color:var(--fa-strong-border);}
  .menu-primary{background:linear-gradient(130deg,#6ddcff,#3aa1ff);color:#041226;border:none;box-shadow:0 16px 32px rgba(61,179,255,0.45);}
  .menu-primary:hover{box-shadow:0 18px 40px rgba(61,179,255,0.55);}
  .menu-secondary{background:linear-gradient(150deg,rgba(66,142,210,0.32),rgba(55,116,186,0.42));color:var(--fa-text);}
  .menu-secondary:not(:disabled):hover{background:linear-gradient(150deg,rgba(96,188,255,0.42),rgba(55,116,186,0.52));border-color:var(--fa-strong-border);}
  .menu-hint{margin:0;color:#b6d7ff;font-size:13px;}
  #loading{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:radial-gradient(circle at 40% 30%,rgba(77,190,255,0.12),rgba(3,4,23,0.94));z-index:80;color:var(--fa-text);font-family:var(--fa-font);padding:20px;}
  .loading-box{width:min(380px,calc(100% - 24px));background:var(--fa-panel-strong);border:1px solid var(--fa-border);border-radius:16px;padding:24px 26px;box-shadow:var(--fa-glow);display:flex;flex-direction:column;gap:12px;position:relative;overflow:hidden;}
  .loading-box::after{content:'';position:absolute;inset:0;background:var(--fa-surface-gloss);pointer-events:none;}
  .loading-title{font-size:18px;letter-spacing:0.1em;text-transform:uppercase;color:#c1e8ff;margin:0;text-shadow:0 0 18px rgba(109,220,255,0.6);}
  .loading-bar{position:relative;width:100%;height:12px;border-radius:999px;background:rgba(28,50,92,0.9);overflow:hidden;border:1px solid var(--fa-border);box-shadow:inset 0 1px 0 rgba(255,255,255,0.08);}
  .loading-bar span{position:absolute;left:0;top:0;height:100%;width:0;background:linear-gradient(90deg,#6ddcff,#3aa1ff);box-shadow:0 8px 18px rgba(61,179,255,0.35);transition:width 0.18s ease-out;}
  .loading-progress{font-size:14px;color:#dff2ff;letter-spacing:0.08em;text-transform:uppercase;}
  .hidden{display:none !important;}
  .station-overlay{position:absolute;top:60px;right:40px;max-width:840px;width:min(840px,calc(100vw - 80px));min-width:540px;max-height:80vh;overflow:hidden;overflow-y:auto;padding:18px 20px;background:radial-gradient(circle at 18% 18%,rgba(109,220,255,0.14),transparent 32%),var(--fa-panel-strong);border:1px solid var(--fa-border);border-radius:16px;z-index:60;color:var(--fa-text);font-family:var(--fa-font);backdrop-filter:blur(14px);box-shadow:0 22px 44px rgba(5,32,74,0.55);}
  .station-overlay::after{content:"";position:absolute;inset:0;background:var(--fa-surface-gloss);pointer-events:none;border-radius:inherit;opacity:0.9;}
  .station-overlay h3{position:relative;z-index:1;margin:0 0 12px 0;font-size:18px;letter-spacing:0.06em;text-transform:uppercase;color:#c1e8ff;text-shadow:0 0 12px rgba(109,220,255,0.45);}
  .station-overlay ul{position:relative;z-index:1;list-style:none;padding:0;margin:0 0 12px 0;display:flex;gap:10px;flex-wrap:wrap;align-items:stretch;}
  .station-overlay li{padding:9px 16px;border:1px solid var(--fa-border);border-radius:12px;background:linear-gradient(150deg,rgba(66,142,210,0.28),rgba(55,116,186,0.46));cursor:pointer;color:var(--fa-text);font-size:14px;transition:background 0.2s,border-color 0.2s,color 0.2s,transform 0.18s ease;flex:1 1 42%;text-align:center;min-width:128px;box-shadow:0 14px 22px rgba(0,0,0,0.26);backdrop-filter:blur(6px);}
  .station-overlay li:hover{background:linear-gradient(150deg,rgba(96,188,255,0.42),rgba(55,116,186,0.54));border-color:var(--fa-strong-border);color:#e6f8ff;transform:translateY(-1px);}
  .station-overlay li.active{background:linear-gradient(150deg,rgba(109,220,255,0.5),rgba(58,161,255,0.56));border-color:var(--fa-strong-border);color:#041226;box-shadow:0 0 0 1px rgba(96,165,250,0.35) inset,0 12px 26px rgba(3,92,160,0.35);}
  .station-tab.hidden{display:none;}
  .station-head{position:relative;z-index:1;display:flex;justify-content:space-between;gap:12px;align-items:flex-start;margin-bottom:12px;}
  .station-title{margin:0;font-size:20px;letter-spacing:0.08em;text-transform:uppercase;color:#e6f8ff;text-shadow:0 0 14px rgba(109,220,255,0.55);}
  .station-subtitle{margin:2px 0 0 0;font-size:12px;letter-spacing:0.16em;text-transform:uppercase;color:var(--fa-muted);}
  .station-balance{display:flex;flex-direction:column;gap:2px;padding:10px 12px;border-radius:12px;background:rgba(8,18,36,0.85);border:1px solid rgba(109,220,255,0.35);box-shadow:0 12px 26px rgba(3,12,32,0.5);}
  .station-balance .label{font-size:11px;letter-spacing:0.14em;text-transform:uppercase;color:#8fb5ff;}
  .station-balance .value{font-size:18px;font-weight:800;color:#f8fbff;letter-spacing:0.04em;}
  .station-panels{position:relative;z-index:1;display:flex;flex-direction:column;gap:12px;}
  .station-tab{display:none;flex-direction:column;gap:12px;}
  .station-tab.active{display:flex;}
  .station-card{padding:12px 14px;border-radius:12px;background:linear-gradient(170deg,rgba(9,16,32,0.92),rgba(12,26,46,0.95));border:1px solid rgba(34,60,104,0.85);box-shadow:0 14px 26px rgba(0,0,0,0.32);display:flex;flex-direction:column;gap:8px;}
  .station-card-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .station-card-title{margin:0;font-size:15px;font-weight:800;letter-spacing:0.04em;color:#e6f8ff;}
  .station-chip{padding:4px 10px;border-radius:999px;background:rgba(63,88,144,0.32);border:1px solid rgba(96,165,250,0.4);color:#dfe7ff;font-size:11px;letter-spacing:0.08em;text-transform:uppercase;}
  .station-card-desc{margin:0;color:#cbd5ff;font-size:13px;line-height:1.5;}
  .station-card-meta{display:flex;flex-wrap:wrap;gap:10px;font-size:12px;color:#9fb4e6;}
  .station-card-actions{display:flex;flex-wrap:wrap;gap:10px;align-items:center;}
  .station-card button{padding:8px 12px;border-radius:10px;border:1px solid var(--fa-border);background:linear-gradient(150deg,rgba(66,142,210,0.28),rgba(55,116,186,0.42));color:var(--fa-text);font-weight:700;letter-spacing:0.06em;text-transform:uppercase;cursor:pointer;transition:background 0.18s,border-color 0.18s,transform 0.18s;box-shadow:0 12px 22px rgba(0,0,0,0.28);}
  .station-card button:hover:not(:disabled){background:linear-gradient(150deg,rgba(96,188,255,0.38),rgba(55,116,186,0.5));border-color:var(--fa-strong-border);transform:translateY(-1px);}
  .station-card button:disabled{opacity:0.45;cursor:not-allowed;}
  .station-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;}
  .station-divider{height:1px;background:linear-gradient(90deg,rgba(109,220,255,0),rgba(109,220,255,0.45),rgba(109,220,255,0));margin:4px 0;}
  .mechanic-toolbar{position:relative;z-index:1;display:flex;align-items:center;gap:8px;margin-bottom:14px;}
  .mechanic-toolbar label{font-weight:700;letter-spacing:0.05em;color:#b8c9f3;text-transform:uppercase;font-size:12px;}
  .mechanic-toolbar select{flex:1;background:linear-gradient(135deg,rgba(6,14,28,0.92),rgba(8,16,34,0.95));color:#dfe7ff;border:1px solid #2a3a5a;border-radius:10px;padding:7px 12px;font-size:14px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.08);}
  .mechanic-body{display:grid;grid-template-columns:1fr 1.2fr;gap:16px;align-items:flex-start;}
  .mechanic-column{display:flex;flex-direction:column;gap:12px;min-width:0;}
  .mechanic-section{background:linear-gradient(170deg,rgba(9,16,32,0.92),rgba(10,22,42,0.95));border:1px solid #1f2c49;border-radius:12px;padding:12px;box-shadow:0 12px 22px rgba(0,0,0,0.32);position:relative;z-index:1;}
  .mechanic-section-head{display:flex;justify-content:space-between;align-items:flex-start;gap:12px;margin-bottom:10px;}
  .mechanic-kicker{margin:0;font-size:11px;letter-spacing:0.14em;text-transform:uppercase;color:#94a9d6;}
  .mechanic-section-head h4{margin:2px 0 6px 0;font-size:18px;letter-spacing:0.04em;color:#e6f8ff;}
  .mechanic-sub{margin:0;color:#9fb4e6;font-size:13px;line-height:1.5;}
  .weapon-pool{display:flex;flex-direction:column;gap:10px;}
  .weapon-group{border:1px solid rgba(34,60,104,0.75);border-radius:10px;padding:10px;background:linear-gradient(150deg,rgba(14,20,36,0.9),rgba(12,18,32,0.92));box-shadow:0 10px 20px rgba(0,0,0,0.28);}
  .weapon-group-header{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:8px;}
  .weapon-group-header h5{margin:0;font-size:14px;letter-spacing:0.06em;text-transform:uppercase;color:#dfe7ff;}
  .weapon-count{font-size:12px;color:#8fb5ff;letter-spacing:0.08em;}
  .weapon-chip{display:flex;align-items:center;gap:10px;padding:9px 10px;border:1px solid rgba(60,90,140,0.7);border-radius:10px;background:linear-gradient(145deg,rgba(14,20,36,0.92),rgba(9,13,24,0.9));box-shadow:0 8px 18px rgba(4,8,20,0.45);cursor:grab;transition:border-color 0.2s,transform 0.2s,box-shadow 0.2s;}
  .weapon-chip:hover{border-color:rgba(109,220,255,0.6);box-shadow:0 10px 22px rgba(8,16,32,0.5);}
  .weapon-chip:active{cursor:grabbing;}
  .weapon-chip .weapon-name{font-weight:700;color:#e6f8ff;}
  .weapon-chip .weapon-meta{display:flex;gap:6px;font-size:12px;color:#9fb4e6;flex-wrap:wrap;}
  .weapon-chip.dragging{opacity:0.75;transform:scale(0.99);}
  .hp-groups{position:relative;z-index:1;display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));}
  .hp-group{background:linear-gradient(170deg,rgba(9,16,32,0.92),rgba(10,22,42,0.95));border:1px solid #1f2c49;border-radius:12px;padding:12px;box-shadow:0 12px 22px rgba(0,0,0,0.32);}
  .hp-group h4{margin:0 0 8px 0;font-weight:800;letter-spacing:0.04em;color:#dfe7ff;display:flex;align-items:center;justify-content:space-between;}
  .hp-group small{color:#8fb5ff;letter-spacing:0.08em;text-transform:uppercase;}
  .hp-slot{border:1px dashed rgba(88,108,170,0.55);border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:8px;background:linear-gradient(145deg,rgba(10,16,30,0.82),rgba(9,13,24,0.9));box-shadow:inset 0 1px 0 rgba(255,255,255,0.04),0 8px 18px rgba(4,8,20,0.45);transition:border-color 0.18s ease,background 0.18s ease,transform 0.18s ease;}
  .hp-slot:not(:last-child){margin-bottom:8px;}
  .hp-slot.drag-over{border-color:#60a5fa;background:rgba(30,48,92,0.58);box-shadow:0 10px 24px rgba(12,48,96,0.45);}
  .hp-slot .hp-slot-header{display:flex;align-items:center;justify-content:space-between;gap:8px;}
  .hp-slot .hp-slot-label{font-size:13px;letter-spacing:0.08em;text-transform:uppercase;color:#9fb4e6;}
  .hp-slot .hp-slot-clear{padding:4px 8px;border-radius:8px;border:1px solid rgba(58,76,118,0.8);background:rgba(10,16,30,0.9);color:#cbd5ff;cursor:pointer;transition:background 0.18s ease,border-color 0.18s ease;}
  .hp-slot .hp-slot-clear:hover{background:rgba(22,32,56,0.95);border-color:rgba(109,220,255,0.55);}
  .hp-slot-body{display:flex;align-items:center;gap:10px;}
  .hp-slot.empty .hp-slot-body{opacity:0.85;}
  .hp-slot .weapon-name{font-weight:700;color:#e6f8ff;}
  .hp-slot .weapon-meta{font-size:12px;color:#9fb4e6;display:flex;gap:6px;flex-wrap:wrap;}
  .hp-slot .hp-slot-hint{font-size:12px;color:#7687b4;letter-spacing:0.06em;}
  .weapon-icon-wrap{width:46px;height:46px;border-radius:12px;background:rgba(20,28,46,0.95);border:1px solid rgba(74,104,164,0.45);box-shadow:0 10px 18px rgba(6,12,28,0.55);display:flex;align-items:center;justify-content:center;overflow:hidden;flex-shrink:0;}
  .weapon-icon-wrap img{width:100%;height:100%;object-fit:contain;image-rendering:auto;}
  .weapon-icon-placeholder{width:46px;height:46px;border-radius:12px;border:1px dashed rgba(88,108,170,0.45);background:rgba(10,16,30,0.8);box-shadow:inset 0 0 12px rgba(24,32,56,0.55);display:flex;align-items:center;justify-content:center;color:#6b7da8;font-size:11px;letter-spacing:0.12em;text-transform:uppercase;}
  .weapon-icon-placeholder[data-type="main"]{border-color:rgba(58,130,246,0.55);color:#90b4ff;}
  .weapon-icon-placeholder[data-type="missile"]{border-color:rgba(16,185,129,0.55);color:#6dd9b7;}
  .weapon-icon-placeholder[data-type="aux"]{border-color:rgba(245,158,11,0.55);color:#f6c26a;}
  .weapon-icon-placeholder[data-type="hangar"]{border-color:rgba(167,139,250,0.55);color:#cab5ff;}
  .weapon-icon-placeholder[data-type="special"]{border-color:rgba(239,68,68,0.55);color:#fda4a4;}
  .weapon-pill{padding:3px 8px;border-radius:999px;background:rgba(63,88,144,0.35);border:1px solid rgba(96,165,250,0.35);color:#dfe7ff;font-size:11px;letter-spacing:0.06em;text-transform:uppercase;}
  .hp-main h4, .hp-main .hp-slot{outline:1px solid #3b82f6;}
  .hp-miss h4, .hp-miss .hp-slot{outline:1px solid #10b981;}
  .hp-aux h4, .hp-aux .hp-slot{outline:1px solid #f59e0b;}
  .hp-hangar h4, .hp-hangar .hp-slot{outline:1px solid #a78bfa;}
  .hp-spec h4, .hp-spec .hp-slot{outline:1px solid #ef4444;}
  #infrastructure-overlay{max-width:720px;width:min(720px,calc(100vw - 80px));opacity:0;transform:translate(0,12px);transition:opacity 0.25s ease,transform 0.28s ease;pointer-events:none;}
  #infrastructure-overlay.infra-visible{opacity:1;transform:translate(0,0);pointer-events:auto;}
  #infrastructure-overlay.infra-hiding{opacity:0;transform:translate(0,18px);pointer-events:none;}
  body.infrastructure-editor #infrastructure-overlay{right:24px;left:auto;transform:translate(28px,12px);}
  body.infrastructure-editor #infrastructure-overlay.infra-visible{transform:translate(0,0);}
  body.infrastructure-editor #infrastructure-overlay.infra-hiding{transform:translate(18px,18px);}
  #infrastructure-overlay h3{cursor:grab;user-select:none;}
  #infrastructure-overlay.dragging h3{cursor:grabbing;}
  #infrastructure-overlay.dragging{box-shadow:0 22px 48px rgba(5,32,74,0.65);}
  .infrastructure-body{display:flex;flex-direction:row;gap:16px;align-items:flex-start;}
  .infra-building-list{display:flex;flex-direction:column;gap:12px;width:240px;max-height:520px;overflow-y:auto;padding-right:4px;}
  .infra-building{background:linear-gradient(160deg,rgba(10,26,48,0.82),rgba(12,32,58,0.9));border:1px solid var(--fa-border);border-radius:12px;padding:12px;display:flex;flex-direction:column;align-items:center;gap:8px;cursor:grab;transition:border-color 0.2s,transform 0.2s,box-shadow 0.2s;box-shadow:0 12px 26px rgba(0,0,0,0.28);}
  .infra-building:hover{border-color:var(--fa-strong-border);box-shadow:0 12px 26px rgba(16,38,84,0.45);}
  .infra-building:active{cursor:grabbing;}
  .infra-building.dragging{opacity:0.65;transform:scale(0.98);}
  .infra-building-canvas{width:96px;height:96px;border-radius:12px;background:radial-gradient(circle at 50% 35%,rgba(109,220,255,0.38),rgba(12,18,36,0.95));}
  .infra-building-name{font-weight:700;letter-spacing:0.04em;text-align:center;color:#e6f8ff;text-shadow:0 0 8px rgba(109,220,255,0.35);}
  .infra-building-meta{font-size:12px;color:var(--fa-muted);text-align:center;}
  .infra-editor{flex:1;display:flex;flex-direction:column;gap:12px;min-width:0;}
  .infra-grid{--infra-cols:6;display:grid;gap:10px;grid-template-columns:repeat(var(--infra-cols),minmax(72px,1fr));padding:12px;background:rgba(8,12,24,0.6);border:1px solid #1f2c49;border-radius:12px;min-height:280px;}
  .infra-cell{position:relative;min-height:96px;border:1px dashed rgba(99,124,180,0.5);border-radius:12px;display:flex;align-items:center;justify-content:center;background:rgba(3,6,16,0.7);transition:border-color 0.2s,background 0.2s,transform 0.2s,opacity 0.2s;}
  .infra-cell.empty:hover{border-color:#3b82f6;}
  .infra-cell.drag-over{border-color:#60a5fa;background:rgba(37,63,128,0.35);}
  .infra-cell.selected{box-shadow:0 0 0 2px #3b82f6 inset;}
  .infra-cell.has-building{border-style:solid;border-color:rgba(94,146,255,0.65);background:rgba(12,18,38,0.85);}
  .infra-cell.completed{border-color:rgba(16,185,129,0.85);background:rgba(12,29,24,0.92);}
  .infra-cell.core{border-style:solid;border-color:rgba(210,118,94,0.65);background:rgba(42,18,18,0.85);cursor:not-allowed;}
  .infra-cell.core .infra-cell-status{color:#fca5a5;}
  .infra-cell canvas{width:80px;height:80px;pointer-events:none;}
  .infra-progress-bar{position:absolute;top:8px;left:8px;right:8px;height:6px;border-radius:6px;background:rgba(47,68,128,0.45);overflow:hidden;}
  .infra-progress-fill{height:100%;width:0%;background:linear-gradient(90deg,#3b82f6,#60a5fa);transition:width 0.2s ease-out;}
  .infra-cell-status{position:absolute;bottom:8px;left:8px;right:8px;font-size:12px;color:#cfe3ff;text-align:center;text-shadow:0 0 4px rgba(0,0,0,0.8);}
  .infra-info{background:rgba(8,12,24,0.6);border:1px solid #1f2c49;border-radius:12px;padding:12px 14px;min-height:120px;display:flex;flex-direction:column;gap:6px;}
  .infra-info h4{margin:0;font-size:16px;color:#8fb5ff;letter-spacing:0.04em;}
  .infra-info p{margin:0;font-size:14px;color:#cbd5ff;line-height:1.5;}
  .infra-info .infra-info-progress{margin-top:4px;}
  .infra-info .infra-info-progress strong{display:block;font-size:12px;letter-spacing:0.08em;color:#94a9d6;text-transform:uppercase;margin-bottom:4px;}
  .infra-info .infra-info-progress .infra-progress-bar{position:relative;top:auto;left:auto;right:auto;margin-top:4px;}
  .infra-info .infra-info-progress .infra-progress-fill{transition:width 0.15s ease-out;}
  .hover-info{position:absolute;top:120px;right:40px;min-width:220px;max-width:320px;background:var(--fa-panel);border:1px solid var(--fa-border);border-radius:14px;padding:14px 18px;z-index:55;color:var(--fa-text);font-family:var(--fa-font);pointer-events:none;backdrop-filter:blur(12px);box-shadow:var(--fa-glow);}
  .hover-info.hidden{display:none !important;}
  .hover-info .hover-title{font-size:16px;font-weight:600;letter-spacing:0.04em;margin:0 0 4px 0;}
  .hover-info .hover-subtitle{display:block;font-size:11px;letter-spacing:0.18em;text-transform:uppercase;color:#8fb5ff;margin-bottom:12px;}
  .hover-info .hover-section{font-size:11px;letter-spacing:0.12em;text-transform:uppercase;color:#94a9d6;margin-bottom:6px;}
  .hover-info .hover-tags{display:flex;flex-wrap:wrap;gap:6px;}
  .hover-info .hover-tag{padding:4px 10px;border-radius:999px;background:rgba(63,88,144,0.38);color:#dfe7ff;font-size:12px;}
  .hover-info .hover-line{font-size:13px;margin-bottom:6px;display:flex;align-items:center;gap:6px;}
  .hover-info .hover-line strong{font-weight:600;color:#8fb5ff;letter-spacing:0.05em;}
  #zoom-indicator{position:absolute;right:24px;top:22px;padding:8px 12px;background:linear-gradient(150deg,rgba(66,142,210,0.32),rgba(55,116,186,0.42));border:1px solid var(--fa-border);border-radius:10px;color:var(--fa-text);font-family:var(--fa-font);font-size:14px;letter-spacing:0.12em;text-transform:uppercase;box-shadow:0 10px 22px rgba(0,0,0,0.35);opacity:0;transform:translateY(-6px);transition:opacity 0.22s ease,transform 0.22s ease;pointer-events:none;z-index:80;}
  #zoom-indicator.visible{opacity:1;transform:translateY(0);}
  .planet-radar{position:fixed;inset:0;pointer-events:none;z-index:78;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;}
  .planet-radar.hidden{display:none !important;}
  .planet-radar-item{position:absolute;display:flex;flex-direction:column;align-items:center;gap:6px;transform:translate(-50%,-50%);color:#e2e8f8;text-shadow:0 2px 10px rgba(0,0,0,0.55);}
  .planet-radar-icon{width:52px;height:52px;padding:8px;border-radius:14px;background:rgba(9,12,24,0.9);border:1px solid rgba(98,128,188,0.5);box-shadow:0 10px 26px rgba(0,0,0,0.55);backdrop-filter:blur(8px);display:flex;align-items:center;justify-content:center;transition:transform 0.2s ease,opacity 0.2s ease;}
  .planet-radar-icon img{width:100%;height:100%;object-fit:contain;filter:drop-shadow(0 0 6px rgba(112,200,255,0.55));}
  .planet-radar-label{padding:4px 10px;border-radius:999px;background:rgba(26,39,68,0.8);border:1px solid rgba(96,132,194,0.6);font-size:11px;letter-spacing:0.14em;text-transform:uppercase;white-space:nowrap;}
</style>
<style>
  /* Overlay 3D musi być nad głównym canvasem (#c) */
  canvas.overlay3d {
    position: absolute;
    inset: 0;
    pointer-events: none !important;
    z-index: 30 !important;
  }
</style>
</head>
<body>
  <div id="ui" class="hidden">
    <div><strong>Space Survivors — gwiazdy na całej mapie + duży silnik plazmowy</strong></div>
    <div class="stat">Czas gry: <span id="game-time">00:00</span></div>
    <div class="stat">W — ciąg (duży silnik plazmowy) · Q/E — strafe · A/D — obrót</div>
    <div class="stat">LPM — rail (A→B, A→B) · PPM — boczne rakiety · F — superbroń · SHIFT — warp / dopalacz na orbitach</div>
    <div style="margin-top:6px"><small>Gwiazdy są proceduralne w całej galaktyce. Silnik: niebieski exhaust + krótki ślad przy ruchu.</small></div>
  </div>
  <div id="side-panels">
    <div id="fleet-ui" class="hidden">
      <h3>Flota</h3>
      <ul id="fleet-list"></ul>
    </div>
    <div id="support-ui" class="hidden">
      <h3>Wsparcie</h3>
      <div class="support-row">
        <button class="support-btn" data-support-spawn="fighter">Fighter Squad</button>
        <button class="support-btn" data-support-spawn="frigate_pd">Frigate (PD)</button>
        <button class="support-btn" data-support-spawn="frigate_laser">Frigate (Laser)</button>
        <button class="support-btn" data-support-spawn="destroyer">Destroyer</button>
        <button class="support-btn" data-support-spawn="battleship">Battleship</button>
      </div>
      <div class="support-row">
        <button id="support-engage" class="support-order-btn">Engage</button>
        <button id="support-guard" class="support-order-btn active">Guard</button>
      </div>
    </div>
  </div>
  <div id="main-menu">
    <div class="menu-panel">
      <h1>Space Survivors</h1>
      <p class="menu-subtitle">Rozpocznij lot lub zajrzyj do nowych opcji.</p>
      <div class="menu-actions">
        <button id="btn-new-game" class="menu-primary">Nowa gra</button>
        <button id="btn-load-game" class="menu-secondary" disabled>Wczytaj grę</button>
        <button id="btn-options" class="menu-secondary" disabled>Opcje</button>
      </div>
      <p class="menu-hint">Wczytaj grę i opcje pojawią się w kolejnych aktualizacjach.</p>
    </div>
  </div>
<div id="game-root">
  <canvas id="c"></canvas>
</div>
<div id="loading" class="hidden">
  <div class="loading-box">
    <div class="loading-title">Ładowanie</div>
    <div class="loading-bar"><span id="loading-fill"></span></div>
    <div id="loading-progress" class="loading-progress">0%</div>
  </div>
</div>
<div id="station-overlay" class="station-overlay hidden">
  <div class="station-head">
    <div>
      <div id="station-title" class="station-title">Stacja orbitalna</div>
      <div id="station-subtitle" class="station-subtitle">Przestrzeń cywilna</div>
    </div>
    <div class="station-balance">
      <div class="label">Kredyty</div>
      <div id="station-credits" class="value">0 cr</div>
    </div>
  </div>
  <ul id="station-tabs"></ul>
  <div class="station-panels">
    <div id="tab-upgrades" class="station-tab"></div>
    <div id="tab-trade" class="station-tab hidden"></div>
    <div id="tab-cantina" class="station-tab hidden"></div>
    <div id="tab-hangar" class="station-tab hidden"></div>
    <div id="tab-mechanic-html" class="station-tab hidden"></div>
    <div id="tab-infrastructure-html" class="station-tab hidden"></div>
  </div>
</div>
<div id="infrastructure-overlay" class="station-overlay hidden">
  <h3>Station Infrastructure</h3>
  <ul>
    <li data-tab="infrastructure">Infrastructure</li>
  </ul>
  <div class="infrastructure-body">
    <div class="infra-building-list" id="infra-building-list"></div>
    <div class="infra-editor">
      <div class="infra-grid" id="infra-grid"></div>
      <div class="infra-info" id="infra-info">
        <h4>Budowa stacji</h4>
        <p>Przeciągnij budynki z listy po lewej na siatkę, aby rozpocząć ich konstrukcję.</p>
      </div>
    </div>
  </div>
</div>
<div id="zoom-indicator">ZOOM X1.00</div>
<div id="planet-radar" class="planet-radar"></div>
<div id="hover-info" class="hover-info hidden">
  <div class="hover-title"></div>
  <span class="hover-subtitle"></span>
  <div class="hover-content"></div>
</div>
<script type="importmap">
{
  "imports": {
    "three": "./node_modules/three/build/three.module.js",
    "three/addons/": "./node_modules/three/examples/jsm/"
  }
}
</script>
<script type="module" src="./src/config/constants.js"></script>
<script src="https://unpkg.com/regl/dist/regl.min.js"></script>
<script type="module">
  import * as THREE from "three";
  import { EffectComposer }  from "three/addons/postprocessing/EffectComposer.js";
  import { RenderPass }      from "three/addons/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
  import { ShaderPass }      from "three/addons/postprocessing/ShaderPass.js";
  import { OutputPass }      from "three/addons/postprocessing/OutputPass.js";
  import { CopyShader }      from "three/addons/shaders/CopyShader.js";
  import { createShortNeedleExhaust, createWarpExhaustBlue } from "./Engineeffects.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { initWorld3D, attachPirateStation3D, dettachPirateStation3D, updateWorld3D, drawWorld3D } from "./src/3d/world3d.js";
  import { initStations3D, updateStations3D, detachPlanetStations3D, drawStations3D } from "./src/3d/stations3D.js";
  import { initOverlay } from "./src/effects3d/overlay.js";
  import { createRailgunExplosionFactory } from "./src/effects3d/railgunExplosion.js";
  import { createArmataImpactFactory } from "./src/effects3d/armataImpact.js";
  import { createAutocannonImpactFactory } from "./src/effects3d/autocannonImpact.js";
  import * as Space2DBackground from "./src/lib/space2d/tyroBackground.js";
  import { WarpBlackHole } from "./src/vfx/warpBlackHole.js";
  import { createShipEntity, applyPlayerInput, runShipAI } from "./src/game/shipEntity.js";
  window.THREE = THREE;
  window.EffectComposer  = EffectComposer;
  window.RenderPass      = RenderPass;
  window.UnrealBloomPass = UnrealBloomPass;
  window.ShaderPass      = ShaderPass;
  window.OutputPass      = OutputPass;
  window.createShortNeedleExhaust = createShortNeedleExhaust;
  window.createWarpExhaustBlue = createWarpExhaustBlue;
  window.GLTFLoader = GLTFLoader;
  window.initWorld3D = initWorld3D;
  window.attachPirateStation3D = attachPirateStation3D;
  window.dettachPirateStation3D = dettachPirateStation3D;
  window.updateWorld3D = updateWorld3D;
  window.drawWorld3D = drawWorld3D;
  window.initStations3D = initStations3D;
  window.updateStations3D = updateStations3D;
  window.drawStations3D = drawStations3D;
  window.detachPlanetStations3D = detachPlanetStations3D;
  window.initOverlay3D = initOverlay;
  window.createRailgunExplosionFactory = createRailgunExplosionFactory;
  window.createArmataImpactFactory = createArmataImpactFactory;
  window.createAutocannonImpactFactory = createAutocannonImpactFactory;
  window.createShipEntity = createShipEntity;
  window.applyPlayerInput = applyPlayerInput;
  window.runShipAI = runShipAI;
  // Nie modyfikujemy namespace'u modułu THREE (jest niemodyfikowalny).
  // Jeśli coś potrzebuje CopyShader globalnie, wystawiamy go przez window:
  window.CopyShader = CopyShader;
  window.Space2DBackground = Space2DBackground;

  const warpFX = new WarpBlackHole({ zIndex: 45, mode: 'offscreen' });
  warpFX.setEnabled(false);
  window.warpBlackHoleFX = warpFX;

</script>
<!-- przełącznik: aktywuj assetowy renderer planet (klasyczny skrypt, aby globalne API było gotowe zanim ruszy pętla gry) -->
<script type="module" src="planet3d.assets.js"></script>

<script type="module">
import { DEFAULT_PLANET_SCALE, TIME_SCALE } from './src/config/constants.js';
import { WORLD, setWorldSize } from './src/world/world.js';
window.bullets = []; 
// Aby stary kod działał, zrobimy alias:
const bullets = window.bullets;
window.DEFAULT_PLANET_SCALE ??= DEFAULT_PLANET_SCALE;
window.TIME_SCALE ??= TIME_SCALE;
window.WORLD ??= WORLD;

// LOKALNY alias na potrzeby tego modułu (ESM nie widzi 'gołych' globali z window):
const PLANET_SCALE =
  (typeof window !== 'undefined' && typeof window.DEFAULT_PLANET_SCALE !== 'undefined')
    ? window.DEFAULT_PLANET_SCALE : (DEFAULT_PLANET_SCALE ?? 3);

// =============== Canvas & utils ===============
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth, H = canvas.height = innerHeight;

const fleetUIRoot = document.getElementById('fleet-ui');
const fleetListEl = document.getElementById('fleet-list');
const supportUIRoot = document.getElementById('support-ui');
const supportGuardBtn = document.getElementById('support-guard');
const supportEngageBtn = document.getElementById('support-engage');
const supportSpawnButtons = document.querySelectorAll('[data-support-spawn]');
const Fleet = window.Fleet || (window.Fleet = {
  ships: [],
  dirty: true,
  ui: {
    root: fleetUIRoot || null,
    list: fleetListEl || null,
    lastUpdate: 0
  }
});
if (!Fleet.ui.root && fleetUIRoot) Fleet.ui.root = fleetUIRoot;
if (!Fleet.ui.list && fleetListEl) Fleet.ui.list = fleetListEl;
function markFleetDirty(){ Fleet.dirty = true; }

const SupportWing = window.SupportWing || (window.SupportWing = {
  units: [],
  order: 'guard',
  ui: {
    root: supportUIRoot || null,
    guardBtn: supportGuardBtn || null,
    engageBtn: supportEngageBtn || null
  }
});
if (!SupportWing.ui.root && supportUIRoot) SupportWing.ui.root = supportUIRoot;
if (!SupportWing.ui.guardBtn && supportGuardBtn) SupportWing.ui.guardBtn = supportGuardBtn;
if (!SupportWing.ui.engageBtn && supportEngageBtn) SupportWing.ui.engageBtn = supportEngageBtn;

const uiRoot = document.getElementById('ui');
const mainMenuEl = document.getElementById('main-menu');
const newGameButton = document.getElementById('btn-new-game');
const loadGameButton = document.getElementById('btn-load-game');
const optionsButton = document.getElementById('btn-options');
const loadingEl = document.getElementById('loading');
const loadingFillEl = document.getElementById('loading-fill');
const loadingProgressEl = document.getElementById('loading-progress');
const planetRadarRoot = document.getElementById('planet-radar');
let gameStarted = false;

function setLoadingProgress(value, label){
  const clamped = Math.max(0, Math.min(100, Math.round(value)));
  if (loadingFillEl) loadingFillEl.style.width = `${clamped}%`;
  if (loadingProgressEl) loadingProgressEl.textContent = label ? `${clamped}% · ${label}` : `${clamped}%`;
}

function showLoadingOverlay(progress = 0, label = ''){
  if (loadingEl) loadingEl.classList.remove('hidden');
  setLoadingProgress(progress, label);
}

function hideLoadingOverlay(){
  if (loadingEl) loadingEl.classList.add('hidden');
}

function nextFrame(){
  return new Promise(resolve => requestAnimationFrame(() => resolve()));
}

function waitForCondition(predicate, timeoutMs = 4000){
  return new Promise(resolve => {
    const start = performance.now();
    (function poll(){
      if (predicate()) return resolve();
      if (performance.now() - start >= timeoutMs) return resolve();
      requestAnimationFrame(poll);
    })();
  });
}

// Model widoku overlayu (ortho nad światem 2D)
const overlayView = {
  center: { x: 0, y: 0 },
  viewport: { w: innerWidth, h: innerHeight },
  zoom: 1.0
};

let spaceBg = null;
let spaceBgReady = false;
const warpBlackHoleFX = window.warpBlackHoleFX || null;
let warpLensMode = 'background';
let warpLensSource = null;

const WARP_LENS_DEFAULTS = Object.freeze({
  threshold: 0,
  radiusBase: 0.420,
  radiusScale: 0.15,
  massBase: 0.32,
  massScale: 0.365,
  softness: 0.6,
  opacityBase: 0.55,
  opacityScale: 0.73,
  tailDepthExtra: -0.2,
  forwardStretch: 1.0
});

const DevVFX = window.DevVFX = window.DevVFX || {};
DevVFX.warpLens = Object.assign({}, WARP_LENS_DEFAULTS, DevVFX.warpLens || {});
window.__WARP_LENS_DEFAULTS = WARP_LENS_DEFAULTS;

function warpLensParam(key){
  const defaults = WARP_LENS_DEFAULTS;
  const bag = DevVFX?.warpLens || defaults;
  const raw = bag[key];
  return Number.isFinite(raw) ? raw : defaults[key];
}

function getAuToWorldUnits(){
  return (typeof BASE_ORBIT === 'number' && BASE_ORBIT > 0) ? BASE_ORBIT : 3000;
}

function getWarpLensThreshold(){
  const v = warpLensParam('threshold');
  if (!Number.isFinite(v)) return WARP_LENS_DEFAULTS.threshold;
  return Math.min(1, Math.max(0, v));
}

function configureWarpLensSource(){
  if (!warpBlackHoleFX) return;
  if (typeof warpBlackHoleFX.setSourceParallaxTransform === 'function') {
    warpBlackHoleFX.setSourceParallaxTransform(null);
  }
  if (warpLensMode === 'background') {
    if (spaceBg && typeof spaceBg.getBackgroundCanvas === 'function') {
      const descriptor = typeof spaceBg.getBackgroundSampleDescriptor === 'function'
        ? spaceBg.getBackgroundSampleDescriptor()
        : null;
      const src = descriptor?.canvas ?? spaceBg.getBackgroundCanvas();
      if (src && warpLensSource !== src) {
        warpLensSource = src;
        warpBlackHoleFX.setSourceCanvas(src);
      }
      if (descriptor && typeof warpBlackHoleFX.setSourceParallaxTransform === 'function') {
        warpBlackHoleFX.setSourceParallaxTransform(descriptor);
      }
    }
  } else if (warpLensMode === 'full') {
    if (warpLensSource !== ctx.canvas) {
      warpLensSource = ctx.canvas;
      warpBlackHoleFX.setSourceCanvas(ctx.canvas);
    }
  }
}

if (warpBlackHoleFX) {
  window.setWarpLensMode = function(mode){
    const next = mode === 'full' ? 'full' : 'background';
    if (warpLensMode !== next) {
      warpLensMode = next;
      warpLensSource = null;
      configureWarpLensSource();
    }
  };
  window.addEventListener('resize', configureWarpLensSource);
}

if (typeof configureWarpLensSource === 'function') {
  configureWarpLensSource();
}

function tryInitSpaceBackground(){
  if (spaceBgReady) return true;
  const module = window.Space2DBackground;
  if (!module) return false;
  spaceBg = module;
  try {
    module.setBgOptions?.({
      renderSun: false,
      renderNebulae: true,
      renderStars: true,
      renderPointStars: false,
      shortScale: true
    });
    module.initSpaceBg?.(window.SUN?.seed ?? 12345);
    module.resizeSpaceBg?.(innerWidth, innerHeight);
    spaceBgReady = true;
    configureWarpLensSource();
    window.removeEventListener('DOMContentLoaded', tryInitSpaceBackground);
    window.removeEventListener('load', tryInitSpaceBackground);
    return true;
  } catch (err) {
    return false;
  }
}

if (!tryInitSpaceBackground()) {
  window.addEventListener('DOMContentLoaded', tryInitSpaceBackground);
  window.addEventListener('load', tryInitSpaceBackground);
  let spaceBgPollAttempts = 0;
  const MAX_SPACE_BG_POLL_ATTEMPTS = 240;
  (function pollSpaceBackground(){
    if (tryInitSpaceBackground() || spaceBgPollAttempts++ >= MAX_SPACE_BG_POLL_ATTEMPTS) return;
    requestAnimationFrame(pollSpaceBackground);
  })();
}

function waitForSpaceBackgroundReady(){
  if (spaceBgReady) return Promise.resolve();
  return waitForCondition(() => spaceBgReady, 2500);
}

let mainScene3D = null;
let planetScene3D = null;
let planetStationsReady = false;

const { createShipEntity, applyPlayerInput, runShipAI } = window;

function asThreeScene(candidate){
  if (!candidate) return null;
  if (candidate.isScene) return candidate;
  if (candidate.scene && candidate.scene.isScene) return candidate.scene;
  if (candidate.scene3D && candidate.scene3D.isScene) return candidate.scene3D;
  if (candidate.planetScene && candidate.planetScene.isScene) return candidate.planetScene;
  if (candidate.sceneObject && candidate.sceneObject.isScene) return candidate.sceneObject;
  return null;
}

function findPlanetScene3D(){
  const directCandidates = [
    mainScene3D,
    planetScene3D,
    window.planetsScene3D,
    window.planetsScene,
    window.planetScene3D,
    window.PlanetScene3D,
    window.PlanetsScene3D,
    window.planets3DScene,
    window.planets3D
  ];
  for (const candidate of directCandidates){
    const scene = asThreeScene(candidate);
    if (scene) return scene;
  }
  const lazyCandidates = [
    typeof window.getPlanetsScene3D === 'function' ? window.getPlanetsScene3D() : null,
    typeof window.getPlanetScene3D === 'function' ? window.getPlanetScene3D() : null
  ];
  for (const candidate of lazyCandidates){
    const scene = asThreeScene(candidate);
    if (scene) return scene;
  }
  return null;
}

function ensurePlanetStationsInit(stationsList){
  if (typeof window.initStations3D !== 'function') return false;
  if (!Array.isArray(stationsList)) return false;
  if (!planetStationsReady) {
    window.initStations3D(null, stationsList);
    planetStationsReady = true;
  }
  return planetStationsReady;
}

function detachPlanetStationsIfNeeded(){
  if (typeof window.detachPlanetStations3D === 'function'){
    window.detachPlanetStations3D(planetScene3D);
  }
  planetScene3D = null;
  planetStationsReady = false;
}

window.addEventListener('beforeunload', detachPlanetStationsIfNeeded);

// Dev flags/tuning (persisted via  where available)
window.DevFlags = Object.assign({
  showRuler: false,
  unlimitedWarp: false,
  showSunDir: false,
  use3DPirateStation: true,
  usePlanetStations3D: true,
  disableCameraShake: false
}, window.DevFlags || {});
const DEFAULT_PIRATE_STATION_SCALE = 6;
const DEFAULT_STATION_3D_SCALE = 2.70;
window.DEFAULT_STATION_SCALE = DEFAULT_PIRATE_STATION_SCALE;
window.DEFAULT_STATION_3D_SCALE = DEFAULT_STATION_3D_SCALE;

window.DevTuning = Object.assign({
  pirateStationScale: DEFAULT_PIRATE_STATION_SCALE
}, window.DevTuning || {});

const DevFlags = window.DevFlags;
const DevTuning = window.DevTuning;
const Dev = window.Dev = window.Dev || {};
if (!Number.isFinite(Dev.station3DScale) || Dev.station3DScale <= 0) {
  Dev.station3DScale = DEFAULT_STATION_3D_SCALE;
}
if (!Number.isFinite(DevTuning.pirateStationScale)) {
  DevTuning.pirateStationScale = DEFAULT_PIRATE_STATION_SCALE;
}

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a + (b - a) * t;
const add = (a,b)=>({x:a.x+b.x,y:a.y+b.y});
const mul = (v,s)=>({x:v.x*s,y:v.y*s});
const len = v=>Math.hypot(v.x,v.y);
const norm = v=>{ const L=len(v); return L?{x:v.x/L,y:v.y/L}:{x:0,y:0}; };
// === AI SPACE PHYSICS UTILS ===
function clampTurnVec(vx, vy, wantVx, wantVy, dt, maxDeg){
  const maxRad = (maxDeg * Math.PI / 180) * dt;
  const a = Math.atan2(vy, vx);
  const b = Math.atan2(wantVy, wantVx);
  let d = b - a;
  while(d >  Math.PI) d -= 2*Math.PI;
  while(d < -Math.PI) d += 2*Math.PI;
  const lim = Math.max(-maxRad, Math.min(maxRad, d));
  const speed = Math.hypot(wantVx, wantVy);
  const ang = a + lim;
  return { vx: Math.cos(ang) * speed, vy: Math.sin(ang) * speed };
}

function getLeadAim(shooter, target, projSpeed){
  const targetX = target.pos ? target.pos.x : target.x;
  const targetY = target.pos ? target.pos.y : target.y;
  const vx = target.vx ?? target.vel?.x ?? 0;
  const vy = target.vy ?? target.vel?.y ?? 0;
  const px = targetX - shooter.x, py = targetY - shooter.y;
  const A = (vx*vx + vy*vy) - projSpeed*projSpeed;
  const B = 2 * (px*vx + py*vy);
  const C = (px*px + py*py);
  let t = 0;
  if(Math.abs(A) < 1e-3){
    t = -C / Math.max(B, -1e-3);
  } else {
    const disc = B*B - 4*A*C;
    t = (disc > 0) ? (-B - Math.sqrt(disc)) / (2*A) : 0;
  }
  t = Math.max(0, Math.min(2.0, t));
  return { x: targetX + vx*t, y: targetY + vy*t };
}
const smoothstep01 = t=>{ const x = clamp(t, 0, 1); return x*x*(3 - 2*x); };
function rotate(local,a){ const c=Math.cos(a), s=Math.sin(a); return {x: local.x*c - local.y*s, y: local.x*s + local.y*c}; }
function rotateInv(world,a){ return rotate(world, -a); }
function muzzlePosFor(entity, dir, extra = 8){
  const rad = (entity.radius != null) ? entity.radius : (entity.r != null ? entity.r : 12);
  return { x: entity.x + dir.x * (rad + extra), y: entity.y + dir.y * (rad + extra) };
}

const fleetNumberFormatter = new Intl.NumberFormat('pl-PL', { maximumFractionDigits: 0 });
const FLEET_UI_REFRESH_MS = 1000;
window.aiSpawnBullet = function(sim, from, to, weapon) {
  const ang = Math.atan2(to.y - from.y, to.x - from.x);
  const spread = (weapon.spread || 0) * (Math.PI / 180);
  const a = ang + (Math.random() * 2 - 1) * spread;
  const speed = weapon.speed || 500;

  // Mapowanie wyglądu pocisku
  let bType = 'plasma';
  if(weapon.name && weapon.name.includes('Rail')) bType = 'rail';
  if(weapon.name && weapon.name.includes('Flak')) bType = 'armata';

  window.bullets.push({
    x: from.x,
    y: from.y,
    vx: Math.cos(a) * speed + (from.vx || 0) * 0.2,
    vy: Math.sin(a) * speed + (from.vy || 0) * 0.2,
    life: (weapon.range || 1000) / speed,
    r: (bType === 'rail') ? 4 : 3,
    owner: from.friendly ? 'player' : 'npc',
    damage: weapon.dmg || 10,
    type: bType,
    color: weapon.color || '#ffd36e',
    source: from,
    explodeRadius: (bType === 'armata') ? (weapon.radius || 40) : 0
  });
};
function formatFleetNumber(value){
  if (!Number.isFinite(value)) return '0';
  return fleetNumberFormatter.format(Math.max(0, Math.round(value)));
}

function percent(value, max){
  if (!Number.isFinite(value) || !Number.isFinite(max) || max <= 0) return 0;
  return clamp(value / max, 0, 1);
}

function appendFleetBar(container, label, value, max, type){
  const labelRow = document.createElement('div');
  labelRow.className = 'fleet-bar-label';
  const labelSpan = document.createElement('span');
  labelSpan.textContent = label;
  const valueSpan = document.createElement('span');
  valueSpan.textContent = `${formatFleetNumber(value)}/${formatFleetNumber(max)}`;
  labelRow.append(labelSpan, valueSpan);
  container.appendChild(labelRow);

  const bar = document.createElement('div');
  bar.className = 'fleet-bar';
  const fill = document.createElement('div');
  fill.className = `fleet-bar-fill ${type}`;
  fill.style.width = `${Math.round(percent(value, max) * 100)}%`;
  bar.appendChild(fill);
  container.appendChild(bar);
}

function renderFleetShip(entry){
  const li = document.createElement('li');
  li.className = 'fleet-ship';

  const header = document.createElement('div');
  header.className = 'fleet-ship-header';
  const nameEl = document.createElement('div');
  nameEl.className = 'fleet-ship-name';
  nameEl.textContent = entry.displayName || entry.name || entry.type || 'Jednostka';
  const metaEl = document.createElement('div');
  metaEl.className = 'fleet-ship-meta';
  metaEl.textContent = entry.roleText || entry.role || 'Flota';
  header.append(nameEl, metaEl);
  li.appendChild(header);

  const bars = document.createElement('div');
  bars.className = 'fleet-bars';
  appendFleetBar(bars, 'Kadłub', entry.status?.hull ?? 0, entry.status?.hullMax ?? 1, 'hull');
  appendFleetBar(bars, 'Tarcza', entry.status?.shield ?? 0, entry.status?.shieldMax ?? 1, 'shield');
  li.appendChild(bars);

  const fighters = document.createElement('div');
  fighters.className = 'fleet-fighters';
  const ready = Math.max(0, entry.fighters?.ready ?? 0);
  const deployed = Math.max(0, entry.fighters?.deployed ?? 0);
  const capacity = entry.fighters?.capacity ?? (ready + deployed);
  const mode = (entry.fighterWing?.order || entry.fighterMode || 'idle');
  const modeLabel = mode === 'engage' ? 'ATAK' : mode === 'guard' ? 'OSŁONA' : mode === 'return' ? 'POWRÓT' : mode.toUpperCase();
  const deployedLabel = deployed > 0 ? ` · W polu: ${formatFleetNumber(deployed)}` : '';
  fighters.textContent = `Myśliwce: ${formatFleetNumber(ready)}/${formatFleetNumber(capacity)} hangar${deployedLabel} · Tryb: ${modeLabel}`;
  li.appendChild(fighters);

  if (entry.fighterWing) {
    const controls = document.createElement('div');
    controls.className = 'fleet-controls';
    const orders = [
      { id: 'engage', label: 'Engage' },
      { id: 'guard',  label: 'Guard' },
      { id: 'return', label: 'Return' }
    ];
    for (const { id, label } of orders) {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'fleet-order-btn' + (mode === id ? ' active' : '');
      btn.textContent = label;
      btn.addEventListener('click', () => commandCarrierFighters(entry, id));
      controls.appendChild(btn);
    }
    li.appendChild(controls);
  }

  const hardpoints = document.createElement('div');
  hardpoints.className = 'fleet-hardpoints';
  const hpLarge = document.createElement('span');
  hpLarge.textContent = `Duże ×${formatFleetNumber(entry.hardpoints?.large ?? 0)}`;
  const hpMedium = document.createElement('span');
  hpMedium.textContent = `Średnie ×${formatFleetNumber(entry.hardpoints?.medium ?? 0)}`;
  hardpoints.append(hpLarge, hpMedium);
  li.appendChild(hardpoints);

  return li;
}

function commandCarrierFighters(entry, order, opts = {}){
  if (!entry) return;
  ensureCarrierWing(entry);
  const wing = entry.fighterWing;
  if (!wing) return;

  const normalized = (order === 'engage' || order === 'guard' || order === 'return') ? order : 'guard';
  if (normalized === wing.order && !opts.force && !opts.auto) {
    return;
  }

  if (opts.auto && normalized === 'return') {
    if (!wing.autoReturnActive) {
      wing.autoReturnActive = true;
      wing.autoResumeOrder = wing.lastManualOrder || wing.order || 'guard';
    }
  } else {
    wing.autoReturnActive = false;
    wing.autoResumeOrder = null;
    wing.lastManualOrder = normalized;
  }

  wing.order = normalized;
  entry.fighterMode = normalized;

  if (normalized === 'return') {
    wing.launchPending = 0;
    for (const fighter of wing.list){
      if (fighter) fighter.orderOverride = 'return';
    }
  } else {
    const ready = Math.max(0, entry.fighters?.ready ?? 0);
    const batchSize = wing.launchBatch || ready;
    const pending = Math.min(ready, batchSize);
    wing.launchPending = pending;
    wing.launchCooldown = 0;
    for (const fighter of wing.list){
      if (fighter) fighter.orderOverride = null;
    }
  }

  if (!opts.silent) markFleetDirty();
}

function updateFleetUI(){
  const ui = Fleet.ui;
  if (!ui || !ui.root || !ui.list) return;
  const now = performance.now();
  if (!Fleet.dirty && now - (ui.lastUpdate || 0) < FLEET_UI_REFRESH_MS) return;
  ui.lastUpdate = now;

  if (!Fleet.ships.length){
    ui.root.classList.add('hidden');
    ui.list.innerHTML = '';
    Fleet.dirty = false;
    return;
  }

  ui.root.classList.remove('hidden');
  ui.list.innerHTML = '';
  for (const ship of Fleet.ships){
    ui.list.appendChild(renderFleetShip(ship));
  }
  Fleet.dirty = false;
}

const SUPPORT_FORMATION = { perRow: 4, colGap: 90, rowGap: 70, lead: 160 };
function supportGuardSlot(slotIndex){
  const row = Math.floor(slotIndex / SUPPORT_FORMATION.perRow);
  const col = slotIndex % SUPPORT_FORMATION.perRow;
  const local = {
    x: SUPPORT_FORMATION.lead + col * SUPPORT_FORMATION.colGap,
    y: (row - 1) * SUPPORT_FORMATION.rowGap
  };
  const rotated = rotate(local, ship.angle);
  return { x: ship.pos.x + rotated.x, y: ship.pos.y + rotated.y };
}

function setSupportOrder(order, opts = {}){
  const normalized = order === 'engage' ? 'engage' : 'guard';
  if (SupportWing.order === normalized && !opts.force) return;
  SupportWing.order = normalized;

  if (SupportWing.ui.guardBtn){
    SupportWing.ui.guardBtn.classList.toggle('active', normalized === 'guard');
  }
  if (SupportWing.ui.engageBtn){
    SupportWing.ui.engageBtn.classList.toggle('active', normalized === 'engage');
  }
}

function cleanupSupportWing(){
  SupportWing.units = SupportWing.units.filter(data => data?.npc && !data.npc.dead);
  SupportWing.units.forEach((data, idx) => { data.slotIndex = idx; });
}

function updateSupportWing(dt){
  cleanupSupportWing();
  if (SupportWing.ui.root) {
    SupportWing.ui.root.classList.remove('hidden');
  }
  if (SupportWing.order === 'engage') {
    const piratesAlive = npcs.some(n => n && !n.dead && n.isPirate);
    if (!piratesAlive) {
      setSupportOrder('guard', { force: true });
    }
  }
}

function supportGuardBehavior(npc, slotIndex, dt){
  const slot = supportGuardSlot(slotIndex);
  const dx = slot.x - npc.x;
  const dy = slot.y - npc.y;
  const dist = Math.hypot(dx, dy) || 1;
  const dir = { x: dx / dist, y: dy / dist };
  const wantSpeed = Math.min(npc.maxSpeed || 240, dist * 1.4);
  const turned = clampTurnVec(npc.vx || 0, npc.vy || 0, dir.x * wantSpeed, dir.y * wantSpeed, dt, 220);
  npc.vx = turned.vx;
  npc.vy = turned.vy;
  npc.angle = Math.atan2(npc.vy || 0, npc.vx || 0);
  if (dist < 12) {
    npc.vx *= 0.92;
    npc.vy *= 0.92;
  }
  npc.forceTarget = null;
  npc.target = null;
}

function runSupportAI(npc, dt){
  const data = npc.supportData;
  if (!data) return;
  if (SupportWing.order === 'guard') {
    supportGuardBehavior(npc, data.slotIndex, dt);
    return;
  }

  const target = aiPickTarget(npc);
  if (!target) {
    setSupportOrder('guard', { force: true });
    supportGuardBehavior(npc, data.slotIndex, dt);
    return;
  }

  npc.forceTarget = target;

  if (data.type === 'fighter') {
    npc.state = npc.state || 'guard';
    runAdvancedFighterAI(npc, dt);
  } else if (data.type === 'frigate_pd' || data.type === 'frigate_laser') {
    aiFrigate(null, npc, dt);
  } else if (data.type === 'destroyer') {
    aiDestroyer(null, npc, dt);
  } else if (data.type === 'battleship') {
    aiBattleship(null, npc, dt);
  }
}

function isPirateStation(st){
  if (!st) return false;
  const name = typeof st.name === 'string' ? st.name.toLowerCase() : '';
  return st.isPirate || st.type === 'pirate' || st.style === 'pirate' || name.includes('pir');
}

function stationScaleFor(st){
  const baseDefault = DEFAULT_STATION_3D_SCALE;
  const rawGlobal = Number.isFinite(Dev.station3DScale) ? Dev.station3DScale : NaN;
  const globalScale = (Number.isFinite(rawGlobal) && rawGlobal > 0) ? rawGlobal : baseDefault;
  const rawPirate = Number.isFinite(DevTuning.pirateStationScale) ? DevTuning.pirateStationScale : NaN;
  const pirateScale = (Number.isFinite(rawPirate) && rawPirate > 0) ? rawPirate : globalScale;
  return isPirateStation(st) ? pirateScale : globalScale;
}

// === HARDPOINTS: enums ===
const HP = {
  MAIN: 'main',
  MISSILE: 'missile',
  AUX: 'aux',
  HANGAR: 'hangar',
  SPECIAL: 'special'
};

// === definicje broni ===
const WEAPONS = {
  railgun_mk1:  { id:'railgun_mk1',  type:HP.MAIN,    name:'Railgun Mk I',  dps:40, energy:6,  ammo:null },
  railgun_mk2:  { id:'railgun_mk2',  type:HP.MAIN,    name:'Railgun Mk II', dps:60, energy:8,  ammo:null },
  armata_mk1:   { id:'armata_mk1',   type:HP.MAIN,    name:'Armata Siege Cannon', damage:220, cooldown:1.8, energy:14, ammo:null },
  heavy_autocannon: { id:'heavy_autocannon', type:HP.MAIN, name:'Heavy Autocannon', damage:28, cooldown:0.16, energy:9, ammo:null },
  missile_rack: { id:'missile_rack', type:HP.MISSILE, name:'Missile Rack',  dps:0,  energy:2,  ammo:20 },
  ciws_mk1:     { id:'ciws_mk1',     type:HP.AUX,     name:'CIWS Mk I',     dps:12, energy:2,  ammo:null },
  laser_pd_mk1: { id:'laser_pd_mk1', type:HP.AUX,     name:'Helios PD Laser', dps:18, energy:3,  ammo:null },
  fighter_bay:  { id:'fighter_bay',  type:HP.HANGAR,  name:'Fighter Bay',   dps:0,  energy:5,  ammo:null },
  super_f:      { id:'super_f',      type:HP.SPECIAL, name:'Super Weapon',  dps:300,energy:20, ammo:null },
};

const WEAPON_ICON_PATHS = {
  heavy_autocannon: 'assets/weapons/heavy_autocannon.svg',
};

// === definicje statków / ram ===
const SHIPS = {
  atlas: {
    id:'atlas', name:'Atlas-class',
    spec: { [HP.MAIN]:4, [HP.MISSILE]:8, [HP.AUX]:8, [HP.HANGAR]:4, [HP.SPECIAL]:1 },
    genHardpoints(bounds){
      const hp = [];
      const w = bounds.w, h = bounds.h;
      placeLine(hp, HP.MAIN,    4, {x:-w*0.25,y:-h*0.48}, {x:w*0.25,y:-h*0.48});
      placeLine(hp, HP.MISSILE, 4, {x:-w*0.48,y:-h*0.15}, {x:-w*0.48,y:h*0.15});
      placeLine(hp, HP.MISSILE, 4, {x:w*0.48, y:-h*0.15}, {x:w*0.48, y:h*0.15});
      placeLine(hp, HP.AUX,     4, {x:-w*0.35,y:-h*0.35}, {x:-w*0.35,y:h*0.35});
      placeLine(hp, HP.AUX,     4, {x:w*0.35, y:-h*0.35}, {x:w*0.35, y:h*0.35});
      placeLine(hp, HP.HANGAR,  2, {x:-w*0.20,y:h*0.48},  {x:w*0.20, y:h*0.48});
      placeLine(hp, HP.HANGAR,  2, {x:-w*0.20,y:h*0.40},  {x:w*0.20, y:h*0.40});
      hp.push({id:uid(), type:HP.SPECIAL, pos:{x:0,y:0,rot:0}, mount:null, ammo:null, maxAmmo:null});
      return hp;
    }
  },
  corvus: {
    id:'corvus', name:'Corvus-class',
    spec: { [HP.MAIN]:2, [HP.MISSILE]:12, [HP.AUX]:4, [HP.HANGAR]:2, [HP.SPECIAL]:1 },
    genHardpoints(bounds){
      const hp=[]; const w=bounds.w, h=bounds.h;
      placeLine(hp, HP.MAIN, 2, {x:-w*0.2,y:-h*0.5}, {x:w*0.2,y:-h*0.5});
      placeLine(hp, HP.MISSILE,6,{x:-w*0.5,y:-h*0.25},{x:-w*0.5,y:h*0.25});
      placeLine(hp, HP.MISSILE,6,{x:w*0.5,y:-h*0.25},{x:w*0.5,y:h*0.25});
      placeLine(hp, HP.AUX,4,{x:0,y:-h*0.2},{x:0,y:h*0.2});
      placeLine(hp, HP.HANGAR,2,{x:-w*0.15,y:h*0.5},{x:w*0.15,y:h*0.5});
      hp.push({id:uid(), type:HP.SPECIAL, pos:{x:0,y:0,rot:0}, mount:null, ammo:null, maxAmmo:null});
      return hp;
    }
  }
};

function placeLine(out, type, count, a, b){
  for (let i=0;i<count;i++){
    const t = count===1 ? 0.5 : (i/(count-1));
    out.push({ id:uid(), type, pos:{ x:a.x+(b.x-a.x)*t, y:a.y+(b.y-a.y)*t, rot:0 }, mount:null, ammo:null, maxAmmo:null });
  }
}
function uid(){ return 'hp_'+Math.random().toString(36).slice(2,9); }

const Game = window.Game || (window.Game={});
Game.infrastructure = Game.infrastructure || new Map();
const previousPlayer = Game.player || {};
const defaultInventory = ['railgun_mk1','railgun_mk2','armata_mk1','heavy_autocannon','missile_rack','ciws_mk1','laser_pd_mk1','fighter_bay','super_f'];
const existingInventory = previousPlayer.inventory ? Array.from(previousPlayer.inventory) : [];
const mergedInventory = new Set([...existingInventory, ...defaultInventory]);
const hasSavedShipPosition = !!previousPlayer.pos;

// =============== Ship ===============
const shipOverrides = {};
if (previousPlayer.pos) shipOverrides.pos = previousPlayer.pos;
if (previousPlayer.vel) shipOverrides.vel = previousPlayer.vel;
if (typeof previousPlayer.angle === 'number') shipOverrides.angle = previousPlayer.angle;
if (typeof previousPlayer.angVel === 'number') shipOverrides.angVel = previousPlayer.angVel;
if (typeof previousPlayer.mass === 'number') shipOverrides.mass = previousPlayer.mass;
if (typeof previousPlayer.linearDamping === 'number') shipOverrides.linearDamping = previousPlayer.linearDamping;
if (typeof previousPlayer.angularDamping === 'number') shipOverrides.angularDamping = previousPlayer.angularDamping;
if (typeof previousPlayer.w === 'number') shipOverrides.w = previousPlayer.w;
if (typeof previousPlayer.h === 'number') shipOverrides.h = previousPlayer.h;
if (previousPlayer.controller) shipOverrides.controller = previousPlayer.controller;
if (previousPlayer.aiController) shipOverrides.aiController = previousPlayer.aiController;

Game.player = createShipEntity({ world: WORLD, overlayView, overrides: shipOverrides });
const ship = Game.player;
window.ship = ship;

ship.inventory = mergedInventory;
ship.shipFrame = previousPlayer.shipFrame || 'atlas';
ship.hardpoints = previousPlayer.hardpoints || [];
ship.weapons = previousPlayer.weapons || {};
ship.spriteW = previousPlayer.spriteW || ship.spriteW || 260;
ship.spriteH = previousPlayer.spriteH || ship.spriteH || 520;

if (previousPlayer && typeof previousPlayer === 'object'){
  for (const [key, value] of Object.entries(previousPlayer)){
    if (ship[key] === undefined){
      ship[key] = value;
    }
  }
}

overlayView.center.x = ship.pos.x;
overlayView.center.y = ship.pos.y;

let rocketAmmo = 0;
let rocketAmmoMax = 0;

function setHardpointMount(hp, weaponId, opts={}){
  if(!hp) return;
  const weapon = weaponId ? WEAPONS[weaponId] : null;
  const inventory = Game.player?.inventory;
  if(!weapon || (inventory && weaponId && !inventory.has(weaponId)) || weapon.type !== hp.type){
    hp.mount = null;
    hp.ammo = null;
    hp.maxAmmo = null;
    return;
  }
  hp.mount = weaponId;
  const baseMax = weapon.ammo != null ? weapon.ammo : null;
  hp.maxAmmo = opts.hasOwnProperty('maxAmmo') ? opts.maxAmmo : baseMax;
  if(weapon.ammo != null){
    const desiredAmmo = opts.hasOwnProperty('ammo') ? opts.ammo : weapon.ammo;
    hp.ammo = Math.max(0, desiredAmmo);
  } else {
    hp.ammo = null;
  }
}

function rebuildHardpointsForFrame(){
  const frame = SHIPS[Game.player.shipFrame];
  if(!frame) return;
  const spriteSize = { w: Game.player.spriteW || 260, h: Game.player.spriteH || 520 };
  Game.player.hardpoints = frame.genHardpoints(spriteSize);
  autoMountDefaults();
  syncWeaponSystems();
}

function autoMountDefaults(){
  mountFirstFree(HP.MAIN, 'railgun_mk2', 4);
  mountFirstFree(HP.MISSILE, 'missile_rack', 8);
  mountFirstFree(HP.AUX, 'ciws_mk1', 8);
  mountFirstFree(HP.HANGAR, 'fighter_bay', 4);
  mountFirstFree(HP.SPECIAL, 'super_f', 1);
}

function mountFirstFree(type, weaponId, howMany){
  if(!Game.player.inventory.has(weaponId)) return;
  for (const hp of Game.player.hardpoints){
    if (howMany<=0) break;
    if (hp.type===type && !hp.mount){
      setHardpointMount(hp, weaponId);
      howMany--;
    }
  }
}

function syncWeaponSystems(){
  const byType = {};
  for (const type of Object.values(HP)) byType[type] = [];
  for (const hp of Game.player.hardpoints){
    if (!hp.mount) continue;
    const weapon = WEAPONS[hp.mount];
    if(weapon) byType[hp.type].push({ hp, weapon });
  }
  Game.player.weapons = byType;
  rocketAmmoMax = missileAmmoCapacity();
  rocketAmmo = missileAmmoTotal();
  updateMainWeaponBehavior();
}

function getMainWeaponBehaviorForWeaponId(id){
  if(!id) return MAIN_WEAPON_BEHAVIOR.default;
  return MAIN_WEAPON_BEHAVIOR[id] || MAIN_WEAPON_BEHAVIOR.default;
}

function updateMainWeaponBehavior(){
  const mainWeapons = Game.player.weapons?.[HP.MAIN] || [];
  let behavior = MAIN_WEAPON_BEHAVIOR.default;
  if(mainWeapons.length){
    for(const loadout of mainWeapons){
      const id = loadout?.weapon?.id;
      const candidate = getMainWeaponBehaviorForWeaponId(id);
      if(!candidate) continue;
      const candidatePriority = candidate.priority ?? 0;
      const currentPriority = behavior.priority ?? 0;
      const candidateCooldown = candidate.cooldown ?? MAIN_WEAPON_BEHAVIOR.default.cooldown;
      const currentCooldown = behavior.cooldown ?? MAIN_WEAPON_BEHAVIOR.default.cooldown;
      const preferCandidate = (candidatePriority > currentPriority)
        || (candidatePriority === currentPriority && candidateCooldown > currentCooldown);
      if(preferCandidate){
        behavior = candidate;
      }
    }
  }
  rail.behaviorId = behavior.id || 'default';
  rail.cdMax = behavior.cooldown ?? MAIN_WEAPON_BEHAVIOR.default.cooldown;
  rail.shotGap = behavior.shotGap ?? MAIN_WEAPON_BEHAVIOR.default.shotGap;
  rail.burstGap = behavior.burstGap ?? MAIN_WEAPON_BEHAVIOR.default.burstGap;
  rail.burstsPerClick = behavior.burstsPerClick ?? MAIN_WEAPON_BEHAVIOR.default.burstsPerClick;
  rail.barrelsPerShot = behavior.barrelsPerShot ?? MAIN_WEAPON_BEHAVIOR.default.barrelsPerShot;
}

function missileAmmoTotal(){
  let total = 0;
  for (const hp of Game.player.hardpoints){
    if(hp.type===HP.MISSILE && hp.mount){
      if(typeof hp.ammo === 'number') total += hp.ammo;
    }
  }
  return total;
}

function missileAmmoCapacity(){
  let total = 0;
  for (const hp of Game.player.hardpoints){
    if(hp.type===HP.MISSILE && hp.mount){
      if(typeof hp.maxAmmo === 'number') total += hp.maxAmmo;
    }
  }
  return total;
}

function tryPreserveMounts(previous){
  if(!previous) return;
  const byType = new Map();
  for (const hp of previous){
    if(!hp.mount) continue;
    const entry = { weaponId: hp.mount, ammo: hp.ammo, maxAmmo: hp.maxAmmo };
    if(!byType.has(hp.type)) byType.set(hp.type, []);
    byType.get(hp.type).push(entry);
  }
  for (const hp of Game.player.hardpoints){
    const arr = byType.get(hp.type);
    if(arr && arr.length){
      const entry = arr.shift();
      setHardpointMount(hp, entry.weaponId, { ammo: entry.ammo, maxAmmo: entry.maxAmmo });
    }
  }
}

function saveLoadout(){
  try{
    localStorage.setItem('loadout', JSON.stringify({
      shipFrame: Game.player.shipFrame,
      hardpoints: Game.player.hardpoints.map(h=>({ id:h.id, type:h.type, mount:h.mount, ammo:h.ammo, maxAmmo:h.maxAmmo }))
    }));
  }catch(e){ console.warn('Loadout save error', e); }
}

function loadLoadout(){
  const raw = localStorage.getItem('loadout');
  if(!raw){ syncWeaponSystems(); return; }
  try{
    const data = JSON.parse(raw);
    if(data.shipFrame && SHIPS[data.shipFrame]){
      Game.player.shipFrame = data.shipFrame;
    }
    const frame = SHIPS[Game.player.shipFrame];
    if(frame){
      const spriteSize = { w: Game.player.spriteW || 260, h: Game.player.spriteH || 520 };
      const fresh = frame.genHardpoints(spriteSize);
      const savedByType = new Map();
      for(const saved of (data.hardpoints||[])){
        if(!saved.mount) continue;
        if(!savedByType.has(saved.type)) savedByType.set(saved.type, []);
        savedByType.get(saved.type).push(saved);
      }
      for(const hp of fresh){
        const arr = savedByType.get(hp.type);
        if(arr && arr.length){
          const saved = arr.shift();
          setHardpointMount(hp, saved.mount, { ammo: saved.ammo, maxAmmo: saved.maxAmmo });
        }
      }
      Game.player.hardpoints = fresh;
    }
  }catch(e){
    console.warn('Loadout parse error', e);
  }
  syncWeaponSystems();
  if(typeof renderMechanic === 'function') renderMechanic();
}

window.addEventListener('beforeunload', saveLoadout);

function drawHardpointGizmos(ctx, worldPos){
  if(!window.DEBUG_DRAW_HARDPOINTS) return;
  ctx.save();
  const screenX = (worldPos.x - camera.x) * camera.zoom + W/2;
  const screenY = (worldPos.y - camera.y) * camera.zoom + H/2;
  ctx.translate(screenX, screenY);
  for (const h of Game.player.hardpoints){
    ctx.beginPath();
    ctx.arc(h.pos.x*camera.zoom, h.pos.y*camera.zoom, 6, 0, Math.PI*2);
    ctx.strokeStyle = ({main:'#3b82f6', missile:'#10b981', aux:'#f59e0b', hangar:'#a78bfa', special:'#ef4444'})[h.type] || '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
  ctx.restore();
}

// =============== Floating HUD state ===============
const HUD_SHOW_LEGACY = false; // stary HUD w lewym dolnym rogu – zostaw false

const HUD = {
  dmg: [],       // popupy obrażeń: {x,y,txt,color,vy,life,max}
  navArrows: [], // niebieskie strzałki po X: {x,y,age,life}
};

// =============== Planet radar UI ===============
const PLANET_ICON_SRC = {
  mercury: 'assets/planet-icons/mercury.svg',
  venus: 'assets/planet-icons/venus.svg',
  earth: 'assets/planet-icons/earth.svg',
  mars: 'assets/planet-icons/mars.svg',
  jupiter: 'assets/planet-icons/jupiter.svg',
  saturn: 'assets/planet-icons/saturn.svg',
  uranus: 'assets/planet-icons/uranus.svg',
  neptune: 'assets/planet-icons/neptune.svg',
  default: 'assets/planet-icons/earth.svg'
};

const planetRadarState = {
  enabled: true,
  visited: new Set(),
  elements: new Map()
};

function formatAuDistance(distAu){
  if (distAu >= 10) return `${distAu.toFixed(0)} AU`;
  if (distAu >= 1) return `${distAu.toFixed(1)} AU`;
  return `${distAu.toFixed(2)} AU`;
}

function projectToScreenEdge(dirX, dirY, margin){
  const halfW = Math.max(1, W / 2 - margin);
  const halfH = Math.max(1, H / 2 - margin);
  const safeX = Math.abs(dirX) < 1e-3 ? 1e-3 : dirX;
  const safeY = Math.abs(dirY) < 1e-3 ? 1e-3 : dirY;
  const scale = Math.min(halfW / Math.abs(safeX), halfH / Math.abs(safeY));
  return { x: W / 2 + safeX * scale, y: H / 2 + safeY * scale };
}

function ensurePlanetRadarItem(id, iconSrc){
  if (!planetRadarRoot) return null;
  let el = planetRadarState.elements.get(id);
  if (el) return el;

  const item = document.createElement('div');
  item.className = 'planet-radar-item';

  const icon = document.createElement('div');
  icon.className = 'planet-radar-icon';
  const img = document.createElement('img');
  img.alt = id;
  img.src = iconSrc;
  icon.appendChild(img);

  const label = document.createElement('div');
  label.className = 'planet-radar-label';

  item.append(icon, label);
  planetRadarRoot.appendChild(item);
  planetRadarState.elements.set(id, item);
  return item;
}

function togglePlanetRadarVisibility(force){
  const next = typeof force === 'boolean' ? force : !planetRadarState.enabled;
  planetRadarState.enabled = next;
  if (planetRadarRoot) {
    planetRadarRoot.classList.toggle('hidden', !next);
  }
}

function updatePlanetRadar(ship, cam){
  if (!Array.isArray(planets)) return;
  const auUnit = getAuToWorldUnits();
  const margin = 32;
  const maxScaleAu = 40;
  const minScale = 0.58;
  const maxScale = 1.4;
  const shouldRender = !!planetRadarRoot && planetRadarState.enabled;

  if (planetRadarRoot) {
    planetRadarRoot.classList.toggle('hidden', !planetRadarState.enabled);
  }

  for (const planet of planets) {
    if (!planet) continue;
    const id = planet.id || planet.name || '';
    if (!id) continue;

    const dx = planet.x - ship.pos.x;
    const dy = planet.y - ship.pos.y;
    const distWorld = Math.hypot(dx, dy);
    const arrivalRadius = Math.max(10, (planet.r || 0) * 2);
    const iconSrc = PLANET_ICON_SRC[id] || PLANET_ICON_SRC[planet.name] || PLANET_ICON_SRC.default;
    const distAu = Math.max(0, (distWorld - Math.max(planet.r || 0, 0)) / auUnit);

    if (planetRadarState.visited.has(id) && distAu >= 2) {
      planetRadarState.visited.delete(id);
    }

    if (distWorld <= arrivalRadius) {
      planetRadarState.visited.add(id);
      const existing = planetRadarState.elements.get(id);
      if (existing) {
        existing.remove();
        planetRadarState.elements.delete(id);
      }
      continue;
    }

    if (planetRadarState.visited.has(id)) {
      const existing = planetRadarState.elements.get(id);
      if (existing) {
        existing.remove();
        planetRadarState.elements.delete(id);
      }
      continue;
    }

    if (!shouldRender) continue;

    const screenPos = worldToScreen(planet.x, planet.y, cam);
    const dirX = screenPos.x - W / 2;
    const dirY = screenPos.y - H / 2;
    const edgePos = projectToScreenEdge(dirX, dirY, margin);

    const item = ensurePlanetRadarItem(id, iconSrc);
    if (!item) continue;
    const iconEl = item.querySelector('.planet-radar-icon');
    const labelEl = item.querySelector('.planet-radar-label');

    const ratio = clamp(distAu / maxScaleAu, 0, 1);
    const scale = maxScale - (maxScale - minScale) * ratio;
    if (iconEl) {
      const base = 62;
      const size = base * scale;
      iconEl.style.width = `${size}px`;
      iconEl.style.height = `${size}px`;
      iconEl.style.opacity = `${0.75 + 0.25 * (1 - ratio)}`;
      iconEl.style.transform = `scale(${scale})`;
    }
    if (labelEl) {
      const label = planet.label || formatPlanetLabel(planet, 0);
      labelEl.textContent = `${label} · ${formatAuDistance(distAu)}`;
      labelEl.style.writingMode = '';
      labelEl.style.transform = '';
      labelEl.style.margin = '';
    }

    if (item) {
      let flexDirection = 'column';
      if (labelEl) {
        if (Math.abs(dirX) > Math.abs(dirY)) {
          labelEl.style.writingMode = 'vertical-rl';
          labelEl.style.transform = dirX > 0 ? 'rotate(180deg)' : '';
          labelEl.style.margin = '4px 0 0 0';
        } else {
          labelEl.style.writingMode = 'horizontal-tb';
        }
      }

      if (edgePos.y > H - margin * 1.5) {
        flexDirection = 'column-reverse';
      }

      item.style.flexDirection = flexDirection;
      item.style.transform = 'translate(-50%, -50%)';
    }

    item.style.left = `${edgePos.x}px`;
    item.style.top = `${edgePos.y}px`;
  }

  if (!shouldRender) return;

  for (const [id, node] of planetRadarState.elements.entries()) {
    const stillExists = planets.some(pl => (pl?.id || pl?.name) === id);
    if (!stillExists || planetRadarState.visited.has(id)) {
      node.remove();
      planetRadarState.elements.delete(id);
    }
  }
}

function hudSpawnDMG(x,y,amount,kind='npc'){
  const color = (kind==='player') ? '#f87171' : '#a7f3d0';
  HUD.dmg.push({ x, y, txt: Math.round(amount), color, vy: -14, life: 1.15, max: 1.15 });
}
function hudUpdateDMG(dt){
  for(const d of HUD.dmg){ d.y += d.vy*dt; d.life -= dt; }
  HUD.dmg = HUD.dmg.filter(d=>d.life>0);
}
function hudRenderDMG(cam){
  ctx.save();
  ctx.font = 'bold 13px system-ui,monospace';
  ctx.textAlign = 'center';
  for(const d of HUD.dmg){
    const s = worldToScreen(d.x, d.y, cam);
    ctx.globalAlpha = Math.max(0, d.life/d.max);
    ctx.fillStyle = d.color;
    ctx.fillText(d.txt, s.x, s.y);
  }
  ctx.restore();
}

function hudPingNpcStations(){
  // Niebieskie strzałki do stacji nie-misyjnych; gasną po 4s
  const targets = stations.filter(s=>!s.mission).slice(0, 8);
  HUD.navArrows = targets.map(s=>({ x:s.x, y:s.y, age:0, life:4.0 }));
}
function hudUpdateNav(dt){
  for(const p of HUD.navArrows) p.age += dt;
  HUD.navArrows = HUD.navArrows.filter(p=>p.age < p.life);
}

function drawArrowOnRing(cx, cy, R, ang, size, color){
  const x = cx + Math.cos(ang)*R, y = cy + Math.sin(ang)*R;
  ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(size, 0);
  ctx.lineTo(-size*0.6, size*0.6);
  ctx.lineTo(-size*0.2, 0);
  ctx.lineTo(-size*0.6, -size*0.6);
  ctx.closePath(); ctx.fill();
  ctx.restore();
}
function hudRenderNav(ship, cam){
  if(!HUD.navArrows.length) return;
  const s = worldToScreen(ship.pos.x, ship.pos.y, cam);
  const R = Math.max(ship.w, ship.h) * camera.zoom * 0.6 + 30;
  for(const p of HUD.navArrows){
    const ang = Math.atan2(p.y - ship.pos.y, p.x - ship.pos.x);
    const a = Math.max(0, 1 - p.age/p.life);
    ctx.save(); ctx.globalAlpha = 0.3 + 0.7*a;
    drawArrowOnRing(s.x, s.y, R, ang, 12, '#60a5fa');
    ctx.restore();
  }
}

function hudRenderFloatingBars(ship, cam){
  const cx = W/2, cy = H/2;
  const R0 = Math.max(ship.w, ship.h) * camera.zoom * 0.8 + 32;

  // BOOST – pokazuj jako poziom paliwa dopalacza
  const boostFuelRatio = clamp(boost.fuel / boost.fuelMax, 0, 1);
  if (boostFuelRatio < 1 || (boost.state === 'active' && boost.fuel > 0)){
    ctx.save();
    ctx.strokeStyle = 'rgba(41,52,65,0.9)'; ctx.lineWidth = 8;
    ctx.beginPath(); ctx.arc(cx, cy, R0, -Math.PI/2, -Math.PI/2 + Math.PI*1.1); ctx.stroke();
    ctx.strokeStyle = '#60a5fa';
    ctx.beginPath(); ctx.arc(cx, cy, R0, -Math.PI/2, -Math.PI/2 + Math.PI*1.1*boostFuelRatio); ctx.stroke();
    ctx.fillStyle = '#bcd7ff'; ctx.font = '12px system-ui,monospace'; ctx.textAlign = 'center';
    ctx.fillText('BOOST', cx, cy - R0 - 10);
    ctx.restore();
  }

  // WARP – pokazuj przy charge/active
  if (warp.state === 'charging' || warp.state === 'active'){
    const t = (warp.state==='charging') ? Math.min(1, warp.charge/warp.chargeTime) : 1;
    const R1 = R0 + 16;
    ctx.save();
    ctx.strokeStyle = 'rgba(30,41,59,0.9)'; ctx.lineWidth = 8;
    ctx.beginPath(); ctx.arc(cx, cy, R1,  Math.PI/2,  Math.PI/2 - Math.PI*1.1, true); ctx.stroke();
    ctx.strokeStyle = '#7dd3fc';
    ctx.beginPath(); ctx.arc(cx, cy, R1,  Math.PI/2,  Math.PI/2 - Math.PI*1.1*t, true); ctx.stroke();
    ctx.fillStyle = '#d0f0ff'; ctx.font = '12px system-ui,monospace'; ctx.textAlign = 'center';
    ctx.fillText('WARP', cx, cy + R1 + 26);
    ctx.restore();
  }
}

// =============== Zoom indicator ===============
const zoomIndicatorEl = document.getElementById('zoom-indicator');
const zoomIndicator = {
  el: zoomIndicatorEl,
  timer: 0,
  hold: 1.2,
  visible: false,
  update(dt){
    if (!this.el) return;
    if (this.timer > 0) {
      this.timer -= dt;
      if (this.timer <= 0 && this.visible) {
        this.visible = false;
        this.el.classList.remove('visible');
      }
    }
  },
  show(zoomValue){
    if (!this.el) return;
    const normalized = clamp(zoomValue / Math.max(0.0001, camera.maxZoom || 1), 0, 1);
    const display = normalized >= 0.995 ? 1 : Math.max(0.01, normalized);
    this.el.textContent = `ZOOM X${display.toFixed(display >= 1 ? 0 : 2)}`;
    this.timer = this.hold;
    this.visible = true;
    this.el.classList.add('visible');
  }
};

// =============== Game time (1 min real = 1 h game) ===============
let gameTime = 0; // seconds
const gameTimeEl = document.getElementById('game-time');
function formatGameTime(sec){
  const t = Math.floor(sec);
  const h = Math.floor(t / 3600) % 24;
  const m = Math.floor((t % 3600) / 60);
  return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
}
function wrapAngle(a){ while(a>Math.PI) a-=2*Math.PI; while(a<-Math.PI) a+=2*Math.PI; return a; }
function interpAngleShort(prev,curr,t){ const d = wrapAngle(curr - prev); return wrapAngle(prev + d * t); }
function shuffleArray(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function leadTarget(shooter, shooterVel, target, speed){
  const tx = target.x, ty = target.y;
  const tvx = target.vx || 0, tvy = target.vy || 0;
  const rx = tx - shooter.x, ry = ty - shooter.y;
  const rvx = tvx - shooterVel.x, rvy = tvy - shooterVel.y;
  const a = rvx*rvx + rvy*rvy - speed*speed;
  const b = 2*(rx*rvx + ry*rvy);
  const c = rx*rx + ry*ry;
  let t = 0;
  if(Math.abs(a) < 1e-6){
    if(Math.abs(b) > 1e-6) t = -c / b;
  } else {
    const disc = b*b - 4*a*c;
    if(disc >= 0){
      const sqrtDisc = Math.sqrt(disc);
      const t1 = (-b - sqrtDisc)/(2*a);
      const t2 = (-b + sqrtDisc)/(2*a);
      t = Math.min(t1, t2);
      if(t < 0) t = Math.max(t1, t2);
    }
  }
  if(!isFinite(t) || t < 0) t = 0;
  return { x: tx + tvx*t, y: ty + tvy*t };
}

// =============== World / camera ===============
const camera = {
  x: WORLD.w / 2,
  y: WORLD.h / 2,
  zoom: 1.0,
  defaultZoom: 1.0,
  altZoom: 0.7,
  minZoom: 0.12,
  maxZoom: 3.2,
  wheelSpeed: 0.002,
  manualZoom: false,
  shakeMag: 0,
  shakeTime: 0,
  shakeDur: 0,
  mode: 'ship',
  focusStation: null,
  freePanSpeed: 1,
  lastPointerX: null,
  lastPointerY: null,
  freeKeyPanSpeed: 1400,
  targetX: WORLD.w / 2,
  targetY: WORLD.h / 2,
  targetZoom: 1.0,
  focusScreenXRatio: 0.3,
  focusScreenYRatio: 0.5,
  focusZoom: 1.0,
  focusArrived: false,
  transition: null,
  addShake(mag, dur){
    if (DevFlags && DevFlags.disableCameraShake) {
      this.shakeMag = 0;
      this.shakeTime = 0;
      this.shakeDur = 0;
      return;
    }
    this.shakeMag = mag;
    this.shakeTime = dur;
    this.shakeDur = dur;
  },
  enterFreeMode(){
    this.mode = 'free';
    this.focusStation = null;
    this.targetX = this.x;
    this.targetY = this.y;
    this.targetZoom = this.zoom;
    this.transition = null;
    this.focusArrived = false;
    this.lastPointerX = null;
    this.lastPointerY = null;
  },
  exitFreeMode(){
    this.mode = 'ship';
    this.focusStation = null;
    this.manualZoom = false;
    this.focusArrived = false;
    this.lastPointerX = null;
    this.lastPointerY = null;
    const tx = ship.pos.x;
    const ty = ship.pos.y;
    const tz = this.defaultZoom;
    this.beginTransition(tx, ty, tz, 0.75, () => {
      this.targetX = tx;
      this.targetY = ty;
      this.targetZoom = tz;
    });
  },
  toggleFreeMode(){
    if(this.mode === 'free') this.exitFreeMode();
    else this.enterFreeMode();
  },
  beginTransition(x, y, zoom, duration = 0.8, onComplete){
    const targetZoom = clamp(zoom, this.minZoom, this.maxZoom);
    this.manualZoom = false;
    this.transition = {
      kind: this.mode,
      startX: this.x,
      startY: this.y,
      startZoom: this.zoom,
      targetX: x,
      targetY: y,
      targetZoom,
      elapsed: 0,
      duration: Math.max(0.0001, duration),
      onComplete
    };
  },
  focusOnStation(station){
    if(!station) return;
    this.focusStation = station;
    this.mode = 'focus';
    this.focusArrived = false;
    this.focusScreenXRatio = 0.3;
    this.focusScreenYRatio = 0.5;
    this.lastPointerX = null;
    this.lastPointerY = null;
    const target = computeStationFocusTarget(station);
    this.focusZoom = target.zoom;
    this.targetX = target.x;
    this.targetY = target.y;
    this.targetZoom = target.zoom;
    this.beginTransition(target.x, target.y, target.zoom, 0.85, () => {
      this.focusArrived = true;
    });
  },
  focusOnInfrastructure(station, layout){
    if(!station) return;
    this.focusStation = station;
    this.mode = 'infrastructure';
    this.focusArrived = false;
    this.focusScreenXRatio = 0.42;
    this.focusScreenYRatio = 0.52;
    this.lastPointerX = null;
    this.lastPointerY = null;
    const target = computeInfrastructureFocusTarget(station, layout);
    this.focusZoom = target.zoom;
    this.targetX = target.x;
    this.targetY = target.y;
    this.targetZoom = target.zoom;
    this.beginTransition(target.x, target.y, target.zoom, 0.9, () => {
      this.focusArrived = true;
    });
  },
  clearFocus(){
    if(this.mode === 'focus' || this.mode === 'infrastructure'){
      this.focusStation = null;
      this.mode = 'ship';
      this.focusArrived = false;
      this.manualZoom = false;
      this.targetZoom = this.defaultZoom;
      this.targetX = ship.pos.x;
      this.targetY = ship.pos.y;
      this.beginTransition(this.targetX, this.targetY, this.targetZoom, 0.6);
      this.lastPointerX = null;
      this.lastPointerY = null;
    }
  }
};

function computeStationFocusTarget(station){
  if(!station) return { x: camera.x, y: camera.y, zoom: camera.zoom };
  const ratioX = camera.focusScreenXRatio ?? 0.32;
  const ratioY = camera.focusScreenYRatio ?? 0.52;
  const baseRadius = ((station.r ?? station.baseR) || 120);
  const desiredRadiusPx = clamp(Math.min(W, H) * 0.24, 180, 320);
  const zoom = clamp(desiredRadiusPx / Math.max(60, baseRadius), camera.minZoom, camera.maxZoom);
  const screenX = ratioX * W;
  const screenY = ratioY * H;
  const x = station.x - (screenX - W/2) / zoom;
  const y = station.y - (screenY - H/2) / zoom;
  return { x, y, zoom, screenX, screenY };
}

function computeInfrastructureFocusTarget(station, layout){
  if(!station) return computeStationFocusTarget(station);
  const activeLayout = layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  const padding = (activeLayout?.cellSize || 200) * 0.9;
  const worldWidth = (activeLayout?.width || 600) + padding;
  const worldHeight = (activeLayout?.height || 400) + padding;
  const zoomX = W / Math.max(worldWidth, 1);
  const zoomY = H / Math.max(worldHeight, 1);
  const baseZoom = Math.min(zoomX, zoomY) * 0.92;
  const zoom = clamp(baseZoom, camera.minZoom, camera.maxZoom);
  const ratioX = 0.42;
  const ratioY = 0.52;
  const screenX = ratioX * W;
  const screenY = ratioY * H;
  const x = station.x - (screenX - W/2) / zoom;
  const y = station.y - (screenY - H/2) / zoom;
  return { x, y, zoom, screenX, screenY };
}

// Model widoku overlayu już istnieje – dopasuj początkowy zoom do kamery
overlayView.zoom = camera.zoom;

function updateCameraTarget(dt){
  if(camera.mode === 'ship'){
    camera.targetX = ship.pos.x;
    camera.targetY = ship.pos.y;
    if(!camera.transition && !camera.manualZoom) camera.targetZoom = camera.defaultZoom;
  } else if(camera.mode === 'free'){
    const moveX = (keys['arrowright'] ? 1 : 0) - (keys['arrowleft'] ? 1 : 0);
    const moveY = (keys['arrowdown'] ? 1 : 0) - (keys['arrowup'] ? 1 : 0);
    if(moveX || moveY){
      const len = Math.hypot(moveX, moveY) || 1;
      const panSpeed = camera.freeKeyPanSpeed / Math.max(0.0001, camera.zoom);
      camera.x += (moveX / len) * panSpeed * dt;
      camera.y += (moveY / len) * panSpeed * dt;
    }
    camera.targetX = camera.x;
    camera.targetY = camera.y;
  } else if(camera.mode === 'focus'){
    const st = camera.focusStation;
    if(st){
      const target = computeStationFocusTarget(st);
      camera.focusZoom = target.zoom;
      camera.targetX = target.x;
      camera.targetY = target.y;
      camera.targetZoom = target.zoom;
      if(camera.transition && camera.transition.kind === 'focus'){
        camera.transition.targetX = target.x;
        camera.transition.targetY = target.y;
        camera.transition.targetZoom = target.zoom;
      }
    } else {
      camera.clearFocus();
      camera.targetX = ship.pos.x;
      camera.targetY = ship.pos.y;
      camera.targetZoom = camera.defaultZoom;
    }
  } else if(camera.mode === 'infrastructure'){
    const st = camera.focusStation;
    if(st){
      const layout = infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
      const target = computeInfrastructureFocusTarget(st, layout);
      camera.focusZoom = target.zoom;
      camera.targetX = target.x;
      camera.targetY = target.y;
      camera.targetZoom = target.zoom;
      if(camera.transition && camera.transition.kind === 'infrastructure'){
        camera.transition.targetX = target.x;
        camera.transition.targetY = target.y;
        camera.transition.targetZoom = target.zoom;
      }
    } else {
      camera.clearFocus();
      camera.targetX = ship.pos.x;
      camera.targetY = ship.pos.y;
      camera.targetZoom = camera.defaultZoom;
    }
  }

  if(camera.transition){
    const tr = camera.transition;
    tr.elapsed = Math.min(tr.elapsed + dt, tr.duration);
    const t = tr.duration <= 0 ? 1 : tr.elapsed / tr.duration;
    const eased = smoothstep01(t);
    camera.x = lerp(tr.startX, tr.targetX, eased);
    camera.y = lerp(tr.startY, tr.targetY, eased);
    camera.zoom = lerp(tr.startZoom, tr.targetZoom, eased);
    if(tr.elapsed >= tr.duration - 1e-6){
      camera.x = tr.targetX;
      camera.y = tr.targetY;
      camera.zoom = tr.targetZoom;
      const onComplete = tr.onComplete;
      camera.transition = null;
      if(typeof onComplete === 'function') onComplete();
    }
  } else {
    if(camera.mode === 'ship'){
      camera.x = camera.targetX;
      camera.y = camera.targetY;
    } else {
      const posLerp = Math.min(1, dt * 6);
      camera.x += (camera.targetX - camera.x) * posLerp;
      camera.y += (camera.targetY - camera.y) * posLerp;
    }
    const zoomLerp = Math.min(1, dt * 4);
    camera.zoom += (camera.targetZoom - camera.zoom) * zoomLerp;
  }

  camera.zoom = clamp(camera.zoom, camera.minZoom, camera.maxZoom);
}

// Bezpieczna, odroczona inicjalizacja overlayu 3D
let overlay3D = null;

window.addEventListener('resize', ()=>{
  W = canvas.width = innerWidth;
  H = canvas.height = innerHeight;
  spaceBg?.resizeSpaceBg?.(innerWidth, innerHeight);
  configureWarpLensSource?.();
  if(camera.mode === 'focus' && camera.focusStation){
    const target = computeStationFocusTarget(camera.focusStation);
    camera.focusZoom = target.zoom;
    camera.targetX = target.x;
    camera.targetY = target.y;
    camera.targetZoom = target.zoom;
    if(camera.transition && camera.transition.kind === 'focus'){
      camera.transition.targetX = target.x;
      camera.transition.targetY = target.y;
      camera.transition.targetZoom = target.zoom;
    }
  }
  if(camera.mode === 'infrastructure' && camera.focusStation){
    const layout = infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
    const target = computeInfrastructureFocusTarget(camera.focusStation, layout);
    camera.focusZoom = target.zoom;
    camera.targetX = target.x;
    camera.targetY = target.y;
    camera.targetZoom = target.zoom;
    if(camera.transition && camera.transition.kind === 'infrastructure'){
      camera.transition.targetX = target.x;
      camera.transition.targetY = target.y;
      camera.transition.targetZoom = target.zoom;
    }
  }
  resizeOverlay3D();
  initStars(true);
});

function startOverlay3D() {
  const init = window.initOverlay3D;
  const railFactory = window.createRailgunExplosionFactory;
  const armataFactory = window.createArmataImpactFactory;
  const autocannonFactory = window.createAutocannonImpactFactory;
  const host = document.getElementById('game-root');

  // Musimy mieć: API z modułu + host z DOM + overlayView z tego skryptu
  if (!init || !railFactory || !host || typeof overlayView === 'undefined') return false;

  const ov = init({ host, getView: () => overlayView });
  overlay3D = ov;
  window.overlay3D = ov;
  window.makeRailgunExplosion = railFactory(ov.scene);
  if (armataFactory) {
    window.makeArmataImpact = armataFactory(ov.scene);
  }
  if (autocannonFactory) {
    window.makeAutocannonImpact = autocannonFactory(ov.scene);
  }
  resizeOverlay3D();
  return true;
}

// Moduły <script type="module"> wykonują się po parsowaniu DOM, więc
// DOMContentLoaded zwykle wystarczy. Dla pewności dodajemy krótki polling.
window.addEventListener('DOMContentLoaded', () => {
  if (startOverlay3D()) return;
  let tries = 0;
  const maxTries = 120; // ~2 sekundy przy 60 FPS
  (function poll() {
    if (startOverlay3D() || tries++ > maxTries) return;
    requestAnimationFrame(poll);
  })();
});

// Helper do spawnu eksplozji 3D
function triggerRailgunExplosion3D(x, y, size = ship.h * 0.22){
  if (overlay3D && window.makeRailgunExplosion) {
    const fx = window.makeRailgunExplosion({ x, y, size });
    overlay3D.spawn(fx);
  }
}

function triggerArmataImpact3D(x, y, size = ship.h * 0.3){
  if (overlay3D && window.makeArmataImpact) {
    const fx = window.makeArmataImpact({ x, y, size });
    overlay3D.spawn(fx);
  }
}

function triggerAutocannonImpact3D(x, y, size = ship.h * 0.2){
  if (overlay3D && window.makeAutocannonImpact) {
    const fx = window.makeAutocannonImpact({ x, y, size });
    overlay3D.spawn(fx);
  }
}

// Resize: utrzymuj rozmiar overlayu = okna
function resizeOverlay3D(){
  overlayView.viewport.w = innerWidth;
  overlayView.viewport.h = innerHeight;
  if (overlay3D) overlay3D.resize();
}

resizeOverlay3D();

// === Ship sprite ===
const USE_SHIP_SPRITE = true;
const shipSprite = new Image();
const capitalShipSpriteCache = {};

function getCapitalShipSprite(src){
  if(!src) return null;
  if(!capitalShipSpriteCache[src]){
    const img = new Image();
    const entry = capitalShipSpriteCache[src] = {
      image: img,
      ready: false,
      error: false,
      width: 0,
      height: 0
    };
    img.onload = () => {
      entry.ready = true;
      entry.width = img.naturalWidth;
      entry.height = img.naturalHeight;
    };
    img.onerror = () => {
      entry.error = true;
    };
    img.src = src;
  }
  return capitalShipSpriteCache[src];
}
ship.spriteReady = false;
shipSprite.onload = () => {
  ship.spriteReady = true;
  ship.spriteW = shipSprite.naturalWidth;
  ship.spriteH = shipSprite.naturalHeight;
  Game.player.spriteW = ship.spriteW;
  Game.player.spriteH = ship.spriteH;
  const prev = Game.player.hardpoints.map(h=>({ type:h.type, mount:h.mount, ammo:h.ammo, maxAmmo:h.maxAmmo }));
  rebuildHardpointsForFrame();
  tryPreserveMounts(prev);
  syncWeaponSystems();
  if(typeof renderMechanic === 'function') renderMechanic();
  saveLoadout();
};
shipSprite.src = "assets/capital_ship_rect_v1.png"; // <- ścieżka do pliku

const npcSpriteFriendly = new Image();
const npcSpriteHostile = new Image();
let npcSpritesReady = 0;

npcSpriteFriendly.onload = () => { npcSpritesReady++; };
npcSpriteHostile.onload = () => { npcSpritesReady++; };

npcSpriteFriendly.src = "assets/npc_friendly.png";
npcSpriteHostile.src = "assets/npc_hostile.png";

const heavyAutocannonSprite = new Image();
let heavyAutocannonSpriteReady = false;
heavyAutocannonSprite.onload = () => {
  heavyAutocannonSpriteReady = true;
};
heavyAutocannonSprite.src = "assets/weapons/heavy_autocannon.svg";

// =============== Proceduralne gwiazdy na CAŁEJ MAPIE ===============
// Generujemy je "na żądanie" w kafelkach 1024×1024 z deterministycznym seedem.
// Dzięki temu gwiazdy są wszędzie, ale pamięć i CPU trzymamy w ryzach.
const STAR_CELL = 1024;
const starCells = new Map(); // key "ix,iy" -> {stars:[...] , lastSeen: frameId}
let frameId = 0;

function mulberry32(a){ return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
function key(ix,iy){ return ix+','+iy; }

function generateCell(ix,iy){
  const seed = ((ix*73856093) ^ (iy*19349663) ^ 0x9e3779b9) >>> 0;
  const rnd = mulberry32(seed);
  const count = 14 + Math.floor(rnd()*10); // 14–23 gwiazdy na komórkę
  const stars = [];
  for(let i=0;i<count;i++){
    const x = ix*STAR_CELL + rnd()*STAR_CELL;
    const y = iy*STAR_CELL + rnd()*STAR_CELL;
    const size = 0.7 + rnd()*2.1;
    const bright = 0.35 + rnd()*0.65;
    stars.push({x,y,size,bright});
  }
  const obj = { stars, lastSeen: frameId };
  starCells.set(key(ix,iy), obj);
  return obj;
}
function getCell(ix,iy){
  const k = key(ix,iy);
  let c = starCells.get(k);
  if(!c) c = generateCell(ix,iy);
  c.lastSeen = frameId;
  return c;
}
function pruneStarCells(){
  // Trzymajmy ~ 600 ostatnio widzianych komórek (wystarczy z zapasem)
  if(starCells.size <= 600) return;
  // Proste LRU: wyrzucamy najstarsze
  const arr = Array.from(starCells.entries());
  arr.sort((a,b)=>a[1].lastSeen - b[1].lastSeen);
  const toDrop = arr.slice(0, Math.max(0, arr.length - 600));
  for(const [k] of toDrop) starCells.delete(k);
}
function initStars(reset=false){
  if(reset){ starCells.clear(); }
}

// =============== Słońce, planety i stacje ===============
const SUN = { x: WORLD.w/2, y: WORLD.h/2, r: 823, r3D: 399,
  color: {
    core:  '#ffe88a',   // jasno-żółty rdzeń
    mid:   '#ffbe3b',   // pomarańcz-żółć
    rim:   '#ff8c1a'    // ciepła krawędź tarczy
  },
  corona: {
    rays: 72,           // ile „igieł”
    jitter: 0.35,       // nieregularność
    length: 0.85,       // długość korony w promieniach R
    pulse: 0.22,        // amplituda pulsu
    haze:  2.8          // rozmiar miękkiej poświaty (×R)
  },
  seed: 93731
};
window.SUN = SUN;

// --- tryb: REALNY UKŁAD SŁONECZNY (domyślnie włączony) ---
const solarParams = new URLSearchParams(location.search);
const USE_SOLAR = solarParams.has('solar') ? solarParams.get('solar') !== '0' : true; // można też sterować paramem URL ?solar=1

function makeSolarPlanets(){
  // Skala: 1 AU ≈ 3000 jednostek świata (Neptun ~ 90k)
  const AU = 3000;
  window.BASE_ORBIT = AU;
  const MIN_SUN_GAP = 600;
  const MIN_PLANET_GAP = 800;
  const INNER_PLANET_COUNT = 4;
  const INNER_EXTRA_ORBIT = 600;
  const INNER_EXTRA_SUN_GAP = 600;
  const INNER_EXTRA_PLANET_GAP = 600;
  const rand = () => Math.random() * Math.PI * 2;
  const defs = [
    { id:'mercury', name:'mercury', baseR: 300,  orbitAU: 4.0 },
    { id:'venus',   name:'venus',   baseR: 320,  orbitAU: 8.5 },
    { id:'earth',   name:'earth',   baseR: 2300, orbitAU: 15.0 },
    { id:'mars',    name:'mars',    baseR: 2500, orbitAU: 25.0 },
    { id:'jupiter', name:'jupiter', baseR: 3800, orbitAU: 50.20 },
    { id:'saturn',  name:'saturn',  baseR: 180,  orbitAU: 80.58 },
    { id:'uranus',  name:'uranus',  baseR: 1100, orbitAU: 100.20 },
    { id:'neptune', name:'neptune', baseR: 730,  orbitAU: 120.00 },
    // { id:'pluto',   name:'pluto',   baseR:  30, orbitAU:39.50 },
  ];

  let minOrbitEdge = SUN.r;
  return defs.map((def, index) => {
    const effectiveR = def.baseR * PLANET_SCALE;
    const baseOrbit = def.orbitAU * AU;
    const isInner = index < INNER_PLANET_COUNT;
    const extraOrbit = isInner ? INNER_EXTRA_ORBIT : 0;
    const sunGap = SUN.r + effectiveR + MIN_SUN_GAP + (isInner ? INNER_EXTRA_SUN_GAP : 0);
    const neighborGap = minOrbitEdge + effectiveR + MIN_PLANET_GAP + (isInner ? INNER_EXTRA_PLANET_GAP : 0);
    const orbitRadius = Math.max(
      baseOrbit + extraOrbit,
      sunGap,
      neighborGap
    );

    minOrbitEdge = orbitRadius + effectiveR;

    return {
      id: def.id,
      name: def.name,
      baseR: def.baseR,
      r: effectiveR,
      orbitAU: def.orbitAU,
      orbitRadius,
      angle: rand(),
      speed: 0
    };
  });
}

const WORLD_BELT_WIDTH_AU = 2;
const WORLD_SAFETY_MARGIN_AU = 2;
const WORLD_EDGE_MARGIN_AU = WORLD_SAFETY_MARGIN_AU;

function computeWorldDiameter(planets){
  const auToWorld = getAuToWorldUnits();
  const beltWidthAU = WORLD_BELT_WIDTH_AU;
  const beltHalfWidthAU = beltWidthAU / 2;
  const safetyMarginAU = WORLD_SAFETY_MARGIN_AU;
  const beltCenterAU = (() => {
    const neptune = planets.find(p => p.id === 'neptune' || p.name === 'neptune');
    if (neptune && Number.isFinite(neptune.orbitAU)) return neptune.orbitAU + 3;

    const maxOrbitAU = planets
      .map(p => p.orbitAU)
      .filter(Number.isFinite)
      .reduce((max, v) => Math.max(max, v), -Infinity);
    if (Number.isFinite(maxOrbitAU)) return maxOrbitAU + 3;

    const maxOrbitRadius = planets
      .map(p => p.orbitRadius)
      .filter(Number.isFinite)
      .reduce((max, v) => Math.max(max, v), -Infinity);
    if (Number.isFinite(maxOrbitRadius)) return (maxOrbitRadius / auToWorld) + 3;

    return 60;
  })();

  const outerRadiusWorld = (beltCenterAU + beltHalfWidthAU + safetyMarginAU) * auToWorld;
  return outerRadiusWorld * 2;
}

function alignWorldToCenter(centerX, centerY){
  SUN.x = centerX;
  SUN.y = centerY;

  if (camera) {
    camera.x = centerX;
    camera.y = centerY;
    camera.targetX = centerX;
    camera.targetY = centerY;
  }

  if (!hasSavedShipPosition && ship) {
    ship.pos.x = centerX;
    ship.pos.y = centerY;
    overlayView.center.x = centerX;
    overlayView.center.y = centerY;
  }
}

// jeśli kiedyś będziemy chcieli wrócić do starych zasad, zostawiamy helper:
function makeProceduralPlanets(){
  // stary kod może zostać, ale domyślnie nieużywany
  const PLANET_TYPES = {
    TERRAN: 'terran',
    VOLCANIC: 'volcanic',
    FROZEN: 'frozen',
    GAS: 'gas',
    BARREN: 'barren'
  };
  const NUM_PLANETS = 7;
  const TYPES = [
    PLANET_TYPES.VOLCANIC,
    PLANET_TYPES.VOLCANIC,
    PLANET_TYPES.TERRAN,
    PLANET_TYPES.TERRAN,
    PLANET_TYPES.BARREN,
    PLANET_TYPES.GAS,
    PLANET_TYPES.FROZEN
  ];
  const BASE_ORBIT = 7000;
  window.BASE_ORBIT = BASE_ORBIT;
  const list = [];
  for (let i = 0; i < NUM_PLANETS; i++) {
    const orbitRadius = BASE_ORBIT * (i + 1);
    const angle = Math.random() * Math.PI * 2;
    const au = i + 1;
    const periodHours = 24 * 365 * Math.pow(au, 1.5);
    const speed = (2 * Math.PI) / (periodHours * 3600);
    const r = (48 + Math.floor(Math.random() * 36)) * 3;
    list.push({ id: i, orbitRadius, angle, speed, r, type: TYPES[i], x: 0, y: 0 });
  }
  return list;
}

const PLANET_DATA = USE_SOLAR ? makeSolarPlanets() : makeProceduralPlanets();

const WORLD_DIAMETER = computeWorldDiameter(PLANET_DATA);
setWorldSize(WORLD, { width: WORLD_DIAMETER, height: WORLD_DIAMETER });
alignWorldToCenter(WORLD.w / 2, WORLD.h / 2);

function formatPlanetLabel(planet, index){
  if (typeof planet.label === 'string' && planet.label.trim().length) {
    return planet.label.trim();
  }
  const candidates = [];
  if (typeof planet.name === 'string') candidates.push(planet.name);
  if (typeof planet.id === 'string') candidates.push(planet.id);
  if (typeof planet.type === 'string') candidates.push(planet.type);

  for (const raw of candidates) {
    if (!raw) continue;
    const pretty = raw
      .replace(/[_-]+/g, ' ')
      .trim()
      .replace(/\b\w/g, ch => ch.toUpperCase());
    if (pretty) return pretty;
  }
  
  // Tego brakowało:
  return `Planet ${index + 1}`;
}
// wylicz pozycje
let planets = PLANET_DATA.map((p, index) => {
  if (p.baseR == null) p.baseR = p.r;
  if (p.r == null && p.baseR != null) {
    p.r = p.baseR * PLANET_SCALE;
  }
  p.x = SUN.x + Math.cos(p.angle) * p.orbitRadius;
  p.y = SUN.y + Math.sin(p.angle) * p.orbitRadius;
  p.label = formatPlanetLabel(p, index);
  return p;
});
window.planets = planets;

// =============== Strefy (planety/słońce/pas asteroid) ===============
const AU_IN_WORLD_UNITS = getAuToWorldUnits();
const ZONE_APPROACH_DISTANCE = AU_IN_WORLD_UNITS; // 1 AU przed granicą
window.ZONE_APPROACH_DISTANCE = ZONE_APPROACH_DISTANCE;

const PIRATE_ORBIT = Object.freeze({
  innerAu: 4,
  outerAu: 6
});

function pirateOrbitRadii(){
  const au = AU_IN_WORLD_UNITS || getAuToWorldUnits();
  return {
    inner: PIRATE_ORBIT.innerAu * au,
    outer: PIRATE_ORBIT.outerAu * au
  };
}

const zoneState = {
  current: null,
  approaching: null,
  lastZoneKey: null,
  lastZoneId: null,
  lastApproachKey: null,
  initialized: false,
  messages: []
};

function makeInterplanetaryZone(){
  return {
    key: 'interplanetary',
    id: 'interplanetary',
    label: 'Interplanetary Zone',
    enteringLabel: 'Interplanetary Zone',
    warpMultiplier: 2,
    wormholeVfx: true
  };
}

const zonePriority = {
  planet_inner: 4,
  planet_outer: 3,
  pirate_inner: 4,
  pirate_outer: 3,
  sun: 2,
  asteroid_belt: 1
};

function zonePropsForId(id){
  if (
    id === 'planet_inner' ||
    id === 'planet_outer' ||
    id === 'pirate_inner' ||
    id === 'pirate_outer' ||
    id === 'sun' ||
    id === 'asteroid_belt'
  ) {
    return { warpMultiplier: 0.3, wormholeVfx: false };
  }
  if (id === 'interplanetary') {
    return { warpMultiplier: 2, wormholeVfx: true };
  }
  return { warpMultiplier: 1, wormholeVfx: false };
}

function isPlanetOrbitZoneId(id){
  return id === 'planet_inner' || id === 'planet_outer' || id === 'pirate_inner' || id === 'pirate_outer';
}

function planetOrbitRadii(planet){
  const baseRadius = Math.max(10, (planet.r || 0) * 2);
  const outerOrbitExtra = Math.max(1600, ZONE_APPROACH_DISTANCE * 0.6);
  const outerRadius = baseRadius + outerOrbitExtra;
  return { inner: baseRadius, outer: outerRadius };
}

function enhanceZoneDescriptor(zone){
  if (!zone) return null;
  const props = zonePropsForId(zone.id);
  zone.warpMultiplier = props.warpMultiplier;
  zone.wormholeVfx = props.wormholeVfx;
  return zone;
}

function formatPlanetOrbitLabel(planet){
  const name = typeof planet.label === 'string' && planet.label.trim().length
    ? planet.label.trim()
    : formatPlanetLabel(planet, 0);
  return name;
}

function formatPirateOrbitLabel(station){
  if (!station) return 'Pirate Station';
  const raw = (station.label || station.name || station.id || '').toString();
  const trimmed = raw.trim();
  return trimmed.length ? trimmed : 'Pirate Station';
}

function detectZones(pos){
  const zones = [];

  for (const [index, planet] of planets.entries()) {
    if (!planet) continue;
    const orbitRadii = planetOrbitRadii(planet);
    const dx = pos.x - planet.x;
    const dy = pos.y - planet.y;
    const dist = Math.hypot(dx, dy);
    const labelName = formatPlanetOrbitLabel(planet) || `Planet ${index + 1}`;
    zones.push({
      key: `planet-${planet.id || planet.name || index}-inner`,
      id: 'planet_inner',
      label: `${labelName} - Inner Orbit`,
      enteringLabel: `${labelName} - Inner Orbit`,
      edgeDist: dist - orbitRadii.inner,
      approachRange: ZONE_APPROACH_DISTANCE,
      priority: zonePriority.planet_inner
    });
    zones.push({
      key: `planet-${planet.id || planet.name || index}-outer`,
      id: 'planet_outer',
      label: `${labelName} - Outer Orbit`,
      enteringLabel: `${labelName} - Outer Orbit`,
      edgeDist: dist - orbitRadii.outer,
      approachRange: ZONE_APPROACH_DISTANCE,
      priority: zonePriority.planet_outer
    });
  }

  const pirateStation = mercMission?.station;
  if (pirateStation) {
    const orbitRadii = pirateOrbitRadii();
    const dx = pos.x - pirateStation.x;
    const dy = pos.y - pirateStation.y;
    const dist = Math.hypot(dx, dy);
    const labelName = formatPirateOrbitLabel(pirateStation);
    if (Number.isFinite(orbitRadii.inner)) {
      zones.push({
        key: `pirate-${pirateStation.id || 'station'}-inner`,
        id: 'pirate_inner',
        label: `${labelName} - Inner Orbit`,
        enteringLabel: `${labelName} - Inner Orbit`,
        edgeDist: dist - orbitRadii.inner,
        approachRange: ZONE_APPROACH_DISTANCE,
        priority: zonePriority.pirate_inner
      });
    }
    if (Number.isFinite(orbitRadii.outer)) {
      zones.push({
        key: `pirate-${pirateStation.id || 'station'}-outer`,
        id: 'pirate_outer',
        label: `${labelName} - Outer Orbit`,
        enteringLabel: `${labelName} - Outer Orbit`,
        edgeDist: dist - orbitRadii.outer,
        approachRange: ZONE_APPROACH_DISTANCE,
        priority: zonePriority.pirate_outer
      });
    }
  }

  const sunRadius = Math.max(10, (SUN.r || 0) * 2);
  const sunDist = Math.hypot(pos.x - SUN.x, pos.y - SUN.y);
  const sunEdge = sunDist - sunRadius;
  zones.push({
    key: 'sun',
    id: 'sun',
    label: 'Sun',
    enteringLabel: 'Entering Sun',
    edgeDist: sunEdge,
    approachRange: ZONE_APPROACH_DISTANCE,
    priority: zonePriority.sun
  });

  if (ASTEROID_BELT) {
    const radial = sunDist;
    const inner = ASTEROID_BELT.inner;
    const outer = ASTEROID_BELT.outer;
    const inside = radial >= inner && radial <= outer;
    const edgeDist = inside
      ? Math.min(radial - inner, outer - radial) * -1
      : Math.min(Math.abs(radial - inner), Math.abs(radial - outer));
    zones.push({
      key: 'asteroid-belt',
      id: 'asteroid_belt',
      label: 'Asteroid Belt',
      enteringLabel: 'Entering Asteroid Belt',
      edgeDist,
      approachRange: ZONE_APPROACH_DISTANCE,
      priority: zonePriority.asteroid_belt
    });
  }

  const insideZones = zones.filter(z => z.edgeDist <= 0);
  insideZones.sort((a, b) => (b.priority - a.priority) || (Math.abs(a.edgeDist) - Math.abs(b.edgeDist)));
  let current = insideZones[0] || makeInterplanetaryZone();

  const approachCandidates = zones
    .filter(z => z.edgeDist > 0 && z.edgeDist <= z.approachRange)
    .sort((a, b) => a.edgeDist - b.edgeDist);
  const approaching = approachCandidates[0] || null;

  return { current: enhanceZoneDescriptor(current), approaching: enhanceZoneDescriptor(approaching) };
}

function pushZoneMessage(text, duration = 3.5){
  zoneState.messages.push({ text, life: duration, maxLife: duration });
}

function updateZoneMessages(dt){
  for (const msg of zoneState.messages) {
    msg.life -= dt;
  }
  zoneState.messages = zoneState.messages.filter(msg => msg.life > 0);
}

function updateZoneState(dt){
  const prevZoneKey = zoneState.current?.key || zoneState.lastZoneKey;
  const prevZoneId = zoneState.current?.id || zoneState.lastZoneId;
  const detection = detectZones(ship.pos);
  zoneState.current = detection.current;
  zoneState.approaching = detection.approaching;

  if (!zoneState.initialized) {
    zoneState.lastZoneKey = zoneState.current?.key || null;
    zoneState.lastZoneId = zoneState.current?.id || null;
    zoneState.initialized = true;
  } else if (zoneState.current && zoneState.current.key !== zoneState.lastZoneKey) {
    if (zoneState.current.label) pushZoneMessage(zoneState.current.label);
    zoneState.lastZoneKey = zoneState.current.key;
  }

  handleZoneTransition(prevZoneId, zoneState.current?.id || null);
  zoneState.lastZoneId = zoneState.current?.id || zoneState.lastZoneId;

  const approachKey = zoneState.approaching?.key || null;
  if (
    zoneState.initialized &&
    approachKey &&
    approachKey !== zoneState.lastApproachKey &&
    approachKey !== zoneState.current?.key &&
    approachKey !== prevZoneKey
  ){
    if (zoneState.approaching?.enteringLabel) pushZoneMessage(zoneState.approaching.enteringLabel);
  }
  zoneState.lastApproachKey = approachKey;

  updateZoneMessages(dt);
}

function handleZoneTransition(prevZoneId, currentZoneId){
  if (currentZoneId === 'pirate_outer' && prevZoneId !== 'pirate_outer') {
    enterPirateOuterOrbit();
  }
  if (currentZoneId === 'pirate_inner' && prevZoneId !== 'pirate_inner') {
    enterPirateInnerOrbit();
  }
}


const ASTEROID_BELT = (() => {
  const AU_TO_WORLD = getAuToWorldUnits();
  const neptuneBelt = (() => {
    const neptune = planets.find(p => p.id === 'neptune' || p.name === 'neptune');
    if (!neptune || !Number.isFinite(neptune.orbitAU)) return null;
    const beltAU = neptune.orbitAU + 3;
    const beltWidthAU = WORLD_BELT_WIDTH_AU;
    const mid = beltAU * AU_TO_WORLD;
    const inner = Math.max(50, mid - (beltWidthAU * AU_TO_WORLD) / 2);
    const outer = mid + (beltWidthAU * AU_TO_WORLD) / 2;
    return { inner, outer, mid };
  })();
  if (neptuneBelt) return neptuneBelt;

  const innerPlanet = planets[3];
  const outerPlanet = planets[4];
  if (innerPlanet && outerPlanet && innerPlanet.orbitRadius && outerPlanet.orbitRadius) {
    const r1 = innerPlanet.orbitRadius;
    const r2 = outerPlanet.orbitRadius;
    const inner = r1 + 0.25 * (r2 - r1);
    const outer = r1 + 0.55 * (r2 - r1);
    return { inner, outer, mid: (inner + outer) / 2 };
  }
  return null;
})();

const STATION_STYLES = ['ringGate','hexHub','triRing','solarPetals','shipyard','tradeSpindle'];

let stations = planets.map(pl => {
  const orbitRadius = pl.r + 300;
  const angle = Math.random() * Math.PI * 2;
  const periodHours = 12; // stacja okrąża planetę w 12h
  const speed = (2 * Math.PI) / (periodHours * 3600);
  const x = pl.x + Math.cos(angle) * orbitRadius;
  const y = pl.y + Math.sin(angle) * orbitRadius;
  const r = 120;
  const portOffset = r + 40;
  const gateOffset = 220;
  const warpGate = { x: x + gateOffset, y, offset: { x: gateOffset, y: 0 } };
  const ports = [
    {x: portOffset, y: 0},
    {x: 0, y: portOffset},
    {x: -portOffset, y: 0},
    {x: 0, y: -portOffset}
  ];
  const style = STATION_STYLES[Math.floor(Math.random()*STATION_STYLES.length)];
  return {
    id: pl.id,
    planet: pl,
    orbitRadius,
    angle,
    speed,
    r,
    baseR: r,
    x,
    y,
    ports,
    style,
    warpGate
  };
});
window.stations = stations;
window.USE_STATION_3D = true;
if (window.__setStation3DScale) {
  window.__lastStationScale = 1;
  if (window.Dev && typeof Dev.station3DScale === 'number') {
    __setStation3DScale(Dev.station3DScale);
  }
}

if (!hasSavedShipPosition) {
  const earthStation = stations.find(st => st.id === 'earth');
  if (earthStation) {
    const dockOffset = earthStation.ports?.[0] || { x: earthStation.r + 40, y: 0 };
    const dockDir = Math.atan2(dockOffset.y, dockOffset.x);
    const dockDist = Math.hypot(dockOffset.x, dockOffset.y);
    const spawnGap = 140;
    const spawnPos = {
      x: earthStation.x + Math.cos(dockDir) * (dockDist + spawnGap),
      y: earthStation.y + Math.sin(dockDir) * (dockDist + spawnGap)
    };

    ship.pos.x = spawnPos.x;
    ship.pos.y = spawnPos.y;
    ship.vel.x = 0;
    ship.vel.y = 0;

    camera.x = spawnPos.x;
    camera.y = spawnPos.y;
    camera.targetX = spawnPos.x;
    camera.targetY = spawnPos.y;

    overlayView.center.x = spawnPos.x;
    overlayView.center.y = spawnPos.y;
  }
}

// oznacz stacje wewnątrz pasa asteroid
(() => {
  if (ASTEROID_BELT) {
    const beltRadius = ASTEROID_BELT.mid;
    for (const st of stations) st.inner = st.orbitRadius < beltRadius;
  } else {
    for (const st of stations) st.inner = true;
  }
})();

// Warp routes between stations
let warpRoutes = {};
function initWarpRoutes(){
  warpRoutes = {};
  for(const from of stations){
    for(const to of stations){
      if(from.id === to.id) continue;
      if(from.inner !== to.inner) continue;
      const sx = from.warpGate?.x ?? from.x;
      const sy = from.warpGate?.y ?? from.y;
      const ex = to.warpGate?.x ?? to.x;
      const ey = to.warpGate?.y ?? to.y;
      const dx = ex - sx;
      const dy = ey - sy;
      const dist = Math.hypot(dx, dy) || 1;
      warpRoutes[from.id + '-' + to.id] = {
        from: from.id,
        to: to.id,
        fromRef: from,
        toRef: to,
        start: { x: sx, y: sy, queues: [[], []] },
        end: { x: ex, y: ey },
        dir: { x: dx / dist, y: dy / dist },
        length: dist
      };
    }
  }
}
function getWarpRoute(fromId, toId){ return warpRoutes[fromId + '-' + toId]; }
initWarpRoutes();

let npcs = [];
window.npcs = npcs;
// === SQUAD SYSTEM ===
const SQUADS = [];
class Squad {
  constructor(team, type) {
    this.id = Math.random().toString(36).substr(2, 9);
    this.team = team; // 'player' lub 'pirate'
    this.type = type; // 'fighter', 'capital'
    this.units = [];
    this.leader = null;
    this.targetSquad = null;
    this.state = 'guard'; // guard, engage, return
  }
  addUnit(u) {
    this.units.push(u);
    u.squad = this;
    // Formacja "Chevron" (strzałka)
    const idx = this.units.length - 1;
    if (idx === 0) {
      this.leader = u;
      u.formationOffset = { x: 0, y: 0 };
    } else {
      // Prosta matematyka formacji: co drugi w lewo/prawo i do tyłu
      const row = Math.floor((idx + 1) / 2);
      const side = (idx % 2 === 0) ? 1 : -1;
      u.formationOffset = { x: -row * 40, y: side * row * 30 };
    }
  }
  update() {
    // Usuń martwe jednostki
    this.units = this.units.filter(u => !u.dead);
    if (this.leader && this.leader.dead) {
      this.leader = this.units[0] || null; // Promocja nowego lidera
    }
  }
}

function stationLaunchPose(station, idx){
  const dirs = [
    { x: 1, y: 0 },
    { x:-1, y: 0 },
    { x: 0, y: 1 },
    { x: 0, y:-1 }
  ];
  const dir = dirs[idx % dirs.length];
  const offset = (station.r || 40) + 50;
  const launchSpeed = 120;
  return {
    x: station.x + dir.x * offset,
    y: station.y + dir.y * offset,
    vx: dir.x * launchSpeed,
    vy: dir.y * launchSpeed
  };
}
const MISSION_NPCS = [];
let mercMission = null;
const missionCompleteBanner = {
  active: false,
  text: '',
  timer: 0,
  duration: 5,
  fadeIn: 0.75,
  fadeOut: 1.25,
  trigger(text){
    this.text = text;
    this.timer = 0;
    this.active = true;
  },
  update(dt){
    if(!this.active) return;
    this.timer += dt;
    if(this.timer >= this.duration){
      this.active = false;
      this.timer = 0;
    }
  },
  alpha(){
    if(!this.active) return 0;
    const { timer, duration, fadeIn, fadeOut } = this;
    if(timer < fadeIn){
      const t = clamp(timer / fadeIn, 0, 1);
      return 1 - Math.pow(1 - t, 3);
    }
    if(timer > duration - fadeOut){
      const t = clamp((duration - timer) / fadeOut, 0, 1);
      return t * t * t;
    }
    return 1;
  },
  progress(){
    if(!this.active) return 0;
    return clamp(this.timer / Math.max(0.0001, this.duration), 0, 1);
  }
};

// === Missions / Journal ===
const MISSIONS = {
  active: [],   // {id, title, type, stationId?, pos:{x,y}, status:'active'|'completed'}
  show: false
};

function spawnMissionFighter(pos){
  const n = makeNPCBase(pos, { hp: 120, accel: 90, maxSpeed: 540, turn: 4.0, radius: 22 });
  n.type = 'pirate';
  n.color = '#ff5533';
  n.isPirate = true;
  n.fighter = true;
  n.ai = function(dt){
    chaseEvadeAI(n, ship, { strafe:true });
  };
  n.mission = true;
  npcs.push(n);
}

function makeNPCBase(pos, stats){
  stats = stats || {};
  return {
    x: pos.x, y: pos.y,
    vx: 0, vy: 0,
    angle: 0,
    hp: stats.hp || 100,
    maxHp: stats.hp || 100,
    accel: stats.accel || 0,
    maxSpeed: stats.maxSpeed || 0,
    turn: stats.turn || 0,
    radius: stats.radius || 20,
    isCollidable: stats.isCollidable !== false,
    dead: false,
    ai: null,
    weapons: {}
  };
}

const SUPPORT_SHIP_TEMPLATES = {
  fighter: {
    color: '#7cff91',
    count: 9,
    stats: { hp: 120, accel: 280, maxSpeed: 540, turn: 5.4, radius: 12 },
    spawnOffset: { x: -60, y: 0 },
    configure(npc, idx){
      npc.fighter = true;
      npc.gun = 'laserS';
      npc.msl = 'AF';
      npc.mslAmmo = 2;
      npc.gunCD = 0;
      npc.mslCD = 0;
      npc.engines = npc.engines || [{ x: -10, y: -6 }, { x: -10, y: 6 }];
      npc.state = 'guard';
      npc._supportIndex = idx;
    }
  },
  frigate_pd: {
    color: '#9ab8ff',
    stats: { hp: 1200, accel: 60, maxSpeed: 280, turn: 1.2, radius: 45 },
    spawnOffset: { x: -120, y: -40 },
    configure(npc){
      npc.pd = 'pd_mk1';
      npc.mainGun = 'm_autocannon';
      npc.preferredRange = 760;
      npc.msl = 'AS';
      npc.mslAmmo = 2;
      npc.keepAngle = true;
    }
  },
  frigate_laser: {
    color: '#8fe0ff',
    stats: { hp: 1200, accel: 60, maxSpeed: 280, turn: 1.2, radius: 45 },
    spawnOffset: { x: -120, y: 40 },
    configure(npc){
      npc.pd = 'pd_laser';
      npc.mainGun = 'm_beam';
      npc.preferredRange = 920;
      npc.msl = 'HE';
      npc.mslAmmo = 2;
      npc.keepAngle = true;
    }
  },
  destroyer: {
    color: '#aac8ff',
    stats: { hp: 3200, accel: 70, maxSpeed: 240, turn: 0.9, radius: 70, friction: 0.995 },
    spawnOffset: { x: -160, y: 0 },
    configure(npc){
      npc.isCapitalShip = true;
      npc.mGun = 'm_rail';
      npc.pd = 'pd_mk1';
      npc.boostDur = 2.8;
      npc.preferredRange = 820;
      npc.keepAngle = true;
    }
  },
  battleship: {
    color: '#c8d4ff',
    stats: { hp: 5200, accel: 55, maxSpeed: 190, turn: 0.6, radius: 110, friction: 0.995 },
    spawnOffset: { x: -190, y: 0 },
    configure(npc){
      npc.isCapitalShip = true;
      npc.pd = 'pd_laser';
      npc.preferredRange = 780;
      npc.keepAngle = true;
    }
  }
};

function spawnSupportShip(templateKey){
  const template = SUPPORT_SHIP_TEMPLATES[templateKey];
  if (!template) return [];
  const created = [];
  const count = Math.max(1, template.count || 1);
  for (let i = 0; i < count; i++){
    const jitter = (Math.random() * 12 - 6);
    const offset = {
      x: (template.spawnOffset?.x || -60) + jitter,
      y: (template.spawnOffset?.y || 0) + ((i % SUPPORT_FORMATION.perRow) - 1.5) * 8
    };
    const rotated = rotate(offset, ship.angle);
    const spawnPos = { x: ship.pos.x + rotated.x, y: ship.pos.y + rotated.y };
    const npc = makeNPCBase(spawnPos, template.stats || {});
    npc.friendly = true;
    npc.mission = true;
    npc.color = template.color || '#7cff91';
    npc.type = templateKey;
    npc.vx = ship.vel?.x ?? npc.vx;
    npc.vy = ship.vel?.y ?? npc.vy;
    npc.supportData = { npc, type: templateKey, slotIndex: SupportWing.units.length + created.length };
    template.configure?.(npc, i);
    npc.ai = dt => runSupportAI(npc, dt);
    SupportWing.units.push(npc.supportData);
    npcs.push(npc);
    created.push(npc);
  }
  return created;
}

const CAPITAL_SHIP_TEMPLATES = {
  carrier: {
    id: 'capital_carrier',
    displayName: 'CSV Aegis',
    roleText: 'Carrier · Capital',
    hull: 42000,
    shield: 28000,
    shieldRegen: 260,
    shieldDelay: 6,
    accel: 32,
    maxSpeed: 220,
    turn: 0.9,
    radius: 150,
    hardpoints: { large: 2, medium: 2 },
    fighters: 100,
    formationOffset: { x: -820, y: 380 },
    fighterLaunchBatch: 100,
    fighterLaunchInterval: 0.12,
    weaponRange: 2300,
    weapons: {
      mainCannons: [
        { id: 'port',   offset: { x: 0.42, y: -0.18 }, cooldown: 3.4, projectileSpeed: 1700, damage: 210, spread: 0.0038, arc: Math.PI / 2.2 },
        { id: 'starboard', offset: { x: 0.42, y: 0.18 }, cooldown: 3.4, projectileSpeed: 1700, damage: 210, spread: 0.0038, arc: Math.PI / 2.2 }
      ],
      dorsalBatteries: [
        { id: 'dorsal', offset: { x: 0.18, y: 0 }, cooldown: 1.6, projectileSpeed: 1300, damage: 38, spread: 0.012, arc: Math.PI / 1.6 }
      ]
    },
    profile: {
      lengthScale: 3.6,
      widthScale: 1.45,
      hullColor: '#5a7dbe',
      deckColor: '#243150',
      accentColor: '#9dc5ff',
      engineColor: 'rgba(130,200,255,0.9)',
      hangarGlow: 'rgba(160,200,255,0.45)',
      spriteSrc: 'assets/carrier.png',
      spriteScale: 1.05,
      spriteRotation: Math.PI / 2,
      spriteOffset: { x: 0, y: 0 },
      spriteLayer: 2,
      spriteEngineGlow: false,
      engineOffsets: [
        { x: -0.38, y: 0.84 },
        { x: 0, y: 0.88 },
        { x: 0.38, y: 0.84 }
      ],
      engineGlowSize: 0.28,
      engineOffsetMode: 'relative'
    }
  }
};

Fleet.templates = Object.assign(Fleet.templates || {}, { capital: CAPITAL_SHIP_TEMPLATES });

function addFleetShip(entry){
  if (!entry || !entry.entity) return null;
  Fleet.ships.push(entry);
  npcs.push(entry.entity);
  markFleetDirty();
  return entry;
}

function createCapitalShipEntry(templateKey, overrides = {}){
  const template = CAPITAL_SHIP_TEMPLATES[templateKey];
  if (!template) return null;
  const offset = overrides.formationOffset || template.formationOffset || { x: -820, y: 420 };
  const basePos = overrides.pos || { x: ship.pos.x + offset.x, y: ship.pos.y + offset.y };

  const npc = makeNPCBase(basePos, {
    hp: template.hull,
    accel: template.accel,
    maxSpeed: template.maxSpeed,
    turn: template.turn,
    radius: template.radius
  });

  npc.hp = template.hull;
  npc.maxHp = template.hull;
  npc.radius = template.radius;
  npc.friendly = true;
  npc.mission = true;
  npc.type = template.id;
  npc.color = template.profile?.accentColor || '#9ccfff';
  npc.isCapitalShip = true;
  npc.capitalProfile = Object.assign({
    lengthScale: 3.4,
    widthScale: 1.4
  }, template.profile || {});
  if (npc.capitalProfile.spriteSrc) {
    npc.capitalSprite = getCapitalShipSprite(npc.capitalProfile.spriteSrc);
  }
  npc.shield = {
    val: template.shield,
    max: template.shield,
    regenRate: template.shieldRegen,
    regenDelay: template.shieldDelay,
    regenTimer: 0
  };
  npc.hardpoints = { large: template.hardpoints.large, medium: template.hardpoints.medium };
  npc.fleetFormationOffset = offset;
  npc.vx = 0;
  npc.vy = 0;
  npc.angle = Math.atan2(ship.pos.y - npc.y, ship.pos.x - npc.x);
  npc.desiredAngle = npc.angle;
  npc.keepAngle = true;
  npc.drawLayer = template.profile?.spriteLayer ?? 0;
  npc.carrierWeapons = createCarrierWeaponSystems(template.weapons || {});

  const entry = {
    id: overrides.id || `fleet_${templateKey}_${Math.random().toString(36).slice(2,8)}`,
    type: templateKey,
    displayName: overrides.displayName || template.displayName,
    roleText: overrides.roleText || template.roleText,
    entity: npc,
    hardpoints: { large: template.hardpoints.large, medium: template.hardpoints.medium },
    fighters: {
      capacity: template.fighters,
      ready: template.fighters,
      deployed: 0
    },
    status: {
      hull: template.hull,
      hullMax: template.hull,
      shield: template.shield,
      shieldMax: template.shield
    },
    template
  };

  entry.fighterWing = createCarrierWing(entry, template);
  entry.fighterMode = entry.fighterWing.order;

  npc.fleetEntry = entry;
  npc.ai = dt => updateCapitalCarrier(entry, dt);

  return entry;
}

const CARRIER_DEFAULT_LAUNCH_BATCH = 12;
const CARRIER_DEFAULT_LAUNCH_INTERVAL = 0.12;
const CARRIER_DEFAULT_WEAPON_RANGE = 2200;
const CARRIER_FIGHTER_RETURN_RADIUS = 120;
const CARRIER_FIGHTER_SOFT_RETURN_RADIUS = 320;
const CARRIER_FIGHTER_ATTACK_RANGE = 1400;
const CARRIER_FIGHTER_REJOIN_TIME = 8;

function createCarrierWeaponSystems(cfg){
  const systems = { mainCannons: [], dorsalBatteries: [] };
  if (cfg && Array.isArray(cfg.mainCannons)){
    for (const weapon of cfg.mainCannons){
      systems.mainCannons.push({
        id: weapon.id || `main_${systems.mainCannons.length}`,
        offset: weapon.offset || { x: 0, y: 0 },
        cooldown: Math.max(0.2, weapon.cooldown || 3.0),
        timer: 0,
        projectileSpeed: weapon.projectileSpeed || 1600,
        damage: weapon.damage || 180,
        spread: weapon.spread || 0,
        arc: weapon.arc || Math.PI / 2,
        muzzleForward: weapon.muzzleForward ?? 0.12,
        type: 'main'
      });
    }
  }
  if (cfg && Array.isArray(cfg.dorsalBatteries)){
    for (const weapon of cfg.dorsalBatteries){
      systems.dorsalBatteries.push({
        id: weapon.id || `aux_${systems.dorsalBatteries.length}`,
        offset: weapon.offset || { x: 0, y: 0 },
        cooldown: Math.max(0.1, weapon.cooldown || 1.4),
        timer: 0,
        projectileSpeed: weapon.projectileSpeed || 1100,
        damage: weapon.damage || 28,
        spread: weapon.spread || 0.01,
        arc: weapon.arc || Math.PI / 1.6,
        muzzleForward: weapon.muzzleForward ?? 0.06,
        type: 'aux'
      });
    }
  }
  return systems;
}

function createCarrierWing(entry, template = {}){
  const wing = {
    entry,
    order: 'guard',
    list: [],
    launchBatch: Math.max(1, Math.round(template.fighterLaunchBatch || CARRIER_DEFAULT_LAUNCH_BATCH)),
    launchInterval: Math.max(0.05, template.fighterLaunchInterval || CARRIER_DEFAULT_LAUNCH_INTERVAL),
    launchPending: 0,
    launchCooldown: 0,
    autoReturnActive: false,
    autoResumeOrder: null,
    lastManualOrder: 'guard',
    targetRange: template.weaponRange || CARRIER_DEFAULT_WEAPON_RANGE,
    nextFormIndex: 0,
    primaryTarget: null
  };
  return wing;
}

function ensureCarrierWing(entry){
  if (!entry) return null;
  if (!entry.fighterWing){
    entry.fighterWing = createCarrierWing(entry, entry.template || {});
    entry.fighterMode = entry.fighterWing.order;
  }
  return entry.fighterWing;
}

// === NOWY SPAWNER DLA LOTNISKOWCA (FRIENDLY CARRIER) ===
function spawnCarrierFighter(entry){
  const wing = ensureCarrierWing(entry);
  if (!wing || !entry || !entry.entity) return null;
  if (!entry.fighters || entry.fighters.ready <= 0) return null;

  const carrier = entry.entity;
  
  // 1. Pozycja startowa
  const formIndex = wing.nextFormIndex % 8; 
  wing.nextFormIndex = (wing.nextFormIndex + 1) % 8;
  const spawnOff = rotate({x: -20, y: 0}, carrier.angle);
  const spawnPos = { x: carrier.x + spawnOff.x, y: carrier.y + spawnOff.y };

  // 2. Fizyka (Parametry z AI SPACE - szybkie i zwrotne)
  const f = makeNPCBase(spawnPos, {
    hp: 120, accel: 280, maxSpeed: 540, turn: 5.5, radius: 12
  });

  // 3. Konfiguracja Bojowa
  f.friendly = true;
  f.mission = true; 
  f.fighter = true;
  f.color = '#7cff91'; // Zielony sojusznik
  f.vx = carrier.vx;
  f.vy = carrier.vy;
  
  // Nowa broń (Laser + Rakiety)
  f.gun = 'laserS'; 
  f.msl = 'AF'; f.mslAmmo = 2;
  f.gunCD = 0; f.mslCD = 0;
  
  // 4. Formacja (Względem GRACZA - leader: ship)
  const row = Math.floor((formIndex + 1) / 2);
  const side = (formIndex % 2 === 0) ? 1 : -1;
  f.formationOffset = { x: -row * 50 - 100, y: side * row * 40 };
  
  f.squad = { leader: carrier, type: 'fighter' }; 

  // 5. MÓZG (Adapter AI)
  f.carrierWing = wing;
  f.carrierEntry = entry;
  f.ai = (dt) => runCarrierFighterAdapter(f, dt);
  
  // Liczniki
  f.id = `carrier_fighter_${Math.random().toString(36).slice(2, 8)}`;
  entry.fighters.ready = Math.max(0, entry.fighters.ready - 1);
  entry.fighters.deployed = Math.min(entry.fighters.capacity, (entry.fighters.deployed || 0) + 1);
  wing.list.push(f);
  markFleetDirty();

  npcs.push(f);
  return f;
}

// --- ADAPTER INTELIGENCJI CARRIERA ---
function runCarrierFighterAdapter(npc, dt) {
  const wing = npc.carrierWing;
  if (!wing) { npc.dead = true; return; }

  // A. DOKOWANIE (RETURN)
  if (wing.order === 'return' || npc.orderOverride === 'return') {
     const carrier = wing.entry.entity;
     if(!carrier || carrier.dead) { npc.dead = true; return; }

     const dx = carrier.x - npc.x, dy = carrier.y - npc.y;
     const dist = Math.hypot(dx, dy);
     const dir = norm({x:dx, y:dy});
     
     const turned = clampTurnVec(npc.vx, npc.vy, dir.x*npc.maxSpeed, dir.y*npc.maxSpeed, dt, 220);
     npc.vx = turned.vx; npc.vy = turned.vy;
     npc.angle = Math.atan2(npc.vy, npc.vx);

     if(dist < 80) {
        npc.dead = true; 
        npc._counted = false; 
        npc.recalled = true; 
     }
     // WAŻNE: Kończymy tu, żeby AI nie nadpisało ruchu
     return; 
  }

  // B. GUARD
  if (wing.order === 'guard') {
     const target = window.aiPickBestTarget ? window.aiPickBestTarget(npc, 3000) : null;
     const dist = target ? Math.hypot(target.x - npc.x, target.y - npc.y) : Infinity;
     // Jeśli nie ma wrogów blisko, wymuś stan 'guard' w nowym AI
     if (dist > 1200) {
        npc.state = 'guard';
     }
  }

  // C. URUCHOM NOWE AI
  if (window.runAdvancedFighterAI) {
     window.runAdvancedFighterAI(npc, dt);
  }
  
  // D. EFEKTY
  if (window.spawnCarrierFighterEngines) {
     window.spawnCarrierFighterEngines(npc);
  }
}

function spawnCarrierFighterEngines(fighter){
  const ang = Math.atan2(fighter.vy, fighter.vx);
  for (const e of fighter.engines){
    const eo = rotate(e, ang + Math.PI);
    spawnParticle(
      { x: fighter.x + eo.x, y: fighter.y + eo.y },
      { x: fighter.vx - Math.cos(ang) * 60, y: fighter.vy - Math.sin(ang) * 60 },
      0.08,
      '#cfe7ff',
      0.7
    );
  }
}

function updateCarrierWing(entry, dt){
  const wing = ensureCarrierWing(entry);
  if (!wing) return;
  wing.launchCooldown = Math.max(0, (wing.launchCooldown || 0) - dt);

  if (wing.launchPending > 0 && wing.launchCooldown <= 0 && entry.fighters.ready > 0){
    spawnCarrierFighter(entry);
    wing.launchPending = Math.max(0, wing.launchPending - 1);
    wing.launchCooldown = wing.launchInterval;
  }

  if (wing.order !== 'return' && wing.launchPending <= 0 && entry.fighters){
    const capacity = entry.fighters.capacity || 0;
    const deployed = entry.fighters.deployed || 0;
    if (deployed < capacity && entry.fighters.ready > 0){
      const pending = Math.min(entry.fighters.ready, wing.launchBatch || entry.fighters.ready);
      if (pending > 0){
        wing.launchPending = pending;
        wing.launchCooldown = 0;
      }
    }
  }

  if (wing.primaryTarget && wing.primaryTarget.dead){
    wing.primaryTarget = null;
  }

  if (entry.fighters){
    entry.fighters.ready = clamp(entry.fighters.ready, 0, entry.fighters.capacity ?? entry.fighters.ready);
    entry.fighters.deployed = clamp(entry.fighters.deployed, 0, entry.fighters.capacity ?? entry.fighters.deployed);
  }
}

function selectCarrierTarget(entry){
  const wing = ensureCarrierWing(entry);
  if (!wing || wing.order === 'return') return null;
  const carrier = entry.entity;
  const range = wing.targetRange || CARRIER_DEFAULT_WEAPON_RANGE;

  if (wing.primaryTarget && isHostileNpc(wing.primaryTarget)){
    const dist = Math.hypot(wing.primaryTarget.x - carrier.x, wing.primaryTarget.y - carrier.y);
    if (dist <= range * 1.15){
      return wing.primaryTarget;
    }
  } else if (wing.primaryTarget && !isHostileNpc(wing.primaryTarget)) {
    wing.primaryTarget = null;
  }

  let anchorX, anchorY;
  if (wing.order === 'guard'){
    anchorX = ship.pos.x;
    anchorY = ship.pos.y;
  } else {
    anchorX = carrier.x;
    anchorY = carrier.y;
  }

  const focusCandidates = [];
  for (const target of lockedTargets){
    if (isHostileNpc(target) && !focusCandidates.includes(target)){
      focusCandidates.push(target);
    }
  }
  if (lockedTarget && isHostileNpc(lockedTarget) && !focusCandidates.includes(lockedTarget)){
    focusCandidates.push(lockedTarget);
  }

  let focus = null;
  let focusDist = Infinity;
  for (const candidate of focusCandidates){
    const dist = Math.hypot(candidate.x - anchorX, candidate.y - anchorY);
    if (dist < focusDist){
      focus = candidate;
      focusDist = dist;
    }
  }

  if (focus && focusDist <= range * 1.2){
    wing.primaryTarget = focus;
    return focus;
  }

  let best = null, bestDist = range;
  for (const npc of npcs){
    if (!npc || npc.dead || npc.friendly) continue;
    const dist = Math.hypot(npc.x - anchorX, npc.y - anchorY);
    if (dist < bestDist){
      best = npc;
      bestDist = dist;
    }
  }
  wing.primaryTarget = best;
  return best;
}

function getCapitalDimensions(npc){
  const profile = npc.capitalProfile || {};
  const radius = npc.radius || 1;
  const length = Math.max(60, radius * (profile.lengthScale || 3.2));
  const width = Math.max(30, radius * (profile.widthScale || 1.2));
  return { length, width, halfL: length * 0.5, halfW: width * 0.5 };
}

function capitalLocalFromNormalized(offset, dims){
  if (!offset) return { x: 0, y: 0 };
  if (offset.absolute) return { x: offset.x || 0, y: offset.y || 0 };
  const nx = Number.isFinite(offset.x) ? offset.x : 0;
  const ny = Number.isFinite(offset.y) ? offset.y : 0;
  return { x: nx * dims.halfL, y: ny * dims.halfW };
}

function updateCarrierWeapons(entry, dt, order, target){
  const npc = entry.entity;
  if (!npc || !npc.carrierWeapons) return;
  const profile = npc.capitalProfile || {};
  const dims = getCapitalDimensions(npc);
  const rotation = (npc.angle || 0) + (profile.spriteRotation || 0);
  const systems = npc.carrierWeapons;
  const range = entry.template?.weaponRange || CARRIER_DEFAULT_WEAPON_RANGE;
  const shouldFire = !!target && order !== 'return';

  const fireWeapon = (weapon, type) => {
    weapon.timer = Math.max(0, (weapon.timer || 0) - dt);
    if (!shouldFire || weapon.timer > 0) return;

    const localBase = capitalLocalFromNormalized(weapon.offset, dims);
    const forwardExtra = Number.isFinite(weapon.muzzleForward) ? weapon.muzzleForward * dims.halfL : 0;
    const local = { x: localBase.x + forwardExtra, y: localBase.y };
    const worldOff = rotate(local, rotation);
    const muzzle = { x: npc.x + worldOff.x, y: npc.y + worldOff.y };
    const lead = leadTarget(muzzle, { x: npc.vx, y: npc.vy }, target, weapon.projectileSpeed);
    const aim = Math.atan2(lead.y - muzzle.y, lead.x - muzzle.x);
    const forward = rotate({ x: 1, y: 0 }, rotation);
    const dirToTarget = { x: Math.cos(aim), y: Math.sin(aim) };
    const dot = forward.x * dirToTarget.x + forward.y * dirToTarget.y;
    const angleDiff = Math.acos(clamp(dot, -1, 1));
    const dist = Math.hypot(target.x - muzzle.x, target.y - muzzle.y);
    if (angleDiff > (weapon.arc || Math.PI / 2) * 0.5 || dist > range * 1.1){
      return;
    }

    const jitter = (Math.random() - 0.5) * (weapon.spread || 0);
    const finalAngle = aim + jitter;
    const dir = { x: Math.cos(finalAngle), y: Math.sin(finalAngle) };
    const speed = weapon.projectileSpeed || 1500;
    const life = Math.max(0.6, (range / speed) * 1.15);
    const bullet = {
      x: muzzle.x,
      y: muzzle.y,
      vx: dir.x * speed + npc.vx,
      vy: dir.y * speed + npc.vy,
      life,
      r: type === 'main' ? 6 : 3,
      owner: 'player',
      damage: weapon.damage || (type === 'main' ? 180 : 32),
      type: type === 'main' ? 'armata' : 'autocannon',
      penetration: type === 'main' ? 2 : 0,
      source: npc,
      effectScale: type === 'main' ? 1.2 : 0.9
    };
    window.bullets.push(bullet);
    if (type === 'main'){
      spawnRailMuzzle(muzzle, dir, { x: npc.vx, y: npc.vy }, 1.2);
      camera.addShake(6, 0.15);
    } else {
      spawnAutocannonMuzzle(muzzle, dir, { x: npc.vx, y: npc.vy }, 0.9);
    }
    weapon.timer = weapon.cooldown || 2.5;
  };

  if (Array.isArray(systems.mainCannons)){
    for (const weapon of systems.mainCannons){
      fireWeapon(weapon, 'main');
    }
  }
  if (Array.isArray(systems.dorsalBatteries)){
    for (const weapon of systems.dorsalBatteries){
      fireWeapon(weapon, 'aux');
    }
  }
}

function spawnCarrierEngineFx(entry){
  const npc = entry.entity;
  if (!npc || !npc.capitalProfile) return;
  const profile = npc.capitalProfile;
  const offsets = Array.isArray(profile.engineOffsets) ? profile.engineOffsets : null;
  if (!offsets || !offsets.length) return;

  const dims = getCapitalDimensions(npc);
  const rotation = (npc.angle || 0) + (profile.spriteRotation || 0);
  const speed = Math.hypot(npc.vx || 0, npc.vy || 0);
  const thrust = clamp(speed / Math.max(1, npc.maxSpeed || 1), 0, 1);
  if (thrust < 0.05 && speed < 12) return;

  const dir = rotate({ x: -1, y: 0 }, rotation);
  const glowScale = Number.isFinite(profile.engineGlowSize) ? profile.engineGlowSize : 0.24;
  const baseRadius = Math.max(6, npc.radius * glowScale * 0.32);

  for (const offset of offsets){
    const local = capitalLocalFromNormalized(offset, dims);
    const worldOff = rotate(local, rotation);
    const pos = { x: npc.x + worldOff.x, y: npc.y + worldOff.y };
    const intensity = 0.32 + thrust * 0.55;
    const particleSize = clamp(baseRadius * (0.7 + thrust * 0.9), 6, npc.radius * 0.3);
    const particleLife = 0.16 + thrust * 0.14;
    const vel = {
      x: npc.vx - dir.x * (100 + thrust * 220),
      y: npc.vy - dir.y * (100 + thrust * 220)
    };
    const color = `rgba(135,205,255,${intensity})`;
    spawnParticle(pos, vel, particleLife, color, particleSize, false);
  }
}

function cleanupCarrierFighters(){
  if (!Fleet || !Array.isArray(Fleet.ships)) return;
  for (const entry of Fleet.ships){
    const wing = entry?.fighterWing;
    if (!wing || !Array.isArray(wing.list)) continue;
    for (let i = wing.list.length - 1; i >= 0; i--){
      const fighter = wing.list[i];
      if (!fighter){
        wing.list.splice(i, 1);
        continue;
      }
      if (!fighter.dead) continue;
      if (!fighter._counted){
        entry.fighters.deployed = Math.max(0, (entry.fighters.deployed || 0) - 1);
        if (fighter.recalled){
          entry.fighters.ready = Math.min(entry.fighters.capacity, (entry.fighters.ready || 0) + 1);
        }
        fighter._counted = true;
        markFleetDirty();
      }
      wing.list.splice(i, 1);
      const idx = npcs.indexOf(fighter);
      if (idx !== -1) npcs.splice(idx, 1);
    }
  }
}

function ensureCarrierWarpDrive(entry){
  if (!entry) return null;
  if (!entry.warpDrive){
    const chargeTime = (warp?.chargeTime || 0.8) * 1.05;
    const entryDuration = (warp?.entryDuration || 0.9) * 1.1;
    entry.warpDrive = {
      state: 'idle',
      charge: 0,
      chargeTime,
      entryDuration,
      entryProgress: 0,
      entryBaseSpeed: 0,
      dir: { x: 1, y: 0 },
      turnRate: (warp?.turnRate || Math.PI / 5) * 0.7,
      alignRate: (warp?.alignRate || Math.PI / 2.5) * 0.8,
      exitProgress: 0,
      exitDuration: 0.8
    };
  }
  return entry.warpDrive;
}

function updateCapitalCarrier(entry, dt){
  const npc = entry?.entity;
  if (!npc || npc.dead) return;

  const wing = ensureCarrierWing(entry);
  const formation = entry.template?.formationOffset || npc.fleetFormationOffset || { x: -800, y: 360 };
  const rotated = rotate(formation, ship.angle);
  const target = { x: ship.pos.x + rotated.x, y: ship.pos.y + rotated.y };
  const toTarget = { x: target.x - npc.x, y: target.y - npc.y };
  const dist = Math.hypot(toTarget.x, toTarget.y);

  const warpDrive = ensureCarrierWarpDrive(entry);
  const playerWarpState = warp.state;
  const shouldWarp = playerWarpState === 'charging' || playerWarpState === 'active';

  if (warpDrive){
    if (!shouldWarp){
      if (warpDrive.state === 'active'){
        warpDrive.state = 'exiting';
        warpDrive.exitProgress = 0;
      } else if (warpDrive.state === 'charging'){
        warpDrive.state = 'idle';
        warpDrive.charge = 0;
      } else if (warpDrive.state === 'exiting'){
        warpDrive.exitProgress = Math.min(1, warpDrive.exitProgress + dt / Math.max(0.001, warpDrive.exitDuration));
        if (warpDrive.exitProgress >= 1){
          warpDrive.state = 'idle';
          warpDrive.charge = 0;
        }
      }
    } else {
      if (warpDrive.state === 'idle'){
        warpDrive.state = 'charging';
        warpDrive.charge = 0;
      } else if (warpDrive.state === 'exiting'){
        warpDrive.state = 'charging';
        warpDrive.exitProgress = 0;
      }
      if (warpDrive.state === 'charging'){
        warpDrive.charge = Math.min(warpDrive.charge + dt, warpDrive.chargeTime);
        if (playerWarpState === 'active' && warpDrive.charge >= warpDrive.chargeTime){
          warpDrive.state = 'active';
          warpDrive.entryProgress = 0;
          warpDrive.entryBaseSpeed = Math.hypot(npc.vx, npc.vy);
          const dir = warp?.dir || { x: Math.cos(npc.angle), y: Math.sin(npc.angle) };
          const mag = Math.hypot(dir.x, dir.y) || 1;
          warpDrive.dir.x = dir.x / mag;
          warpDrive.dir.y = dir.y / mag;
        }
      } else if (warpDrive.state === 'active'){
        if (playerWarpState !== 'active'){
          warpDrive.state = 'exiting';
          warpDrive.exitProgress = 0;
        } else {
          warpDrive.entryProgress = Math.min(1, warpDrive.entryProgress + dt / Math.max(0.001, warpDrive.entryDuration));
          const curAngle = Math.atan2(warpDrive.dir.y, warpDrive.dir.x);
          const targetAngle = Math.atan2(warp.dir.y || 0, warp.dir.x || 1);
          const delta = wrapAngle(targetAngle - curAngle);
          const maxTurn = warpDrive.turnRate * dt;
          const newAngle = curAngle + clamp(delta, -maxTurn, maxTurn);
          warpDrive.dir.x = Math.cos(newAngle);
          warpDrive.dir.y = Math.sin(newAngle);
        }
      }
    }
    if (warpDrive.state !== 'active' && playerWarpState !== 'active'){
      warpDrive.entryProgress = 0;
    }
  }

  const driveState = warpDrive ? warpDrive.state : 'idle';
  let speedLimit = npc.maxSpeed || 0;
  let followGain = 1.3;
  let matchGain = 2.2;
  let dampenClose = true;

  if (driveState === 'charging'){
    followGain = 1.8;
    matchGain = 3.3;
    speedLimit = Math.max(speedLimit, npc.maxSpeed || 0);
  } else if (driveState === 'active'){
    const ramp = warpDrive ? smoothstep01(warpDrive.entryProgress) : 1;
    followGain = 2.6 + 1.2 * ramp;
    matchGain = 3.8 + 1.8 * ramp;
    speedLimit = Math.max(speedLimit, warp.speed * 1.05);
    dampenClose = false;
  } else if (driveState === 'exiting'){
    followGain = 2.2;
    matchGain = 3.0;
    speedLimit = Math.max(speedLimit, Math.hypot(ship.vel.x, ship.vel.y) + 260, npc.maxSpeed || 0);
  }

  const desiredVel = {
    x: ship.vel.x + toTarget.x * followGain,
    y: ship.vel.y + toTarget.y * followGain
  };

  npc.vx += (desiredVel.x - npc.vx) * Math.min(1, matchGain * dt);
  npc.vy += (desiredVel.y - npc.vy) * Math.min(1, matchGain * dt);

  if (dampenClose && dist < 90){
    const slow = Math.exp(-1.5 * dt);
    npc.vx *= slow;
    npc.vy *= slow;
  }

  limitSpeed(npc, speedLimit);

  if (driveState === 'active' && warpDrive){
    const desiredAngle = Math.atan2(warpDrive.dir.y, warpDrive.dir.x);
    const diff = wrapAngle(desiredAngle - npc.angle);
    const maxAlign = warpDrive.alignRate * dt;
    npc.angle = wrapAngle(npc.angle + clamp(diff, -maxAlign, maxAlign));
  } else {
    const spd = Math.hypot(npc.vx, npc.vy);
    if (spd > 1){
      npc.angle = Math.atan2(npc.vy, npc.vx);
    } else {
      const desiredAngle = Math.atan2(ship.pos.y - npc.y, ship.pos.x - npc.x);
      const diff = wrapAngle(desiredAngle - npc.angle);
      const turnLimit = (entry.template?.turn ?? npc.turn ?? 0) * dt;
      npc.angle = wrapAngle(npc.angle + clamp(diff, -turnLimit, turnLimit));
    }
  }
  npc.desiredAngle = npc.angle;

  if (wing){
    if (warp.state === 'charging' || warp.state === 'active'){
      commandCarrierFighters(entry, 'return', { auto: true });
    } else if (wing.autoReturnActive && wing.order === 'return' && wing.list.length === 0 && (entry.fighters.deployed || 0) === 0){
      const resume = wing.autoResumeOrder && wing.autoResumeOrder !== 'return' ? wing.autoResumeOrder : (wing.lastManualOrder || 'guard');
      wing.autoReturnActive = false;
      wing.autoResumeOrder = null;
      if (resume && resume !== 'return'){
        commandCarrierFighters(entry, resume, { force: true, silent: true });
        markFleetDirty();
      }
    }
  }

  updateCarrierWing(entry, dt);
  const attackTarget = selectCarrierTarget(entry);
  if (attackTarget){
    const desiredAngle = Math.atan2(attackTarget.y - npc.y, attackTarget.x - npc.x);
    const diff = wrapAngle(desiredAngle - npc.angle);
    const turnLimit = (entry.template?.turn ?? npc.turn ?? 0) * dt;
    npc.angle = wrapAngle(npc.angle + clamp(diff, -turnLimit, turnLimit));
    npc.desiredAngle = npc.angle;
  }

  updateCarrierWeapons(entry, dt, wing?.order || 'guard', attackTarget);
  spawnCarrierEngineFx(entry);

  const shield = npc.shield;
  if (shield){
    if (shield.regenTimer > 0){
      shield.regenTimer = Math.max(0, shield.regenTimer - dt);
    } else if (shield.val < shield.max){
      const before = shield.val;
      shield.val = Math.min(shield.max, shield.val + shield.regenRate * dt);
      if (Math.abs(before - shield.val) > 0.5){
        entry.status.shield = shield.val;
        markFleetDirty();
      }
    }
    if (Math.abs(entry.status.shield - shield.val) > 0.5){
      entry.status.shield = shield.val;
      markFleetDirty();
    }
  } else if (entry.status.shield !== 0){
    entry.status.shield = 0;
    markFleetDirty();
  }

  if (Math.abs(entry.status.hull - npc.hp) > 0.5){
    entry.status.hull = Math.max(0, npc.hp);
    markFleetDirty();
  }
}

function initFleet(){
  Fleet.ships.length = 0;
  markFleetDirty();
  if (Fleet.ui?.root) Fleet.ui.root.classList.add('hidden');
  const carrier = createCapitalShipEntry('carrier');
  if (carrier) addFleetShip(carrier);
}

function makeRailgun(cfg){ return { ...cfg }; }
function makeRocketPod(cfg){ return { ...cfg }; }
function makeGatling(cfg){ return { ...cfg }; }
function spawnInterceptor(pos){
  const n = makeNPCBase(pos, { hp: 160, accel: 90, maxSpeed: 540, turn: 4.0, radius: 22 });
  n.type = 'interceptor';
  n.ai = function(dt){
    chaseEvadeAI(n, ship, { strafe:true, dodgeRails:true, rocketBurst:false });
  };
  MISSION_NPCS.push(n);
}
function spawnPirate(kind, station) {
  const angle = Math.random() * Math.PI * 2;
  const dist = (station.r || 100) + 150;
  // Obliczamy pozycję startową wokół stacji
  const pos = {
    x: station.x + Math.cos(angle) * dist,
    y: station.y + Math.sin(angle) * dist
  };

  // Statystyki w zależności od typu
  let stats = { hp: 100, accel: 200, maxSpeed: 400, turn: 4.0, radius: 20 };
  if (kind === 'interceptor' || kind === 'fighter') {
    stats = { hp: 80, accel: 280, maxSpeed: 540, turn: 5.5, radius: 12 };
  } else if (kind.includes('frigate')) {
    stats = { hp: 1200, accel: 60, maxSpeed: 280, turn: 1.2, radius: 45 };
  } else if (kind === 'destroyer') {
    stats = { hp: 3200, accel: 70, maxSpeed: 240, turn: 0.9, radius: 70, friction: 0.992 };
  } else if (kind === 'battleship') {
    stats = { hp: 5200, accel: 55, maxSpeed: 190, turn: 0.6, radius: 110, friction: 0.995 };
  }

  // Używamy istniejącego makeNPCBase
  const npc = makeNPCBase(pos, stats);

  // Konfiguracja
  npc.type = kind;
  npc.friendly = false;
  npc.isPirate = true;
  npc.fighter = (kind === 'fighter' || kind === 'interceptor');
  npc.color = '#ff5c7c';
  npc.mission = true; // To ważne, żeby nie znikał po oddaleniu

  // Logika AI
  if (kind === 'interceptor' || kind === 'fighter') {
      npc.fighter = true; 
  }
  if (kind.includes('frigate')) {
    npc.pd = kind === 'frigate_laser' ? 'pd_laser' : 'pd_mk1';
    npc.mainGun = kind === 'frigate_laser' ? 'm_beam' : 'm_autocannon';
    npc.preferredRange = kind === 'frigate_laser' ? 920 : 760;
    npc.msl = kind === 'frigate_laser' ? 'HE' : 'AS';
    npc.mslAmmo = 2;
    npc.home = station;
    npc.size = { w: 120, h: 40 }; // Wymiary dla funkcji rysującej
    npc.forceTarget = ship;
    npc.ai = (dt) => { if(window.aiFrigate) window.aiFrigate(null, npc, dt); };
  } else if (kind === 'destroyer') {
    npc.isCapitalShip = true;
    npc.mGun = 'm_rail';
    npc.pd = 'pd_mk1';
    npc.boostDur = 2.8;
    npc.preferredRange = 820;
    npc.forceTarget = ship;
    npc.ai = (dt) => { if(window.aiDestroyer) window.aiDestroyer(null, npc, dt); };
  } else if (kind === 'battleship') {
    npc.isCapitalShip = true;
    npc.pd = 'pd_laser';
    npc.preferredRange = 780;
    npc.forceTarget = ship;
    npc.ai = (dt) => { if(window.aiBattleship) window.aiBattleship(null, npc, dt); };
  } else {
    npc.gun = 'laserS';
    npc.msl = 'AF';
    npc.mslAmmo = 1;
    npc.ai = (dt) => { if(window.runAdvancedFighterAI) window.runAdvancedFighterAI(npc, dt); };
  }

  npc.angle = Math.atan2(ship.pos.y - npc.y, ship.pos.x - npc.x);

  npcs.push(npc);
  return npc;
}
window.spawnPirate = spawnPirate;
  
function spawnDestroyer(pos){
  const n = makeNPCBase(pos, { hp: 1200, accel: 40, maxSpeed: 260, turn: 1.2, radius: 60 });
  n.type = 'destroyer';
  n.weapons = {
    railL: makeRailgun({ dmg: 85, cooldown: 0.85, spread: 0.004 }),
    railR: makeRailgun({ dmg: 85, cooldown: 0.85, spread: 0.004 }),
    rocketL: makeRocketPod({ salvo: 3, cooldown: 2.8 }),
    rocketR: makeRocketPod({ salvo: 3, cooldown: 2.8 })
  };
  n.ai = function(dt){
    battleshipAI(n, ship);
    useRailPair(n, ship);
    useRocketsPair(n, ship);
  };
  MISSION_NPCS.push(n);
}

function spawnFrigate(pos){
  const n = makeNPCBase(pos, { hp: 650, accel: 60, maxSpeed: 360, turn: 2.0, radius: 44 });
  n.type = 'frigate';
  armPirate(n, 'mid'); // AI i uzbrojenie jak w piratach
  MISSION_NPCS.push(n);
}

function spawnGunship(pos){
  const n = makeNPCBase(pos, { hp: 520, accel: 60, maxSpeed: 360, turn: 2.4, radius: 40 });
  n.type = 'gunship';
  n.weapons = {
    ciwsL: makeGatling({ dps: 65, heat: 0.3 }),
    ciwsR: makeGatling({ dps: 65, heat: 0.3 }),
    rockets: makeRocketPod({ salvo: 2, cooldown: 3.2 })
  };
  n.ai = function(dt){
    dogfightAI(n, ship);
    useCIWSPair(n, ship);
    maybeFireRockets(n, ship);
  };
  MISSION_NPCS.push(n);
}
const TRAFFIC_WEIGHTS = {
  mercury: { civilian: 0.02, convoy: 0.25 },
  venus:   { civilian: 0.03, convoy: 0.25 },
  earth:   { civilian: 1.80, convoy: 0.50 },
  mars:    { civilian: 1.60, convoy: 0.55 },
  default: { civilian: 0.40, convoy: 0.40 }
};

function trafficWeightFor(station, kind){
  const table = TRAFFIC_WEIGHTS[station.id] || TRAFFIC_WEIGHTS.default;
  if(kind === 'convoy') return table.convoy ?? TRAFFIC_WEIGHTS.default.convoy;
  if(kind === 'civilian') return table.civilian ?? TRAFFIC_WEIGHTS.default.civilian;
  if(kind && typeof table[kind] === 'number') return table[kind];
  return table.civilian ?? TRAFFIC_WEIGHTS.default.civilian;
}

function weightedPickStation(kind, scope){
  let pool;
  if(Array.isArray(scope)){
    pool = scope.slice();
  }else if(scope === 'inner' || scope === 'outer'){
    const match = scope === 'inner';
    pool = stations.filter(s => s.inner === match);
  }else if(typeof scope === 'boolean'){
    pool = stations.filter(s => s.inner === scope);
  }else{
    pool = stations.slice();
  }
  if(!pool.length) return null;
  let total = 0;
  const weighted = pool.map(st => {
    const w = Math.max(0, trafficWeightFor(st, kind));
    total += w;
    return { st, w };
  });
  if(total <= 0){
    return pool[Math.floor(Math.random()*pool.length)];
  }
  let r = Math.random() * total;
  for(const { st, w } of weighted){
    r -= w;
    if(r <= 0) return st;
  }
  return weighted[weighted.length - 1].st;
}

function preferEarthMarsRoute(stationId){
  return (stationId === 'earth' || stationId === 'mars') && Math.random() < 0.7;
}

function pickNextStation(startStationId, type){
  const start = stations.find(s=>s.id===startStationId) || stations[0];
  if(!start) return startStationId;
  if(preferEarthMarsRoute(start.id)){
    return start.id === 'earth' ? 'mars' : 'earth';
  }
  const isCivil = type && (type.startsWith('civilian') || type.startsWith('freighter'));
  const sameSphere = stations.filter(s => s.inner === start.inner && s.id !== start.id);
  const otherSphere = stations.filter(s => s.inner !== start.inner);
  let pool = sameSphere.length ? sameSphere : stations.filter(s => s.id !== start.id);
  if(isCivil && otherSphere.length && Math.random() < 0.35){
    pool = otherSphere;
  }
  let target = weightedPickStation(isCivil ? 'civilian' : null, pool);
  if(!target || target.id === start.id){
    const fallbackPool = pool.length ? pool : stations.filter(s => s.id !== start.id);
    if(fallbackPool.length){
      return fallbackPool[Math.floor(Math.random()*fallbackPool.length)].id;
    }
    return startStationId;
  }
  return target.id;
}
const NPC_TYPES = {
  'freighter-small':  { radius:10, speed:100, hp:100, color:'#8ab4d6', weapon:null, isCollidable: false },
  'freighter-medium': { radius:15, speed:100, hp:150, color:'#769cb8', weapon:null, isCollidable: false },
  'freighter-large':  { radius:25, speed:100, hp:200, color:'#5d829c', weapon:null, isCollidable: false },
  'freighter-capital':{ radius:48, speed:100, hp:400, color:'#45667d', weapon:null, isCollidable: false },
  'police':           { radius:24, speed:100, hp:200, color:'#44aaff', weapon:'null', isCollidable: true },
  'civilian-small':   { radius:6, speed:100, hp:10, color:'#cccccc', weapon:null, isCollidable: false },
  'civilian-large':   { radius:12, speed:100, hp:50, color:'#bbbbbb', weapon:null, isCollidable: false },
  'guard':            { radius:20, speed:100, hp:100, color:'#ff9933', weapon:'gun', isCollidable: true },
  'mercenary':        { radius:25, speed:100, hp:100, color:'#ff6633', weapon:'gun', isCollidable: true }
};
// ==========================================================================================
// 1. BAZA DANYCH AI SPACE (Statystyki broni i pocisków)
// ==========================================================================================

const AISPACE_GUNS = {
  laserS: { name:'Laser krótki', dps:40, dmg:8,  rps:5,   speed:520, range:380, spread:2,  color:'#86f7ff' },
  pulse:  { name:'Pulse blaster', dps:55, dmg:14, rps:4,   speed:420, range:420, spread:3,  color:'#ffd36e' },
  rail:   { name:'Rail micro',    dps:65, dmg:26, rps:1.8, speed:900, range:560, spread:0.6,color:'#c0b7ff' },
  gatling:{ name:'Gatling',       dps:70, dmg:3,  rps:12,  speed:520, range:320, spread:4,  color:'#9fff75' }
};

const AISPACE_PD = {
  pd_mk1:   { name:'PD Mk1',   dmg:5,  rps:9,  speed:560,  range:380, spread:6,   color:'#8cffd0', burst:3 },
  pd_laser: { name:'PD Laser', dmg:3,  rps:18, speed:1200, range:420, spread:0.7, color:'#ff77ff', burst:10 }
};

const AISPACE_FLAK = {
  flak_L:   { name:'Flak L', burst:1, rps:0.8, speed:380, range:520, radius:48, dmg:28, color:'#ffef8a' }
};

const AISPACE_MISSILES = {
  AF: { name:'AIM-3',  speed:360, turn:600, life:4.0, dmg:45,  seek:'fighter', color:'#7cd7ff' },
  AS: { name:'ASM-6',  speed:300, turn:320, life:6.0, dmg:120, seek:'ship',    color:'#ffad7c' },
  HE: { name:'HET-4',  speed:280, turn:250, life:5.0, dmg:160, seek:'any',     color:'#ff7cf0' },
  SW: { name:'Swarm-8',speed:340, turn:550, life:3.0, dmg:18,  seek:'fighter', color:'#b3ff7c', swarm:6, spread:18 }
};

const AISPACE_GUNS_M = {
  m_beam:       { name:'M Beam',       dmg:24,  rps:1.8, speed:900,  range:820,  spread:0.4, color:'#8fd8ff', isBeam:true },
  m_pulse:      { name:'M Pulse',      dmg:40,  rps:1.1, speed:700,  range:760,  spread:0.8, color:'#ffd98a' },
  m_rail:       { name:'M Rail',       dmg:85,  rps:0.55,speed:1200, range:880,  spread:0.35,color:'#d0c9ff' },
  m_autocannon: { name:'M Auto',       dmg:22,  rps:3.2, speed:780,  range:680,  spread:1.2, color:'#b6ff9a' },
  h_beam:       { name:'Heavy Beam',   dmg:260, rps:0.22,speed:1500, range:1100, spread:0.1, color:'#ff0000', isBeam:true },
  h_rapid:      { name:'Rapid Laser L',dmg:45,  rps:5.0, speed:900,  range:750,  spread:1.0, color:'#00ff00' }
};

const AISPACE_BS_BROADSIDE = {
  dmg:80, rps:0.6, speed:620, range:650, spread:2.5, color:'#ff9b4b'
};

// ==========================================================================================
// 2. ADAPTER SYSTEMU (Most między AI SPACE a Space Survivors)
// ==========================================================================================

// Ten obiekt udaje silnik z AI Space, żebyśmy nie musieli przepisywać każdej linijki AI
const PirateSim = {
  time: 0,
  get units() {
    // Zwraca listę celów: Gracz + jego sojusznicy + wrodzy piraci (dla friendly fire check)
    return [ship, ...npcs.filter(n => !n.dead)];
  },
  // Symulacja pocisków i eksplozji nie jest potrzebna tutaj, bo gra ma własną w main loop
  projectiles: [], 
  wrecks: []
};

// Funkcja strzelania - TŁUMACZY broń z AI Space na pociski w grze
window.spawnBulletAdapter = function(owner, target, weaponDef, opts = {}) {
  if (!weaponDef) return;

  // 1. Obliczamy pozycję i kąt
  // Jeśli jest target, używamy leadAim (przewidywanie), jeśli nie - strzelamy przed siebie
  let aimPoint;
  const targetPos = target ? (target.pos ? { x: target.pos.x, y: target.pos.y } : { x: target.x, y: target.y }) : null;
  if (target) {
     aimPoint = getLeadAim(owner, target, weaponDef.speed || 500);
  } else {
     const angle = owner.angle || 0;
     aimPoint = {
         x: owner.x + Math.cos(angle) * 1000, 
         y: owner.y + Math.sin(angle) * 1000 
     };
  }

  const ang = Math.atan2(aimPoint.y - owner.y, aimPoint.x - owner.x);
  
  // 2. Rozrzut (Spread)
  const spreadRad = (weaponDef.spread || 0) * (Math.PI / 180);
  const finalAngle = ang + (Math.random() - 0.5) * spreadRad;

  // 3a. Instant beam (AI Space heavy beams)
  if (weaponDef.isBeam) {
    const beamRange = weaponDef.range || 0;
    const desiredEnd = targetPos || {
      x: owner.x + Math.cos(finalAngle) * beamRange,
      y: owner.y + Math.sin(finalAngle) * beamRange
    };
    const dx = desiredEnd.x - owner.x;
    const dy = desiredEnd.y - owner.y;
    const dist = Math.hypot(dx, dy) || 1;
    const maxDist = beamRange > 0 ? Math.min(dist, beamRange) : dist;
    const endPoint = {
      x: owner.x + (dx / dist) * maxDist,
      y: owner.y + (dy / dist) * maxDist
    };

    spawnLaserBeam({ x: owner.x, y: owner.y }, endPoint, opts.beamWidth || 8, {
      life: weaponDef.beamLife || 0.08,
      colorOuter: weaponDef.color,
      colorInner: '#ffffff',
      glowColor: weaponDef.color,
      glowBlur: 28,
      outerWidthMul: 1.3,
      innerWidthMul: 0.6
    });

    if (target) {
      const dmg = weaponDef.dmg || 0;
      if (target === ship || target.isPlayer) {
        applyDamageToPlayer(dmg);
      } else if (target.isStation) {
        applyDamageToStation(target, dmg);
      } else if (target.isPlatform) {
        applyDamageToPlatform(target, dmg);
      } else {
        applyDamageToNPC(target, dmg, 'beam');
      }
      spawnDefaultHit(endPoint.x, endPoint.y, 1.0);
    }
    return;
  }

  // 3. Wygląd pocisku (Typ)
  let bType = 'plasma';
  let size = 3;
  
  // Wykrywanie typu po nazwie lub właściwościach
  const name = (weaponDef.name || '').toLowerCase();
  if (name.includes('rail') || name.includes('beam')) { bType = 'rail'; size = 4; }
  if (name.includes('flak') || name.includes('armata')) { bType = 'armata'; size = 5; }
  if (name.includes('auto') || name.includes('gatling')) { bType = 'autocannon'; size = 2; }
  if (opts.type) bType = opts.type; // Override

  // 4. Dodanie pocisku do gry
  window.bullets.push({
    x: owner.x,
    y: owner.y,
    // Dziedziczenie pędu statku (20%) dla realizmu
    vx: Math.cos(finalAngle) * weaponDef.speed + (owner.vx || 0) * 0.2,
    vy: Math.sin(finalAngle) * weaponDef.speed + (owner.vy || 0) * 0.2,
    
    life: (weaponDef.range || 800) / weaponDef.speed,
    r: size,
    owner: owner.friendly ? 'player' : 'npc', // Ważne dla kolizji!
    damage: weaponDef.dmg || 10,
    type: bType,
    color: weaponDef.color || '#fff',
    source: owner,
    
    // Specyficzne dla Flak/Armata
    explodeRadius: (bType === 'armata' || name.includes('flak')) ? (weaponDef.radius || 50) : 0,
    
    // Specyficzne dla Rail (przebicie)
    penetration: (bType === 'rail') ? 2 : 0
  });
  
  // Opcjonalnie: odrzut lub efekt wizualny wystrzału (muzzle flash)
  // spawnParticle({x: owner.x, y: owner.y}, {x:0,y:0}, 0.1, weaponDef.color, size*2, true);
};

// Funkcja pomocnicza do znajdowania celu (Używana przez AI dużych statków)
window.aiPickBestTarget = function(self, weaponRange) {
  let best = null;
  let maxScore = -Infinity;
  
  // Kogo atakujemy?
  const enemies = self.friendly 
     ? npcs.filter(n => n.isPirate && !n.dead) // Sojusznik bije piratów
     : [ship, ...npcs.filter(n => n.friendly && !n.dead)]; // Pirat bije gracza i sojuszników

  for (const t of enemies) {
    const distSq = (t.x - self.x)**2 + (t.y - self.y)**2;
    
    // Ignoruj cele poza zasięgiem radaru (np. 3500j)
    if (distSq > 3500*3500) continue;

    let score = -distSq; // Im bliżej tym lepiej
    
    // Priorytetyzacja
    if (t === ship) score += 500000; // Gracz priorytetem
    if (t.isCapitalShip) score += 200000; // Duże statki groźne

    // Bonus jeśli jest w zasięgu broni (nie musi gonić)
    if (weaponRange && distSq < weaponRange*weaponRange) score += 100000;

    if (score > maxScore) {
      maxScore = score;
      best = t;
    }
  }
  return best;
};

function pirateRoleKind(npc){
  if (!npc) return 'other';
  const type = npc.type || '';
  if (npc.fighter || type === 'fighter' || type === 'interceptor' || type === 'drone') return 'fighter';
  if (type.includes('frigate')) return npc.subType === 'laser' ? 'frigate_laser' : 'frigate';
  if (type === 'destroyer') return 'destroyer';
  if (type === 'battleship' || npc.isCapitalShip) return 'battleship';
  return 'other';
}

function pirateTargetKind(target){
  if (!target) return 'other';
  if (target === ship) return 'battleship';
  const type = target.type || '';
  if (target.fighter || type === 'fighter' || type === 'interceptor' || type === 'drone') return 'fighter';
  if (type.includes('frigate')) return 'frigate';
  if (type === 'destroyer') return 'destroyer';
  if (type === 'battleship' || target.isCapitalShip) return 'battleship';
  return 'other';
}

function pirateEffectiveHp(target){
  if (!target) return 0;
  const hull = (target.hp ?? target.hull?.val ?? 0);
  const shield = (target.shield?.val ?? target.shield ?? 0);
  return Math.max(0, hull + shield);
}

function pirateEngageScore(attacker, target){
  const attackerKind = pirateRoleKind(attacker);
  const targetKind = pirateTargetKind(target);
  const tx = target?.pos?.x ?? target?.x ?? 0;
  const ty = target?.pos?.y ?? target?.y ?? 0;
  const dx = tx - (attacker?.x ?? 0);
  const dy = ty - (attacker?.y ?? 0);
  const distSq = dx*dx + dy*dy;

  let score = -distSq * 0.0008;

  if (attackerKind === 'fighter') {
    if (targetKind === 'fighter') {
      score += distSq < 6250000 ? 40000 : 1000;
    } else {
      score += 1000;
    }
  } else if (attackerKind === 'frigate') {
    if (targetKind === 'fighter') score += 2000;
    else if (targetKind === 'frigate') score += 800;
    else score += 200;
  } else if (attackerKind === 'frigate_laser') {
    if (targetKind === 'battleship') score += 2500;
    else if (targetKind === 'destroyer') score += 2000;
    else if (targetKind === 'frigate') score += 1500;
    else score -= 300;
  } else if (attackerKind === 'destroyer') {
    if (targetKind === 'frigate') score += 4500;
    else if (targetKind === 'destroyer') score += 2500;
    else if (targetKind === 'battleship') score += 1000;
    else score += 500;
  } else if (attackerKind === 'battleship') {
    if (targetKind === 'battleship') score += 4000;
    else if (targetKind === 'destroyer') score += 3000;
    else if (targetKind === 'frigate') score += 2000;
    else score -= 500;
  }

  if (distSq < 122500) {
    if (attackerKind === 'fighter' && targetKind !== 'fighter') score += 6000;
    else score += 8000;
  }

  const effHp = pirateEffectiveHp(target);
  const incoming = target?.incomingDamage ?? 0;
  if (effHp > 0) {
    const overkill = incoming / (effHp + 1);
    if (overkill > 1.2) score -= 1500 * (overkill - 1.0);
  }

  score += Math.random() * 250;
  return score;
}

function pickPirateEngageTarget(npc){
  if (!npc?.isPirate || mercMission?.alertStage !== 'engage') return null;
  const candidates = [ship, ...npcs.filter(n => n.friendly && !n.dead)];
  let best = null;
  let bestScore = -Infinity;
  for (const target of candidates) {
    const score = pirateEngageScore(npc, target);
    if (score > bestScore) {
      bestScore = score;
      best = target;
    }
  }
  return best;
}
  // ==========================================================================================
// 2. LOGIKA AI (MÓZGI STATKÓW - "AI SPACE PORT")
// ==========================================================================================

// Helper: Znajdowanie najlepszego celu (Gracz lub sojusznik)
function aiPickTarget(npc) {
  if (npc?.isPirate) {
    if (mercMission?.alertStage === 'guard' && npc.guardHold) return null;
    const engageTarget = pickPirateEngageTarget(npc);
    if (engageTarget) return engageTarget;
  }
  if (npc && npc.forceTarget && !npc.forceTarget.dead) {
    return npc.forceTarget;
  }
  let best = null;
  let maxScore = -Infinity;
  
  // Pirat atakuje: Gracza (ship) i sojusznicze NPC (friendly=true)
  const targets = npc.friendly 
    ? npcs.filter(n => n.isPirate && !n.dead) 
    : [ship, ...npcs.filter(n => n.friendly && !n.dead)];

  for (const t of targets) {
    const tx = t.pos ? t.pos.x : t.x;
    const ty = t.pos ? t.pos.y : t.y;
    const distSq = (tx - npc.x)**2 + (ty - npc.y)**2;

    if (distSq > 3500**2) continue; // Ignoruj cele poza zasięgiem radaru

    // Punktacja: im bliżej tym lepiej, priorytet dla Gracza i Capital Ships
    let score = -distSq;
    if (t === ship) score += 10000000; 
    if (t.isCapitalShip) score += 5000000;
    
    if (score > maxScore) {
      maxScore = score;
      best = t;
    }
  }
  return best;
}

// --- B. AI FREGATY (FRIGATE) ---
function aiFrigate(sim, npc, dt) {
  npc.gunCD = Math.max(0, (npc.gunCD || 0) - dt);
  npc.pdCD = Math.max(0, (npc.pdCD || 0) - dt);
  npc.mslCD = Math.max(0, (npc.mslCD || 0) - dt);

  let target = (npc.forceTarget && !npc.forceTarget.dead) ? npc.forceTarget : npc.target;
  if (!target || target.dead) {
    target = aiPickTarget(npc);
  }
  npc.target = target;

  const home = npc.home;
  const patrolRadius = npc.patrolRadius || (home ? home.r + 260 : 320);
  if (home && !npc.patrolAngle) {
    npc.patrolAngle = Math.random() * Math.PI * 2;
  }
  const patrolPoint = home
    ? { x: home.x + Math.cos(npc.patrolAngle) * patrolRadius, y: home.y + Math.sin(npc.patrolAngle) * patrolRadius }
    : null;

  const desired = target ? { x: target.x, y: target.y } : (patrolPoint || { x: npc.x + Math.cos(npc.angle) * 120, y: npc.y + Math.sin(npc.angle) * 120 });
  const dx = desired.x - npc.x;
  const dy = desired.y - npc.y;
  const dist = Math.hypot(dx, dy) || 1;
  const desiredDir = { x: dx / dist, y: dy / dist };
  const idealRange = npc.preferredRange || 850;

  let thrust = 0;
  if (target) {
    if (dist > idealRange) thrust = npc.accel;
    else if (dist < idealRange * 0.6) thrust = -npc.accel * 0.6;
  } else {
    thrust = npc.accel * 0.35;
    if (home && dist < 80) {
      npc.patrolAngle = wrapAngle(npc.patrolAngle + 0.6 * dt);
    }
  }

  npc.vx += desiredDir.x * thrust * dt;
  npc.vy += desiredDir.y * thrust * dt;

  const desiredAng = target ? Math.atan2(dy, dx) : Math.atan2(desiredDir.y, desiredDir.x);
  const diff = wrapAngle(desiredAng - npc.angle);
  npc.angle = wrapAngle(npc.angle + clamp(diff, -npc.turn * dt, npc.turn * dt));
  npc.desiredAngle = npc.angle;

  if (target) {
    const mainDef = AISPACE_GUNS_M[npc.mainGun] || AISPACE_GUNS_M.m_pulse;
    if (npc.gunCD <= 0 && dist < (mainDef.range || 800)) {
      window.spawnBulletAdapter(npc, target, mainDef, { type: mainDef.isBeam ? 'beam' : undefined });
      npc.gunCD = 1.0 / (mainDef.rps || 1.0);
    }

    const pdDef = AISPACE_PD[npc.pd];
    if (pdDef && npc.pdCD <= 0 && dist < (pdDef.range || 500)) {
      const burst = pdDef.burst || 1;
      for (let i = 0; i < burst; i++) {
        window.spawnBulletAdapter(npc, target, pdDef, { type: 'ciws' });
      }
      npc.pdCD = 1.0 / (pdDef.rps || 8);
    }

    if (npc.msl && npc.mslAmmo > 0 && npc.mslCD <= 0 && dist < 1400) {
      const mslDef = AISPACE_MISSILES[npc.msl] || AISPACE_MISSILES.AS;
      const dir = desiredDir;
      window.bullets.push({
        x: npc.x,
        y: npc.y,
        vx: dir.x * mslDef.speed + npc.vx,
        vy: dir.y * mslDef.speed + npc.vy,
        life: mslDef.life || 5,
        r: 5,
        owner: npc.friendly ? 'player' : 'npc',
        damage: mslDef.dmg || 80,
        type: 'rocket',
        target: target,
        color: mslDef.color,
        turnRate: (mslDef.turn || SIDE_ROCKET_TURN_RATE) * Math.PI / 180,
        homingDelay: 0.3,
        explodeRadius: 50
      });
      npc.mslAmmo -= 1;
      npc.mslCD = 6.0;
    }
  }

  npc.vx *= (npc.friction || 0.986);
  npc.vy *= (npc.friction || 0.986);
}

// --- C. AI NISZCZYCIELA (DESTROYER) ---
// Agresywne, używa głównego Railguna i Boosta
window.aiDestroyer = function(sim, npc, dt) {
  npc.mCD = Math.max(0, (npc.mCD||0) - dt);
  npc.boostT = Math.max(0, (npc.boostT||0) - dt);
  npc.boostCd = Math.max(0, (npc.boostCd||0) - dt);

  const target = aiPickTarget(npc);
  const gunDef = AISPACE_GUNS_M[npc.mGun] || AISPACE_GUNS_M.m_rail;
  
  if (target) {
    const dx = target.x - npc.x;
    const dy = target.y - npc.y;
    const dist = Math.hypot(dx, dy);
    const desiredAng = Math.atan2(dy, dx);

    // Logika Boosta (szarża)
    const facingTarget = Math.abs(wrapAngle(desiredAng - npc.angle)) < 0.2;
    if (dist > 900 && npc.boostCd <= 0 && facingTarget) {
       npc.boostT = npc.boostDur || 2.0;
       npc.boostCd = 10.0;
    }

    let thrust = 0;
    if (dist > 700) thrust = npc.accel; // Leć do
    else if (dist < 500) thrust = -npc.accel * 0.5; // Za blisko

    // Jeśli boost aktywny -> MOC SILNIKÓW x2
    if (npc.boostT > 0) thrust *= 2.5;

    // Obrót
    let dAng = desiredAng - npc.angle;
    while(dAng > Math.PI) dAng -= 2*Math.PI;
    while(dAng < -Math.PI) dAng += 2*Math.PI;
    npc.angle += Math.max(-npc.turn*dt, Math.min(npc.turn*dt, dAng));

    const c = Math.cos(npc.angle);
    const s = Math.sin(npc.angle);
    npc.vx += c * thrust * dt;
    npc.vy += s * thrust * dt;

    // Strzał z głównego działa (Railgun)
    if (npc.mCD <= 0 && dist < gunDef.range && facingTarget) {
       window.spawnBulletAdapter(npc, target, gunDef, {type:'rail'});
       // Efekt odrzutu (wizualny) można dodać tu
       npc.mCD = 1.0 / (gunDef.rps || 0.5);
       
       // Niszczyciele często strzelają seriami 2-3 pocisków,
       // ale uprośćmy: strzela raz, ale mocno.
    }
  }
  
  npc.vx *= (npc.friction || 0.985);
  npc.vy *= (npc.friction || 0.985);
};

// --- D. AI PANCERNIKA (BATTLESHIP) ---
// Powolny, ustawia się bokiem (Broadside), potężne salwy
window.aiBattleship = function(sim, npc, dt) {
  npc.broadLeftCD = Math.max(0, (npc.broadLeftCD||0) - dt);
  npc.broadRightCD = Math.max(0, (npc.broadRightCD||0) - dt);
  npc.pdCD = Math.max(0, (npc.pdCD||0) - dt);

  const target = aiPickTarget(npc);
  const broadsideDef = AISPACE_BS_BROADSIDE;
  const pdDef = AISPACE_PD[npc.pd] || AISPACE_PD.pd_laser;

  if (target) {
    const dx = target.x - npc.x;
    const dy = target.y - npc.y;
    const dist = Math.hypot(dx, dy);
    const angToTarget = Math.atan2(dy, dx);
    
    // Pancernik chce ustawić się BOKIEM (Broadside)
    // Bok lewy: target angle + 90 stopni
    // Bok prawy: target angle - 90 stopni
    
    const leftFlankAng = angToTarget + Math.PI/2;
    const rightFlankAng = angToTarget - Math.PI/2;
    
    // Sprawdź do którego boku ma bliżej
    const diffLeft = Math.abs(wrapAngle(leftFlankAng - npc.angle));
    const diffRight = Math.abs(wrapAngle(rightFlankAng - npc.angle));
    
    const desiredAng = (diffLeft < diffRight) ? leftFlankAng : rightFlankAng;
    
    // Powolny obrót
    let dAng = desiredAng - npc.angle;
    while(dAng > Math.PI) dAng -= 2*Math.PI;
    while(dAng < -Math.PI) dAng += 2*Math.PI;
    npc.angle += Math.max(-npc.turn*dt, Math.min(npc.turn*dt, dAng));

    // Napęd (utrzymywanie dystansu ~600-800)
    let thrust = 0;
    if (dist > 900) thrust = npc.accel;
    else if (dist < 500) thrust = -npc.accel * 0.5;

    // Pancernik porusza się wolno
    npc.vx += Math.cos(npc.angle) * thrust * dt;
    npc.vy += Math.sin(npc.angle) * thrust * dt;
    
    // --- STRZELANIE (BROADSIDE) ---
    // Sprawdź czy bok jest wycelowany
    const sideArc = 0.5; // ok. 30 stopni tolerancji
    
    // Prawa burta
    if (diffRight < sideArc && npc.broadRightCD <= 0 && dist < broadsideDef.range) {
       // Salwa 4 dział
       for(let i=0; i<4; i++) {
         // Symulacja różnych luf wzdłuż kadłuba
         const offsetDist = (i - 1.5) * 20; 
         const bx = npc.x + Math.cos(npc.angle)*offsetDist;
         const by = npc.y + Math.sin(npc.angle)*offsetDist;
         const fakeSource = { ...npc, x: bx, y: by }; // Hack dla pozycji startowej
         
         window.spawnBulletAdapter(fakeSource, target, broadsideDef, {type:'plasma'});
       }
       npc.broadRightCD = 2.0; // Wolne przeładowanie
    }
    
    // Lewa burta
    if (diffLeft < sideArc && npc.broadLeftCD <= 0 && dist < broadsideDef.range) {
       for(let i=0; i<4; i++) {
         const offsetDist = (i - 1.5) * 20; 
         const bx = npc.x + Math.cos(npc.angle)*offsetDist;
         const by = npc.y + Math.sin(npc.angle)*offsetDist;
         const fakeSource = { ...npc, x: bx, y: by };
         
         window.spawnBulletAdapter(fakeSource, target, broadsideDef, {type:'plasma'});
       }
       npc.broadLeftCD = 2.0;
    }

    // PD (Obrona punktowa) - strzela niezależnie w najbliższy cel
    if (npc.pdCD <= 0 && dist < (pdDef.range || 500)) {
       const burst = pdDef.burst || 1;
       for(let i=0; i<burst; i++) {
         window.spawnBulletAdapter(npc, target, pdDef, {type:'ciws'});
       }
       npc.pdCD = 1.0 / (pdDef.rps || 10);
    }
  }

  npc.vx *= (npc.friction || 0.99);
  npc.vy *= (npc.friction || 0.99);
};
window.runAdvancedFighterAI = runAdvancedFighterAI;
window.aiFrigate = aiFrigate;
window.aiDestroyer = aiDestroyer;
window.aiBattleship = aiBattleship;
// Helper strzelania dla myśliwców
function tryFireFighter(npc, target, dt) {
  if(!target) return;
  const gunDef = AISPACE_GUNS[npc.gun] || AISPACE_GUNS.laserS;
  
  // Kąt
  const angleToTarget = Math.atan2(target.y - npc.y, target.x - npc.x);
  const myAngle = Math.atan2(npc.vy, npc.vx); // Myśliwce strzelają w kierunku lotu (drift)
  const diff = Math.abs(wrapAngle(angleToTarget - myAngle));
  const dist = Math.hypot(target.x - npc.x, target.y - npc.y);

  // Strzał z działa
  if (dist < gunDef.range && diff < 0.3 && npc.gunCD <= 0) {
     window.spawnBulletAdapter(npc, target, gunDef);
     npc.gunCD = 1.0 / (gunDef.rps || 5);
  }
  
  // Strzał rakietą (rzadziej)
  if (npc.mslAmmo > 0 && npc.mslCD <= 0 && dist < 1000 && diff < 0.5) {
      const mslDef = AISPACE_MISSILES[npc.msl || 'AF'];
      const dir = norm({ x: target.x - npc.x, y: target.y - npc.y });
      const speed = mslDef.speed || 300;
      // Rakieta startuje z prędkością statku
      window.bullets.push({
        x: npc.x, y: npc.y,
        vx: dir.x * speed + npc.vx,
        vy: dir.y * speed + npc.vy,
        life: mslDef.life || 4, r: 4,
        owner: npc.friendly ? 'player' : 'npc',
        damage: mslDef.dmg || 40,
        type: 'rocket',
        target: target,
        color: mslDef.color,
        turnRate: (mslDef.turn || SIDE_ROCKET_TURN_RATE) * Math.PI / 180,
        homingDelay: 0.2,
        explodeRadius: 40
      });
      npc.mslAmmo--;
      npc.mslCD = 4.0;
  }
}
function initNPCs() {
  npcs = [];
  SQUADS.length = 0; // Reset eskadr
  let npcCounter = 0;

  // 1. Stwórz eskadrę pirackich myśliwców (Interceptor Squad)
  const pirateSquad = new Squad('pirate', 'fighter');
  SQUADS.push(pirateSquad);

  const startX = ship.pos.x + 2000;
  const startY = ship.pos.y;

  // Spawn 5 myśliwców w formacji
  for(let i=0; i<5; i++) {
    const npc = makeNPCBase({ x: startX + Math.random()*100, y: startY + Math.random()*100 }, {
      hp: 80,
      accel: 220, // Wyższe przyspieszenie dla nowej fizyki
      maxSpeed: 450,
      turn: 6.0,
      radius: 18
    });
    
    npc.id = `pirate_${npcCounter++}`;
    npc.friendly = false;
    npc.isPirate = true;
    npc.type = 'interceptor';
    npc.fighter = true;
    npc.color = '#ff5c7c'; // Czerwony z AI SPACE
    npc.mission = true; // Misje używają nowego AI; omijaj cywilny autopilot
    npc.gunCD = 0;
    
    // *** KLUCZOWA ZMIANA: Przypisanie nowego AI ***
    npc.ai = (dt) => runAdvancedFighterAI(npc, dt);
    
    npcs.push(npc);
    pirateSquad.addUnit(npc);
  }

  // 2. Stwórz eskadrę sojuszniczą (jeśli chcesz testować dogfight)
  const allySquad = new Squad('player', 'fighter');
  SQUADS.push(allySquad);
  
  for(let i=0; i<3; i++) {
     const npc = makeNPCBase({ x: ship.pos.x - 200, y: ship.pos.y + 200 }, {
       hp: 100, accel: 220, maxSpeed: 450, turn: 6.0, radius: 18
     });
     npc.id = `ally_${npcCounter++}`;
     npc.friendly = true;
     npc.type = 'ally_fighter';
     npc.fighter = true;
     npc.color = '#7cff91'; // Zielony z AI SPACE
     npc.mission = true; // Wymuś ścieżkę mission dla runAdvancedFighterAI
     npc.ai = (dt) => runAdvancedFighterAI(npc, dt);
     
     npcs.push(npc);
     allySquad.addUnit(npc);
  }
}
// Ensure Three.js modules are loaded before initializing 3D objects
window.addEventListener('DOMContentLoaded', () => {
  const planetInitResult = initPlanets3D(planets, SUN);
  const sceneFromInit = asThreeScene(planetInitResult);
  if (sceneFromInit) {
    planetScene3D = sceneFromInit;
  }
  // overlay main scene
  let overlayScene = null;
  if (typeof window.initWorld3D === 'function') {
    const res = initWorld3D();
    const candidate = asThreeScene(res?.scene || res);
    if (candidate) {
      mainScene3D = candidate;
      overlayScene = candidate;
    } else if (res?.scene) {
      mainScene3D = res.scene;
      overlayScene = res.scene;
    }
  }
  // stacje – własna warstwa 3D (ortho), bez world3D
  if (typeof window.initStations3D === 'function') {
    window.initStations3D(null, stations);
    planetScene3D = overlayScene;
    planetStationsReady = true;
  }
  if (!planetStationsReady && !ensurePlanetStationsInit(stations)) {
    let tries = 0;
    const maxTries = 240;
    (function poll(){
      if (ensurePlanetStationsInit(stations) || tries++ > maxTries) return;
      requestAnimationFrame(poll);
    })();
  }
});

function waitForPlanetsReady(){
  if (planetScene3D || planetStationsReady) return Promise.resolve();
  return waitForCondition(() => planetScene3D || planetStationsReady, 2500);
}

// =============== Bullets & effects ===============

// const particles = []; // USUNIĘTE
const shockwaves = [];
const MAX_PARTICLES = 8000;          // twardy sufit (dobry balans)
const MAX_PARTICLES_DRAW = 4500;     // ile maks. rysujemy na ekranie

// === POCZĄTEK NOWEGO KODU (Pula Cząsteczek) ===
const particlePool = [];
let nextParticleIndex = 0;
(function initParticlePool() { // Samowywołująca się funkcja do zainicjowania puli
  for (let i = 0; i < MAX_PARTICLES; i++) {
    particlePool.push({
      pos: { x: 0, y: 0 },
      vel: { x: 0, y: 0 },
      life: 0,
      age: 0,
      color: '#fff',
      size: 1,
      flash: false,
      beam: false,
      start: { x: 0, y: 0 },
      end: { x: 0, y: 0 },
      width: 0,
      alpha: 1,
      fadeWithLife: true,
      glowColor: null,
      colorOuter: null,
      colorInner: null,
      glowBlur: 0,
      outerWidthMul: 1,
      innerWidthMul: 1,
      active: false // Flaga 'aktywności' jest kluczowa
    });
  }
})();
// === KONIEC NOWEGO KODU ===

function pushParticleSafe(p){
  // Ta funkcja nie jest już potrzebna, ale zostawiamy ją pustą,
  // na wypadek gdyby inne części kodu ją wołały (jak spawnLaserBeam).
  // spawnParticle jest teraz główną funkcją.
}

function spawnParticle(pos, vel, life, color, size, flash){
  const p = particlePool[nextParticleIndex]; // Weź następną cząsteczkę z puli

  // Ustaw jej właściwości
  p.pos.x = pos.x;
  p.pos.y = pos.y;
  p.vel.x = vel.x;
  p.vel.y = vel.y;
  p.life = life;
  p.age = 0;
  p.color = color || '#ffb677';
  p.size = size || 2;
  p.flash = !!flash;
  p.beam = false;
  p.start.x = 0;
  p.start.y = 0;
  p.end.x = 0;
  p.end.y = 0;
  p.width = 0;
  p.alpha = 1;
  p.fadeWithLife = true;
  p.colorOuter = null;
  p.colorInner = null;
  p.glowColor = null;
  p.glowBlur = 0;
  p.outerWidthMul = 1;
  p.innerWidthMul = 1;
  p.active = true; // <-- AKTYWUJ CZĄSTECZKĘ

  // Przesuń indeks na następne wolne miejsce
  nextParticleIndex = (nextParticleIndex + 1) % MAX_PARTICLES;
}
function spawnExplosionPlasma(x,y,scale=1){
  const count = Math.round(22 * scale);
  for(let i=0;i<count;i++){
    const a = Math.random()*Math.PI*2;
    const s = 120 + Math.random()*260 * scale;
    spawnParticle({x,y}, {x:Math.cos(a)*s, y:Math.sin(a)*s}, 0.45 + Math.random()*0.5, '#7CFF7C', 2 + Math.random()*3, true);
  }
}
function spawnRailHitEffect(x,y,scale=1){
  // Tylko 3D (skalowane parametrem efektu)
  triggerRailgunExplosion3D(x, y, ship.h * 0.22 * scale);
}

function spawnArmataHitEffect(x, y, scale = 1){
  triggerArmataImpact3D(x, y, ship.h * 0.3 * scale);
  const count = Math.round(28 * scale);
  for(let i=0;i<count;i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 200 + Math.random() * 280;
    const color = (Math.random() < 0.45) ? '#ffd2a0' : '#ff9f58';
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.22 + Math.random() * 0.18,
      color,
      2.2 + Math.random() * 2.6,
      true
    );
  }
  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.12, '#fff2d0', 7.5 * scale, true);
  spawnShockwave(x, y, { r: 14 * scale, maxR: 120 * scale, w: 3.2 * scale, maxLife: 0.42, color: 'rgba(255,170,90,' });
}

function spawnAutocannonHitEffect(x, y, scale = 1){
  triggerAutocannonImpact3D(x, y, ship.h * 0.18 * scale);
  const sparkCount = Math.round(20 * scale);
  for(let i = 0; i < sparkCount; i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 280 + Math.random() * 240;
    const color = (Math.random() < 0.5) ? '#ffe4a8' : '#ffba60';
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.18 + Math.random() * 0.14,
      color,
      1.6 + Math.random() * 1.4,
      true
    );
  }
  const smokeCount = Math.round(6 * scale);
  for(let i = 0; i < smokeCount; i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 60 + Math.random() * 80;
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.32 + Math.random() * 0.18,
      'rgba(90,110,180,0.55)',
      3.2 * scale,
      false
    );
  }
  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.1, '#ffffff', 5.4 * scale, true);
  spawnShockwave(x, y, { r: 10 * scale, maxR: 90 * scale, w: 2.6 * scale, maxLife: 0.28, color: 'rgba(255,205,140,' });
}

function spawnRailMuzzle(pos, dir, baseVel, scale = 1){
  spawnParticle({ x: pos.x, y: pos.y }, { x: 0, y: 0 }, 0.1, '#bfe7ff', 6 * scale, true);
  const angle = Math.atan2(dir.y, dir.x);
  for(let i = 0; i < 5; i++){
    const aa = angle + (Math.random() - 0.5) * 0.14;
    const speed = 220 + Math.random() * 60;
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 6 * scale, y: pos.y + Math.sin(aa) * 6 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.2, y: Math.sin(aa) * speed + baseVel.y * 0.2 },
      0.12,
      '#bfe7ff',
      1.6 * scale,
      true
    );
  }
}

function spawnArmataMuzzle(pos, dir, baseVel, scale = 1){
  const angle = Math.atan2(dir.y, dir.x);
  spawnParticle(
    { x: pos.x, y: pos.y },
    { x: dir.x * 160 + baseVel.x * 0.12, y: dir.y * 160 + baseVel.y * 0.12 },
    0.16,
    '#ffd6a0',
    9 * scale,
    true
  );
  for(let i = 0; i < 10; i++){
    const spread = (Math.random() - 0.5) * 0.38;
    const aa = angle + spread;
    const speed = 260 + Math.random() * 140;
    const size = 2.6 + Math.random() * 2.8;
    const life = 0.16 + Math.random() * 0.14;
    const color = (Math.random() < 0.5) ? '#ffbe7a' : '#ffcfa0';
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 8 * scale, y: pos.y + Math.sin(aa) * 8 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.18, y: Math.sin(aa) * speed + baseVel.y * 0.18 },
      life,
      color,
      size * scale,
      true
    );
  }
  for(let i = 0; i < 4; i++){
    const aa = angle + (Math.random() - 0.5) * 0.25;
    const speed = 120 + Math.random() * 60;
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 4 * scale, y: pos.y + Math.sin(aa) * 4 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.08, y: Math.sin(aa) * speed + baseVel.y * 0.08 },
      0.3 + Math.random() * 0.18,
      '#d76926',
      1.8 * scale,
      false
    );
  }
  spawnShockwave(pos.x, pos.y, { r: 10 * scale, maxR: 80 * scale, w: 2.6 * scale, maxLife: 0.3, color: 'rgba(255,170,90,' });
}

function spawnAutocannonMuzzle(pos, dir, baseVel, scale = 1){
  const angle = Math.atan2(dir.y, dir.x);
  spawnParticle(
    { x: pos.x, y: pos.y },
    { x: dir.x * 220 + baseVel.x * 0.18, y: dir.y * 220 + baseVel.y * 0.18 },
    0.12,
    '#ffdba6',
    7 * scale,
    true
  );
  for(let i = 0; i < 8; i++){
    const spread = (Math.random() - 0.5) * 0.32;
    const aa = angle + spread;
    const speed = 300 + Math.random() * 180;
    const color = (Math.random() < 0.35) ? '#ffe6b0' : '#ffbf6b';
    const size = 1.6 + Math.random() * 1.6;
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 6 * scale, y: pos.y + Math.sin(aa) * 6 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.16, y: Math.sin(aa) * speed + baseVel.y * 0.16 },
      0.16 + Math.random() * 0.12,
      color,
      size * scale,
      true
    );
  }
  for(let i = 0; i < 4; i++){
    const aa = angle + (Math.random() - 0.5) * 0.2;
    const speed = 120 + Math.random() * 60;
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 4 * scale, y: pos.y + Math.sin(aa) * 4 * scale },
      { x: Math.cos(aa) * speed + baseVel.x * 0.08, y: Math.sin(aa) * speed + baseVel.y * 0.08 },
      0.24 + Math.random() * 0.18,
      '#6b7cff',
      1.4 * scale,
      false
    );
  }
  spawnShockwave(pos.x, pos.y, { r: 8 * scale, maxR: 70 * scale, w: 2.2 * scale, maxLife: 0.22, color: 'rgba(255,200,120,' });
}

function spawnSiegeMuzzle(pos, dir, baseVel, scale = 1){
  const angle = Math.atan2(dir.y, dir.x);
  spawnParticle(
    { x: pos.x, y: pos.y },
    { x: dir.x * 200 + baseVel.x * 0.15, y: dir.y * 200 + baseVel.y * 0.15 },
    0.18,
    '#ffe6b0',
    12 * scale,
    true
  );
  for(let i = 0; i < 14; i++){
    const spread = (Math.random() - 0.5) * 0.32;
    const aa = angle + spread;
    const speed = 320 + Math.random() * 160;
    const color = (Math.random() < 0.4) ? '#ffcf7f' : '#ffdca8';
    const vel = {
      x: Math.cos(aa) * speed + baseVel.x * 0.16,
      y: Math.sin(aa) * speed + baseVel.y * 0.16
    };
    spawnParticle(
      { x: pos.x + Math.cos(aa) * 10 * scale, y: pos.y + Math.sin(aa) * 10 * scale },
      vel,
      0.22 + Math.random() * 0.14,
      color,
      2.4 * scale,
      true
    );
  }
  spawnShockwave(pos.x, pos.y, { r: 12 * scale, maxR: 100 * scale, w: 3.0 * scale, maxLife: 0.32, color: 'rgba(255,190,110,' });
}

function spawnSiegeHitEffect(x, y, scale = 1){
  triggerArmataImpact3D(x, y, ship.h * 0.36 * scale);
  const count = Math.round(36 * scale);
  for(let i = 0; i < count; i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 240 + Math.random() * 320;
    const color = (Math.random() < 0.45) ? '#ffd09a' : '#ffb670';
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.26 + Math.random() * 0.18,
      color,
      2.6 + Math.random() * 2.8,
      true
    );
  }
  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.16, '#fff6d6', 9.5 * scale, true);
  spawnShockwave(x, y, { r: 16 * scale, maxR: 150 * scale, w: 3.4 * scale, maxLife: 0.42, color: 'rgba(255,195,120,' });
}
function spawnDefaultHit(x,y,scale=1){
  for(let i=0;i<14*scale;i++){
    const a = Math.random()*Math.PI*2;
    const s = 80 + Math.random()*160 * scale;
    spawnParticle({x,y}, {x:Math.cos(a)*s, y:Math.sin(a)*s}, 0.24 + Math.random()*0.36, '#ffb36b', 1 + Math.random()*2, true);
  }
  spawnParticle({x,y}, {x:0,y:0}, 0.08, '#ffffff', 4 * scale, true);
}

function spawnShockwave(x, y, opts = {}){
  shockwaves.push({
    x, y,
    r: opts.r || 20,
    maxR: opts.maxR || 800,
    w: opts.w || 8,
    life: 0,
    maxLife: opts.maxLife || 0.6,
    color: opts.color || 'rgba(180,200,255,'
  });
}

// =============== Station UI ===============
let stationUI = {
  open:false,
  visible:false,
  awaitingCamera:false,
  appear:0,
  autoPosition:true,
  tab:'upgrades',
  station:null,
  cursorOver:false,
  hoverId:null,
  x:(W-450)/2,
  y:(H-520)/2,
  w:450,
  h:520,
  dragging:false,
  dragDX:0,
  dragDY:0,
  editorMode:false
};

const OPTIONS = {
  vfx: { colorTempK: 8000, bloomGain: 1.1 },
  audio: { master: 0.8, sfx: 1.0, music: 0.7 },
  controls: { mouseSensitivity: 1.0 } // bez odwracania osi
};
let OPTIONS_OPEN = false;

function stationUnderCursor(){
  const world = screenToWorld(mouse.x, mouse.y);
  for(const s of stations){
    const d = Math.hypot(world.x - s.x, world.y - s.y);
    if(d < (s.r||120)) return s;
  }
  return null;
}

function openStationUI(station){
  if(!station) return;
  setStationEditorMode(false);
  stationUI.open = true;
  stationUI.visible = false;
  stationUI.awaitingCamera = true;
  stationUI.station = station;
  stationUI.tab = 'upgrades';
  stationUI.appear = 0;
  stationUI.autoPosition = true;
  stationUI.x = (W - stationUI.w) / 2;
  stationUI.y = (H - stationUI.h) / 2;
  stationUI.dragging = false;
  stationUI.editorMode = false;
  mouse.left = false;
  mouse.right = false;
  setInfrastructureActiveStation(station);
  camera.focusOnStation(station);
}

function closeStationUI(){
  if(!stationUI.open) return;
  setStationEditorMode(false);
  stationUI.open = false;
  stationUI.visible = false;
  stationUI.awaitingCamera = false;
  stationUI.station = null;
  stationUI.dragging = false;
  stationUI.autoPosition = false;
  stationUI.editorMode = false;
  setInfrastructureActiveStation(null);
  setInfrastructureUIVisible(false);
  camera.clearFocus();
}

function setStationEditorMode(enabled){
  const body = document.body;
  const overlay = infrastructureBuilder.overlay;
  const allow = !!enabled && !!stationUI.station && stationUI.open && !stationUI.awaitingCamera;
  if(allow === stationUI.editorMode) return;
  stationUI.editorMode = allow;
  if(body){
    body.classList.toggle('infrastructure-editor', stationUI.editorMode);
  }
  if(!stationUI.editorMode){
    infrastructureBuilder.hoveredCell = null;
    infrastructureBuilder.draggingBuildingId = null;
    if(overlay) overlay.classList.remove('editor-active');
    if(stationUI.open && stationUI.station){
      camera.focusOnStation(stationUI.station);
    } else {
      camera.clearFocus();
    }
    return;
  }
  if(overlay) overlay.classList.add('editor-active');
  const station = stationUI.station;
  if(!station) return;
  const state = ensureInfrastructureState(station);
  const layout = state?.layout;
  camera.focusOnInfrastructure(station, layout);
}

function updateStationUIState(dt){
  if(!stationUI.open && stationUI.awaitingCamera){
    stationUI.awaitingCamera = false;
  }

  if(stationUI.open && stationUI.awaitingCamera){
    const sameStation = camera.mode === 'focus' && camera.focusStation === stationUI.station;
    if(sameStation){
      const dx = camera.x - camera.targetX;
      const dy = camera.y - camera.targetY;
      const closeEnough = Math.hypot(dx, dy) < 2.0 && Math.abs(camera.zoom - camera.targetZoom) < 0.02;
      const arrived = camera.focusArrived || closeEnough;
      if(!camera.transition && arrived){
        stationUI.awaitingCamera = false;
        stationUI.visible = true;
        stationUI.appear = Math.max(0, stationUI.appear);
        stationUI.autoPosition = true;
        camera.focusArrived = false;
      }
    }
    if(camera.mode !== 'focus' || camera.focusStation !== stationUI.station){
      stationUI.awaitingCamera = false;
    }
  }

  const shouldBeVisible = stationUI.open && stationUI.visible && !stationUI.awaitingCamera;
  const targetAlpha = shouldBeVisible ? 1 : 0;
  const fadeInSpeed = 4;
  const fadeOutSpeed = 5;
  if(targetAlpha > stationUI.appear){
    stationUI.appear = Math.min(targetAlpha, stationUI.appear + dt * fadeInSpeed);
  } else if(targetAlpha < stationUI.appear){
    stationUI.appear = Math.max(targetAlpha, stationUI.appear - dt * fadeOutSpeed);
  }

  if(!stationUI.open && stationUI.appear <= 0.0001){
    stationUI.appear = 0;
    stationUI.visible = false;
    stationUI.station = null;
    stationUI.autoPosition = true;
  }

  const wantsEditor = stationUI.open && stationUI.visible && !stationUI.awaitingCamera && stationUI.tab === 'infrastructure';
  setStationEditorMode(wantsEditor);
}

const hoverInfoState = {
  el: document.getElementById('hover-info'),
  title: document.querySelector('#hover-info .hover-title'),
  subtitle: document.querySelector('#hover-info .hover-subtitle'),
  content: document.querySelector('#hover-info .hover-content'),
  type: null,
  target: null
};

function toTitleCaseFromKey(value){
  return String(value || '')
    .split(/[-_\s]+/g)
    .filter(Boolean)
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join(' ');
}

function availableStationTabs(station){
  if (Array.isArray(station?.tabs) && station.tabs.length) {
    return station.tabs.map(toTitleCaseFromKey);
  }
  return ['Upgrades', 'Trade', 'Cantina', 'Hangar', 'Mechanic', 'Infrastructure'];
}

function formatNpcName(npc){
  if(!npc) return '';
  if(typeof npc.name === 'string' && npc.name.trim()) return npc.name;
  if(typeof npc.callsign === 'string' && npc.callsign.trim()) return npc.callsign;
  if(npc.type) return toTitleCaseFromKey(npc.type);
  if(npc.id != null) return `Jednostka #${npc.id}`;
  return 'Jednostka';
}

function formatShieldValue(entity){
  const shield = entity?.shield;
  if(shield && typeof shield.val === 'number' && typeof shield.max === 'number'){
    return `${Math.max(0, Math.round(shield.val))}/${Math.max(0, Math.round(shield.max))}`;
  }
  return 'Brak';
}

function formatWeaponName(weapon){
  if(!weapon) return 'Brak';
  if(typeof weapon === 'string') return toTitleCaseFromKey(weapon);
  if(weapon.name) return toTitleCaseFromKey(weapon.name);
  return 'Brak';
}

function hideHoverInfo(){
  const { el, content } = hoverInfoState;
  if(!el) return;
  if(content) content.innerHTML = '';
  if(!el.classList.contains('hidden')) el.classList.add('hidden');
  hoverInfoState.type = null;
  hoverInfoState.target = null;
}

function updateHoverInfo(target, type){
  const { el, title, subtitle, content } = hoverInfoState;
  if(!el) return;
  if(!target || !type){
    hideHoverInfo();
    return;
  }
  hoverInfoState.type = type;
  hoverInfoState.target = target;
  el.classList.remove('hidden');
  if(content) content.innerHTML = '';

  if(type === 'station'){
    if(title) title.textContent = target.name || (target.id ? `Stacja ${String(target.id).toUpperCase()}` : 'Stacja');
    if(subtitle) subtitle.textContent = 'STACJA ORBITALNA';
    if(content){
      const section = document.createElement('div');
      section.className = 'hover-section';
      section.textContent = 'Zakładki';
      content.appendChild(section);

      const tags = document.createElement('div');
      tags.className = 'hover-tags';
      for(const tab of availableStationTabs(target)){
        const span = document.createElement('span');
        span.className = 'hover-tag';
        span.textContent = tab;
        tags.appendChild(span);
      }
      content.appendChild(tags);
    }
  } else if(type === 'npc'){
    if(title) title.textContent = formatNpcName(target);
    if(subtitle) subtitle.textContent = target.friendly ? 'SOJUSZNIK' : 'CELE NPC';
    if(content){
      const lines = [
        { label:'HP', value: `${Math.max(0, Math.round(target.hp ?? 0))}/${Math.max(0, Math.round(target.maxHp ?? target.hp ?? 0))}` },
        { label:'Tarcza', value: formatShieldValue(target) },
        { label:'Broń', value: formatWeaponName(target.weapon) }
      ];
      for(const line of lines){
        const row = document.createElement('div');
        row.className = 'hover-line';
        const strong = document.createElement('strong');
        strong.textContent = `${line.label}:`;
        const span = document.createElement('span');
        span.textContent = line.value;
        row.appendChild(strong);
        row.appendChild(span);
        content.appendChild(row);
      }
    }
  } else if(type === 'platform'){
    if(title) title.textContent = target.label || 'Platforma obronna';
    if(subtitle) subtitle.textContent = 'PIRACKA OBRONA';
    if(content){
      const lines = [];
      if(target.shield){
        lines.push({ label:'Osłony', value: `${Math.max(0, Math.round(target.shield.val))}/${target.shield.max}` });
      }
      lines.push({ label:'Kadłub', value: `${Math.max(0, Math.round(target.hp ?? 0))}/${Math.max(0, Math.round(target.maxHp ?? target.hp ?? 0))}` });
      lines.push({ label:'Orbita', value: `${Math.round(target.orbitRadius)} u` });
      for(const line of lines){
        const row = document.createElement('div');
        row.className = 'hover-line';
        const strong = document.createElement('strong');
        strong.textContent = `${line.label}:`;
        const span = document.createElement('span');
        span.textContent = line.value;
        row.appendChild(strong);
        row.appendChild(span);
        content.appendChild(row);
      }
    }
  }
}

window.addEventListener('keydown', (e)=>{
  if(stationUI.open){
    if(e.code==='Escape'){ closeStationUI(); return; }
    if(e.code==='Digit1') stationUI.tab='upgrades';
    if(e.code==='Digit2') stationUI.tab='trade';
    if(e.code==='Digit3') stationUI.tab='cantina';
    if(e.code==='Digit4') stationUI.tab='hangar';
    if(e.code==='Digit5') stationUI.tab='mechanic';
    if(e.code==='Digit6') stationUI.tab='infrastructure';
  }
});

window.addEventListener('keydown', (e)=>{
  if(e.code==='KeyO' && !stationUI.open){ OPTIONS_OPEN = !OPTIONS_OPEN; }
});

function renderStationUI(){
  const alpha = clamp(stationUI.appear, 0, 1);

  const shouldShow = stationUI.open && stationUI.visible && !stationUI.awaitingCamera && alpha > 0.001;
  const showInfrastructure = shouldShow && stationUI.tab === 'infrastructure';

  setInfrastructureUIVisible(showInfrastructure);

  const overlay = stationOverlayDom.root;
  if(!overlay){
    return;
  }

  overlay.style.opacity = shouldShow ? alpha.toFixed(2) : '0';
  overlay.classList.toggle('hidden', !shouldShow);
  if(shouldShow){
    renderStationOverlay(stationUI.tab, stationUI.station);
  }
}

function positionStationUIPanel(){
  const st = stationUI.station;
  if(!st) return;
  const screen = worldToScreen(st.x, st.y, camera);
  const margin = 48;
  const maxX = W - stationUI.w - margin;
  stationUI.x = clamp(screen.x + margin, margin, maxX);
  const centeredY = (H - stationUI.h) / 2;
  stationUI.y = clamp(centeredY, margin, H - stationUI.h - margin);
}

function setMechanicUIVisible(visible){
  const overlay = document.getElementById('mechanic-overlay');
  if(!overlay) return;
  const panel = document.getElementById('tab-mechanic');
  const tabBtn = overlay.querySelector('li[data-tab="mechanic"]');
  const active = !!visible;
  overlay.classList.toggle('hidden', !active);
  if(panel) panel.classList.toggle('hidden', !active);
  if(tabBtn) tabBtn.classList.toggle('active', active);
}

const INFRASTRUCTURE_BUILDINGS = [
  { id:'solar_array', name:'Orbitalna Elektrownia Słoneczna', buildTime:75, icon:'solar' },
  { id:'shipyard_s', name:'Orbitalna Stocznia (S)', buildTime:90, icon:'shipyard', tier:'S' },
  { id:'shipyard_m', name:'Orbitalna Stocznia (M)', buildTime:110, icon:'shipyard', tier:'M' },
  { id:'shipyard_l', name:'Orbitalna Stocznia (L)', buildTime:140, icon:'shipyard', tier:'L' },
  { id:'shipyard_capital', name:'Orbitalna Stocznia (Capital)', buildTime:170, icon:'shipyard', tier:'C' },
  { id:'shipyard_supercapital', name:'Orbitalna Stocznia (SuperCapital)', buildTime:210, icon:'shipyard', tier:'SC' },
  { id:'storage_metal', name:'Magazyn Metali', buildTime:60, icon:'storage', label:'M', color:'#60a5fa' },
  { id:'storage_fuel', name:'Magazyn Paliwa', buildTime:70, icon:'storage', label:'F', color:'#f97316' },
  { id:'storage_gas', name:'Magazyn Gazów', buildTime:65, icon:'storage', label:'G', color:'#14b8a6' },
  { id:'storage_plastics', name:'Magazyn Tworzyw Sztucznych', buildTime:85, icon:'storage', label:'P', color:'#a855f7' }
];
const INFRA_BUILDING_MAP = new Map(INFRASTRUCTURE_BUILDINGS.map(b => [b.id, b]));

const INFRA_CELL_WORLD_SIZE = 220;
const INFRA_CELL_WORLD_GAP = 60;
const INFRA_CELL_WORLD_STEP = INFRA_CELL_WORLD_SIZE + INFRA_CELL_WORLD_GAP;
let infrastructureLayoutCache = null;

function computeInfrastructureLayout(cols, rows){
  const width = INFRA_CELL_WORLD_SIZE + (cols - 1) * INFRA_CELL_WORLD_STEP;
  const height = INFRA_CELL_WORLD_SIZE + (rows - 1) * INFRA_CELL_WORLD_STEP;
  const originOffset = { x: -width / 2, y: -height / 2 };
  const cells = [];
  let centerIndex = 0;
  let bestDist = Infinity;
  for(let row=0; row<rows; row++){
    for(let col=0; col<cols; col++){
      const idx = row * cols + col;
      const local = {
        x: originOffset.x + col * INFRA_CELL_WORLD_STEP + INFRA_CELL_WORLD_SIZE / 2,
        y: originOffset.y + row * INFRA_CELL_WORLD_STEP + INFRA_CELL_WORLD_SIZE / 2
      };
      const dist = Math.hypot(local.x, local.y);
      if(dist < bestDist){
        bestDist = dist;
        centerIndex = idx;
      }
      cells.push({ index: idx, col, row, local, blocked:false });
    }
  }
  if(cells[centerIndex]) cells[centerIndex].blocked = true;
  return {
    cellSize: INFRA_CELL_WORLD_SIZE,
    cellGap: INFRA_CELL_WORLD_GAP,
    step: INFRA_CELL_WORLD_STEP,
    cols,
    rows,
    originOffset,
    width,
    height,
    cells,
    centerIndex
  };
}

function getInfrastructureLayout(cols, rows){
  if(!infrastructureLayoutCache || infrastructureLayoutCache.cols !== cols || infrastructureLayoutCache.rows !== rows){
    infrastructureLayoutCache = computeInfrastructureLayout(cols, rows);
  }
  return infrastructureLayoutCache;
}

const infrastructureBuilder = {
  overlay: document.getElementById('infrastructure-overlay'),
  list: document.getElementById('infra-building-list'),
  grid: document.getElementById('infra-grid'),
  info: document.getElementById('infra-info'),
  gridCols: 6,
  gridRows: 4,
  gridCells: [],
  stationStates: new Map(),
  selectedCell: null,
  activeStationKey: null,
  activeStationRef: null,
  hideTimer: null,
  isVisible: false,
  needsRender: false,
  hoveredCell: null,
  draggingBuildingId: null,
  draggingOverlay: false,
  overlayOffset: { x: 0, y: 0 },
  overlayPosition: null,
  editorAlpha: 0,
  ghostAlpha: 0,
  layout: null
};

function clampInfrastructureOverlayPosition(pos, overlay){
  const maxX = Math.max(8, window.innerWidth - overlay.offsetWidth - 8);
  const maxY = Math.max(12, window.innerHeight - overlay.offsetHeight - 12);
  return {
    x: Math.min(Math.max(8, pos.x), maxX),
    y: Math.min(Math.max(12, pos.y), maxY)
  };
}

function applyInfrastructureOverlayPosition(){
  const overlay = infrastructureBuilder.overlay;
  if(!overlay) return;
  if(!infrastructureBuilder.overlayPosition){
    const rect = overlay.getBoundingClientRect();
    infrastructureBuilder.overlayPosition = { x: rect.left, y: rect.top };
  }
  const pos = clampInfrastructureOverlayPosition(infrastructureBuilder.overlayPosition, overlay);
  infrastructureBuilder.overlayPosition = pos;
  overlay.style.left = `${pos.x}px`;
  overlay.style.top = `${pos.y}px`;
  overlay.style.right = 'auto';
  overlay.style.bottom = 'auto';
}

function setupInfrastructureOverlayDrag(){
  const overlay = infrastructureBuilder.overlay;
  if(!overlay) return;
  const header = overlay.querySelector('h3');
  if(!header) return;

  const endDrag = ()=>{
    if(!infrastructureBuilder.draggingOverlay) return;
    infrastructureBuilder.draggingOverlay = false;
    overlay.classList.remove('dragging');
    document.removeEventListener('pointermove', onMove);
    document.removeEventListener('pointerup', endDrag);
  };

  const onMove = (ev)=>{
    if(!infrastructureBuilder.draggingOverlay) return;
    const nextPos = {
      x: ev.clientX - infrastructureBuilder.overlayOffset.x,
      y: ev.clientY - infrastructureBuilder.overlayOffset.y
    };
    infrastructureBuilder.overlayPosition = clampInfrastructureOverlayPosition(nextPos, overlay);
    overlay.style.left = `${infrastructureBuilder.overlayPosition.x}px`;
    overlay.style.top = `${infrastructureBuilder.overlayPosition.y}px`;
  };

  header.addEventListener('pointerdown', (ev)=>{
    if(ev.button !== 0 || !infrastructureBuilder.isVisible) return;
    const rect = overlay.getBoundingClientRect();
    infrastructureBuilder.overlayOffset = { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
    infrastructureBuilder.overlayPosition = { x: rect.left, y: rect.top };
    infrastructureBuilder.draggingOverlay = true;
    overlay.classList.add('dragging');
    applyInfrastructureOverlayPosition();
    document.addEventListener('pointermove', onMove);
    document.addEventListener('pointerup', endDrag);
  });

  window.addEventListener('resize', ()=>{
    if(infrastructureBuilder.overlayPosition && infrastructureBuilder.isVisible){
      applyInfrastructureOverlayPosition();
    }
  });
}

setupInfrastructureOverlayDrag();

function getInfrastructureStationKey(station){
  if(!station) return null;
  if(station.id != null) return `station-${station.id}`;
  if(station.name) return `station-${station.name}`;
  const x = Math.round(station.x ?? 0);
  const y = Math.round(station.y ?? 0);
  return `station-${x}-${y}`;
}

function findStationByKey(key){
  if(!key) return null;
  for(const st of stations){
    if(getInfrastructureStationKey(st) === key) return st;
  }
  return null;
}

function ensureInfrastructureState(station){
  const key = getInfrastructureStationKey(station);
  if(!key) return null;
  const cols = infrastructureBuilder.gridCols;
  const rows = infrastructureBuilder.gridRows;
  const totalCells = cols * rows;
  const layout = getInfrastructureLayout(cols, rows);
  infrastructureBuilder.layout = layout;
  let state = infrastructureBuilder.stationStates.get(key);
  if(!state){
    state = {
      stationKey: key,
      stationRef: station || null,
      stationName: station?.name || null,
      cells: Array.from({ length: totalCells }, () => null),
      cellMeta: layout.cells,
      layout,
      centerIndex: layout.centerIndex
    };
    infrastructureBuilder.stationStates.set(key, state);
  } else {
    if(state.cells.length !== totalCells){
      if(state.cells.length > totalCells){
        state.cells.length = totalCells;
      } else {
        state.cells = state.cells.concat(Array(totalCells - state.cells.length).fill(null));
      }
    }
    state.cellMeta = layout.cells;
    state.layout = layout;
    state.centerIndex = layout.centerIndex;
    if(station) state.stationRef = station;
    if(station?.name) state.stationName = station.name;
  }
  if(!state.stationRef){
    state.stationRef = station || findStationByKey(key) || null;
  }
  return state;
}

function setInfrastructureActiveStation(station){
  const key = getInfrastructureStationKey(station);
  if(infrastructureBuilder.activeStationKey === key){
    infrastructureBuilder.activeStationRef = station || null;
    if(key){
      const state = ensureInfrastructureState(station || findStationByKey(key));
      if(state && station) state.stationRef = station;
    }
    return;
  }
  infrastructureBuilder.activeStationKey = key;
  infrastructureBuilder.activeStationRef = station || null;
  if(key){
    const state = ensureInfrastructureState(station || findStationByKey(key));
    if(state && station) state.stationRef = station;
  }
  infrastructureBuilder.selectedCell = null;
  infrastructureBuilder.needsRender = true;
  if(infrastructureBuilder.isVisible){
    renderInfrastructureOverlay();
  }
}

function getActiveInfrastructureState(){
  const station = infrastructureBuilder.activeStationRef || stationUI.station;
  return station ? ensureInfrastructureState(station) : null;
}

function drawSolarIcon(ctx){
  ctx.save();
  const grad = ctx.createRadialGradient(0, 0, 6, 0, 0, 32);
  grad.addColorStop(0, '#fff7cc');
  grad.addColorStop(0.5, '#fde68a');
  grad.addColorStop(1, '#f59e0b');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(0, 0, 22, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = 'rgba(79,129,255,0.9)';
  ctx.fillStyle = 'rgba(59,89,178,0.85)';
  ctx.lineWidth = 3;
  for(let i=0;i<4;i++){
    ctx.save();
    ctx.rotate((Math.PI/2) * i);
    ctx.beginPath();
    ctx.rect(18, -9, 30, 18);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  ctx.strokeStyle = 'rgba(255,237,213,0.55)';
  ctx.lineWidth = 2;
  for(let i=0;i<8;i++){
    const angle = (Math.PI / 4) * i;
    ctx.beginPath();
    ctx.moveTo(Math.cos(angle) * 12, Math.sin(angle) * 12);
    ctx.lineTo(Math.cos(angle) * 32, Math.sin(angle) * 32);
    ctx.stroke();
  }
  ctx.restore();
}

function drawShipyardIcon(ctx, tier){
  ctx.save();
  const accent = ({
    S:'#38bdf8',
    M:'#34d399',
    L:'#818cf8',
    C:'#f97316',
    SC:'#f472b6'
  })[tier] || '#38bdf8';

  ctx.fillStyle = 'rgba(20,28,52,0.95)';
  ctx.strokeStyle = accent;
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.rect(-32, -20, 64, 40);
  ctx.fill();
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(-32, -12); ctx.lineTo(-48, -20);
  ctx.moveTo(-32, 12);  ctx.lineTo(-48, 20);
  ctx.moveTo(32, -12);  ctx.lineTo(48, -20);
  ctx.moveTo(32, 12);   ctx.lineTo(48, 20);
  ctx.stroke();

  ctx.fillStyle = 'rgba(56,91,189,0.35)';
  ctx.beginPath();
  ctx.arc(0, 0, 16, 0, Math.PI * 2);
  ctx.fill();
  ctx.strokeStyle = accent;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(0, 0, 16, 0, Math.PI * 2);
  ctx.stroke();

  ctx.fillStyle = '#e2e8f0';
  ctx.font = tier === 'SC' ? 'bold 14px Inter, system-ui' : 'bold 16px Inter, system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(tier || 'S', 0, 0);
  ctx.restore();
}

function drawStorageIcon(ctx, color, label){
  ctx.save();
  ctx.fillStyle = 'rgba(10,16,34,0.95)';
  ctx.strokeStyle = color || '#60a5fa';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.rect(-30, -24, 60, 48);
  ctx.fill();
  ctx.stroke();

  ctx.fillStyle = (color || '#60a5fa') + '33';
  ctx.fillRect(-24, -6, 48, 12);

  ctx.fillStyle = color || '#60a5fa';
  ctx.fillRect(-28, 18, 56, 6);

  ctx.fillStyle = '#dbeafe';
  ctx.font = 'bold 18px Inter, system-ui';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(label || 'S', 0, -4);
  ctx.restore();
}

function drawGenericIcon(ctx){
  ctx.save();
  ctx.fillStyle = 'rgba(56,80,160,0.9)';
  ctx.beginPath();
  ctx.moveTo(0, -24);
  ctx.lineTo(20, 0);
  ctx.lineTo(0, 24);
  ctx.lineTo(-20, 0);
  ctx.closePath();
  ctx.fill();
  ctx.strokeStyle = 'rgba(160,200,255,0.8)';
  ctx.lineWidth = 2;
  ctx.stroke();
  ctx.restore();
}

function drawBuildingPreview(canvas, building){
  if(!canvas || !building) return;
  const ctx = canvas.getContext('2d');
  if(!ctx) return;
  const w = canvas.width;
  const h = canvas.height;
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = 'rgba(6,10,24,0.95)';
  ctx.fillRect(0, 0, w, h);
  ctx.translate(w / 2, h / 2);
  ctx.shadowColor = 'rgba(32,64,128,0.45)';
  ctx.shadowBlur = 12;
  switch(building.icon){
    case 'solar':
      drawSolarIcon(ctx);
      break;
    case 'shipyard':
      drawShipyardIcon(ctx, building.tier);
      break;
    case 'storage':
      drawStorageIcon(ctx, building.color, building.label);
      break;
    default:
      drawGenericIcon(ctx);
  }
  ctx.restore();
}

function infrastructureDragBuildingId(ev){
  let id = null;
  if(ev && ev.dataTransfer){
    id = ev.dataTransfer.getData('text/infrastructure-building') || ev.dataTransfer.getData('text/plain');
  }
  if(!id){
    id = infrastructureBuilder.draggingBuildingId;
  }
  if(!id) return null;
  return INFRA_BUILDING_MAP.has(id) ? id : null;
}

function handleInfrastructureCellDragEnter(ev){
  const id = infrastructureDragBuildingId(ev);
  const cellEl = ev.currentTarget;
  const idx = Number.parseInt(cellEl.dataset.index, 10);
  const state = getActiveInfrastructureState();
  const meta = (state && Number.isInteger(idx)) ? state.cellMeta?.[idx] : null;
  if(!id || !state || !meta || meta.blocked) return;
  ev.preventDefault();
  infrastructureBuilder.hoveredCell = idx;
  cellEl.classList.add('drag-over');
}

function handleInfrastructureCellDragOver(ev){
  const id = infrastructureDragBuildingId(ev);
  const cellEl = ev.currentTarget;
  const idx = Number.parseInt(cellEl.dataset.index, 10);
  const state = getActiveInfrastructureState();
  const meta = (state && Number.isInteger(idx)) ? state.cellMeta?.[idx] : null;
  if(!id || !state || !meta || meta.blocked) return;
  ev.preventDefault();
  if(ev.dataTransfer){
    ev.dataTransfer.dropEffect = 'copy';
  }
  infrastructureBuilder.hoveredCell = idx;
}

function handleInfrastructureCellDragLeave(ev){
  const cellEl = ev.currentTarget;
  cellEl.classList.remove('drag-over');
  const related = ev.relatedTarget;
  if(!cellEl.contains(related)){ // left the cell entirely
    const idx = Number.parseInt(cellEl.dataset.index, 10);
    if(Number.isInteger(idx) && infrastructureBuilder.hoveredCell === idx){
      infrastructureBuilder.hoveredCell = null;
    }
  }
}

function handleInfrastructureCellDrop(ev){
  ev.preventDefault();
  const cellEl = ev.currentTarget;
  cellEl.classList.remove('drag-over');
  const id = infrastructureDragBuildingId(ev);
  if(!id) return;
  const idx = Number.parseInt(cellEl.dataset.index, 10);
  if(!Number.isInteger(idx)) return;
  const state = getActiveInfrastructureState();
  if(!state) return;
  const meta = state.cellMeta?.[idx];
  if(meta?.blocked) return;
  startInfrastructureBuildAtCell(state, idx, id);
  infrastructureBuilder.hoveredCell = idx;
  renderInfrastructureOverlay();
}

function startInfrastructureBuildAtCell(state, idx, buildingId){
  const building = INFRA_BUILDING_MAP.get(buildingId);
  if(!state || !building) return false;
  const totalCells = infrastructureBuilder.gridCols * infrastructureBuilder.gridRows;
  if(idx < 0 || idx >= totalCells) return false;
  const meta = state.cellMeta?.[idx];
  if(!meta || meta.blocked) return false;
  if(state.cells[idx] && state.cells[idx].status === 'completed') return false;
  state.cells[idx] = {
    buildingId,
    status:'building',
    elapsed:0,
    duration:Math.max(1, building.buildTime),
    progress:0,
    startedAt:performance.now()/1000,
    cellIndex: idx,
    gridX: meta.col,
    gridY: meta.row,
    localPos: { x: meta.local.x, y: meta.local.y },
    emitted: false
  };
  infrastructureBuilder.selectedCell = idx;
  infrastructureBuilder.needsRender = true;
  return true;
}

function infrastructureLocalToWorld(station, local){
  if(!station || !local) return { x: station?.x ?? 0, y: station?.y ?? 0 };
  const angle = station.angle || 0;
  const rotated = rotate(local, angle);
  return { x: station.x + rotated.x, y: station.y + rotated.y };
}

function emitInfrastructureCompletion(state, idx, cell){
  if(!state || !cell || cell.emitted) return;
  const station = state.stationRef || findStationByKey(state.stationKey);
  if(!station) return;
  const meta = state.cellMeta?.[idx];
  const local = cell.localPos || meta?.local;
  if(!local) return;
  cell.localPos = { x: local.x, y: local.y };
  const worldPos = infrastructureLocalToWorld(station, cell.localPos);
  if(!Game.infrastructure) Game.infrastructure = new Map();
  let list = Game.infrastructure.get(state.stationKey);
  if(!list){
    list = [];
    Game.infrastructure.set(state.stationKey, list);
  }
  let existing = list.find(inst => inst.cellIndex === idx);
  if(!existing){
    existing = { cellIndex: idx };
    list.push(existing);
  }
  existing.buildingId = cell.buildingId;
  existing.stationKey = state.stationKey;
  existing.localPos = { x: cell.localPos.x, y: cell.localPos.y };
  existing.worldPos = worldPos;
  existing.stationRef = station;
  existing.status = 'completed';
  cell.emitted = true;
}

function drawInfrastructureIcon(ctx, building, center, size, alpha = 1){
  if(!ctx || !building || !center) return;
  ctx.save();
  ctx.translate(center.x, center.y);
  const scale = size > 0 ? (size / 96) : 1;
  ctx.scale(scale, scale);
  ctx.globalAlpha *= alpha;
  switch(building.icon){
    case 'solar':
      drawSolarIcon(ctx);
      break;
    case 'shipyard':
      drawShipyardIcon(ctx, building.tier);
      break;
    case 'storage':
      drawStorageIcon(ctx, building.color, building.label);
      break;
    default:
      drawGenericIcon(ctx);
      break;
  }
  ctx.restore();
}

function drawInfrastructureGrid(ctx, cam, station, state){
  if(!ctx || !cam || !station || !state) return;
  const alpha = infrastructureBuilder.editorAlpha;
  if(alpha <= 0.001) return;
  const layout = state.layout || infrastructureBuilder.layout || getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
  const cellSizeWorld = layout?.cellSize ?? INFRA_CELL_WORLD_SIZE;
  const cellSize = cellSizeWorld * cam.zoom;
  const half = cellSize / 2;
  ctx.save();
  ctx.globalAlpha = alpha * 0.85;
  for(let i=0;i<layout.cells.length;i++){
    const meta = layout.cells[i];
    const worldCenter = infrastructureLocalToWorld(station, meta.local);
    const screen = worldToScreen(worldCenter.x, worldCenter.y, cam);
    const cellData = state.cells[i];
    const blocked = !!meta.blocked;
    const done = cellData?.status === 'completed';
    const progress = clamp(cellData?.progress ?? 0, 0, 1);

    const fillBase = blocked ? 'rgba(210,80,70,0.25)' : 'rgba(60,100,180,0.18)';
    const fillBuilding = done ? 'rgba(56,180,135,0.26)' : 'rgba(90,140,220,0.28)';
    ctx.fillStyle = cellData ? fillBuilding : fillBase;
    ctx.fillRect(screen.x - half, screen.y - half, cellSize, cellSize);

    ctx.lineWidth = Math.max(1, 1.3 * cam.zoom);
    ctx.strokeStyle = blocked ? 'rgba(255,120,90,0.6)' : 'rgba(130,170,255,0.35)';
    if(cellData){
      ctx.strokeStyle = done ? 'rgba(82,205,150,0.8)' : 'rgba(108,170,255,0.75)';
    }
    ctx.strokeRect(screen.x - half, screen.y - half, cellSize, cellSize);

    if(cellData){
      const building = INFRA_BUILDING_MAP.get(cellData.buildingId);
      if(building){
        drawInfrastructureIcon(ctx, building, screen, cellSize * 0.72, alpha);
      }
      if(!done){
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(96,165,250,0.85)';
        ctx.lineWidth = Math.max(1.4, cam.zoom * 2.2);
        ctx.arc(screen.x, screen.y, cellSize * 0.38, -Math.PI/2, -Math.PI/2 + Math.PI * 2 * progress);
        ctx.stroke();
      }
    } else if(blocked){
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,110,90,0.65)';
      ctx.setLineDash([8 * cam.zoom, 6 * cam.zoom]);
      ctx.lineDashOffset = performance.now() * 0.04;
      ctx.strokeRect(screen.x - half, screen.y - half, cellSize, cellSize);
      ctx.setLineDash([]);
    }
  }

  const hovered = infrastructureBuilder.hoveredCell;
  const ghostId = infrastructureBuilder.draggingBuildingId;
  if(ghostId && hovered != null){
    const meta = state.cellMeta?.[hovered];
    if(meta){
      const worldCenter = infrastructureLocalToWorld(station, meta.local);
      const screen = worldToScreen(worldCenter.x, worldCenter.y, cam);
      const blocked = !!meta.blocked || !!state.cells[hovered];
      const ghostAlpha = infrastructureBuilder.ghostAlpha * alpha;
      if(ghostAlpha > 0.02){
        ctx.globalAlpha = ghostAlpha * 0.9;
        ctx.fillStyle = blocked ? 'rgba(220,70,70,0.35)' : 'rgba(80,150,255,0.3)';
        ctx.fillRect(screen.x - half, screen.y - half, cellSize, cellSize);
        if(!blocked){
          const building = INFRA_BUILDING_MAP.get(ghostId);
          if(building){
            drawInfrastructureIcon(ctx, building, screen, cellSize * 0.72, ghostAlpha);
          }
        }
        ctx.globalAlpha = alpha * 0.85;
      }
    }
  }
  ctx.restore();
}

function drawInfrastructureInstances(ctx, cam){
  if(!ctx || !cam || !Game.infrastructure) return;
  const activeKey = (stationUI.editorMode && stationUI.station) ? getInfrastructureStationKey(stationUI.station) : null;
  ctx.save();
  Game.infrastructure.forEach((list, key) => {
    if(activeKey && key === activeKey) return;
    for(const inst of list){
      if(!inst || !inst.worldPos || !inst.buildingId) continue;
      const building = INFRA_BUILDING_MAP.get(inst.buildingId);
      if(!building) continue;
      const screen = worldToScreen(inst.worldPos.x, inst.worldPos.y, cam);
      const size = INFRA_CELL_WORLD_SIZE * cam.zoom * 0.6;
      ctx.globalAlpha = 0.9;
      drawInfrastructureIcon(ctx, building, screen, size, 0.95);
    }
  });
  ctx.restore();
}

function initInfrastructureUI(){
  const overlay = infrastructureBuilder.overlay;
  if(!overlay) return;
  const tabBtn = overlay.querySelector('li[data-tab="infrastructure"]');
  if(tabBtn){
    tabBtn.addEventListener('click', ()=>{
      stationUI.open = true;
      stationUI.tab = 'infrastructure';
      setInfrastructureUIVisible(true);
    });
  }

  const list = infrastructureBuilder.list;
  if(list){
    list.innerHTML = '';
    for(const building of INFRASTRUCTURE_BUILDINGS){
      const item = document.createElement('div');
      item.className = 'infra-building';
      item.draggable = true;
      item.dataset.building = building.id;
      const canvas = document.createElement('canvas');
      canvas.width = 96;
      canvas.height = 96;
      canvas.className = 'infra-building-canvas';
      item.appendChild(canvas);
      const name = document.createElement('div');
      name.className = 'infra-building-name';
      name.textContent = building.name;
      item.appendChild(name);
      const meta = document.createElement('div');
      meta.className = 'infra-building-meta';
      meta.textContent = `Czas budowy: ${building.buildTime}s`;
      item.appendChild(meta);
      item.addEventListener('dragstart', (ev)=>{
        item.classList.add('dragging');
        infrastructureBuilder.draggingBuildingId = building.id;
        if(ev.dataTransfer){
          ev.dataTransfer.effectAllowed = 'copy';
          ev.dataTransfer.setData('text/plain', building.id);
          ev.dataTransfer.setData('text/infrastructure-building', building.id);
        }
      });
      item.addEventListener('dragend', ()=>{
        item.classList.remove('dragging');
        infrastructureBuilder.draggingBuildingId = null;
        infrastructureBuilder.hoveredCell = null;
      });
      list.appendChild(item);
      drawBuildingPreview(canvas, building);
    }
  }

  const grid = infrastructureBuilder.grid;
  if(grid){
    grid.style.setProperty('--infra-cols', infrastructureBuilder.gridCols);
    grid.innerHTML = '';
    infrastructureBuilder.gridCells = [];
    const layout = getInfrastructureLayout(infrastructureBuilder.gridCols, infrastructureBuilder.gridRows);
    const total = infrastructureBuilder.gridCols * infrastructureBuilder.gridRows;
    for(let i=0;i<total;i++){
      const cell = document.createElement('div');
      cell.className = 'infra-cell empty';
      cell.dataset.index = String(i);
      const meta = layout.cells?.[i];
      if(meta?.blocked){
        cell.classList.add('core');
        cell.classList.remove('empty');
        cell.dataset.blocked = '1';
      } else {
        cell.dataset.blocked = '0';
      }
      const canvas = document.createElement('canvas');
      canvas.width = 96;
      canvas.height = 96;
      cell.appendChild(canvas);
      const progressBar = document.createElement('div');
      progressBar.className = 'infra-progress-bar';
      const fill = document.createElement('div');
      fill.className = 'infra-progress-fill';
      progressBar.appendChild(fill);
      cell.appendChild(progressBar);
      const status = document.createElement('div');
      status.className = 'infra-cell-status';
      status.textContent = meta?.blocked ? 'Rdzeń stacji' : 'Puste';
      cell.appendChild(status);
      cell.addEventListener('dragenter', handleInfrastructureCellDragEnter);
      cell.addEventListener('dragover', handleInfrastructureCellDragOver);
      cell.addEventListener('dragleave', handleInfrastructureCellDragLeave);
      cell.addEventListener('drop', handleInfrastructureCellDrop);
      cell.addEventListener('click', ()=>{
        infrastructureBuilder.selectedCell = i;
        renderInfrastructureOverlay();
      });
      infrastructureBuilder.gridCells.push(cell);
      grid.appendChild(cell);
    }
  }

  setInfrastructureUIVisible(false);
  renderInfrastructureOverlay();
}

function setInfrastructureUIVisible(visible){
  const overlay = infrastructureBuilder.overlay;
  if(!overlay) return;
  if(visible){
    if(infrastructureBuilder.isVisible){
      if(stationUI.station){
        setInfrastructureActiveStation(stationUI.station);
      }
      if(infrastructureBuilder.needsRender){
        renderInfrastructureOverlay();
      }
      return;
    }
    if(infrastructureBuilder.hideTimer){
      clearTimeout(infrastructureBuilder.hideTimer);
      infrastructureBuilder.hideTimer = null;
    }
    overlay.classList.remove('hidden');
    overlay.classList.remove('infra-hiding');
    void overlay.offsetWidth;
    overlay.classList.add('infra-visible');
    applyInfrastructureOverlayPosition();
    infrastructureBuilder.isVisible = true;
    if(stationUI.station){
      setInfrastructureActiveStation(stationUI.station);
    }
    renderInfrastructureOverlay();
  } else {
    if(!infrastructureBuilder.isVisible){
      overlay.classList.add('hidden');
      return;
    }
    overlay.classList.remove('infra-visible');
    overlay.classList.add('infra-hiding');
    infrastructureBuilder.isVisible = false;
    if(infrastructureBuilder.hideTimer){
      clearTimeout(infrastructureBuilder.hideTimer);
    }
    infrastructureBuilder.hideTimer = setTimeout(()=>{
      overlay.classList.add('hidden');
      overlay.classList.remove('infra-hiding');
    }, 220);
    infrastructureBuilder.hoveredCell = null;
    infrastructureBuilder.draggingOverlay = false;
    overlay.classList.remove('dragging');
  }
}

function renderInfrastructureInfo(state){
  const info = infrastructureBuilder.info;
  if(!info) return;
  info.innerHTML = '';
  const station = infrastructureBuilder.activeStationRef || stationUI.station;
  const title = document.createElement('h4');
  title.textContent = station?.name ? `Infrastruktura: ${station.name}` : 'Budowa stacji';
  info.appendChild(title);

  if(!state){
    const p = document.createElement('p');
    p.textContent = 'Brak aktywnej stacji. Wybierz stację, aby rozpocząć budowę.';
    info.appendChild(p);
    return;
  }

  const totalUsed = state.cells.filter(Boolean).length;
  const completed = state.cells.filter(cell => cell && cell.status === 'completed').length;

  if(infrastructureBuilder.selectedCell == null){
    const p = document.createElement('p');
    p.textContent = 'Przeciągnij budynek na siatkę, aby rozpocząć budowę. Kliknij pole, aby zobaczyć szczegóły.';
    info.appendChild(p);
    const summary = document.createElement('p');
    summary.textContent = `Ukończone budynki: ${completed}/${totalUsed}.`;
    summary.style.fontSize = '12px';
    summary.style.color = '#94a9d6';
    info.appendChild(summary);
    return;
  }

  const idx = infrastructureBuilder.selectedCell;
  const meta = state.cellMeta?.[idx];
  if(!meta){
    const p = document.createElement('p');
    p.textContent = 'Nie można odczytać danych pola. Odśwież interfejs.';
    info.appendChild(p);
    return;
  }
  const cell = state.cells[idx];
  const local = cell?.localPos || meta.local;
  if(cell && !cell.localPos && local){
    cell.localPos = { x: local.x, y: local.y };
  }
  if(meta.blocked && !cell){
    const p = document.createElement('p');
    p.textContent = 'Rdzeń stacji — strefa serwisowa niedostępna dla infrastruktury.';
    info.appendChild(p);
    const coords = document.createElement('p');
    coords.textContent = `Położenie rdzenia: Δx ${Math.round(local?.x ?? 0)}, Δy ${Math.round(local?.y ?? 0)}.`;
    coords.style.fontSize = '12px';
    coords.style.color = '#94a9d6';
    info.appendChild(coords);
    return;
  }
  if(!cell){
    const p = document.createElement('p');
    p.textContent = 'Puste pole. Upuść budynek z listy po lewej, aby rozpocząć konstrukcję.';
    info.appendChild(p);
    if(local){
      const coords = document.createElement('p');
      coords.textContent = `Położenie względem centrum: Δx ${Math.round(local.x)}, Δy ${Math.round(local.y)}.`;
      coords.style.fontSize = '12px';
      coords.style.color = '#94a9d6';
      info.appendChild(coords);
    }
    return;
  }

  const building = INFRA_BUILDING_MAP.get(cell.buildingId);
  const name = document.createElement('p');
  name.textContent = building?.name || 'Budowa';
  name.style.fontWeight = '600';
  info.appendChild(name);

  const status = document.createElement('p');
  const progress = cell.status === 'completed' ? 1 : clamp(cell.progress ?? 0, 0, 1);
  if(cell.status === 'completed'){
    status.textContent = 'Status: Zakończono budowę.';
  } else {
    const remaining = Math.max(0, (cell.duration ?? 0) - (cell.elapsed ?? 0));
    status.textContent = `Status: W budowie — ${Math.round(progress*100)}% (pozostało ${remaining.toFixed(1)}s).`;
  }
  info.appendChild(status);

  const buildTime = document.createElement('p');
  buildTime.textContent = `Czas budowy: ${building?.buildTime ?? '?'} s`;
  buildTime.style.fontSize = '13px';
  buildTime.style.color = '#a8b4d9';
  info.appendChild(buildTime);

  if(local){
    const coords = document.createElement('p');
    coords.textContent = `Położenie względem stacji: Δx ${Math.round(local.x)}, Δy ${Math.round(local.y)}.`;
    coords.style.fontSize = '12px';
    coords.style.color = '#94a9d6';
    info.appendChild(coords);
  }

  const progressWrap = document.createElement('div');
  progressWrap.className = 'infra-info-progress';
  const strong = document.createElement('strong');
  strong.textContent = 'Postęp';
  progressWrap.appendChild(strong);
  const bar = document.createElement('div');
  bar.className = 'infra-progress-bar';
  const fill = document.createElement('div');
  fill.className = 'infra-progress-fill';
  fill.style.width = `${Math.round(progress * 100)}%`;
  bar.appendChild(fill);
  progressWrap.appendChild(bar);
  info.appendChild(progressWrap);
}

function renderInfrastructureOverlay(){
  if(!infrastructureBuilder.gridCells.length){
    infrastructureBuilder.needsRender = true;
    return;
  }
  const station = infrastructureBuilder.activeStationRef || stationUI.station;
  const state = station ? ensureInfrastructureState(station) : null;
  if(station && !infrastructureBuilder.activeStationRef){
    infrastructureBuilder.activeStationRef = station;
  }
  const total = infrastructureBuilder.gridCols * infrastructureBuilder.gridRows;
  if(state && state.cells.length < total){
    const diff = total - state.cells.length;
    state.cells = state.cells.concat(Array(diff).fill(null));
  }

  for(let i=0;i<infrastructureBuilder.gridCells.length;i++){
    const cellEl = infrastructureBuilder.gridCells[i];
    const cellData = state ? state.cells[i] : null;
    const meta = state ? state.cellMeta?.[i] : null;
    const blocked = !!meta?.blocked;
    const canvas = cellEl.querySelector('canvas');
    const progressFill = cellEl.querySelector('.infra-progress-fill');
    const status = cellEl.querySelector('.infra-cell-status');
    cellEl.classList.toggle('selected', infrastructureBuilder.selectedCell === i);
    cellEl.classList.toggle('core', blocked);
    if(cellData){
      const building = INFRA_BUILDING_MAP.get(cellData.buildingId);
      cellEl.classList.remove('empty');
      cellEl.classList.add('has-building');
      const done = cellData.status === 'completed';
      cellEl.classList.toggle('completed', done);
      const progress = done ? 1 : clamp(cellData.progress ?? 0, 0, 1);
      if(canvas) drawBuildingPreview(canvas, building);
      if(progressFill) progressFill.style.width = `${Math.round(progress * 100)}%`;
      if(status) status.textContent = done ? 'Zakończono' : `${Math.round(progress * 100)}%`;
    } else {
      cellEl.classList.toggle('empty', !blocked);
      cellEl.classList.remove('has-building', 'completed');
      if(canvas){
        const ctx = canvas.getContext('2d');
        if(ctx){ ctx.clearRect(0, 0, canvas.width, canvas.height); }
      }
      if(progressFill) progressFill.style.width = '0%';
      if(status) status.textContent = blocked ? 'Rdzeń stacji' : 'Puste';
    }
  }
  infrastructureBuilder.needsRender = false;
  renderInfrastructureInfo(state || null);
}

function renderInfrastructureTab(){
  uiTitle('Infrastruktura stacji');
  const station = stationUI.station;
  if(!station){
    uiText('Brak aktywnej stacji.');
    return;
  }
  const state = ensureInfrastructureState(station);
  const totalUsed = state.cells.filter(Boolean).length;
  const completed = state.cells.filter(cell => cell && cell.status === 'completed').length;
  uiText('Zarządzaj infrastrukturą w panelu Infrastructure obok.');
  uiText(`Budowy ukończone: ${completed}/${totalUsed}.`);
  uiText('Przeciągnij budynek na siatkę, aby rozpocząć konstrukcję lub kliknij pole, by zobaczyć postęp.');
}

function updateInfrastructureEditorState(dt){
  const target = stationUI.editorMode ? 1 : 0;
  if(target > infrastructureBuilder.editorAlpha){
    infrastructureBuilder.editorAlpha = Math.min(target, infrastructureBuilder.editorAlpha + dt * 4.2);
  } else if(target < infrastructureBuilder.editorAlpha){
    infrastructureBuilder.editorAlpha = Math.max(target, infrastructureBuilder.editorAlpha - dt * 5.6);
    if(infrastructureBuilder.editorAlpha <= 0.001){
      infrastructureBuilder.editorAlpha = 0;
      infrastructureBuilder.hoveredCell = null;
    }
  }

  const ghostTarget = infrastructureBuilder.draggingBuildingId ? 1 : 0;
  if(ghostTarget > infrastructureBuilder.ghostAlpha){
    infrastructureBuilder.ghostAlpha = Math.min(ghostTarget, infrastructureBuilder.ghostAlpha + dt * 10);
  } else if(ghostTarget < infrastructureBuilder.ghostAlpha){
    infrastructureBuilder.ghostAlpha = Math.max(ghostTarget, infrastructureBuilder.ghostAlpha - dt * 8);
  }
}

function updateInfrastructureState(dt){
  let changed = false;
  infrastructureBuilder.stationStates.forEach(state => {
    if(!state || !state.cells) return;
    state.cells.forEach((cell, idx) => {
      if(!cell) return;
      if(cell.status === 'building'){
        const prev = cell.progress || 0;
        cell.elapsed = (cell.elapsed || 0) + dt;
        const duration = Math.max(0.1, cell.duration || 1);
        cell.progress = clamp(cell.elapsed / duration, 0, 1);
        if(cell.progress !== prev) changed = true;
        if(cell.progress >= 1 && cell.status !== 'completed'){
          cell.status = 'completed';
          changed = true;
        }
      }
      if(cell.status === 'completed' && !cell.emitted){
        emitInfrastructureCompletion(state, idx, cell);
        changed = true;
      }
    });
  });
  if(changed){
    if(infrastructureBuilder.isVisible){
      renderInfrastructureOverlay();
    } else {
      infrastructureBuilder.needsRender = true;
    }
  } else if(infrastructureBuilder.isVisible && infrastructureBuilder.needsRender){
    renderInfrastructureOverlay();
  }
}

function syncInfrastructureWorldPositions(){
  if(!Game.infrastructure) return;
  Game.infrastructure.forEach((list, key) => {
    const station = findStationByKey(key);
    if(!station) return;
    for(const inst of list){
      if(!inst || !inst.localPos) continue;
      inst.stationRef = station;
      inst.worldPos = infrastructureLocalToWorld(station, inst.localPos);
    }
  });
}

function renderMechanicTab(){
  uiTitle('Mechanic');
  uiText('Zarządzaj hardpointami i uzbrojeniem w panelu obok.');
}

function initMechanicUI(){
  // Ta funkcja jest teraz uproszczona, ponieważ logika została przeniesiona 
  // bezpośrednio do buildMechanicPanel w głównym oknie stacji.
  // Zachowujemy ją tylko dla kompatybilności, jeśli coś ją wywołuje.
}

const HP_GROUP_META = {
  [HP.MAIN]:    { title:'Broń główna', css:'hp-main' },
  [HP.MISSILE]: { title:'Rakiety', css:'hp-miss' },
  [HP.AUX]:     { title:'Broń dodatkowa', css:'hp-aux' },
  [HP.HANGAR]:  { title:'Hangary', css:'hp-hangar' },
  [HP.SPECIAL]: { title:'Broń specjalna', css:'hp-spec' },
};
let mechanicDragWeaponId = null;

function mechanicIconForWeapon(weapon, hpType){
  const iconPath = weapon ? WEAPON_ICON_PATHS[weapon.id] : null;
  const hasIcon = !!iconPath;
  if(hasIcon){
    const wrap = document.createElement('span');
    wrap.className = 'weapon-icon-wrap';
    const img = document.createElement('img');
    img.src = iconPath;
    img.loading = 'lazy';
    img.alt = weapon?.name || 'Broń';
    wrap.appendChild(img);
    return wrap;
  }
  const placeholder = document.createElement('span');
  placeholder.className = 'weapon-icon-placeholder';
  placeholder.dataset.type = hpType;
  placeholder.textContent = weapon ? 'NO ART' : 'EMPTY';
  return placeholder;
}

function weaponMetaText(weapon){
  if(!weapon) return '';
  const parts = [];
  if(weapon.dps != null) parts.push(`${weapon.dps} dps`);
  if(weapon.damage != null) parts.push(`${weapon.damage} dmg`);
  if(weapon.cooldown != null) parts.push(`${weapon.cooldown}s cd`);
  if(weapon.ammo != null) parts.push(`${weapon.ammo} ammo`);
  if(weapon.energy != null) parts.push(`${weapon.energy}e`);
  return parts.join(' • ');
}

function applyWeaponToHardpoint(hp, weaponId){
  if(!hp) return;
  const weapon = weaponId ? WEAPONS[weaponId] : null;
  setHardpointMount(hp, weaponId);
  if(weapon && weapon.ammo != null){
    hp.ammo = weapon.ammo;
    hp.maxAmmo = weapon.ammo;
  }
  syncWeaponSystems();
  renderMechanic();
  saveLoadout();
}

function attachSlotDnD(slot, hp){
  slot.addEventListener('dragover', (e)=>{
    const weaponId = mechanicDragWeaponId || e.dataTransfer?.getData('text/plain');
    const weapon = weaponId ? WEAPONS[weaponId] : null;
    if(!weapon || weapon.type !== hp.type) return;
    e.preventDefault();
    slot.classList.add('drag-over');
  });
  slot.addEventListener('dragleave', ()=>{ slot.classList.remove('drag-over'); });
  slot.addEventListener('drop', (e)=>{
    const weaponId = e.dataTransfer?.getData('text/plain') || mechanicDragWeaponId;
    const weapon = weaponId ? WEAPONS[weaponId] : null;
    slot.classList.remove('drag-over');
    if(!weapon || weapon.type !== hp.type) return;
    e.preventDefault();
    applyWeaponToHardpoint(hp, weapon.id);
  });
}

function quickMountWeapon(weapon){
  if(!weapon) return;
  const targetHp = Game.player.hardpoints.find(h=>h.type === weapon.type);
  if(targetHp){
    applyWeaponToHardpoint(targetHp, weapon.id);
  }
}

function createWeaponChip(weapon){
  const chip = document.createElement('div');
  chip.className = 'weapon-chip';
  chip.draggable = true;
  chip.dataset.weaponId = weapon.id;
  chip.dataset.weaponType = weapon.type;
  chip.appendChild(mechanicIconForWeapon(weapon, weapon.type));

  const content = document.createElement('div');
  content.style.display = 'flex';
  content.style.flexDirection = 'column';
  content.style.gap = '4px';
  const name = document.createElement('div');
  name.className = 'weapon-name';
  name.textContent = weapon.name;
  const meta = document.createElement('div');
  meta.className = 'weapon-meta';
  const metaText = weaponMetaText(weapon);
  if(metaText) meta.textContent = metaText;
  content.appendChild(name);
  content.appendChild(meta);
  chip.appendChild(content);

  chip.addEventListener('dragstart', (e)=>{
    mechanicDragWeaponId = weapon.id;
    chip.classList.add('dragging');
    if(e.dataTransfer){
      e.dataTransfer.setData('text/plain', weapon.id);
      e.dataTransfer.effectAllowed = 'move';
    }
  });
  chip.addEventListener('dragend', ()=>{
    mechanicDragWeaponId = null;
    chip.classList.remove('dragging');
  });
  chip.addEventListener('dblclick', ()=> quickMountWeapon(weapon));
  return chip;
}

function renderAvailableWeapons(root){
  if(!root) return;
  root.innerHTML = '';
  const inventory = Game.player?.inventory || new Set();
  const weapons = [...inventory].map(id => WEAPONS[id]).filter(Boolean);
  const grouped = {};
  for(const t of Object.values(HP)) grouped[t] = [];
  for(const w of weapons){
    grouped[w.type].push(w);
  }
  for(const type of Object.values(HP)){
    const meta = HP_GROUP_META[type];
    const wrapper = document.createElement('div');
    wrapper.className = 'weapon-group';
    const header = document.createElement('div');
    header.className = 'weapon-group-header';
    const title = document.createElement('h5');
    title.textContent = meta?.title || type;
    const count = document.createElement('span');
    count.className = 'weapon-count';
    count.textContent = `${grouped[type].length} szt.`;
    header.appendChild(title);
    header.appendChild(count);
    wrapper.appendChild(header);

    if(!grouped[type].length){
      const empty = document.createElement('div');
      empty.className = 'weapon-meta';
      empty.textContent = 'Brak dostępnych części w magazynie.';
      wrapper.appendChild(empty);
    } else {
      grouped[type].sort((a,b)=>a.name.localeCompare(b.name));
      for(const weapon of grouped[type]){
        wrapper.appendChild(createWeaponChip(weapon));
      }
    }
    root.appendChild(wrapper);
  }
}

function createHpSlot(hp, idx){
  const slot = document.createElement('div');
  slot.className = 'hp-slot';
  slot.dataset.hpId = hp.id;
  slot.dataset.hpType = hp.type;
  if(!hp.mount) slot.classList.add('empty');

  const header = document.createElement('div');
  header.className = 'hp-slot-header';
  const label = document.createElement('span');
  label.className = 'hp-slot-label';
  label.textContent = `Slot #${idx+1}`;
  const clearBtn = document.createElement('button');
  clearBtn.className = 'hp-slot-clear';
  clearBtn.textContent = 'Odczep';
  clearBtn.disabled = !hp.mount;
  clearBtn.addEventListener('click', ()=>{
    applyWeaponToHardpoint(hp, null);
  });
  header.appendChild(label);
  header.appendChild(clearBtn);
  slot.appendChild(header);

  const body = document.createElement('div');
  body.className = 'hp-slot-body';
  const weapon = hp.mount ? WEAPONS[hp.mount] : null;
  body.appendChild(mechanicIconForWeapon(weapon, hp.type));
  const info = document.createElement('div');
  info.style.display = 'flex';
  info.style.flexDirection = 'column';
  info.style.gap = '4px';
  const name = document.createElement('div');
  name.className = 'weapon-name';
  name.textContent = weapon ? weapon.name : 'Brak zamontowanej broni';
  const meta = document.createElement('div');
  meta.className = 'weapon-meta';
  meta.textContent = weapon ? weaponMetaText(weapon) : 'Upuść część z magazynu, aby zamontować.';
  info.appendChild(name);
  info.appendChild(meta);
  body.appendChild(info);
  slot.appendChild(body);

  const hint = document.createElement('div');
  hint.className = 'hp-slot-hint';
  hint.textContent = 'Przeciągnij broń z listy po lewej.';
  slot.appendChild(hint);

  attachSlotDnD(slot, hp);
  return slot;
}

function renderInstalledHardpoints(root){
  if(!root) return;
  const listByType = {};
  for(const t of Object.values(HP)) listByType[t] = [];
  for(const hp of Game.player.hardpoints) listByType[hp.type].push(hp);
  root.innerHTML = '';
  for(const type of Object.values(HP)){
    const meta = HP_GROUP_META[type];
    const slots = listByType[type];
    const group = document.createElement('div');
    group.className = `hp-group ${meta?.css || ''}`;
    const title = document.createElement('h4');
    title.textContent = meta?.title || type;
    const small = document.createElement('small');
    small.textContent = `${slots.length} slotów`;
    title.appendChild(small);
    group.appendChild(title);

    if(!slots.length){
      const empty = document.createElement('div');
      empty.className = 'hp-slot empty';
      const label = document.createElement('div');
      label.className = 'hp-slot-hint';
      label.textContent = 'Brak slotów w tej kategorii.';
      empty.appendChild(label);
      group.appendChild(empty);
    } else {
      slots.forEach((hp, idx)=>{
        group.appendChild(createHpSlot(hp, idx));
      });
    }
    root.appendChild(group);
  }
}

function renderMechanic(){
  renderAvailableWeapons(document.getElementById('mechanic-available'));
  renderInstalledHardpoints(document.getElementById('hp-groups'));
  const sel = document.getElementById('ship-frame-select');
  if(sel && sel.value !== Game.player.shipFrame){
    sel.value = Game.player.shipFrame;
  }
}

// --- Zakładki ---
const PLAYER = { credits: 1200, cargo: {}, shipId: 'starter' };
const BLUEPRINTS = {
  upgrades: [
    { id:'rail_cooler', name:'Chłodzenie raila', cost:600, apply(){ rail.heatCap *= 1.25; rail.coolRate *= 1.15; } },
    { id:'boost_core',  name:'Wzmocniony boost', cost:700, apply(){
      boost.extraThrustMul *= 1.15;
      boost.consumeRate *= 0.9;
      boost.handlingMultiplier *= 1.05;
    } },
    { id:'agility',     name:'Zwrotność +',      cost:500, apply(){
      ship.angularDamping *= 0.9;
      ship.engines.torqueLeft.maxThrust  = Math.round(ship.engines.torqueLeft.maxThrust * 1.12);
      ship.engines.torqueRight.maxThrust = Math.round(ship.engines.torqueRight.maxThrust * 1.12);
    } },
  ],
  ships: [
    { id:'scout', name:'Scout', cost:2500, stats:{ hp:0.8, speed:1.3, cargo:0.6 } },
    { id:'frigate', name:'Fregata', cost:4200, stats:{ hp:1.6, speed:0.85, cargo:1.4 } },
  ],
};

const STATION_TAB_CONFIG = [
  { id:'upgrades', label:'Ulepszenia' },
  { id:'trade', label:'Handel' },
  { id:'cantina', label:'Kantyna' },
  { id:'hangar', label:'Hangar' },
  { id:'mechanic', label:'Mechanik' },
  { id:'infrastructure', label:'Infrastruktura' },
];

const MARKET = { // ceny przykładowe
  buy:{ ruda: 22, paliwo: 15, żywność: 8 },
  sell:{ ruda: 18, paliwo: 12, żywność: 6 }
};

const stationOverlayDom = {
  root: document.getElementById('station-overlay'),
  tabs: document.getElementById('station-tabs'),
  title: document.getElementById('station-title'),
  subtitle: document.getElementById('station-subtitle'),
  credits: document.getElementById('station-credits'),
  panels: {
    upgrades: document.getElementById('tab-upgrades'),
    trade: document.getElementById('tab-trade'),
    cantina: document.getElementById('tab-cantina'),
    hangar: document.getElementById('tab-hangar'),
    mechanic: document.getElementById('tab-mechanic-html'),
    infrastructure: document.getElementById('tab-infrastructure-html'),
  }
};

const stationOverlayState = {
  built:false,
  activeTab:null,
  stationKey:null
};

function createStationCard({ title, badge, description, meta = [], actions = [] }){
  const card = document.createElement('div');
  card.className = 'station-card';

  const header = document.createElement('div');
  header.className = 'station-card-header';
  const titleEl = document.createElement('h4');
  titleEl.className = 'station-card-title';
  titleEl.textContent = title;
  header.appendChild(titleEl);
  if(badge){
    const chip = document.createElement('span');
    chip.className = 'station-chip';
    chip.textContent = badge;
    header.appendChild(chip);
  }
  card.appendChild(header);

  if(description){
    const desc = document.createElement('p');
    desc.className = 'station-card-desc';
    desc.textContent = description;
    card.appendChild(desc);
  }

  if(meta.length){
    const metaEl = document.createElement('div');
    metaEl.className = 'station-card-meta';
    meta.forEach(text => {
      const span = document.createElement('span');
      span.textContent = text;
      metaEl.appendChild(span);
    });
    card.appendChild(metaEl);
  }

  if(actions.length){
    const actionsEl = document.createElement('div');
    actionsEl.className = 'station-card-actions';
    actions.forEach(action => {
      const btn = document.createElement('button');
      btn.textContent = action.label;
      if(action.dataset){
        for(const [k,v] of Object.entries(action.dataset)){
          btn.dataset[k] = v;
        }
      }
      if(typeof action.disabled === 'boolean') btn.disabled = action.disabled;
      btn.addEventListener('click', action.onClick);
      actionsEl.appendChild(btn);
    });
    card.appendChild(actionsEl);
  }

  return card;
}

function initStationOverlayTabs(){
  if(!stationOverlayDom.tabs) return;
  stationOverlayDom.tabs.innerHTML = '';
  for(const tab of STATION_TAB_CONFIG){
    const li = document.createElement('li');
    li.dataset.tab = tab.id;
    li.textContent = tab.label;
    li.addEventListener('click', ()=>{
      stationUI.tab = tab.id;
      renderStationUI();
    });
    stationOverlayDom.tabs.appendChild(li);
  }
}

function buildUpgradesPanel(){
  const pane = stationOverlayDom.panels.upgrades;
  if(!pane) return;
  pane.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'station-grid';
  for(const upgrade of BLUEPRINTS.upgrades){
    const card = createStationCard({
      title: upgrade.name,
      badge: 'Upgrade',
      description: 'Ulepszenie statku instalowane przez warsztat stacji.',
      meta: [`Koszt: ${upgrade.cost} cr`],
      actions: [{
        label: 'Kup',
        dataset: { upgradeId: upgrade.id, cost: upgrade.cost },
        onClick: ()=>purchaseUpgrade(upgrade)
      }]
    });
    grid.appendChild(card);
  }
  pane.appendChild(grid);
}

function buildTradePanel(){
  const pane = stationOverlayDom.panels.trade;
  if(!pane) return;
  pane.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'station-grid';
  const allItems = new Set([...Object.keys(MARKET.buy), ...Object.keys(MARKET.sell)]);
  for(const item of allItems){
    const buyPrice = MARKET.buy[item];
    const sellPrice = MARKET.sell[item];
    const card = createStationCard({
      title: toTitleCaseFromKey(item),
      badge: 'Rynek',
      description: 'Handluj surowcami z dokami stacji.',
      meta: [
        buyPrice ? `Kupno: ${buyPrice} cr` : 'Kupno: niedostępne',
        sellPrice ? `Sprzedaż: ${sellPrice} cr` : 'Sprzedaż: niedostępna',
        `Ładownia: ${PLAYER.cargo[item] || 0}`
      ],
      actions: [
        buyPrice ? {
          label: 'Kup',
          dataset: { tradeItem: item, tradeType: 'buy', price: buyPrice },
          onClick: ()=>handleTrade('buy', item, buyPrice)
        } : null,
        sellPrice ? {
          label: 'Sprzedaj',
          dataset: { tradeItem: item, tradeType: 'sell', price: sellPrice },
          onClick: ()=>handleTrade('sell', item, sellPrice)
        } : null
      ].filter(Boolean)
    });
    grid.appendChild(card);
  }
  pane.appendChild(grid);
}

function buildCantinaPanel(){
  const pane = stationOverlayDom.panels.cantina;
  if(!pane) return;
  pane.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'station-grid';
  grid.appendChild(createStationCard({
    title: 'Najemnik: piracka stacja',
    badge: 'Misja',
    description: 'Odbierz kontrakt na zniszczenie pirackiej placówki w pobliskim sektorze.',
    meta: ['Nagrody za eliminację wrogów'],
    actions: [{ label:'Przyjmij', onClick: startMercenaryMission }]
  }));
  grid.appendChild(createStationCard({
    title: 'Wojna o terytorium',
    badge: 'Misja',
    description: 'Dołącz do sił sojuszniczych i odbij punkt kontrolny z rąk piratów.',
    meta: ['Aktywuje wrogie fale w sektorze'],
    actions: [{ label:'Dołącz', onClick: startTerritoryWarMission }]
  }));
  pane.appendChild(grid);
}

function buildHangarPanel(){
  const pane = stationOverlayDom.panels.hangar;
  if(!pane) return;
  pane.innerHTML = '';
  const grid = document.createElement('div');
  grid.className = 'station-grid';

  const repairCard = createStationCard({
    title: 'Naprawy kadłuba',
    badge: 'Serwis',
    description: 'Przywróć kadłub statku do pełnej sprawności.',
    meta: ['Status: 0% uszkodzeń'],
    actions: [{ label: 'Napraw', dataset:{ action:'repair' }, onClick: handleRepair }]
  });
  grid.appendChild(repairCard);

  for(const shipBP of BLUEPRINTS.ships){
    const card = createStationCard({
      title: shipBP.name,
      badge: 'Hangar',
      description: 'Zamów nową ramę statku i przeładuj systemy.',
      meta: [
        `Koszt: ${shipBP.cost} cr`,
        `Kadłub: ${Math.round(shipBP.stats.hp * 100)}%`,
        `Prędkość: ${Math.round(shipBP.stats.speed * 100)}%`
      ],
      actions: [{
        label: 'Kup',
        dataset:{ shipId: shipBP.id, cost: shipBP.cost },
        onClick: ()=>purchaseShip(shipBP)
      }]
    });
    grid.appendChild(card);
  }
  pane.appendChild(grid);
}

function buildMechanicPanel(){
  const pane = stationOverlayDom.panels.mechanic;
  if(!pane) return;
  
  // Wstrzykujemy strukturę HTML warsztatu bezpośrednio do zakładki
  pane.innerHTML = `
    <div class="mechanic-toolbar">
      <label>Rama statku:</label>
      <select id="ship-frame-select" style="margin-left:8px; width:200px; background:#060e1c; color:#fff; border:1px solid #2a3a5a; padding:4px; border-radius:4px;"></select>
    </div>
    <div class="mechanic-body" style="margin-top:12px;">
      <div class="mechanic-column mechanic-parts">
        <div class="mechanic-section">
          <div class="mechanic-section-head">
            <div>
              <p class="mechanic-kicker">Dostępne części</p>
              <h4>Magazyn broni</h4>
              <p class="mechanic-sub">Przeciągnij broń na slot hardpointu, aby ją zamontować.</p>
            </div>
          </div>
          <div id="mechanic-available" class="weapon-pool"></div>
        </div>
      </div>
      <div class="mechanic-column mechanic-install">
        <div class="mechanic-section">
          <div class="mechanic-section-head">
            <div>
              <p class="mechanic-kicker">Uzbrojenie statku</p>
              <h4>Hardpointy</h4>
              <p class="mechanic-sub">Upuść część na slot po prawej, aby zamienić uzbrojenie.</p>
            </div>
          </div>
          <div id="hp-groups" class="hp-groups mechanic-grid"></div>
        </div>
      </div>
    </div>
  `;

  // Inicjalizacja listy wyboru statku (ponieważ właśnie stworzyliśmy element select)
  const sel = document.getElementById('ship-frame-select');
  if(sel){
    sel.innerHTML = Object.values(SHIPS).map(s=>
      `<option value="${s.id}" ${Game.player.shipFrame===s.id?'selected':''}>${s.name}</option>`
    ).join('');
    
    sel.onchange = () => {
      Game.player.shipFrame = sel.value;
      // Przelicz hardpointy dla nowej ramy
      const prev = Game.player.hardpoints.map(h=>({ type:h.type, mount:h.mount, ammo:h.ammo, maxAmmo:h.maxAmmo }));
      if(typeof rebuildHardpointsForFrame === 'function') rebuildHardpointsForFrame();
      if(typeof tryPreserveMounts === 'function') tryPreserveMounts(prev);
      if(typeof syncWeaponSystems === 'function') syncWeaponSystems();
      renderMechanic();
      if(typeof saveLoadout === 'function') saveLoadout();
    };
  }

  // Wymuś renderowanie zawartości (ikony broni i sloty)
  renderMechanic();
}

function buildInfrastructurePanel(){
  const pane = stationOverlayDom.panels.infrastructure;
  if(!pane) return;
  pane.innerHTML = '';
  pane.appendChild(createStationCard({
    title: 'Infrastruktura stacji',
    badge: 'Budowa',
    description: 'Przeciągaj budynki na siatkę infrastruktury, aby rozwijać stację.',
    meta: ['Skrót klawiatury: [6]'],
    actions: [{
      label:'Otwórz budowę',
      onClick: ()=>{
        stationUI.tab = 'infrastructure';
        setInfrastructureUIVisible(true);
        renderStationUI();
      }
    }]
  }));
}

function initStationOverlay(){
  if(!stationOverlayDom.root) return;
  initStationOverlayTabs();
  buildUpgradesPanel();
  buildTradePanel();
  buildCantinaPanel();
  buildHangarPanel();
  buildMechanicPanel();
  buildInfrastructurePanel();
  stationOverlayState.built = true;
}

function updateStationHeader(station){
  if(stationOverlayDom.title){
    stationOverlayDom.title.textContent = station?.name || 'Stacja orbitalna';
  }
  if(stationOverlayDom.subtitle){
    const parts = [];
    if(station?.planet?.name) parts.push(`Orbita: ${station.planet.name}`);
    if(Number.isFinite(station?.x) && Number.isFinite(station?.y)){
      parts.push(`Pozycja: ${Math.round(station.x)}, ${Math.round(station.y)}`);
    }
    stationOverlayDom.subtitle.textContent = parts.join(' • ') || 'Przestrzeń cywilna';
  }
  if(stationOverlayDom.credits){
    stationOverlayDom.credits.textContent = `${Math.round(PLAYER.credits)} cr`;
  }
}

function setActiveStationTab(tab){
  if(stationOverlayDom.tabs){
    stationOverlayDom.tabs.querySelectorAll('li').forEach(li => {
      li.classList.toggle('active', li.dataset.tab === tab);
    });
  }
  for(const [key, pane] of Object.entries(stationOverlayDom.panels)){
    if(!pane) continue;
    const match = key === tab;
    pane.classList.toggle('active', match);
    pane.classList.toggle('hidden', !match);
  }
}

function updateUpgradeButtons(){
  const buttons = stationOverlayDom.panels.upgrades?.querySelectorAll('button[data-upgrade-id]');
  if(!buttons) return;
  buttons.forEach(btn => {
    const cost = Number(btn.dataset.cost) || 0;
    btn.disabled = PLAYER.credits < cost;
  });
}

function updateTradeCards(){
  const cards = stationOverlayDom.panels.trade?.querySelectorAll('.station-card');
  if(!cards) return;
  cards.forEach(card => {
    const item = card.querySelector('[data-trade-item]')?.dataset.tradeItem
      || card.querySelector('button[data-trade-item]')?.dataset.tradeItem;
    if(!item) return;
    const meta = card.querySelector('.station-card-meta');
    if(meta){
      const metaSpans = [...meta.querySelectorAll('span')];
      if(metaSpans[2]) metaSpans[2].textContent = `Ładownia: ${PLAYER.cargo[item] || 0}`;
    }
    card.querySelectorAll('button[data-trade-type]').forEach(btn => {
      const price = Number(btn.dataset.price) || 0;
      const type = btn.dataset.tradeType;
      if(type === 'buy'){
        btn.disabled = PLAYER.credits < price;
      }
      if(type === 'sell'){
        btn.disabled = (PLAYER.cargo[item] || 0) <= 0;
      }
    });
  });
}

function updateHangarCards(){
  const pane = stationOverlayDom.panels.hangar;
  if(!pane) return;
  const cards = [...pane.querySelectorAll('.station-card')];
  const damageFrac = 1 - (ship.hull.val / ship.hull.max);
  const damagePct = Math.ceil(damageFrac * 100);
  const repairCost = Math.ceil(damageFrac * 600);
  const repairCard = cards.find(card => card.querySelector('button[data-action="repair"]'));
  if(repairCard){
    const meta = repairCard.querySelector('.station-card-meta span');
    if(meta) meta.textContent = `Status: ${damagePct}% uszkodzeń`;
    const btn = repairCard.querySelector('button[data-action="repair"]');
    if(btn) btn.disabled = damagePct <= 0 || PLAYER.credits < repairCost;
  }
  for(const btn of pane.querySelectorAll('button[data-ship-id]')){
    const cost = Number(btn.dataset.cost) || 0;
    btn.disabled = PLAYER.credits < cost;
  }
}

function renderStationOverlay(tab, station){
  if(!stationOverlayState.built) initStationOverlay();
  if(!stationOverlayDom.root) return;
  const stationKey = getInfrastructureStationKey(station) || station?.name || 'station';
  if(stationOverlayState.activeTab !== tab || stationOverlayState.stationKey !== stationKey){
    setActiveStationTab(tab);
    stationOverlayState.activeTab = tab;
    stationOverlayState.stationKey = stationKey;
  }
  updateStationHeader(station);
  updateUpgradeButtons();
  updateTradeCards();
  updateHangarCards();
}

function handleTrade(type, item, price){
  if(type === 'buy'){
    if(PLAYER.credits >= price){
      PLAYER.credits -= price;
      PLAYER.cargo[item] = (PLAYER.cargo[item] || 0) + 1;
    } else {
      toast('Za mało kredytów');
    }
  } else if(type === 'sell'){
    if((PLAYER.cargo[item] || 0) > 0){
      PLAYER.cargo[item] -= 1;
      PLAYER.credits += price;
    }
  }
  updateStationOverlay(stationUI.tab, stationUI.station);
}

function purchaseUpgrade(upgrade){
  if(!upgrade) return;
  if(PLAYER.credits >= upgrade.cost){
    PLAYER.credits -= upgrade.cost;
    upgrade.apply();
    toast('Zainstalowano: ' + upgrade.name);
  } else {
    toast('Za mało kredytów');
  }
  updateStationOverlay(stationUI.tab, stationUI.station);
}

function purchaseShip(shipBP){
  if(!shipBP) return;
  if(PLAYER.credits >= shipBP.cost){
    PLAYER.credits -= shipBP.cost;
    PLAYER.shipId = shipBP.id;
    applyShipStats(shipBP.stats);
    toast('Zakupiono: ' + shipBP.name);
  } else {
    toast('Za mało kredytów');
  }
  updateStationOverlay(stationUI.tab, stationUI.station);
}

function handleRepair(){
  const damageFrac = 1 - (ship.hull.val / ship.hull.max);
  const repairCost = Math.ceil(damageFrac * 600);
  if(damageFrac <= 0){
    toast('Kadłub jest w pełni sprawny');
    return;
  }
  if(PLAYER.credits >= repairCost){
    PLAYER.credits -= repairCost;
    ship.hull.val = ship.hull.max;
    toast('Naprawiono kadłub.');
  } else {
    toast('Za mało kredytów');
  }
  updateStationOverlay(stationUI.tab, stationUI.station);
}

function updateStationOverlay(tab, station){
  renderStationOverlay(tab, station);
}

initMechanicUI();
initInfrastructureUI();
function startMercenaryMission(){
  if(mercMission) { toast('Misja już aktywna. Wciśnij J aby zobaczyć dziennik.'); return; }

  const beltTarget = (() => {
    if (!ASTEROID_BELT) return null;
    const inner = ASTEROID_BELT.inner;
    if (!Number.isFinite(inner)) return null;
    const safeMargin = Math.max(1200, ZONE_APPROACH_DISTANCE * 0.6);
    const radius = Math.max(500, inner - safeMargin);
    return { radius, angle: Math.random() * Math.PI * 2 };
  })();

  const earth = planets.find(p => p.id === 'earth' || p.name === 'earth');
  const targetPlanet = earth || planets[2] || planets[0];
  const earthOrbit = targetPlanet ? planetOrbitRadii(targetPlanet) : null;

  const orbitRadius = beltTarget?.radius
    ?? earthOrbit?.outer
    ?? Math.max(1600, (targetPlanet?.r || 0) * 4);
  const angle = beltTarget?.angle ?? (Math.random() * Math.PI * 2);
  const centerX = beltTarget ? SUN.x : (targetPlanet?.x || SUN.x);
  const centerY = beltTarget ? SUN.y : (targetPlanet?.y || SUN.y);
  const x = centerX + Math.cos(angle) * orbitRadius;
  const y = centerY + Math.sin(angle) * orbitRadius;

  const r = 220;
  const portOffset = r + 60;
  const ports = [
    {x: portOffset, y: 0},
    {x: 0, y: portOffset},
    {x: -portOffset, y: 0},
    {x: 0, y: -portOffset}
  ];

  const station = {
    id: 'PIR',
    x, y, r,
    baseR: r,
    isPirate: true,
    hp: 10000, maxHp: 10000,
    static: true, mission: true,
    ports,
    style: STATION_STYLES[Math.floor(Math.random()*STATION_STYLES.length)],
    shield: {
      max: 9000,
      val: 9000,
      regenRate: 650,
      regenDelay: 4.5,
      regenTimer: 0
    }
  };

  stations.push(station);
  if (typeof window.attachPirateStation3D === 'function') {
    if (!mainScene3D && typeof window.initWorld3D === 'function') {
      const res = initWorld3D();
      mainScene3D = res?.scene || mainScene3D;
    }
    window.attachPirateStation3D(mainScene3D, station);
  }
  mercMission = {
    station,
    npcsSpawned:false,
    alertStage: 'idle',
    guardConfigured: false,
    weaponPlatforms: [],
    // --- SWARM control ---
    swarm: {
      active:false,
      maxAlive: 200,     // <- zwiększony limit
      timer: 2,
      baseInterval: 1.0, // skraca się wraz z utratą HP stacji
      queue: []
    }
  };

  mercMission.guards = [];
  for (let i = 0; i < 6; i++)
    mercMission.guards.push( spawnStationGuard(station, 'interceptor', i * (Math.PI*2/6)) );
  for (let i = 0; i < 2; i++)
    mercMission.guards.push( spawnStationGuard(station, 'frigate', i * Math.PI) );

  const orbitBase = station.r + 220;
  const baseAngle = Math.random() * Math.PI * 2;
  const angleStep = Math.PI / 2;
  const jitter = 0.25;
  const platformConfigs = [
    { angle: baseAngle + (Math.random()-0.5)*jitter, orbitRadius: orbitBase, label: 'Platforma A' },
    { angle: baseAngle + angleStep + (Math.random()-0.5)*jitter, orbitRadius: orbitBase + 80, label: 'Platforma B', orbitSpeed: 0.18 },
    { angle: baseAngle + angleStep*2 + (Math.random()-0.5)*jitter, orbitRadius: orbitBase + 40, label: 'Platforma C', orbitSpeed: -0.16 },
    { angle: baseAngle + angleStep*3 + (Math.random()-0.5)*jitter, orbitRadius: orbitBase + 120, label: 'Platforma D', orbitSpeed: 0.14 }
  ];
  if (typeof window.resetSwarmQueue === 'function') {
      window.resetSwarmQueue();
  }
  for(const cfg of platformConfigs){
    const platform = spawnWeaponPlatform(station, cfg);
    mercMission.weaponPlatforms.push(platform);
  }

  // Zapis do dziennika + koordy do markera mapy
  const exists = MISSIONS.active.find(m => m.id === 'merc_pirate_station' && m.status === 'active');
  if(!exists){
    MISSIONS.active.push({
      id: 'merc_pirate_station',
      title: 'Najemnik: piracka stacja',
      type: 'mercenary',
      stationId: station.id,
      pos: { x, y },
      status: 'active'
    });
  }

  toast('Misja najemnik rozpoczęta. Wciśnij M aby otworzyć mapę — cel oznaczony X. Dziennik: J.');
}

function spawnWeaponPlatform(station, config = {}){
  const radius = config.radius ?? 52;
  const canvasSize = Math.max(64, Math.ceil(radius * 2.6));
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = canvasSize;
  const ctxPlatform = canvas.getContext('2d');
  const center = canvasSize / 2;

  // baza platformy
  const baseR = canvasSize * 0.38;
  const outerR = canvasSize * 0.46;
  const innerR = canvasSize * 0.18;
  const glowGrad = ctxPlatform.createRadialGradient(center, center, innerR, center, center, outerR);
  glowGrad.addColorStop(0, 'rgba(120,180,255,0.4)');
  glowGrad.addColorStop(1, 'rgba(0,20,40,0.02)');
  ctxPlatform.fillStyle = glowGrad;
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, outerR, 0, Math.PI*2); ctxPlatform.fill();

  ctxPlatform.fillStyle = '#1c2338';
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR, 0, Math.PI*2); ctxPlatform.fill();

  const plateGrad = ctxPlatform.createRadialGradient(center, center, innerR*0.4, center, center, baseR);
  plateGrad.addColorStop(0, '#6f87c8');
  plateGrad.addColorStop(0.6, '#3c4f7a');
  plateGrad.addColorStop(1, '#2a3556');
  ctxPlatform.fillStyle = plateGrad;
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR*0.88, 0, Math.PI*2); ctxPlatform.fill();

  ctxPlatform.strokeStyle = 'rgba(184,196,255,0.28)';
  ctxPlatform.lineWidth = Math.max(1.5, canvasSize * 0.02);
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR*0.72, 0, Math.PI*2); ctxPlatform.stroke();

  ctxPlatform.strokeStyle = 'rgba(62,112,182,0.65)';
  ctxPlatform.lineWidth = Math.max(1.2, canvasSize * 0.015);
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, baseR*0.52, 0, Math.PI*2); ctxPlatform.stroke();

  ctxPlatform.fillStyle = '#182030';
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, innerR, 0, Math.PI*2); ctxPlatform.fill();

  ctxPlatform.fillStyle = '#93b6ff';
  for(let i=0;i<6;i++){
    const a = (i/6) * Math.PI*2;
    const slotR = innerR * 1.35;
    const px = center + Math.cos(a) * slotR;
    const py = center + Math.sin(a) * slotR;
    ctxPlatform.save();
    ctxPlatform.translate(px, py);
    ctxPlatform.rotate(a);
    ctxPlatform.fillRect(-canvasSize*0.02, -canvasSize*0.09, canvasSize*0.04, canvasSize*0.18);
    ctxPlatform.restore();
  }

  ctxPlatform.strokeStyle = 'rgba(255,255,255,0.35)';
  ctxPlatform.lineWidth = Math.max(1.0, canvasSize * 0.01);
  ctxPlatform.beginPath(); ctxPlatform.arc(center, center, innerR*0.65, 0, Math.PI*2); ctxPlatform.stroke();

  const orbitRadius = config.orbitRadius ?? (station.r + 220 + Math.random()*120);
  const orbitSpeed = config.orbitSpeed ?? ((Math.random() < 0.5 ? -1 : 1) * (0.14 + Math.random()*0.07));
  const angle = config.angle ?? (Math.random() * Math.PI * 2);
  const hpMax = config.hp ?? 1800;
  const shieldMax = (config.shield && config.shield.max) || config.shieldMax || 720;
  const shieldRegen = (config.shield && config.shield.regenRate) || config.shieldRegen || 240;
  const shieldDelay = (config.shield && config.shield.regenDelay) || config.shieldDelay || 3.5;
  const missileCd = config.missileCd ?? (3.2 + Math.random()*0.6);
  const railCd = config.railCd ?? (1.2 + Math.random()*0.4);

  const platform = {
    id: config.id || uid(),
    type: 'weapon_platform',
    label: config.label || 'Platforma',
    station,
    radius,
    canvas,
    orbitRadius,
    orbitSpeed,
    angle,
    rotation: Math.random() * Math.PI * 2,
    spin: config.spin ?? (Math.random()*0.6 - 0.3),
    hp: hpMax,
    maxHp: hpMax,
    shield: (shieldMax > 0) ? { max: shieldMax, val: shieldMax, regenRate: shieldRegen, regenDelay: shieldDelay, regenTimer: 0 } : null,
    rail: { cd: railCd * Math.random(), cdMax: railCd, scatter: config.railScatter ?? 0.04, damage: config.railDamage ?? 60 },
    missile: { cd: missileCd * Math.random(), cdMax: missileCd, damage: config.missileDamage ?? SIDE_BULLET_DAMAGE },
    hitFlash: 0,
    destroyed: false,
    deathTimer: 0,
    removed: false
  };

  platform.x = station.x + Math.cos(angle) * orbitRadius;
  platform.y = station.y + Math.sin(angle) * orbitRadius;

  return platform;
}

function resetMercMission(){
  if(!mercMission) return;
  if(mercMission.weaponPlatforms){
    mercMission.weaponPlatforms.length = 0;
  }
  mercMission = null;
}
function startTerritoryWarMission(){ toast('Dołączono do wojny terytorialnej'); }

function renderOptions(){
  if(!OPTIONS_OPEN) return;
  hudBeginPanel();
  uiTitle('Opcje');
  slider('VFX: temperatura (K)', 1000, 20000, 500, OPTIONS.vfx, 'colorTempK');
  slider('VFX: bloom', 0.2, 2.5, 0.05, OPTIONS.vfx, 'bloomGain');
  slider('Audio: master', 0, 1, 0.05, OPTIONS.audio, 'master');
  slider('Audio: SFX', 0, 1, 0.05, OPTIONS.audio, 'sfx');
  slider('Audio: muzyka', 0, 1, 0.05, OPTIONS.audio, 'music');
  slider('Mysz: czułość', 0.3, 2.0, 0.05, OPTIONS.controls, 'mouseSensitivity');
  // brak opcji odwrócenia osi zgodnie z prośbą
  hudEndPanel();
}

function renderMissionJournal(){
  if(!MISSIONS.show) return;
  const w = 420, h = 260;
  const x = (W - w)/2, y = 60;
  hudBeginPanel(x, y, w, h);
  uiTitle('Dziennik misji [J]');
  if(MISSIONS.active.length === 0){
    uiText('Brak przyjętych misji.');
  } else {
    for(const m of MISSIONS.active){
      const status = m.status === 'active' ? 'AKTYWNA' : 'ZAKOŃCZONA';
      uiText(`${m.title} — ${status}`);
    }
  }
  hudEndPanel();
}

function spawnLaserBeam(start, end, width, opts={}){
  const p = particlePool[nextParticleIndex];
  p.pos.x = start.x;
  p.pos.y = start.y;
  p.vel.x = 0;
  p.vel.y = 0;
  p.life = (opts && opts.life != null) ? opts.life : 0.12;
  p.age = 0;
  p.flash = false;
  p.beam = true;
  p.start.x = start.x;
  p.start.y = start.y;
  p.end.x = end.x;
  p.end.y = end.y;
  p.width = width;
  p.alpha = opts?.alpha ?? 1;
  p.fadeWithLife = (opts && Object.prototype.hasOwnProperty.call(opts, 'fadeWithLife')) ? opts.fadeWithLife : undefined;
  p.colorOuter = opts?.colorOuter ?? null;
  p.colorInner = opts?.colorInner ?? null;
  p.glowColor = opts?.glowColor ?? null;
  p.glowBlur = opts?.glowBlur ?? 0;
  p.outerWidthMul = opts?.outerWidthMul ?? 1;
  p.innerWidthMul = opts?.innerWidthMul ?? 1;
  p.size = 0;
  p.color = '#fff';
  p.active = true;
  nextParticleIndex = (nextParticleIndex + 1) % MAX_PARTICLES;
}

// =============== Input ===============
const input = { main:0, leftSide:0, rightSide:0, torque:0 };
const keys = {};
let showMap = false;
let shiftBinding = null;
const mapView = {
  zoom: 1,
  targetZoom: 1,
  minZoom: 0.6,
  maxZoom: 6,
  viewX: null,
  viewY: null,
  smoothness: 0.15,
};
let PAUSED = false;
let lastCameraModeBeforePause = null;

function setPaused(state){
  const next = !!state;
  if(next === PAUSED) return;
  PAUSED = next;
  if(PAUSED){
    lastCameraModeBeforePause = camera.mode;
    if(camera.mode !== 'free') camera.enterFreeMode();
  } else {
    if(lastCameraModeBeforePause && lastCameraModeBeforePause !== 'free'){
      camera.exitFreeMode();
    }
    lastCameraModeBeforePause = null;
  }
}

function togglePause(){
  setPaused(!PAUSED);
}

function currentShiftMode(){
  return isPlanetOrbitZoneId(zoneState.current?.id) ? 'boost' : 'warp';
}

function activateBoostIfAllowed(){
  if (!isPlanetOrbitZoneId(zoneState.current?.id)) return false;
  if (boost.fuel > 0) {
    boost.state = 'active';
    return true;
  }
  return false;
}

function stopBoost(){
  if (boost.state === 'active') {
    boost.state = 'idle';
  }
}

function handleWarpKeyDown(){
  if(warp.state==='idle' && (DevFlags.unlimitedWarp || warp.fuel>0)){
    warp.state='charging';
    warp.charge=0;
  }
}

function handleWarpKeyUp(){
  if(warp.state==='charging'){ warp.state='idle'; warp.charge=0; }
  else if(warp.state==='active'){ warp.state='idle'; exitWarp(); }
}

function handleShiftDown(){
  shiftBinding = currentShiftMode();
  if (shiftBinding === 'boost') {
    activateBoostIfAllowed();
  } else {
    handleWarpKeyDown();
  }
}

function handleShiftUp(){
  const mode = shiftBinding || currentShiftMode();
  if (mode === 'boost') {
    stopBoost();
  } else {
    handleWarpKeyUp();
  }
  shiftBinding = null;
}
window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(e.code==='Space'){ e.preventDefault(); }
  if(e.code==='ShiftLeft' || e.code==='ShiftRight'){ e.preventDefault(); }
  const k = e.key.toLowerCase();
  keys[k] = true;
  if (k === 'shift') {
    handleShiftDown();
  }
  if(k === 'm'){
    showMap = !showMap;
    if (showMap) {
      mapView.targetZoom = clamp(mapView.targetZoom, mapView.minZoom, mapView.maxZoom);
      mapView.viewX = null;
      mapView.viewY = null;
    }
  }
  if(k === 'j') MISSIONS.show = !MISSIONS.show;
  if(k === 'g' && !stationUI.open){
    camera.toggleFreeMode();
  }
  if(k === ' '){
    togglePause();
    updateInput();
    return;
  }
  if(k === 'x'){
    triggerScanWave();
    hudPingNpcStations();
    togglePlanetRadarVisibility();
  }
  if (k === 'z') {
    if(!(Game.player.weapons?.[HP.HANGAR]?.length)) { toast('Brak dostępnych hangarów.'); return; }
    if (SQUAD.order === 'idle' || SQUAD.list.length === 0) {
      // start + ESKORTA
      SQUAD.list = [];
      for (let i = 0; i < FIGHTERS_PER_LAUNCH; i++) {
        const f = spawnFighter();
        f.formIndex = i;              // <- indeks w formacji
        SQUAD.list.push(f);
      }
      SQUAD.order = 'escort';
      SQUAD.targets = [];
      toast('Myśliwce: ESKORTA');
    } else if (SQUAD.order === 'escort') {
      SQUAD.targets = pickSquadTargets();
      SQUAD.order = 'attack';
      toast(SQUAD.targets.length ? 'Myśliwce: ATAK' : 'Myśliwce: ATAK (brak oznaczeń — wybiorą najbliższych)');
    } else if (SQUAD.order === 'attack') {
      SQUAD.order = 'return';
      toast('Myśliwce: POWRÓT');
    } else if (SQUAD.order === 'return') {
      SQUAD.order = 'escort';
      SQUAD.targets = [];
      toast('Myśliwce: ESKORTA');
    }
  }
  if(k === 'r'){
    if(highlightedEnemies.length){
      lockedTargets = highlightedEnemies.filter(isHostileNpc)
        .sort((a,b)=>Math.hypot(a.x-ship.pos.x,a.y-ship.pos.y) - Math.hypot(b.x-ship.pos.x,b.y-ship.pos.y));
      highlightTimer = 0;
      highlightedEnemies = [];
    } else if (scan.scanned && isHostileNpc(scan.scanned)) {
      lockedTarget = scan.scanned;
    } else {
      lockedTarget = null;
    }
  }
  updateInput();
});
window.addEventListener('keyup', e=>{
  const k = e.key.toLowerCase();
  keys[k] = false;
  if (k === 'shift') {
    handleShiftUp();
  }
  updateInput();
});
function updateInput(){
  const main = keys['w'] ? 1 : 0;
  const leftSide = keys['e'] ? 1 : 0;
  const rightSide = keys['q'] ? 1 : 0;
  let torque = 0; if(keys['a']) torque -= 1; if(keys['d']) torque += 1;
  applyPlayerInput(ship, {
    controller: 'player',
    thrustX: torque,
    thrustY: main,
    main,
    leftSide,
    rightSide,
    torque
  }, input);
  if(keys['f']) tryFireSpecial();
}

// targeting / scanning
const SCAN_RANGE = 10000;
const SCAN_VFX_SPEED = 4000;
const SCAN_ARROW_LIFE = 1.5;
const scan = { target:null, scanned:null, targetType:null };
let lockedTarget = null;
let lockedTargets = [];
let highlightedEnemies = [];
let highlightTimer = 0;
const HIGHLIGHT_TIME = 3;
const HIGHLIGHT_RANGE = 2000;
const radarPings = [];
const scanWaves = [];
const scanArrows = [];

function isHostileNpc(n){
  return !!(n && !n.dead && !n.friendly);
}

function isPirateScanTarget(n){
  if (!isHostileNpc(n)) return false;
  if (!n.isPirate) return false;
  const type = String(n.type || '').toLowerCase();
  if (type === 'destroyer' || type === 'battleship') return false;
  if (n.isCapitalShip) return false;
  return true;
}
const NPC_DESPAWN_RADIUS = 20000;
function spawnRadarPing(x,y){ radarPings.push({x,y,age:0,life:1}); }
function triggerScanWave(){
  const wave = {x:ship.pos.x,y:ship.pos.y,r:0,speed:SCAN_VFX_SPEED,max:SCAN_RANGE,hit:new Set()};
  scanWaves.push(wave);
  scanArrows.length = 0;
 // Merge of branches:
  // 1) codex/add-various-npc-types-and-groups → prefer enemies that have weapons
  // 2) main → only highlight those within HIGHLIGHT_RANGE
  const inRange = (n) => Math.hypot(n.x - ship.pos.x, n.y - ship.pos.y) <= HIGHLIGHT_RANGE;
  highlightedEnemies = npcs.filter(n => isPirateScanTarget(n) && inRange(n));
  highlightTimer = HIGHLIGHT_TIME;
  for(const st of stations){
    const dist = Math.hypot(st.x - ship.pos.x, st.y - ship.pos.y);
    spawnRadarPing(st.x, st.y);
    if(dist <= SCAN_RANGE){
      scanArrows.push({target:st,age:0,life:SCAN_ARROW_LIFE});
      wave.hit.add(st);
    }
  }
}

const mouse = { x: W/2, y: H/2, left:false, right:false, click:false, overCanvas:false };
canvas.addEventListener('mousemove', e=>{
  mouse.x = e.clientX; mouse.y = e.clientY;
  mouse.overCanvas = true;
  const hasMovement = typeof e.movementX === 'number' && typeof e.movementY === 'number';
  const movementX = hasMovement ? e.movementX : ((camera.lastPointerX == null) ? 0 : e.clientX - camera.lastPointerX);
  const movementY = hasMovement ? e.movementY : ((camera.lastPointerY == null) ? 0 : e.clientY - camera.lastPointerY);
  camera.lastPointerX = e.clientX;
  camera.lastPointerY = e.clientY;
  if(camera.mode === 'free' && !stationUI.open){
    const panMul = camera.freePanSpeed / Math.max(0.0001, camera.zoom);
    camera.x += movementX * panMul;
    camera.y += movementY * panMul;
    camera.targetX = camera.x;
    camera.targetY = camera.y;
  }
  if(stationUI.open && stationUI.dragging){
    stationUI.x = mouse.x - stationUI.dragDX;
    stationUI.y = mouse.y - stationUI.dragDY;
    stationUI.autoPosition = false;
  }
});
canvas.addEventListener('mouseenter', e=>{
  mouse.overCanvas = true;
  if(e){
    camera.lastPointerX = e.clientX;
    camera.lastPointerY = e.clientY;
  }
});
canvas.addEventListener('mouseleave', ()=>{
  mouse.overCanvas = false;
  mouse.left = false;
  mouse.right = false;
  mouse.click = false;
  scan.target = null;
  scan.scanned = null;
  scan.targetType = null;
  hideHoverInfo();
  camera.lastPointerX = null;
  camera.lastPointerY = null;
});
canvas.addEventListener('mousedown', e=>{
  if(e.button===0){
    if(stationUI.open){
      const interactive = stationUI.visible && !stationUI.awaitingCamera && stationUI.appear > 0.05;
      if(interactive){
        const inX = mouse.x >= stationUI.x && mouse.x <= stationUI.x + stationUI.w;
        const inY = mouse.y >= stationUI.y && mouse.y <= stationUI.y + stationUI.h;
        if(inX && inY && mouse.y <= stationUI.y + 24){
          stationUI.dragging = true;
          stationUI.dragDX = mouse.x - stationUI.x;
          stationUI.dragDY = mouse.y - stationUI.y;
          stationUI.autoPosition = false;
        }
      }
      return;
    }
    mouse.left=true;
    if(scan.targetType === 'station' && mouse.overCanvas){
      return;
    }
    if(!stationUI.open && !warp.isBusy()) triggerRailVolley();
  }
  if(e.button===2){
    e.preventDefault();
    if(stationUI.open) return;
    mouse.right=true;
    if(!stationUI.open && !warp.isBusy()){
      const mouseWorld = screenToWorld(mouse.x, mouse.y);
      const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
      const side = (local.x >= 0) ? 'right' : 'left';
      fireRocket(side);
      rocketCooldown = ROCKET_FIRE_INTERVAL;
    }
  }
  if(e.button===1){
    e.preventDefault();
    camera.zoom = Math.abs(camera.zoom - camera.defaultZoom) < 0.03 ? camera.altZoom : camera.defaultZoom;
    camera.targetZoom = camera.zoom;
    camera.manualZoom = true;
    if(camera.transition && camera.transition.kind === 'ship') camera.transition = null;
    zoomIndicator.show(camera.zoom);
  }
});
canvas.addEventListener('mouseup', e=>{
  if(e.button===0){
    const wasDragging = stationUI.dragging;
    if(stationUI.dragging){
      stationUI.dragging=false;
    }
    if(stationUI.open){
      if(!wasDragging){
        mouse.click=true;
      }
      return;
    }
    mouse.left=false;
    if(!wasDragging){
      mouse.click=true;
    }
  }
  if(e.button===2){
    if(stationUI.open) return;
    mouse.right=false;
  }
});
canvas.addEventListener('contextmenu', e=>e.preventDefault());
canvas.addEventListener('wheel', e=>{
  if (stationUI.open) return;
  e.preventDefault();
  if (showMap) {
    const zoomFactor = 1 - e.deltaY * 0.0016;
    mapView.targetZoom = clamp(mapView.targetZoom * zoomFactor, mapView.minZoom, mapView.maxZoom);
    return;
  }
  const f = 1 - e.deltaY * camera.wheelSpeed;
  camera.zoom = clamp(camera.zoom * f, camera.minZoom, camera.maxZoom);
  camera.targetZoom = camera.zoom;
  camera.manualZoom = true;
  if(camera.transition && camera.transition.kind === 'ship') camera.transition = null;
  zoomIndicator.show(camera.zoom);
}, {passive:false});

const GAMEPAD = { enabled:true, dead:0.15, last:{} };

function applyGamepad(){
  const pads = navigator.getGamepads?.() || [];
  const p = pads[0];
  if(!p) return;
  const ax = (v)=> (Math.abs(v)<GAMEPAD.dead?0:v);
  const lx = ax(p.axes[0]||0), ly = ax(p.axes[1]||0);
  const rx = ax(p.axes[2]||0), ry = ax(p.axes[3]||0);
  const forward = ly * -1;
  applyPlayerInput(ship, {
    controller: 'player',
    thrustX: lx,
    thrustY: forward,
    aimX: rx,
    aimY: ry * -1,
    main: Math.max(0, forward),
    torque: lx,
    leftSide: 0,
    rightSide: 0
  }, input);
  // przyciski
  const btn = (i)=>!!(p.buttons[i]&&p.buttons[i].pressed);
  if(btn(0)) triggerRailVolley();      // A / Cross
  if(btn(1)) fireRocket();             // B / Circle
  if(btn(2)){
    activateBoostIfAllowed();
  } else if(boost.state==='active' && !btn(2)){
    stopBoost();
  }
  if(btn(3)) attemptWarp();            // Y / Triangle
  if(btn(9)) togglePause();            // START
}

// =============== Side rockets ===============
const ROCKET_FIRE_INTERVAL = 0.11;
let rocketCooldown = 0;
let nextRocketIndexLeft = 0, nextRocketIndexRight = 0;
const SIDE_BULLET_SPEED = 760, SIDE_BULLET_DAMAGE = 20;
const SIDE_PLASMA_EXPLODE_RADIUS = 48;
const SIDE_ROCKET_TURN_RATE = 6;
const SIDE_ROCKET_HOMING_DELAY = 0.25;
const SPECIAL_COOLDOWN = 10; ship.special.cooldownTimer = 0;
const SPECIAL_DAMAGE = 1500;

function consumeMissileAmmo(side){
  const entries = (Game.player.weapons?.[HP.MISSILE] || []).map(e=>e.hp);
  if(!entries.length) return false;
  const available = entries.filter(hp => hp.mount && (hp.ammo === null || hp.ammo > 0));
  if(!available.length) return false;
  let preferred = null;
  if(side === 'left'){
    preferred = available.find(hp => (hp.pos?.x || 0) <= 0);
  } else if(side === 'right'){
    preferred = available.find(hp => (hp.pos?.x || 0) >= 0);
  }
  const target = preferred || available[0];
  if(typeof target.ammo === 'number'){
    target.ammo = Math.max(0, target.ammo - 1);
  }
  rocketAmmo = missileAmmoTotal();
  saveLoadout();
  return true;
}

function fireRocket(side){
  if(!(Game.player.weapons?.[HP.MISSILE]?.length)) return;
  if(rocketAmmoMax > 0 && rocketAmmo <= 0) return;
  const guns = side === 'left' ? ship.sideGunsLeft : ship.sideGunsRight;
  const idx = side === 'left' ? nextRocketIndexLeft : nextRocketIndexRight;
  const gunOff = guns[idx % guns.length];
  const target = (lockedTarget && !lockedTarget.dead) ? lockedTarget : null;
  if(!consumeMissileAmmo(side)) return;
  fireSideGunAtOffset(gunOff, side, target);
  if(side === 'left') nextRocketIndexLeft = (idx + 1) % guns.length;
  else nextRocketIndexRight = (idx + 1) % guns.length;
}

function fireSideGunAtOffset(gunOff, side, target=null){
  const gunWorld = add(ship.pos, rotate(gunOff, ship.angle));
  const dl = side === 'left' ? -1 : 1;
  const dir = rotate({x:dl, y:0}, ship.angle);
window.bullets.push({ x: gunWorld.x, y: gunWorld.y, px: gunWorld.x, py: gunWorld.y,
    vx: dir.x*SIDE_BULLET_SPEED + ship.vel.x, vy: dir.y*SIDE_BULLET_SPEED + ship.vel.y,
    life:2.4, r:5, owner:'player', damage:SIDE_BULLET_DAMAGE, penetration:0, type:'rocket',
    explodeRadius: SIDE_PLASMA_EXPLODE_RADIUS, homingDelay: SIDE_ROCKET_HOMING_DELAY, target,
    source: ship, spawnGrace: 0.08 });
  spawnParticle({x:gunWorld.x, y:gunWorld.y}, {x:dir.x*120 + ship.vel.x*0.1, y:dir.y*120 + ship.vel.y*0.1}, 0.14, '#b4ffb4', 3.2, true);
  for(let k=0;k<6;k++){
    const aa = Math.atan2(dir.y, dir.x) + (Math.random()-0.5)*0.9;
    spawnParticle({x:gunWorld.x + Math.cos(aa)*6, y:gunWorld.y + Math.sin(aa)*6}, {x:Math.cos(aa)*160, y:Math.sin(aa)*160}, 0.14 + Math.random()*0.06, '#a8ff9a', 1.1, true);
  }
}

// =============== Fighters ===============
const FIGHTER_ORBIT_RADIUS = 200;  // były zbyt blisko
const FIGHTER_ORBIT_SPEED = 1.8;
const FIGHTER_ATTACK_RANGE = 1000;
const FIGHTERS_PER_LAUNCH = 10;
const FIGHTER_ACCEL = 880;
const FIGHTER_MAX_SPEED = 1180;
const FIGHTER_TURN_RATE = 9.6;
const FIGHTER_DRAG_COEFF = 2.6;
const FIGHTER_ESCORT_POSITION_GAIN = 3.0;
const FIGHTER_ESCORT_FOLLOW_GAIN = 7.5;

// Bliska eskorta - lokalne offsety względem kadłuba (w pikselach)
const FIGHTER_FORMATION = [
  {x:-150, y:-120}, {x:150, y:-120},
  {x:-190, y:-70},  {x:190, y:-70},
  {x:-190, y:-10},  {x:190, y:-10},
  {x:-150, y: 60},  {x:150, y: 60},
  {x:-100, y:-180}, {x:100, y:-180}
];

function fighterAI(dt){
  // lekkie tłumienie
  const drag = Math.exp(-3 * dt);
  this.vx *= drag; this.vy *= drag;

  // helpery
  const limit = (e, vmax)=>{ const s = Math.hypot(e.vx, e.vy); if(s>vmax){ const k=vmax/s; e.vx*=k; e.vy*=k; } };
  const faceAndThrust = (tx, ty, accelMul=1.0)=>{
    const desired = Math.atan2(ty - this.y, tx - this.x);
    if (typeof this.heading !== 'number' || Number.isNaN(this.heading)) {
      this.heading = Math.atan2(this.vy, this.vx);
      if (!Number.isFinite(this.heading)) this.heading = desired;
    }
    const speed = Math.hypot(this.vx, this.vy);
    const current = speed > 4 ? Math.atan2(this.vy, this.vx) : this.heading;
    const diff = wrapAngle(desired - current);
    const maxTurn = this.turn * dt;
    const turn = clamp(diff, -maxTurn, maxTurn);
    this.heading = wrapAngle(current + turn);
    const ang = this.heading;
    this.vx += Math.cos(ang) * this.accel * accelMul * dt;
    this.vy += Math.sin(ang) * this.accel * accelMul * dt;
    // VFX silników
    for (const e of this.engines){
      const off = rotate(e, ang + Math.PI);
      spawnParticle({x:this.x + off.x, y:this.y + off.y},
                    {x:this.vx - Math.cos(ang)*80, y:this.vy - Math.sin(ang)*80},
                    0.10, this.friendly ? '#cfe7ff' : '#ffc9c0', 0.8);
    }
    return ang;
  };
  const canGunsFire = (target)=>{
    const dx = target.x - this.x, dy = target.y - this.y;
    const dist = Math.hypot(dx, dy);
    const speed = Math.hypot(this.vx, this.vy);
    const facing = speed > 4
      ? Math.atan2(this.vy, this.vx)
      : (typeof this.heading === 'number' ? this.heading : Math.atan2(this.vy, this.vx));
    const aim = Math.atan2(dy, dx);
    const align = Math.abs(wrapAngle(aim - facing));
    const closing = (this.vx*dx + this.vy*dy) > 0; // lecimy w stronę celu
    const MIN = 260, MAX = 820, ALIGN_OK = 0.28; // ~16°
    return (dist >= MIN && dist <= MAX && align < ALIGN_OK && closing);
  };

  // === POWRÓT DO STATKU (despawn) ===
  if (SQUAD.order === 'return'){
    // bardziej „miękka” nawigacja + większy promień dokowania
    const dx = ship.pos.x - this.x, dy = ship.pos.y - this.y;
    const d  = Math.hypot(dx, dy) || 1;
    const ang = faceAndThrust(ship.pos.x, ship.pos.y, 1.0);

    // dopasowanie prędkości kiedy blisko – silniejsze niż było
    if (d < 260){
      this.vx += (ship.vel.x - this.vx) * Math.min(1, 8*dt);
      this.vy += (ship.vel.y - this.vy) * Math.min(1, 8*dt);
    }
    limit(this, this.maxSpeed);

    // fallback timer: jak utkną — wymuś dokowanie
    this._retT = (this._retT||0) + dt;

    const DOCK_R = 70; // było ~40
    if (d < DOCK_R || (this._retT > 8 && d < 300)){
      this.dead = true;
      const i = SQUAD.list.indexOf(this);
      if (i !== -1) SQUAD.list.splice(i, 1);
      if (SQUAD.list.length === 0){
        SQUAD.order = 'idle';
        SQUAD.targets = [];
        toast('Myśliwce: ZADOKOWANE');
      }
    }
    return;
  }

  // === ATAK: nalot (ingress -> pass -> egress) ===
  if (SQUAD.order === 'attack'){
    // wybór celu (jak wcześniej)
    let target = null;
    if (SQUAD.targets.length){
      const idx = Math.max(0, SQUAD.list.indexOf(this));
      const t = SQUAD.targets[idx % SQUAD.targets.length];
      if (t && !t.dead) target = t;
    }
    if (!target){
      let best=null, bd=Infinity;
      for (const n of npcs){
        if (n.dead || n.friendly) continue;
        const d = Math.hypot(n.x - this.x, n.y - this.y);
        if (d < bd){ bd = d; best = n; }
      }
      target = best;
    }
    if (!target){ SQUAD.order = 'escort'; return; }

    // inicjalizacja stanu „pass”
    if (!this._pass || this._pass.targetId !== target.id){
      this._pass = {
        phase: 'ingress',   // ingress | attack | egress
        t: 0,
        targetId: target.id,
        egressT: 0,
      };
      this.ciwsCd = 0; this.missileCd = 0; // bez natychmiastowego strzału
    }
    this._pass.t += dt;

    // metryki względem celu
    const dx = target.x - this.x, dy = target.y - this.y;
    const dist = Math.hypot(dx, dy) || 1;
    const lead = leadTarget({x:this.x,y:this.y},{x:this.vx||0,y:this.vy||0}, target, Math.max(300, this.maxSpeed*0.9));

    if (this._pass.phase === 'ingress'){
      // zbliż się do punktu wyprzedzenia, bez ognia
      faceAndThrust(lead.x, lead.y, 1.0);
      limit(this, this.maxSpeed);
      // warunki otwarcia ognia: w zasięgu + wyrównanie
      const facing = Math.atan2(this.vy, this.vx);
      const aim = Math.atan2(dy, dx);
      const align = Math.abs(wrapAngle(aim - facing));
      const APPROACH = 900, ALIGN_OK = 0.35;
      if (dist < APPROACH && align < ALIGN_OK){
        this._pass.phase = 'attack';
        this._pass.t = 0;
      }
      return;
    }

    if (this._pass.phase === 'attack'){
      // krótka prosta z ogniem (nalot)
      const ang = faceAndThrust(lead.x, lead.y, 1.0);
      limit(this, this.maxSpeed);

      // Strzelaj tylko w „oknie”
      if (canGunsFire(target)){
        this.ciwsCd = Math.max(0, this.ciwsCd - dt);
        this.missileCd = Math.max(0, this.missileCd - dt);
        const dir = {x:Math.cos(ang), y:Math.sin(ang)};
        if (this.ciwsCd === 0){
          window.bullets.push({
            x:this.x + dir.x*8, y:this.y + dir.y*8,
            vx: dir.x*CIWS_BULLET_SPEED + this.vx,
            vy: dir.y*CIWS_BULLET_SPEED + this.vy,
            life:1.2, r:2, owner:'player', damage:CIWS_DAMAGE, type:'ciws'
          });
          this.ciwsCd = CIWS_FIRE_INTERVAL;
        }
        if (this.missiles>0 && this.missileCd === 0){
          window.bullets.push({
            x:this.x + dir.x*8, y:this.y + dir.y*8,
            vx: dir.x*SIDE_BULLET_SPEED + this.vx,
            vy: dir.y*SIDE_BULLET_SPEED + this.vy,
            life:2.4, r:5, owner:'player', damage:SIDE_BULLET_DAMAGE,
            penetration:0, type:'rocket',
            explodeRadius: SIDE_PLASMA_EXPLODE_RADIUS,
            homingDelay: SIDE_ROCKET_HOMING_DELAY,
            target
          });
          this.missiles--; this.missileCd = 1.5;
        }
      }

      // warunki zakończenia przelotu
      const passed = (this.vx*dx + this.vy*dy) < 0; // minęliśmy cel
      if (this._pass.t > 1.6 || dist < 180 || passed){
        this._pass.phase = 'egress';
        this._pass.egressT = 0;
      }
      return;
    }

    if (this._pass.phase === 'egress'){
      // odejście po przelocie – odskocz od celu
      this._pass.egressT += dt;
      const awayX = this.x - dx, awayY = this.y - dy; // kierunek od celu
      faceAndThrust(awayX, awayY, 0.9);
      limit(this, this.maxSpeed);
      if (this._pass.egressT > 0.9){
        this._pass.phase = 'ingress';
        this._pass.t = 0;
      }
      return;
    }
  }

  // === ESKORTA (domyślnie) ===
  const local = FIGHTER_FORMATION[this.formIndex % FIGHTER_FORMATION.length] || {x:-140, y:-90};
  const off = rotate(local, ship.angle);
  const anchor = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };

  const to = { x: anchor.x - this.x, y: anchor.y - this.y };
  const desiredVel = { x: ship.vel.x + to.x * 2.2, y: ship.vel.y + to.y * 2.2 };
  const spd = Math.hypot(desiredVel.x, desiredVel.y);
  const vmax = this.maxSpeed * 0.95;
  if (spd > vmax){ const s = vmax/spd; desiredVel.x*=s; desiredVel.y*=s; }
  this.vx += (desiredVel.x - this.vx) * Math.min(1, 5.5*dt);
  this.vy += (desiredVel.y - this.vy) * Math.min(1, 5.5*dt);

  const ang = Math.atan2(this.vy, this.vx);
  for(const e of this.engines){
    const eo = rotate(e, ang + Math.PI);
    spawnParticle({x:this.x + eo.x, y:this.y + eo.y},
                  {x:this.vx - Math.cos(ang)*60, y:this.vy - Math.sin(ang)*60},
                  0.08, '#cfe7ff', 0.7);
  }
}


function aiClamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function aiDist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
function aiClampTurnAngle(currentAng, targetAng, maxRateRad, dt){
  let d = targetAng - currentAng;
  while(d >  Math.PI) d -= 2*Math.PI;
  while(d < -Math.PI) d += 2*Math.PI;
  const change = aiClamp(d, -maxRateRad * dt, maxRateRad * dt);
  let out = currentAng + change;
  if(out >  Math.PI) out -= 2*Math.PI;
  if(out < -Math.PI) out += 2*Math.PI;
  return out;
}
function aiLeadAim(shooter,target,projSpeed=180){
  const vx=target.vx||0, vy=target.vy||0;
  const px=target.x-shooter.x, py=target.y-shooter.y;
  const A=(vx*vx+vy*vy)-projSpeed*projSpeed;
  const B=2*(px*vx+py*vy);
  const C=(px*px+py*py);
  let t=0;
  if(Math.abs(A)<1e-3){
    t = -C/Math.max(B,-1e-3);
  }else{
    const disc=B*B-4*A*C;
    t = (disc>0)?(-B-Math.sqrt(disc))/(2*A):0;
  }
  t = Math.max(0,Math.min(2.0,t));
  return {x:target.x+vx*t,y:target.y+vy*t};
}
const SQUAD = {
  id: 'player_squad',
  list: [],      
  order: 'idle', 
  targets: []    
};
window.SQUAD = SQUAD;
function pickSquadTargets() {
  // Zwraca wszystkich żywych wrogów (nie-friendly)
  return npcs.filter(n => !n.friendly && !n.dead);
}
window.pickSquadTargets = pickSquadTargets;
window.spawnFighter = function() {
  // 1. Sprawdź czy statek i hangar istnieją
  if (!window.ship) return;
  
  const hasHangar = Game.player.weapons && Game.player.weapons.hangar && Game.player.weapons.hangar.length > 0;
  if(!hasHangar) { 
      if(typeof toast === 'function') toast('Brak modułu hangaru!'); 
      return; 
  }

  // 2. Definicja 2 Hangarów (Lewy i Prawy)
  const halfW = (ship.w || 60) * 0.5; 
  const halfH = (ship.h || 120) * 0.1; // Lekko przesunięte do tyłu względem środka

  const hangarSlots = [
      { x: -halfW, y: halfH, side: -1 }, // Lewa burta
      { x:  halfW, y: halfH, side:  1 }  // Prawa burta
  ];

  const createdFighters = [];

  // 3. PĘTLA: Generuj oba myśliwce natychmiast
  for (const slot of hangarSlots) {
      
      // Obliczanie pozycji w świecie (Rotacja)
      const c = Math.cos(ship.angle);
      const s = Math.sin(ship.angle);
      
      const spawnX = ship.pos.x + (slot.x * c - slot.y * s);
      const spawnY = ship.pos.y + (slot.x * s + slot.y * c);

      // Stworzenie obiektu
      const f = makeNPCBase({x: spawnX, y: spawnY}, {
        hp: 80, 
        accel: 350, 
        maxSpeed: 650, 
        turn: 7.0, 
        radius: 12
      });
      
      f.friendly = true;
      f.mission = true; 
      f.fighter = true;
      f.color = '#7cff91'; 
      
      // Fizyka Wyrzutni (Wyrzut na boki)
      const launchSpeed = 180; // Trochę mocniejszy wyrzut
      // Wektor boczny (prostopadły do kadłuba)
      const sideDirX = c; 
      const sideDirY = s;
      
      f.vx = ship.vel.x + (sideDirX * launchSpeed * slot.side);
      f.vy = ship.vel.y + (sideDirY * launchSpeed * slot.side);
      f.angle = ship.angle; 

      // Uzbrojenie
      f.gun = 'laserS'; 
      f.msl = 'AF'; f.mslAmmo = 4;
      f.gunCD = 0.5; 

      // Zarządzanie eskadrą
      if (!window.SQUAD) window.SQUAD = { list: [], order: 'idle', targets: [] };
      
      // WAŻNE: Pobieramy aktualną długość listy dla KAŻDEGO myśliwca z osobna,
      // żeby zajęły różne miejsca w formacji
      const idx = window.SQUAD.list.length;
      f.formIndex = idx;
      
      // Pozycja w formacji "V"
      const row = Math.floor((idx + 1) / 2);
      const formSide = (idx % 2 === 0) ? 1 : -1;
      f.formationOffset = { x: -140 - (row * 50), y: formSide * (60 + row * 30) };

      f.squad = { leader: ship, type: 'fighter' }; 
      
      // AI
      f.ai = (dt) => { if(window.runAdvancedFighterAI) window.runAdvancedFighterAI(f, dt); };

      // Dodanie do gry
      window.SQUAD.list.push(f);
      npcs.push(f);
      createdFighters.push(f);

      // Efekt dymu przy wylocie
      if(window.spawnParticle) {
          for(let i=0; i<4; i++) {
              window.spawnParticle(
                  {x: spawnX, y: spawnY}, 
                  {x: ship.vel.x + (Math.random()-0.5)*40, y: ship.vel.y + (Math.random()-0.5)*40}, 
                  0.3, '#ffffff', 2 + Math.random()*2, false
              );
          }
      }
  }
  
  return createdFighters;
};
 

// --- NOWY SPAWNER STRAŻNIKÓW STACJI (Dla misji) ---
// Zastępuje ten stary, który używał 'guardAI'
function spawnStationGuard(st, kind, angle){
  const orbitR = st.r + 180;
  const pos = { x: st.x + Math.cos(angle)*orbitR, y: st.y + Math.sin(angle)*orbitR };
  
  // Używamy nowego, uniwersalnego spawnera piratów (to ten z dołu pliku)
  const n = spawnPirate(kind, st); 
  
  // Nadpisujemy pozycję na orbitę (bo spawnPirate losuje pozycję)
  n.x = pos.x; n.y = pos.y; n.vx = 0; n.vy = 0;
  n.guard = true; n.home = st; 
  n.orbitAngle = angle; n.orbitRadius = orbitR;
  
  // Nie psujemy n.ai! spawnPirate już nadał mu dobre AI.
  return n;
}
function lineOffsets(count, spacing){
  const start = -((count - 1) * spacing) / 2;
  const arr = [];
  for(let i=0;i<count;i++) arr.push(start + i * spacing);
  return arr;
}

function buildMercSwarmQueue(station){
  if(!station) return [];
  const toPlayer = norm({ x: ship.pos.x - station.x, y: ship.pos.y - station.y });
  const right = { x: -toPlayer.y, y: toPlayer.x };
  const baseDist = station.r + 220;
  const rowSpacing = 200;
  const queue = [];

  const addRow = (kinds, dist, spacing) => {
    const offsets = lineOffsets(kinds.length, spacing);
    kinds.forEach((kind, idx) => {
      const offset = offsets[idx];
      queue.push({
        kind,
        pos: {
          x: station.x + toPlayer.x * dist + right.x * offset,
          y: station.y + toPlayer.y * dist + right.y * offset
        },
        offset,
        right,
        forward: toPlayer
      });
    });
  };

  addRow(new Array(10).fill('fighter_squad'), baseDist + rowSpacing * 3, 180);
  addRow([...new Array(5).fill('frigate_pd'), ...new Array(2).fill('frigate_laser')], baseDist + rowSpacing * 2, 210);
  addRow(new Array(5).fill('destroyer'), baseDist + rowSpacing, 240);
  addRow(new Array(3).fill('battleship'), baseDist, 300);
  return queue;
}

function resetSwarmQueue(){
  if(!mercMission || !mercMission.swarm) return;
  mercMission.swarm.timer = 0.5;
  const st = mercMission.station;
  const formationQueue = buildMercSwarmQueue(st);
  if(formationQueue.length){
    mercMission.swarm.queue = formationQueue;
    return;
  }
  // Fallback jeśli nie da się zbudować formacji
  const types = ['fighter_squad', 'interceptor', 'gunship', 'frigate_pd'];
  mercMission.swarm.queue = [];
  for(let i=0; i<5; i++){
     mercMission.swarm.queue.push(types[Math.floor(Math.random()*types.length)]);
  }
}
window.resetSwarmQueue = resetSwarmQueue;

function spawnFighterLineSquad(station, anchor, right, facing){
  const squad = new Squad('pirate', 'fighter');
  SQUADS.push(squad);
  const spacing = 36;
  const dirRight = right || { x: -Math.sin(facing), y: Math.cos(facing) };
  for(let i=0; i<9; i++){
    const n = spawnPirate('fighter', station);
    const offset = (i - 4) * spacing;
    if(anchor){
      n.x = anchor.x + dirRight.x * offset;
      n.y = anchor.y + dirRight.y * offset;
    }
    n.angle = facing;
    n.vx += Math.cos(facing) * 30;
    n.vy += Math.sin(facing) * 30;
    squad.addUnit(n);
    n.formationOffset = { x: offset, y: 0 };
    n.forceTarget = ship;
  }
  return squad;
}

function setPirateGuardFlags(npc, station){
  npc.guardHold = true;
  npc.guardStation = station || npc.guardStation || null;
  npc.forceTarget = null;
  npc.target = null;
}

function assignPirateLine(units, station, forward, right, distance, spacing){
  const mid = (units.length - 1) * 0.5;
  units.forEach((npc, idx) => {
    const offset = (idx - mid) * spacing;
    setPirateGuardFlags(npc, station);
    npc.guardMode = 'line';
    npc.guardAnchor = {
      x: station.x + forward.x * distance + right.x * offset,
      y: station.y + forward.y * distance + right.y * offset
    };
    npc.guardFacing = Math.atan2(forward.y, forward.x);
    npc.vx = 0; npc.vy = 0;
  });
}

function assignPirateOrbit(units, station, radius, speed, jitter = 0){
  units.forEach((npc, idx) => {
    setPirateGuardFlags(npc, station);
    npc.guardMode = 'orbit';
    npc.guardOrbitRadius = radius;
    const sign = (idx % 2 === 0) ? 1 : -1;
    npc.guardOrbitSpeed = (speed + (Math.random() - 0.5) * jitter) * sign;
    npc.guardAngle = Math.atan2(npc.y - station.y, npc.x - station.x);
  });
}

function clearPirateGuardState(){
  for (const npc of npcs) {
    if (!npc?.isPirate) continue;
    npc.guardHold = false;
    npc.guardMode = null;
    npc.guardStation = null;
    npc.guardAnchor = null;
    npc.guardFacing = null;
  }
  if (mercMission) {
    mercMission.guardConfigured = false;
  }
}

function setupPirateGuardFormation(station){
  if (!mercMission || !station) return;
  const orbit = pirateOrbitRadii();
  const forward = norm({ x: ship.pos.x - station.x, y: ship.pos.y - station.y });
  const right = { x: -forward.y, y: forward.x };
  const defensiveRing = Math.min(
    station.r + 1400,
    Math.max(station.r + 900, (orbit.inner || (station.r + 1200)) - 200)
  );
  const rearRing = Math.max(station.r + 620, defensiveRing - 260);
  const pdOrbit = Math.max(station.r + 320, Math.min(rearRing - 180, station.r + 900));
  const fighterOrbit = Math.max(pdOrbit + 140, station.r + 480);

  const pirates = npcs.filter(n => n.isPirate && !n.dead && n.mission);
  const capitals = pirates.filter(n => n.isCapitalShip || n.type === 'battleship' || n.type === 'destroyer');
  const laserFrigates = pirates.filter(n => (n.type && n.type.includes('frigate') && n.subType === 'laser') || n.type === 'frigate_laser');
  const pdFrigates = pirates.filter(n => n.type && n.type.includes('frigate') && n.subType !== 'laser');
  const fighters = pirates.filter(n => n.fighter || n.type === 'fighter' || n.type === 'interceptor');

  clearPirateGuardState();
  assignPirateLine(capitals, station, forward, right, defensiveRing, 320);
  assignPirateLine(laserFrigates, station, forward, right, rearRing, 220);
  assignPirateOrbit(pdFrigates, station, pdOrbit, 0.24, 0.08);
  assignPirateOrbit(fighters, station, fighterOrbit, 0.48, 0.12);

  mercMission.guardConfigured = true;
}

function updatePirateGuardBehavior(station, dt){
  if (!station || !mercMission?.guardConfigured) return;
  for (const npc of npcs) {
    if (!npc?.isPirate || npc.dead || !npc.guardMode || npc.guardStation !== station) continue;
    if (npc.guardMode === 'orbit') {
      const ang = npc.guardAngle = wrapAngle((npc.guardAngle || 0) + (npc.guardOrbitSpeed || 0) * dt);
      const r = npc.guardOrbitRadius || (station.r + 360);
      npc.x = station.x + Math.cos(ang) * r;
      npc.y = station.y + Math.sin(ang) * r;
      npc.vx = -Math.sin(ang) * r * (npc.guardOrbitSpeed || 0);
      npc.vy =  Math.cos(ang) * r * (npc.guardOrbitSpeed || 0);
      npc.angle = Math.atan2(npc.vy, npc.vx);
    } else if (npc.guardMode === 'line' && npc.guardAnchor) {
      const dx = npc.guardAnchor.x - npc.x;
      const dy = npc.guardAnchor.y - npc.y;
      const dist = Math.hypot(dx, dy) || 1;
      const dir = { x: dx / dist, y: dy / dist };
      const accel = (npc.accel || 140) * dt;
      npc.vx += dir.x * accel;
      npc.vy += dir.y * accel;
      const friction = npc.friction || 0.985;
      npc.vx *= friction;
      npc.vy *= friction;
      npc.x += npc.vx * dt;
      npc.y += npc.vy * dt;
      npc.angle = typeof npc.guardFacing === 'number' ? npc.guardFacing : npc.angle;
    }
  }
}

function enterPirateOuterOrbit(){
  if (!mercMission || !mercMission.station || mercMission.alertStage === 'engage') return;
  if (mercMission.alertStage === 'guard' && mercMission.guardConfigured) return;
  mercMission.alertStage = 'guard';
  mercMission.aggro = false;
  if (mercMission.swarm) mercMission.swarm.active = false;
  setupPirateGuardFormation(mercMission.station);
}

function enterPirateInnerOrbit(){
  if (!mercMission || !mercMission.station) return;
  if (mercMission.alertStage !== 'engage') {
    mercMission.alertStage = 'engage';
    clearPirateGuardState();
  }
  if (!mercMission.aggro) triggerMercAggro('player_inner_orbit');
}

function triggerMercAggro(reason){
  if(!mercMission) return;
  mercMission.aggro = true;
  mercMission.aggroReason = mercMission.aggroReason || reason;
  mercMission.alertStage = 'engage';
  clearPirateGuardState();

  if(mercMission.swarm){
    mercMission.swarm.active = true;
    if(!mercMission.swarm.queue || !mercMission.swarm.queue.length) resetSwarmQueue();
    if(!mercMission.swarm.timer || mercMission.swarm.timer > 1.2) mercMission.swarm.timer = 1.2;
  }

  // --- ZMIANA TUTAJ ---
  for(const npc of npcs){
    if(npc.mission && npc.isPirate && !npc.dead){
      // USUWAMY/KOMENTUJEMY TE LINIE:
      // npc.forceTarget = ship; 
      // npc.target = ship;
      
      // Zamiast tego czyścimy forceTarget, aby AI mogło samo wybrać cel (np. myśliwce gracza)
      npc.forceTarget = null; 
      npc.target = null;
    }
  }
}


// =============== Rail (2 lufy: serie A→B, A→B) ===============
const RAIL_SPEED = 2600, RAIL_PEN = 3, RAIL_DAMAGE = 60;
const ARMATA_SPLASH_RADIUS = 140;
const ARMATA_SPLASH_FALLOFF_MIN = 0.2;
const BASE_MAIN_BEHAVIOR = {
  id: 'default',
  priority: 1,
  cooldown: 0.38,
  burstsPerClick: 2,
  shotGap: 0.07,
  burstGap: 0.18,
  recoilKick: 14,
  recoilMax: 12,
  barrelsPerShot: 2,
  muzzleFx: spawnRailMuzzle,
  hitFx: spawnRailHitEffect,
  projectile: {
    type: 'rail',
    speed: RAIL_SPEED,
    life: 2.0,
    radius: 4,
    penetration: RAIL_PEN,
    effectScale: 1.0,
  },
};

function createMainWeaponBehavior(overrides = {}) {
  const projectileOverrides = overrides.projectile || {};
  const behavior = {
    ...BASE_MAIN_BEHAVIOR,
    ...overrides,
    projectile: {
      ...BASE_MAIN_BEHAVIOR.projectile,
      ...projectileOverrides,
    },
    muzzleFx: overrides.muzzleFx || BASE_MAIN_BEHAVIOR.muzzleFx,
    hitFx: overrides.hitFx || BASE_MAIN_BEHAVIOR.hitFx,
  };
  behavior.id = overrides.id || behavior.id;
  behavior.priority = overrides.priority ?? behavior.priority ?? BASE_MAIN_BEHAVIOR.priority;
  behavior.barrelsPerShot = overrides.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot;
  return behavior;
}

const MAIN_WEAPON_BEHAVIOR = {
  default: createMainWeaponBehavior(),
  railgun_mk2: createMainWeaponBehavior({ id: 'railgun_mk2', priority: 2 }),
  armata_mk1: createMainWeaponBehavior({
    id: 'armata_mk1',
    priority: 3,
    cooldown: 1.8,
    burstsPerClick: 1,
    shotGap: 0,
    burstGap: 0.32,
    recoilKick: 20,
    recoilMax: 18,
    barrelsPerShot: 1,
    muzzleFx: spawnArmataMuzzle,
    hitFx: spawnArmataHitEffect,
    projectile: {
      type: 'armata',
      speed: RAIL_SPEED * 0.78,
      life: 2.6,
      radius: 6,
      penetration: 0,
      explodeRadius: ARMATA_SPLASH_RADIUS,
      effectScale: 1.4,
    },
  }),
  heavy_autocannon: createMainWeaponBehavior({
    id: 'heavy_autocannon',
    priority: 4,
    cooldown: 0.16,
    burstsPerClick: 1,
    shotGap: 0.045,
    burstGap: 0.1,
    recoilKick: 8,
    recoilMax: 10,
    barrelsPerShot: 1,
    projectile: {
      type: 'autocannon',
      speed: RAIL_SPEED * 0.82,
      life: 1.6,
      radius: 3,
      penetration: 1,
      effectScale: 0.9,
    },
    muzzleFx: spawnAutocannonMuzzle,
    hitFx: spawnAutocannonHitEffect,
  }),
};
MAIN_WEAPON_BEHAVIOR.railgun_mk1 = MAIN_WEAPON_BEHAVIOR.default;

const rail = {
  cd: [0, 0],
  cdMax: MAIN_WEAPON_BEHAVIOR.default.cooldown,
  shotGap: MAIN_WEAPON_BEHAVIOR.default.shotGap,
  burstGap: MAIN_WEAPON_BEHAVIOR.default.burstGap,
  burstsPerClick: MAIN_WEAPON_BEHAVIOR.default.burstsPerClick,
  barrelsPerShot: MAIN_WEAPON_BEHAVIOR.default.barrelsPerShot,
  queue: [],
  nextStart: 0,
  behaviorId: MAIN_WEAPON_BEHAVIOR.default.id,
};
let railTimer = 0;

rebuildHardpointsForFrame();
loadLoadout();

function triggerRailVolley(){
  if(!(Game.player.weapons?.[HP.MAIN]?.length)) return;
  if(rail.queue.length) return;
  const start = rail.nextStart; rail.nextStart ^= 1;
  const barrels = Math.max(1, rail.barrelsPerShot || 2);
  const orderPair = barrels === 1 ? [0] : [start, 1 - start];
  for(let b=0;b<rail.burstsPerClick;b++){
    const baseDelay = b * (orderPair.length * rail.shotGap + rail.burstGap);
    for(let idx = 0; idx < orderPair.length; idx++){
      rail.queue.push({ timer: baseDelay + idx * rail.shotGap, barrel: orderPair[idx] });
    }
  }
}
function fireRailBarrel(barIndex){
  const mainWeapons = Game.player.weapons?.[HP.MAIN] || [];
  if(!mainWeapons.length) return;
  const spriteScale = ship.visual?.spriteScale || 1;
  const forwardLen = Math.min((ship.h * spriteScale) * 0.40, 52 * spriteScale); // było 0.36 i 46
  const gap = 10 * spriteScale;
  const turrets = [ship.turret, ship.turret2, ship.turret3, ship.turret4];
  const activeCount = Math.min(mainWeapons.length, turrets.length);
  let maxCooldown = 0;
  for(let i=0;i<activeCount;i++){
    const t = turrets[i];
    const weaponData = mainWeapons[i]?.weapon;
    const behavior = getMainWeaponBehaviorForWeaponId(weaponData?.id);
    const projectile = behavior.projectile || BASE_MAIN_BEHAVIOR.projectile;
    const barrelsPerShot = Math.max(1, behavior.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot);
    const normalizedIndex = Math.min(barIndex, barrelsPerShot - 1);
    const offsetFrac = barrelsPerShot === 1 ? 0 : (normalizedIndex / (barrelsPerShot - 1) - 0.5) * 2;
    const lateralOffset = (gap * 0.5) * offsetFrac;
    const damage = weaponData?.damage ?? weaponData?.dps ?? RAIL_DAMAGE;
    const a = t.angle;
    const f = {x:Math.cos(a), y:Math.sin(a)};
    const p = {x:-Math.sin(a), y:Math.cos(a)};
    const off = rotate(t.offset, ship.angle);
    const px = ship.pos.x + off.x + f.x * forwardLen + p.x * lateralOffset;
    const py = ship.pos.y + off.y + f.y * forwardLen + p.y * lateralOffset;
    window.bullets.push({
      x: px,
      y: py,
      vx: f.x * (projectile.speed ?? RAIL_SPEED) + ship.vel.x,
      vy: f.y * (projectile.speed ?? RAIL_SPEED) + ship.vel.y,
      life: projectile.life ?? 2.0,
      r: projectile.radius ?? 4,
      owner: 'player',
      damage,
      penetration: (projectile.penetration != null) ? projectile.penetration : RAIL_PEN,
      type: projectile.type || 'rail',
      weaponId: weaponData?.id,
      effectScale: projectile.effectScale ?? 1.0,
      explodeRadius: projectile.explodeRadius,
    });
    const recoilKick = behavior.recoilKick ?? t.recoilKick;
    const recoilMax = behavior.recoilMax ?? t.recoilMax;
    t.recoil = Math.min(t.recoil + recoilKick, recoilMax);
    const muzzleFx = behavior.muzzleFx || spawnRailMuzzle;
    muzzleFx({ x: px, y: py }, f, ship.vel, projectile.effectScale ?? 1.0);
    maxCooldown = Math.max(maxCooldown, behavior.cooldown ?? rail.cdMax);
  }
  rail.cd[barIndex] = maxCooldown || rail.cdMax;
}

// =============== CIWS (point-defence) ===============
const CIWS_FIRE_INTERVAL = 0.06;
const CIWS_BULLET_SPEED = 900;
const CIWS_DAMAGE = 8;
const CIWS_RANGE = 600;

const SIEGE_CANNON_COOLDOWN = 5.2;
const SIEGE_CANNON_DAMAGE = 200;
const SIEGE_CANNON_SPEED = 1700;
const SIEGE_CANNON_RANGE = 1800;
const SIEGE_CANNON_SPREAD = 0.0045;
const SIEGE_CANNON_LIFE = 1.1 * (SIEGE_CANNON_RANGE / SIEGE_CANNON_SPEED);

const LASER_PD_FIRE_INTERVAL = 0.18;
const LASER_PD_DAMAGE = 16;
const LASER_PD_RANGE = 620;
const LASER_PD_BEAM_WIDTH = 6;

function ciwsStep(dt){
  const auxWeapons = Game.player.weapons?.[HP.AUX] || [];
  for(let i=0;i<ship.ciws.length;i++){
    if(i >= auxWeapons.length) break;
    const loadout = auxWeapons[i];
    if(!loadout || !loadout.weapon) continue;
    const weaponId = loadout.weapon.id;
    const isLaser = weaponId === 'laser_pd_mk1';
    const gun = ship.ciws[i];
    gun.cd = Math.max(0, gun.cd - dt);
    const off = rotate(gun.offset, ship.angle);
    const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
    const baseVel = { x: ship.vel.x - ship.angVel * off.y, y: ship.vel.y + ship.angVel * off.x };
    const range = isLaser ? LASER_PD_RANGE : CIWS_RANGE;
    let target = null; let dist = range;
    for(const npc of npcs){
      if(npc.dead || npc.friendly || !npc.isPirate) continue;
      const d = Math.hypot(npc.x - base.x, npc.y - base.y);
      if(d < dist){ dist = d; target = npc; }
    }
    if(!target) continue;

    const aimPoint = isLaser ? { x: target.x, y: target.y }
                             : leadTarget(base, baseVel, target, CIWS_BULLET_SPEED);
    const desired = Math.atan2(aimPoint.y - base.y, aimPoint.x - base.x);
    let diff = wrapAngle(desired - gun.angle);
    const aimStrength = isLaser ? 9 : 8;
    const maxVel = isLaser ? 6.5 : 6;
    let desiredVel = clamp(diff * aimStrength, -maxVel, maxVel);
    const velDelta = desiredVel - gun.angVel;
    const maxDelta = 40 * dt;
    gun.angVel += clamp(velDelta, -maxDelta, maxDelta);
    gun.angVel *= Math.exp(-8 * dt);
    gun.angVel = clamp(gun.angVel, -maxVel, maxVel);
    gun.angle = wrapAngle(gun.angle + gun.angVel * dt);

    const aimTolerance = isLaser ? 0.1 : 0.15;
    if(Math.abs(diff) >= aimTolerance || gun.cd > 0) continue;

    if(isLaser){
      firePointDefenseLaser(gun, base, baseVel, target);
    } else {
      fireCIWSGun(gun, base, baseVel);
    }
  }
}

function fireCIWSGun(gun, base, baseVel){
  const dir = { x: Math.cos(gun.angle), y: Math.sin(gun.angle) };
  const px = base.x + dir.x * 6;
  const py = base.y + dir.y * 6;
  window.bullets.push({
    x:px,
    y:py,
    vx: dir.x*CIWS_BULLET_SPEED + baseVel.x,
    vy: dir.y*CIWS_BULLET_SPEED + baseVel.y,
    life:1.2,
    r:2,
    owner:'player',
    damage:CIWS_DAMAGE,
    type:'ciws'
  });
  spawnParticle(
    {x:px, y:py},
    {x:dir.x*120 + baseVel.x*0.1, y:dir.y*120 + baseVel.y*0.1},
    0.06,
    '#ffdf9e',
    2.0,
    true
  );
  gun.cd = CIWS_FIRE_INTERVAL;
}

function firePointDefenseLaser(gun, base, baseVel, target){
  const dir = { x: Math.cos(gun.angle), y: Math.sin(gun.angle) };
  const muzzle = { x: base.x + dir.x * 6, y: base.y + dir.y * 6 };
  const toTarget = { x: target.x - muzzle.x, y: target.y - muzzle.y };
  const distance = clamp(Math.hypot(toTarget.x, toTarget.y), 0, LASER_PD_RANGE);
  const beamEnd = { x: muzzle.x + dir.x * distance, y: muzzle.y + dir.y * distance };

  spawnLaserBeam(muzzle, beamEnd, LASER_PD_BEAM_WIDTH, {
    life: 0.09,
    colorOuter: 'rgba(110,200,255,0.9)',
    colorInner: 'rgba(250,255,255,1.0)',
    glowColor: 'rgba(90,180,255,0.95)',
    glowBlur: 22,
    outerWidthMul: 1.05,
    innerWidthMul: 0.45
  });
  spawnPointDefenseLaserMuzzle(muzzle, dir, baseVel);
  spawnPointDefenseLaserHit(beamEnd.x, beamEnd.y);
  applyDamageToNPC(target, LASER_PD_DAMAGE, 'laser_pd');
  gun.cd = LASER_PD_FIRE_INTERVAL;
}

function spawnPointDefenseLaserMuzzle(pos, dir, baseVel){
  const tangential = { x: -dir.y, y: dir.x };
  for(let i=0;i<3;i++){
    const spread = (Math.random()-0.5) * 0.6;
    const vel = {
      x: dir.x * (220 + Math.random()*80) + tangential.x * spread * 80 + baseVel.x * 0.1,
      y: dir.y * (220 + Math.random()*80) + tangential.y * spread * 80 + baseVel.y * 0.1
    };
    spawnParticle(
      { x: pos.x, y: pos.y },
      vel,
      0.08 + Math.random()*0.05,
      '#8fe4ff',
      2.2 + Math.random()*0.8,
      true
    );
  }
}

function spawnPointDefenseLaserHit(x, y){
  for(let i=0;i<12;i++){
    const a = Math.random() * Math.PI * 2;
    const speed = 160 + Math.random() * 200;
    spawnParticle(
      { x, y },
      { x: Math.cos(a) * speed, y: Math.sin(a) * speed },
      0.16 + Math.random()*0.14,
      '#78d9ff',
      1.4 + Math.random()*1.6,
      true
    );
  }
  spawnParticle({ x, y }, { x: 0, y: 0 }, 0.05, '#ffffff', 4.4, true);
  spawnShockwave(x, y, { r: 5, maxR: 70, w: 2.4, maxLife: 0.35, color: 'rgba(110,200,255,' });
}

// =============== Specjal & dmg ===============
function tryFireSpecial(){
  if(!(Game.player.weapons?.[HP.SPECIAL]?.length)) return;
  if(ship.special.cooldownTimer>0) return;
  ship.special.cooldownTimer = SPECIAL_COOLDOWN;
  const dir = rotate({x:0,y:-1}, ship.angle);
  const start = add(ship.pos, rotate({x:0, y:-ship.h/2}, ship.angle));
  const length = 2000;
  const end = { x: start.x + dir.x*length, y: start.y + dir.y*length };
  const width = ship.w;
  const npcsInRange = npcs.filter(npc => !npc.dead && Math.hypot(npc.x - start.x, npc.y - start.y) < length + npc.radius);
  let hits = 0;
  const HIT_CAP = 80; // wystarczająco dużo, by czuć „miotłę”, ale bez zgonu CPU
  for (const npc of npcsInRange){
    if (hits >= HIT_CAP) break;
    const vx = npc.x - start.x, vy = npc.y - start.y;
    const proj = vx*dir.x + vy*dir.y;
    if (proj < 0 || proj > length) continue;
    const perp = Math.abs(vx*dir.y - vy*dir.x);
    if (perp <= npc.radius + width*0.5){
      applyDamageToNPC(npc, SPECIAL_DAMAGE, 'none');
      if ((hits & 1) === 0) spawnParticle({x:npc.x, y:npc.y}, {x:0,y:0}, 0.10, '#9ccfff', 5, true);
      hits++;
    }
  }
  spawnLaserBeam(start, end, width);
  for(let i=0;i<8;i++){
    const t = i/7;
    const px = start.x + dir.x*length*t + (Math.random()-0.5)*width*0.3;
    const py = start.y + dir.y*length*t + (Math.random()-0.5)*width*0.3;
    spawnParticle({x:px, y:py}, {x:(Math.random()-0.5)*120, y:(Math.random()-0.5)*120}, 0.2, '#9ccfff', 2.5, true);
  }
}
function applyDamageToPlayer(amount){
  if(ship.shield.val>0){ const s = Math.min(ship.shield.val, amount); ship.shield.val -= s; amount -= s; ship.shield.regenTimer = ship.shield.regenDelay; }
  if(amount>0) ship.hull.val = Math.max(0, ship.hull.val - amount);
  hudSpawnDMG(ship.pos.x, ship.pos.y - ship.h*0.4, amount, 'player');
}
function applyDamageToNPC(npc, dmg, cause='default'){
  if(npc.dead) return;
  if(!Number.isFinite(dmg) || dmg <= 0) return;
  npc.hitFlash = 0.12;
  npc.damageHue = (npc.damageHue || 0) + dmg;

  let remaining = dmg;
  if (npc.shield && npc.shield.max > 0){
    npc.shield.regenTimer = npc.shield.regenDelay ?? 0;
    const absorbed = Math.min(npc.shield.val, remaining);
    if (absorbed > 0){
      npc.shield.val -= absorbed;
      remaining -= absorbed;
      if (npc.fleetEntry){
        npc.fleetEntry.status.shield = npc.shield.val;
        markFleetDirty();
      }
    }
  }

  if(remaining <= 0){
    return;
  }

  npc.hp -= remaining;
  hudSpawnDMG(npc.x, npc.y - (npc.radius||20)*0.8, remaining, 'npc');
  if (npc.fleetEntry){
    npc.fleetEntry.status.hull = npc.hp;
    markFleetDirty();
  }
  if(npc.hp<=0){
    npc.dead = true; npc.respawnTimer = 3 + Math.random()*6;
    if(cause === 'plasma'){ spawnExplosionPlasma(npc.x, npc.y, 1.2); }
    else if(cause === 'default'){ spawnDefaultHit(npc.x, npc.y, 1.2); }
  }
}

function applyDamageToStation(station, amount){
  let dmg = amount || 0;
  if(dmg <= 0) return 0;
  if(station.shield){
    station.shield.regenTimer = station.shield.regenDelay;
    const absorbed = Math.min(station.shield.val, dmg);
    station.shield.val -= absorbed;
    dmg -= absorbed;
  }
  if(dmg > 0){
    station.hp = Math.max(0, station.hp - dmg);
  }
  return dmg;
}

function applyDamageToPlatform(platform, amount){
  if(!platform || platform.destroyed) return 0;
  let dmg = amount || 0;
  if(dmg <= 0) return 0;
  if(platform.shield){
    platform.shield.regenTimer = platform.shield.regenDelay;
    const absorbed = Math.min(platform.shield.val, dmg);
    platform.shield.val -= absorbed;
    dmg -= absorbed;
  }
  if(dmg > 0){
    platform.hp = Math.max(0, platform.hp - dmg);
  }
  platform.hitFlash = 0.18;
  hudSpawnDMG(platform.x, platform.y - platform.radius * 0.65, amount, 'npc');
  if(platform.hp <= 0 && !platform.destroyed){
    platform.destroyed = true;
    platform.deathTimer = 0;
    spawnExplosionPlasma(platform.x, platform.y, 1.4);
    spawnShockwave(platform.x, platform.y, { maxR: 420, maxLife: 0.6, color: 'rgba(255,140,120,' });
  }
  return dmg;
}

// =============== Collisions & particles ===============
function bulletsAndCollisionsStep(dt){
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.px = b.x; b.py = b.y;
    b.x += b.vx * dt; b.y += b.vy * dt;
    b.life -= dt;
    b.age = (b.age || 0) + dt; // krótki „grace” po wystrzale

    if(b.type === 'plasma' || b.type === 'rocket'){
      const trailVel = { x: -b.vx*0.02 + (Math.random()-0.5)*10, y: -b.vy*0.02 + (Math.random()-0.5)*10 };
      spawnParticle({x:b.x + (Math.random()-0.5)*3, y:b.y + (Math.random()-0.5)*3}, trailVel, 0.28, '#8cff8c', 1.0, false);
      if(b.type === 'rocket'){
        if(b.homingDelay > 0){
          b.homingDelay -= dt;
        } else {
          // HOMING: NPC -> gracz, player -> cele (NPC)
          let target = null;

          if (b.owner !== 'player') {
            // rakiety piratów zawsze gonią gracza
            target = { x: ship.pos.x, y: ship.pos.y };
          } else if (b.target && !b.target.dead) {
            target = { x: b.target.x, y: b.target.y };
          } else if (lockedTargets.length){
            let dist = Infinity, chosen = null;
            for(const t of lockedTargets){
              if(t.dead) continue;
              const d = Math.hypot(t.x - b.x, t.y - b.y);
              if(d < dist){ dist = d; chosen = t; }
            }
            if(chosen) target = { x: chosen.x, y: chosen.y };
          } else if (lockedTarget && !lockedTarget.dead){
            target = { x: lockedTarget.x, y: lockedTarget.y };
          } else {
            let dist = Infinity;
            for(const npc of npcs){
              if(npc.dead) continue;
              // graczowe rakiety nie strzelają w sojusznicze (friendly) cele
              if (b.owner==='player' && npc.friendly) continue;
              const d = Math.hypot(npc.x - b.x, npc.y - b.y);
              if(d < dist){ dist = d; target = {x:npc.x, y:npc.y}; }
            }
            if(!target){
              const mouseWorld = screenToWorld(mouse.x, mouse.y);
              target = { x: mouseWorld.x, y: mouseWorld.y };
            }
          }

          const speed = Math.hypot(b.vx, b.vy);
          const dir = norm({x:target.x - b.x, y:target.y - b.y});
          const current = Math.atan2(b.vy, b.vx);
          const desired = Math.atan2(dir.y, dir.x);
          const diff = wrapAngle(desired - current);
          const turnRate = (b.turnRate != null) ? b.turnRate : SIDE_ROCKET_TURN_RATE;
          const maxTurn = turnRate * dt;
          const turn = Math.abs(diff) < maxTurn ? diff : Math.sign(diff) * maxTurn;
          const newAng = current + turn;
          b.vx = Math.cos(newAng) * speed;
          b.vy = Math.sin(newAng) * speed;
        }
      }
    } else if(b.type === 'autocannon'){
      const trailVel = {
        x: -b.vx * 0.015 + (Math.random() - 0.5) * 28,
        y: -b.vy * 0.015 + (Math.random() - 0.5) * 28
      };
      const color = (Math.random() < 0.45) ? '#ffdca8' : '#ffb86b';
      spawnParticle(
        { x: b.x + (Math.random() - 0.5) * 2, y: b.y + (Math.random() - 0.5) * 2 },
        trailVel,
        0.18,
        color,
        1.1,
        true
      );
      if(Math.random() < 0.35){
        spawnParticle(
          { x: b.x, y: b.y },
          { x: -trailVel.x * 0.4, y: -trailVel.y * 0.4 },
          0.26,
          'rgba(90,110,180,0.4)',
          1.8,
          false
        );
      }
    }

    if(b.life <= 0){ bullets.splice(i,1); continue; }

    // hit NPC (z pominięciem własnego źródła w czasie grace)
    let hitNPC = null;
    for (const npc of npcs){
      if (npc.dead || npc.isCollidable === false) continue;
      
      // --- FIX FRIENDLY FIRE ---
      // Gracz nie trafia sojuszników
      if (b.owner === 'player' && npc.friendly) continue;
      // NPC (pirat) nie trafia innych piratów
      if (b.owner === 'npc' && !npc.friendly) continue; 
      // -------------------------

      if (b.source && b.source === npc && b.age < (b.spawnGrace || 0)) continue;
      const d = Math.hypot(npc.x - b.x, npc.y - b.y);
      if (d < npc.radius + b.r){ hitNPC = npc; break; }
    }

    if(hitNPC){
      if(b.owner === 'player' && hitNPC.mission && hitNPC.isPirate){
        triggerMercAggro('pirate_hit');
      }
      if(b.type === 'plasma' || b.type === 'rocket'){
        const ex = b.x, ey = b.y;
        spawnExplosionPlasma(ex, ey, 1.0);
        for(const npc of npcs){
          if(npc.dead || (b.owner==='player' && npc.friendly)) continue;
          const d2 = Math.hypot(npc.x - ex, npc.y - ey);
          if(d2 <= b.explodeRadius + npc.radius){
            const falloff = 1 - (d2 / (b.explodeRadius + npc.radius));
            applyDamageToNPC(npc, Math.round(b.damage * (0.9 * falloff + 0.1)), 'plasma');
          }
        }
        bullets.splice(i,1);
        continue;
      } else if(b.type === 'armata'){
        applyDamageToNPC(hitNPC, b.damage, 'armata');
        spawnArmataHitEffect(b.x, b.y, b.effectScale || 1.0);
        const radius = b.explodeRadius ?? ARMATA_SPLASH_RADIUS;
        if(radius > 0){
          for (const npc of npcs){
            if (npc === hitNPC || npc.dead) continue;
            if (b.owner === 'player' && npc.friendly) continue;
            const d2 = Math.hypot(npc.x - b.x, npc.y - b.y);
            if (d2 <= radius + npc.radius){
              const falloff = 1 - Math.min(1, d2 / (radius + npc.radius));
              const scaled = Math.max(ARMATA_SPLASH_FALLOFF_MIN, falloff);
              const splashDmg = Math.round(b.damage * 0.6 * scaled);
              if (splashDmg > 0){
                applyDamageToNPC(npc, splashDmg, 'armata');
              }
            }
          }
        }
        bullets.splice(i,1);
        continue;
      } else if(b.type === 'rail'){
        applyDamageToNPC(hitNPC, b.damage, 'rail');
        spawnRailHitEffect(b.x, b.y, 1.0);
        b.penetration = (b.penetration !== undefined) ? b.penetration - 1 : (RAIL_PEN - 1);
        if(b.penetration <= 0){ bullets.splice(i,1); }
        continue;
      } else if(b.type === 'autocannon'){
        applyDamageToNPC(hitNPC, b.damage, 'autocannon');
        spawnAutocannonHitEffect(b.x, b.y, b.effectScale || 1.0);
        if(b.penetration != null){
          b.penetration -= 1;
          if(b.penetration <= 0){ bullets.splice(i,1); }
        } else {
          bullets.splice(i,1);
        }
        continue;
      } else if(b.type === 'siege'){
        applyDamageToNPC(hitNPC, b.damage, 'siege');
        spawnSiegeHitEffect(b.x, b.y, b.effectScale || 1.0);
        bullets.splice(i,1);
        continue;
      } else {
        applyDamageToNPC(hitNPC, b.damage, 'default');
        spawnDefaultHit(b.x, b.y, 1.0);
        bullets.splice(i,1);
        continue;
      }
    }

    if(mercMission && mercMission.weaponPlatforms && mercMission.weaponPlatforms.length){
      let hitPlatform = false;
      for(const platform of mercMission.weaponPlatforms){
        if(!platform || platform.destroyed) continue;
        if (b.source && b.source === platform && b.age < (b.spawnGrace || 0)) continue;
        const d = Math.hypot(platform.x - b.x, platform.y - b.y);
        if(d < platform.radius + b.r){
          applyDamageToPlatform(platform, b.damage || 0);
          triggerMercAggro('platform_hit');
          if(b.type === 'armata'){
            spawnArmataHitEffect(b.x, b.y, b.effectScale || 1.0);
          } else if(b.type === 'rail'){
            spawnRailHitEffect(b.x, b.y, 1.0);
          } else if(b.type === 'autocannon'){
            spawnAutocannonHitEffect(b.x, b.y, b.effectScale || 1.0);
          } else {
            spawnExplosionPlasma(b.x, b.y, 1.0);
          }
          bullets.splice(i,1);
          hitPlatform = true;
          break;
        }
      }
      if(hitPlatform) continue;
    }

    // hit mission station
    for(const st of stations){
      if(!st.hp) continue;
      if (b.source && b.source === st && b.age < (b.spawnGrace || 0)) continue;
      const d = Math.hypot(st.x - b.x, st.y - b.y);
      if(d < st.r + b.r){
        applyDamageToStation(st, b.damage || 0);
        if(mercMission && mercMission.station === st){
          triggerMercAggro('station_hit');
        }
        if(st.hp <= 0){
          if(mercMission && mercMission.station === st){
            PLAYER.credits += 10000;
            stations.splice(stations.indexOf(st),1);
            if (typeof window.dettachPirateStation3D === 'function') {
              window.dettachPirateStation3D(mainScene3D);
            }
            const m = MISSIONS.active.find(mm => mm.id === 'merc_pirate_station' && mm.status === 'active');
            if(m) m.status = 'completed';

            missionCompleteBanner.trigger('misja zakończona');
            toast('Misja zakończona: +10000 cr');
            resetMercMission();
          }
        }
        if(b.type === 'armata'){
          spawnArmataHitEffect(b.x, b.y, b.effectScale || 1.0);
        } else if(b.type === 'rail'){
          spawnRailHitEffect(b.x, b.y, 1.0);
        } else if(b.type === 'autocannon'){
          spawnAutocannonHitEffect(b.x, b.y, b.effectScale || 1.0);
        } else if(b.type === 'siege'){
          spawnSiegeHitEffect(b.x, b.y, b.effectScale || 1.0);
        } else {
          spawnExplosionPlasma(b.x, b.y, 1.0);
        }
        bullets.splice(i,1);
        break;
      }
    }

    // hit player
    if(b.owner !== 'player'){
      const hitR = Math.max(ship.w, ship.h) * 0.45;
      const d = Math.hypot(ship.pos.x - b.x, ship.pos.y - b.y);
      if(d < hitR + b.r){
        applyDamageToPlayer(b.damage);
        if(b.type === 'siege'){
          spawnSiegeHitEffect(b.x, b.y, b.effectScale || 1.0);
        } else if(b.type === 'armata'){
          spawnArmataHitEffect(b.x, b.y, b.effectScale || 1.0);
        } else if(b.type === 'rail'){
          spawnRailHitEffect(b.x, b.y, 1.0);
        } else if(b.type === 'autocannon'){
          spawnAutocannonHitEffect(b.x, b.y, b.effectScale || 1.0);
        } else {
          spawnDefaultHit(b.x, b.y, 1.0);
        }
        bullets.splice(i,1);
        continue;
      }
    }
  }

  // particles
  for (const p of particlePool) { // Iteruj po całej puli
    if (!p.active) continue; // Pomiń nieaktywne

    p.age += dt;
    if (p.age >= p.life) {
      p.active = false; // <-- Deaktywuj zamiast usuwać (splice)
      continue;
    }

    if (p.beam) continue;
    p.vel.x *= 0.98; p.vel.y *= 0.98; p.vel.y += 8*dt;
    p.pos.x += p.vel.x * dt; p.pos.y += p.vel.y * dt;
  }
}

// =============== NPC movement/shooting ===============
let npcFireTimer = 0;
function npcShootingStep(dt){
  npcFireTimer -= dt;
  if(npcFireTimer <= 0){
    npcFireTimer = 0.45 + Math.random()*0.8;
    const candidates = npcs.filter(n=>!n.dead && n.weapon && !n.friendly && Math.hypot(n.x-ship.pos.x, n.y-ship.pos.y) < 900);
    if(candidates.length){
      const shooter = candidates[Math.floor(Math.random()*candidates.length)];
      const dir = norm({x: ship.pos.x - shooter.x, y: ship.pos.y - shooter.y});
      const bx = shooter.x + dir.x*(shooter.radius+6), by = shooter.y + dir.y*(shooter.radius+6);
      if(shooter.weapon === 'railgun'){
        window.bullets.push({ x:bx, y:by, vx: dir.x*600 + shooter.vx, vy: dir.y*600 + shooter.vy, life: 2.0, r:4, owner:'npc', damage:40, type:'rail', penetration:1 });
      } else {
        window.bullets.push({ x:bx, y:by, vx: dir.x*220 + shooter.vx, vy: dir.y*220 + shooter.vy, life: 4, r:3, owner:'npc', damage:12 });
      }
    }
  }
}
function npcStep(dt){
  const DESPAWN_RADIUS_SQ = NPC_DESPAWN_RADIUS * NPC_DESPAWN_RADIUS;
  for(const npc of npcs){
    if (npc.hitFlash) npc.hitFlash = Math.max(0, npc.hitFlash - dt);
    if(!npc.mission){
      const dx = npc.x - ship.pos.x;
      const dy = npc.y - ship.pos.y;
      if(dx*dx + dy*dy > DESPAWN_RADIUS_SQ){
        npc.dead = true;
        npc.respawnTimer = 5;
        continue;
      }
    }
    if(npc.mission){
      if(npc.dead) continue;
      if(npc.ai) npc.ai(dt);
      if (npc.fighter) { const drag = Math.exp(-3*dt); npc.vx *= drag; npc.vy *= drag; }
      npc.x += (npc.vx||0)*dt;
      npc.y += (npc.vy||0)*dt;
      if (npc.keepAngle){
        if (typeof npc.desiredAngle === 'number'){
          npc.angle = npc.desiredAngle;
        }
      } else {
        npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
      }
      continue;
    }
    if(npc.dead){
      npc.respawnTimer -= dt;
      if(npc.respawnTimer<=0){
        const base = stations.find(s=>s.id===npc.lastStation) || stations[0];
        const group = stations.filter(s=>s.inner === base.inner);
        const start = group[Math.floor(Math.random()*group.length)];
        const targetId = pickNextStation(start.id, npc.type);
        const startPort = Math.floor(Math.random()*start.ports.length);
        const spawnPos = stationPortWorld(start, startPort);
        npc.x = spawnPos.x;
        npc.y = spawnPos.y;
        npc.vx = 0; npc.vy = 0;
        npc.hp = npc.maxHp; npc.dead=false; npc.target = targetId; npc.fade = 1; npc.docking=false; npc.lastStation=start.id;
        const target = stations.find(s=>s.id===targetId);
        npc.dockPort = target ? Math.floor(Math.random()*target.ports.length) : 0;
        if(target && start.inner === target.inner){
          const route = getWarpRoute(start.id, targetId);
          if(route){ npc.warpRoute = route; npc.phase = 'toGate'; npc.lane = Math.floor(Math.random()*2); }
          else { npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0; }
        } else {
          npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0;
        }
      }
      continue;
    }
    if(npc.docking){
      const st = stations.find(s=>s.id===npc.lastStation);
      if(st){
        const portPos = stationPortWorld(st, npc.dockPort || 0);
        npc.x = portPos.x; npc.y = portPos.y;
      }
      npc.fade -= dt / 0.6;
      if(npc.fade <= 0 && st){
        const targetId = pickNextStation(npc.lastStation, npc.type);
        const startPort = Math.floor(Math.random()*st.ports.length);
        const spawnPos = stationPortWorld(st, startPort);
        npc.x = spawnPos.x;
        npc.y = spawnPos.y;
        npc.vx = 0; npc.vy = 0;
        npc.target = targetId; npc.fade = 1; npc.docking=false; npc.lastStation=st.id;
        const target = stations.find(s=>s.id===targetId);
        npc.dockPort = target ? Math.floor(Math.random()*target.ports.length) : 0;
        if(target && st.inner === target.inner){
          const route = getWarpRoute(st.id, targetId);
          if(route){ npc.warpRoute = route; npc.phase = 'toGate'; npc.lane = Math.floor(Math.random()*2); }
          else { npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0; }
        } else {
          npc.warpRoute = null; npc.phase = 'direct'; npc.lane = 0;
        }
      }
      continue;
    }
    if(npc.phase === 'warping'){
      npc.x += npc.vx*dt; npc.y += npc.vy*dt;
      npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
      const route = npc.warpRoute;
      const traveled = (npc.x - route.start.x) * route.dir.x + (npc.y - route.start.y) * route.dir.y;
      if(traveled >= route.length){
        npc.phase = 'toStation';
        npc.x = route.end.x; npc.y = route.end.y;
      }
      continue;
    }
    if(npc.phase === 'toGate'){
      const gate = npc.warpRoute.start;
      const start = stations.find(s=>s.id===npc.lastStation);
      const gv = { x: gate.x - start.x, y: gate.y - start.y };
      const gd = Math.hypot(gv.x, gv.y) || 1;
      const dirToGate = { x: gv.x/gd, y: gv.y/gd };
      const perp = { x: -dirToGate.y, y: dirToGate.x };
      const laneOffset = npc.lane ? 20 : -20;
      const gatePos = { x: gate.x + perp.x*laneOffset, y: gate.y + perp.y*laneOffset };
      const queue = gate.queues[npc.lane];
      let idx = queue.indexOf(npc);
      if(idx === -1){ queue.push(npc); idx = queue.length-1; }
      const spacing = 30;
      const targetPos = {
        x: gatePos.x - dirToGate.x * idx * spacing,
        y: gatePos.y - dirToGate.y * idx * spacing
      };
      const distGate = Math.hypot(npc.x - gatePos.x, npc.y - gatePos.y);
      if(idx === 0 && distGate < 5){
        queue.shift();
        npc.phase = 'warping';
        npc.vx = npc.warpRoute.dir.x * 4000;
        npc.vy = npc.warpRoute.dir.y * 4000;
        npc.x = gatePos.x;
        npc.y = gatePos.y;
        continue;
      }
      const to = { x: targetPos.x - npc.x, y: targetPos.y - npc.y };
      const d = Math.hypot(to.x, to.y);
      if(d < 1){
        npc.vx = 0; npc.vy = 0;
        continue;
      }
      const dir = { x: to.x/d, y: to.y/d };
      const desiredV = { x: dir.x*npc.speed, y: dir.y*npc.speed };
      npc.vx += (desiredV.x - (npc.vx||0)) * clamp(1.5*dt,0,1);
      npc.vy += (desiredV.y - (npc.vy||0)) * clamp(1.5*dt,0,1);
      npc.x += npc.vx*dt; npc.y += npc.vy*dt; npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
      continue;
    }
    let targetPos, st = null;
    if(npc.leader != null){
      const leader = npcs.find(n=>n.id===npc.leader && !n.dead);
      if(leader){
        targetPos = {
          x: leader.x + Math.cos(npc.orbitAngle) * npc.orbitRadius,
          y: leader.y + Math.sin(npc.orbitAngle) * npc.orbitRadius
        };
      } else {
        npc.leader = null;
      }
    }
    if(!targetPos){
      st = stations.find(s=>s.id===npc.target);
      if(!st){
        npc.target = pickNextStation(npc.lastStation, npc.type);
        const start = stations.find(s=>s.id===npc.lastStation);
        const target = stations.find(s=>s.id===npc.target);
        if(start && target && start.inner === target.inner){
          const route = getWarpRoute(start.id, npc.target);
          if(route){
            npc.warpRoute = route;
            npc.phase = 'toGate';
            npc.lane = Math.floor(Math.random()*2);
          } else {
            npc.warpRoute = null;
            npc.phase = 'direct';
            npc.lane = 0;
          }
        } else {
          npc.warpRoute = null;
          npc.phase = 'direct';
          npc.lane = 0;
        }
        continue;
      }
      if(npc.phase === 'toStation' || npc.phase === 'direct'){
        targetPos = stationPortWorld(st, npc.dockPort || 0);
      } else {
        targetPos = { x: st.x, y: st.y };
      }
    }
    const to = { x: targetPos.x - npc.x, y: targetPos.y - npc.y };
    const d = Math.hypot(to.x,to.y);
    const dir = d?{x:to.x/d,y:to.y/d}:{x:0,y:0};
    const desiredSpeed = npc.leader != null ? npc.speed : npc.speed * (d < 120 ? (d/120) : 1);
    const desiredV = { x: dir.x*desiredSpeed, y: dir.y*desiredSpeed };
    npc.vx += (desiredV.x - (npc.vx||0)) * clamp(1.5*dt,0,1);
    npc.vy += (desiredV.y - (npc.vy||0)) * clamp(1.5*dt,0,1);
    const toP = { x: ship.pos.x - npc.x, y: ship.pos.y - npc.y }; const dp = Math.hypot(toP.x,toP.y);
    if(dp < 120){ npc.vx -= (toP.x/dp) * 40*dt; npc.vy -= (toP.y/dp) * 40*dt; }
    npc.x += npc.vx*dt; npc.y += npc.vy*dt; npc.angle = Math.atan2(npc.vy||0, npc.vx||0);
    const portPos = st ? stationPortWorld(st, npc.dockPort || 0) : null;
    const distToStation = portPos ? Math.hypot(portPos.x - npc.x, portPos.y - npc.y) : Infinity;
    if(npc.leader == null && st && distToStation < 20){
      npc.docking = true;
      npc.x = portPos.x; npc.y = portPos.y;
      npc.vx = 0; npc.vy = 0;
      npc.lastStation = st.id;
    }
  }
}

function pirateMissionStep(dt){
  if(!mercMission) return;
  const st = mercMission.station;
  if(!st) return;

  const orbitRadii = pirateOrbitRadii();
  const aggroRadius = mercMission.aggroRadius || orbitRadii.inner || (st.r + 1200);
  mercMission.aggroRadius = aggroRadius;
  const distToPlayer = Math.hypot(ship.pos.x - st.x, ship.pos.y - st.y);
  const zoneId = zoneState.current?.id;
  if (zoneId === 'pirate_outer' && mercMission.alertStage !== 'engage') {
    enterPirateOuterOrbit();
  }
  if (zoneId === 'pirate_inner') {
    enterPirateInnerOrbit();
  }
  const shouldAggro = zoneId === 'pirate_inner' || distToPlayer < aggroRadius;
  if(!mercMission.aggro && shouldAggro){
    triggerMercAggro(zoneId === 'pirate_inner' ? 'player_inner_orbit' : 'player_inside_zone');
  }

  if (mercMission.alertStage === 'guard') {
    updatePirateGuardBehavior(st, dt);
  }

  // (Zachowaj logikę platform obronnych bez zmian - pominąłem dla czytelności, wklej tutaj kod platform z oryginału)
  PirateSim.time = (PirateSim.time || 0) + dt;

  const platforms = mercMission.weaponPlatforms || [];
  const target = { x: ship.pos.x, y: ship.pos.y, vx: ship.vel.x, vy: ship.vel.y };
  for(const platform of platforms){
    if(!platform) continue;
    platform.hitFlash = Math.max(0, platform.hitFlash - dt);
    if(platform.destroyed){
      platform.deathTimer += dt;
      if(platform.deathTimer > 3){
        platform.removed = true;
      }
      continue;
    }

    platform.angle += platform.orbitSpeed * dt;
    platform.rotation = wrapAngle(platform.rotation + platform.spin * dt);
    platform.x = st.x + Math.cos(platform.angle) * platform.orbitRadius;
    platform.y = st.y + Math.sin(platform.angle) * platform.orbitRadius;

    const tangentialVel = {
      x: -Math.sin(platform.angle) * platform.orbitRadius * platform.orbitSpeed,
      y:  Math.cos(platform.angle) * platform.orbitRadius * platform.orbitSpeed
    };

    if(platform.shield){
      if(platform.shield.regenTimer > 0){
        platform.shield.regenTimer = Math.max(0, platform.shield.regenTimer - dt);
      } else {
        platform.shield.val = clamp(platform.shield.val + platform.shield.regenRate * dt, 0, platform.shield.max);
      }
    }

    platform.rail.cd = Math.max(0, platform.rail.cd - dt);
    platform.missile.cd = Math.max(0, platform.missile.cd - dt);

    const distToPlayer = Math.hypot(target.x - platform.x, target.y - platform.y);

    if(platform.rail.cd === 0 && distToPlayer < 2200){
      const lead = leadTarget({ x: platform.x, y: platform.y }, tangentialVel, target, RAIL_SPEED * 0.9);
      const aim = Math.atan2(lead.y - platform.y, lead.x - platform.x);
      const jitter = (Math.random() - 0.5) * platform.rail.scatter;
      const dir = { x: Math.cos(aim + jitter), y: Math.sin(aim + jitter) };
      const muzzle = muzzlePosFor(platform, dir, 14);
      window.bullets.push({
        x:muzzle.x, y:muzzle.y,
        vx: dir.x*(RAIL_SPEED*0.9), vy: dir.y*(RAIL_SPEED*0.9),
        life:2.0, r:4, owner:'npc', damage:platform.rail.damage, type:'rail', penetration:2,
        source: platform, spawnGrace: 0.08
      });
      spawnParticle({x:muzzle.x,y:muzzle.y}, {x:0,y:0}, 0.10, '#bfe7ff', 6, true);
      platform.rail.cd = platform.rail.cdMax;
    }

    if(platform.missile.cd === 0 && distToPlayer < 2600){
      const lead = leadTarget({ x: platform.x, y: platform.y }, tangentialVel, target, SIDE_BULLET_SPEED);
      const aim = Math.atan2(lead.y - platform.y, lead.x - platform.x);
      const dir = {x:Math.cos(aim), y:Math.sin(aim)};
      const muzzleR = muzzlePosFor(platform, dir, 16);
      window.bullets.push({
        x:muzzleR.x, y:muzzleR.y, px:muzzleR.x, py:muzzleR.y,
        vx: dir.x*SIDE_BULLET_SPEED, vy: dir.y*SIDE_BULLET_SPEED,
        life:2.6, r:5, owner:'npc', damage:platform.missile.damage,
        type:'rocket', explodeRadius:SIDE_PLASMA_EXPLODE_RADIUS,
        homingDelay:SIDE_ROCKET_HOMING_DELAY,
        source: platform, spawnGrace: 0.12
      });
      platform.missile.cd = platform.missile.cdMax;
    }
  }
  if(platforms.length){
    mercMission.weaponPlatforms = platforms.filter(p => p && !p.removed);
  }

  if (mercMission.alertStage !== 'engage') return;

  // --- SWARM (Fale wrogów) ---
  const swarm = mercMission.swarm;
  if(!swarm) return;
  if(!swarm.active) return;

  // Liczba żywych piratów
  const alive = npcs.reduce((a,n)=>a + (n.mission && !n.friendly && !n.dead ? 1:0), 0);
  
  swarm.timer -= dt;
  
  // Jeśli mało wrogów i upłynął czas -> spawnuj
  if(swarm.timer <= 0 && alive < swarm.maxAlive){
    // Reset timera (dłuższy odstęp po spawnie fali)
    swarm.timer = 8.0;

    // Pobierz typ z kolejki
    const queued = Array.isArray(swarm.queue) ? swarm.queue.shift() : null;
    const descriptor = (queued && typeof queued === 'object') ? queued : { kind: queued };
    let kind = descriptor.kind || ((Math.random()<0.6)?'fighter_squad':'frigate_pd');
    const spawnPos = descriptor.pos;
    const angleToPlayer = spawnPos
      ? Math.atan2(ship.pos.y - spawnPos.y, ship.pos.x - spawnPos.x)
      : Math.atan2(ship.pos.y - st.y, ship.pos.x - st.x);

    // JEŚLI FIGHTER -> SPAWNUJ CAŁĄ ESKADRĘ (9 sztuk)
    if(kind === 'fighter' || kind === 'interceptor' || kind === 'fighter_squad'){
        const anchor = spawnPos || { x: st.x + Math.cos(angleToPlayer) * (st.r + 240), y: st.y + Math.sin(angleToPlayer) * (st.r + 240) };
        spawnFighterLineSquad(st, anchor, descriptor.right, angleToPlayer);
    }
    // INNE STATKI (pojedynczo, ale z nowym AI)
    else {
        const npc = spawnPirate(kind, st);
        if(spawnPos){
          npc.x = spawnPos.x; npc.y = spawnPos.y;
          npc.formationSlot = { x: descriptor.offset || 0, y: 0 };
          npc.angle = angleToPlayer;
          npc.vx += Math.cos(angleToPlayer) * 20;
          npc.vy += Math.sin(angleToPlayer) * 20;
        }
        npc.forceTarget = ship;
    }

    // Jeśli kolejka pusta, odnów ją
    if(swarm.queue && swarm.queue.length === 0) resetSwarmQueue();
  }
}

// =============== Warp (jak wcześniej) ===============
const warp = {
  state:'idle', // idle | charging | active
  charge:0, chargeTime:0.8,
  orientTolerance: Math.PI/30,
  speed:3800,
  fuelMax:60, fuel:60, consumeRate:1.0, regenRate:5,
  dir:{x:0,y:0},
  turnRate: Math.PI / 5, // maksymalna prędkość skrętu w rad/s podczas warpa
  alignRate: Math.PI / 2.5, // szybkość zgrywania kadłuba do kierunku lotu
  entryProgress:0,
  entryDuration:0.9,
  entryBaseSpeed:0,
  isBusy(){ return this.state!=='idle'; }
};

function exitWarp(){
  spawnShockwave(ship.pos.x, ship.pos.y, { maxR: 1200, maxLife: 0.7 });
  camera.addShake(18, 0.22);
  warp.entryProgress = 0;
}

const boost = {
  state:'idle',
  fuelMax:15, fuel:15,
  regenRate:0.7,
  consumeRate:1.5,
  extraThrustMul:0.8,
  handlingMultiplier:1.35,
  dampingFactor:0.55,
  angularDampingFactor:0.65,
  effectTime:0, effectDuration:0.25, effectDir:{x:0,y:-1}
};

function attemptWarp(){
  if (warp.state === 'idle' && (DevFlags.unlimitedWarp || warp.fuel > 0)) {
    warp.state = 'charging';
    warp.charge = 0;
    return;
  }
  if (warp.state === 'charging') {
    warp.state = 'idle';
    warp.charge = 0;
    return;
  }
  if (warp.state === 'active') {
    warp.state = 'idle';
    exitWarp();
  }
}

function engageWarp(dir){
  const ndir = norm(dir);
  warp.dir.x = ndir.x;
  warp.dir.y = ndir.y;
  ship.angle = Math.atan2(ndir.y, ndir.x) + Math.PI/2;
  ship.angVel = 0;
  warp.state='active';
  warp.entryProgress = 0;
  warp.entryBaseSpeed = Math.hypot(ship.vel.x, ship.vel.y);
  if (DevFlags.unlimitedWarp) {
    warp.fuel = warp.fuelMax;
  }
  spawnParticle({x:ship.pos.x, y:ship.pos.y}, {x:0,y:0}, 0.14, '#bfe7ff', 8, true);
  for(let i=0;i<18;i++){
    const a = Math.random()*Math.PI*2;
    spawnParticle({x:ship.pos.x, y:ship.pos.y}, {x:Math.cos(a)*320, y:Math.sin(a)*320}, 0.18+Math.random()*0.18, '#cce6ff', 1.4, false);
  }
}

// =============== Fizyk ===============
function physicsStep(dt){
  updateCameraTarget(dt);
  updateStationUIState(dt);
  updateInfrastructureEditorState(dt);
  updateInfrastructureState(dt);
  // czas gry
  gameTime = (gameTime + dt * TIME_SCALE) % (24*3600);
  // aktualizacja orbit planet i stacji
  for(const pl of planets){
    pl.angle += pl.speed * dt * TIME_SCALE;
    const R = pl.devOrbitOverrideR ?? pl.orbitRadius ?? pl.orbit?.radius ?? pl.orbitR ?? BASE_ORBIT;
    if ('orbitRadius' in pl) pl.orbitRadius = R;
    if (pl.orbit && 'radius' in pl.orbit) pl.orbit.radius = R;
    if ('orbitR' in pl) pl.orbitR = R;
    pl.x = SUN.x + Math.cos(pl.angle) * R;
    pl.y = SUN.y + Math.sin(pl.angle) * R;
  }
  for(const st of stations){
    if(st.static) continue;
    st.angle += st.speed * dt * TIME_SCALE;
    st.x = st.planet.x + Math.cos(st.angle) * st.orbitRadius;
    st.y = st.planet.y + Math.sin(st.angle) * st.orbitRadius;
  }
  for(const st of stations){
    if(!st.warpGate) continue;
    const off = st.warpGate.offset;
    const ox = off && typeof off.x === 'number' ? off.x : 0;
    const oy = off && typeof off.y === 'number' ? off.y : 0;
    st.warpGate.x = st.x + ox;
    st.warpGate.y = st.y + oy;
  }
  for(const key in warpRoutes){
    const route = warpRoutes[key];
    if(!route) continue;
    const from = route.fromRef;
    const to = route.toRef;
    if(!from || !to) continue;
    const sx = from.warpGate?.x ?? from.x;
    const sy = from.warpGate?.y ?? from.y;
    const ex = to.warpGate?.x ?? to.x;
    const ey = to.warpGate?.y ?? to.y;
    route.start.x = sx;
    route.start.y = sy;
    route.end.x = ex;
    route.end.y = ey;
    const dx = ex - sx;
    const dy = ey - sy;
    const dist = Math.hypot(dx, dy) || 1;
    route.dir.x = dx / dist;
    route.dir.y = dy / dist;
    route.length = dist;
  }
  syncInfrastructureWorldPositions();
  for(const st of stations){
    if(!st.shield) continue;
    if(st.shield.regenTimer > 0){
      st.shield.regenTimer = Math.max(0, st.shield.regenTimer - dt);
    } else {
      st.shield.val = clamp(st.shield.val + st.shield.regenRate * dt, 0, st.shield.max);
    }
  }
  for (const st of stations) {
    if (st.baseR == null) st.baseR = st.r;
    const scale = stationScaleFor(st);
    st.r = (st.baseR || st.r) * scale;
  }
  updateZoneState(dt);
  if (boost.state === 'active' && !isPlanetOrbitZoneId(zoneState.current?.id)) {
    boost.state = 'idle';
  }
  // regen paliwa gdy nie warpuje
  if(warp.state!=='active'){
    warp.fuel = clamp(warp.fuel + warp.regenRate*dt, 0, warp.fuelMax);
    if(DevFlags.unlimitedWarp) warp.fuel = warp.fuelMax;
    warp.entryProgress = 0;
  }
  if (ship.controller === 'ai'){
    const aiControl = runShipAI(ship, dt);
    if (aiControl){
      applyPlayerInput(ship, aiControl, input);
    }
  }
  const boostAllowed = isPlanetOrbitZoneId(zoneState.current?.id);
  let boostActive = boost.state === 'active' && boostAllowed;
  if(boost.state === 'active'){
    boost.fuel = clamp(boost.fuel - boost.consumeRate*dt, 0, boost.fuelMax);
    if(boost.fuel <= 0){
      boost.state = 'idle';
      boostActive = false;
    } else {
      boostActive = true;
    }
  } else {
    boostActive = false;
    if(boost.effectTime <= 0){
      boost.fuel = clamp(boost.fuel + boost.regenRate*dt, 0, boost.fuelMax);
    }
  }
  if(!boostActive && boost.effectTime>0) boost.effectTime = Math.max(0, boost.effectTime - dt);

  // rail queue/cd
  rail.cd[0] = Math.max(0, rail.cd[0]-dt);
  rail.cd[1] = Math.max(0, rail.cd[1]-dt);
  const requiredBarrels = Math.max(1, rail.barrelsPerShot || 2);
  const secondaryReady = requiredBarrels < 2 || rail.cd[1] <= 0;
  if (!stationUI.open && mouse.left  && rail.queue.length===0 && rail.cd[0]<=0 && secondaryReady && !warp.isBusy()) { triggerRailVolley(); }
  for(const q of rail.queue) q.timer -= dt;
  let firedSomething = true;
  while(firedSomething){
    firedSomething = false;
    for(let i=0;i<rail.queue.length;i++){
      const q = rail.queue[i];
      if(q.timer <= 0 && rail.cd[q.barrel] <= 0 && !warp.isBusy()){
        fireRailBarrel(q.barrel);
        rail.queue.splice(i,1);
        firedSomething = true;
        break;
      }
    }
  }
  railTimer = (requiredBarrels > 1) ? Math.min(rail.cd[0], rail.cd[1]) : rail.cd[0];

  ship.special.cooldownTimer = Math.max(0, ship.special.cooldownTimer - dt);
  if(ship.shield.regenTimer > 0) ship.shield.regenTimer -= dt;
  else ship.shield.val = clamp(ship.shield.val + ship.shield.regenRate * dt, 0, ship.shield.max);
  rocketCooldown = Math.max(0, rocketCooldown - dt);
  // mouse world position
  const mouseWorld = screenToWorld(mouse.x, mouse.y);
  const hasMissilesEquipped = (Game.player.weapons?.[HP.MISSILE]?.length || 0) > 0;
  if (!stationUI.open && mouse.right && !warp.isBusy() && hasMissilesEquipped && (rocketAmmoMax === 0 || rocketAmmo > 0) && rocketCooldown<=0) {
    const local = rotateInv({ x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y }, ship.angle);
    const side = (local.x >= 0) ? 'right' : 'left';
    fireRocket(side);
    rocketCooldown = ROCKET_FIRE_INTERVAL;
  }

  // hover scanning
  let hover = null;
  let hoverType = null;
  if(mouse.overCanvas){
    let bestDistSq = Infinity;
    const npcMargin = 20;
    for(const npc of npcs){
      if(npc.dead) continue;
      const radius = (npc.radius || 0) + npcMargin;
      const dx = npc.x - mouseWorld.x;
      const dy = npc.y - mouseWorld.y;
      const distSq = dx*dx + dy*dy;
      if(distSq <= radius*radius && distSq < bestDistSq){
        bestDistSq = distSq;
        hover = npc;
        hoverType = 'npc';
      }
    }
    const stationMargin = 24;
    for(const st of stations){
      const baseR = ((st.r ?? st.baseR) || 120) + stationMargin;
      const dx = st.x - mouseWorld.x;
      const dy = st.y - mouseWorld.y;
      const distSq = dx*dx + dy*dy;
      if(distSq <= baseR*baseR && distSq < bestDistSq){
        bestDistSq = distSq;
        hover = st;
        hoverType = 'station';
      }
    }
    if(mercMission && mercMission.weaponPlatforms){
      const platformMargin = 18;
      for(const platform of mercMission.weaponPlatforms){
        if(!platform || platform.removed) continue;
        const radius = (platform.radius || 0) + platformMargin;
        const dx = platform.x - mouseWorld.x;
        const dy = platform.y - mouseWorld.y;
        const distSq = dx*dx + dy*dy;
        if(distSq <= radius*radius && distSq < bestDistSq){
          bestDistSq = distSq;
          hover = platform;
          hoverType = 'platform';
        }
      }
    }
  }

  if(hover){
    scan.target = hover;
    scan.targetType = hoverType;
    scan.scanned = hover;
    updateHoverInfo(hover, hoverType);
    if(!stationUI.open && mouse.click && hoverType === 'station'){
      openStationUI(hover);
      mouse.click = false;
    }
  } else {
    if(scan.target || scan.scanned || scan.targetType){
      scan.target = null;
      scan.scanned = null;
      scan.targetType = null;
    }
    hideHoverInfo();
  }
  if(lockedTarget && (!isHostileNpc(lockedTarget) || lockedTarget.dead)) lockedTarget = null;
  lockedTargets = lockedTargets.filter(isHostileNpc);
  if(highlightTimer > 0){
    highlightTimer -= dt;
    if(highlightTimer <= 0){ highlightTimer = 0; highlightedEnemies = []; }
  }

  // update radar pings
  for(let i=radarPings.length-1;i>=0;i--){
    const p = radarPings[i];
    p.age += dt; if(p.age>p.life) radarPings.splice(i,1);
  }
  // update scan waves
  for(let i=scanWaves.length-1;i>=0;i--){
    const w = scanWaves[i];
    w.r += w.speed*dt;
    for(const npc of npcs){
      if(npc.dead) continue;
      if(!w.hit.has(npc) && Math.hypot(npc.x-w.x, npc.y-w.y) <= w.r){ w.hit.add(npc); spawnRadarPing(npc.x,npc.y); }
    }
    for(const st of stations){
      if(!w.hit.has(st) && Math.hypot(st.x-w.x, st.y-w.y) <= w.r){ w.hit.add(st); spawnRadarPing(st.x,st.y); }
    }
    if(mercMission && mercMission.weaponPlatforms){
      for(const platform of mercMission.weaponPlatforms){
        if(!platform || platform.destroyed || platform.removed) continue;
        if(!w.hit.has(platform) && Math.hypot(platform.x - w.x, platform.y - w.y) <= w.r){
          w.hit.add(platform);
          spawnRadarPing(platform.x, platform.y);
        }
      }
    }
    if(w.r > w.max) scanWaves.splice(i,1);
  }

  // update scan arrows
  for(let i=scanArrows.length-1;i>=0;i--){
    const a = scanArrows[i];
    if(warp.state !== 'active') a.age += dt;
    if(a.age > a.life) scanArrows.splice(i,1);
  }

  // turret aim (poza warp active)
  if(warp.state!=='active'){
    for(const t of [ship.turret, ship.turret2, ship.turret3, ship.turret4]){
      const off = rotate(t.offset, ship.angle);
      const base = { x: ship.pos.x + off.x, y: ship.pos.y + off.y };
      const aimPos = (lockedTarget && !lockedTarget.dead)
        ? leadTarget(base, ship.vel, lockedTarget, RAIL_SPEED)
        : mouseWorld;
      let diffT = wrapAngle(Math.atan2(aimPos.y - base.y, aimPos.x - base.x) - t.angle);
      let desiredVel = clamp(diffT * 6.5, -t.maxSpeed, t.maxSpeed);
      const velDelta = desiredVel - t.angVel;
      const maxDelta = t.maxAccel * dt;
      t.angVel += clamp(velDelta, -maxDelta, maxDelta);
      t.angVel *= Math.exp(-t.damping * dt);
      t.angVel = clamp(t.angVel, -t.maxSpeed, t.maxSpeed);
      t.angle = wrapAngle(t.angle + t.angVel * dt);
    }
  }
  for(const t of [ship.turret, ship.turret2, ship.turret3, ship.turret4]){
    t.recoil = Math.max(0, t.recoil - t.recoilRecover * dt);
  }

  // siły
  let totalF = {x:0,y:0}, totalTorque = 0;
  const forwardLocal = {x:0, y:-1};

  if(warp.state==='active'){
    const turnInput = clamp(input.torque, -1, 1);
    if(Math.abs(turnInput) > 1e-3){
      const currentAngle = Math.atan2(warp.dir.y, warp.dir.x);
      const maxTurn = warp.turnRate * dt;
      const delta = clamp(turnInput * warp.turnRate * dt, -maxTurn, maxTurn);
      const newAngle = currentAngle + delta;
      warp.dir.x = Math.cos(newAngle);
      warp.dir.y = Math.sin(newAngle);
    }
    const desiredBodyAngle = Math.atan2(warp.dir.y, warp.dir.x) + Math.PI/2;
    const diffBody = wrapAngle(desiredBodyAngle - ship.angle);
    const maxAlign = warp.alignRate * dt;
    ship.angle = wrapAngle(ship.angle + clamp(diffBody, -maxAlign, maxAlign));
    ship.angVel = 0;

    warp.entryProgress = Math.min(1, warp.entryProgress + dt / Math.max(0.001, warp.entryDuration));
    const entryEase = smoothstep01(warp.entryProgress);
    const zoneWarpMul = zoneState.current?.warpMultiplier ?? 1;
    const maxWarpSpeed = warp.speed * zoneWarpMul;
    const entryStartSpeed = Math.min(warp.entryBaseSpeed, maxWarpSpeed);
    const targetSpeed = entryStartSpeed + (maxWarpSpeed - entryStartSpeed) * entryEase;
    const targetV = { x: warp.dir.x*targetSpeed, y: warp.dir.y*targetSpeed };
    ship.vel.x += (targetV.x - ship.vel.x) * clamp(6*dt,0,1);
    ship.vel.y += (targetV.y - ship.vel.y) * clamp(6*dt,0,1);
    if(!DevFlags.unlimitedWarp){
      warp.fuel = Math.max(0, warp.fuel - warp.consumeRate*dt);
      if(warp.fuel<=0){ warp.state='idle'; exitWarp(); }
    } else {
      warp.fuel = warp.fuelMax;
    }
  }
 else if(warp.state==='charging'){
    const dirToMouse = norm({x: mouseWorld.x - ship.pos.x, y: mouseWorld.y - ship.pos.y});
    warp.dir.x = dirToMouse.x;
    warp.dir.y = dirToMouse.y;
    const desiredBodyAngle = Math.atan2(dirToMouse.y, dirToMouse.x) + Math.PI/2;
    const kp = 5.5, maxSpin=2.5, accel=8.0;
    const diffB = wrapAngle(desiredBodyAngle - ship.angle);
    const desiredSpin = clamp(diffB * kp, -maxSpin, maxSpin);
    const delta = clamp(desiredSpin - ship.angVel, -accel*dt, accel*dt);
    ship.angVel += delta;
    if(warp.charge < warp.chargeTime) warp.charge += dt;
    if(warp.charge >= warp.chargeTime && Math.abs(diffB) <= warp.orientTolerance && (DevFlags.unlimitedWarp || warp.fuel>0)){
      engageWarp(dirToMouse);
    }
  }
  else {
    const handlingMul = boostActive ? boost.handlingMultiplier : 1;
    const forwardWorld = rotate(forwardLocal, ship.angle);

    if(boostActive){
      boost.effectTime = boost.effectDuration;
      boost.effectDir = {x: forwardWorld.x, y: forwardWorld.y};
    }

    // GŁÓWNY DUŻY SILNIK — ciąg do przodu
    if(input.main>0){
      const e = ship.engines.main;
      const wo = rotate(e.offset, ship.angle);
      const wf = forwardWorld;
      let thrust = e.maxThrust * input.main;
      if(boostActive){
        thrust *= (1 + boost.extraThrustMul);
      }
      totalF.x += wf.x * thrust; totalF.y += wf.y * thrust;
      totalTorque += (wo.x * (wf.y * thrust) - wo.y * (wf.x * thrust));
    }
    // mały krótki ślad przy poruszaniu (bez gazu)
    const spd = len(ship.vel);
    if(spd > 60){
      const e = ship.engines.main;
      const wo = rotate(e.offset, ship.angle);
      const backDir = norm({x:-ship.vel.x, y:-ship.vel.y});
      spawnParticle({x: ship.pos.x + wo.x, y: ship.pos.y + wo.y},
                    {x: backDir.x*50 + (Math.random()-0.5)*20, y: backDir.y*50 + (Math.random()-0.5)*20},
                    0.18, '#bfe7ff', 1.2, false);
    }

    // boczne i moment
    if(input.leftSide>0){
      const e = ship.engines.sideLeft;
      const thrust = e.maxThrust * input.leftSide * handlingMul;
      const wo = rotate(e.offset, ship.angle);
      const lateral = rotate({x:1,y:0}, ship.angle);
      const worldForce = {x: lateral.x * thrust, y: lateral.y * thrust};
      totalF.x += worldForce.x; totalF.y += worldForce.y;
      totalTorque += (wo.x * worldForce.y - wo.y * worldForce.x);
      spawnParticle(add(ship.pos, wo), add(ship.vel, mul(worldForce,-0.002)), 0.30, '#cfe7ff', 1.0);
    }
    if(input.rightSide>0){
      const e = ship.engines.sideRight;
      const thrust = e.maxThrust * input.rightSide * handlingMul;
      const wo = rotate(e.offset, ship.angle);
      const lateral = rotate({x:-1,y:0}, ship.angle);
      const worldForce = {x: lateral.x * thrust, y: lateral.y * thrust};
      totalF.x += worldForce.x; totalF.y += worldForce.y;
      totalTorque += (wo.x * worldForce.y - wo.y * worldForce.x);
      spawnParticle(add(ship.pos, wo), add(ship.vel, mul(worldForce,-0.002)), 0.30, '#cfe7ff', 1.0);
    }
    if(input.torque !== 0){
      const sign = Math.sign(input.torque);
      const left = ship.engines.torqueLeft; const right = ship.engines.torqueRight;
      const thrust = left.maxThrust * Math.abs(input.torque) * handlingMul;
      const o1 = rotate(left.offset, ship.angle), o2 = rotate(right.offset, ship.angle);
      const lateral1 = rotate({x:1,y:0}, ship.angle), lateral2 = rotate({x:-1,y:0}, ship.angle);
      const f1 = mul(lateral1, thrust * sign), f2 = mul(lateral2, thrust * sign);
      totalF.x += f1.x + f2.x; totalF.y += f1.y + f2.y;
      totalTorque += (o1.x * f1.y - o1.y * f1.x) + (o2.x * f2.y - o2.y * f2.x);
      spawnParticle(add(ship.pos, o1), add(ship.vel, mul(f1,-0.002)), 0.22, '#cfe7ff',1.0);
      spawnParticle(add(ship.pos, o2), add(ship.vel, mul(f2,-0.002)), 0.22, '#cfe7ff',1.0);
    }
  }

  // integracja ruchu
  const ax = totalF.x / ship.mass, ay = totalF.y / ship.mass;
  ship.vel.x += ax*dt; ship.vel.y += ay*dt;
  const linDamp = Math.exp(-ship.linearDamping * (boostActive ? boost.dampingFactor : 1) * dt);
  if(warp.state!=='active'){ ship.vel.x *= linDamp; ship.vel.y *= linDamp; }
  if (boostActive && warp.state !== 'active') {
    const zoneId = zoneState.current?.id;
    const boostCap = (zoneId === 'planet_outer' || zoneId === 'pirate_outer')
      ? warp.speed * 0.4
      : (zoneId === 'planet_inner' || zoneId === 'pirate_inner')
        ? warp.speed * 0.3
        : null;
    if (boostCap) {
      const speed = len(ship.vel);
      if (speed > boostCap) {
        const scale = boostCap / speed;
        ship.vel.x *= scale;
        ship.vel.y *= scale;
      }
    }
  }
  ship.pos.x += ship.vel.x*dt; ship.pos.y += ship.vel.y*dt;

  // granice
  const margin = Math.max(50, getAuToWorldUnits() * WORLD_EDGE_MARGIN_AU);
  ship.pos.x = clamp(ship.pos.x, margin, WORLD.w - margin);
  ship.pos.y = clamp(ship.pos.y, margin, WORLD.h - margin);

  // obrót
  const angAcc = totalTorque / ship.inertia;
  ship.angVel += angAcc*dt;
  ship.angVel *= Math.exp(-ship.angularDamping * (boostActive ? boost.angularDampingFactor : 1) * dt);
  ship.angle += ship.angVel*dt;
  ship.angle = wrapAngle(ship.angle);
  // Aktualizacja logiki eskadr
  SQUADS.forEach(s => s.update());
  updateSupportWing(dt);
  npcStep(dt);
  cleanupCarrierFighters();
  pirateMissionStep(dt);
  ciwsStep(dt);
  bulletsAndCollisionsStep(dt);
  npcShootingStep(dt);
  hudUpdateDMG(dt);
  hudUpdateNav(dt);
}

// ======= Efekty VFX =======
let _engineVFX = null;
let _engineVFXLoading = false;

function getEngineVFX() {
  if (_engineVFX) return _engineVFX;

  if (typeof THREE === "undefined") return null;

  // 1) Upewnij się, że mamy konstruktory efektów
  if (typeof window.createShortNeedleExhaust !== "function") {
    if (!_engineVFXLoading) {
      _engineVFXLoading = true;
      import("./Engineeffects.js").then(mod => {
        window.createShortNeedleExhaust = mod.createShortNeedleExhaust;
        window.createWarpExhaustBlue   = mod.createWarpExhaustBlue;
      }).catch(err => console.warn("Engineeffects.js failed to load", err))
        .finally(() => { _engineVFXLoading = false; });
    }
    return null;
  }

  // 2) Offscreen canvas i scena
  const canvas = document.createElement("canvas");
  // więcej miejsca, żeby ogon nie był ścinany
  canvas.width = 128;
  canvas.height = 256;
  const ctx2d = canvas.getContext("2d");

  const scene = new THREE.Scene();
  scene.background = null;

  const camera = new THREE.OrthographicCamera(-64, 64, 64, -192, -1000, 1000);
  camera.position.z = 10;
  camera.lookAt(0, 0, 0);

  const exhaust = window.createShortNeedleExhaust();
  exhaust.group.position.y = 0; // zero — unikamy clipu przy obrocie
  scene.add(exhaust.group);

  // 3) Renderer: użyj współdzielonego jeśli jest, w przeciwnym razie lokalnego
  let localRenderer = null;
  function pickRenderer(w, h) {
    if (typeof window.getSharedRenderer === "function") {
      const r = window.getSharedRenderer(w, h);
      return r || null;
    }
    if (!localRenderer) {
      localRenderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
        premultipliedAlpha: true,
        preserveDrawingBuffer: true
      });
      localRenderer.setPixelRatio(1);
    }
    // dopasuj rozmiar jeśli się zmienił
    const d = localRenderer.getSize(new THREE.Vector2());
    if (d.x !== w || d.y !== h) localRenderer.setSize(w, h, false);
    return localRenderer;
  }

  function resetRendererForVFX(renderer, width, height) {
    if (!renderer) return;
    if (typeof renderer.setRenderTarget === 'function') renderer.setRenderTarget(null);
    if (typeof renderer.setPixelRatio === 'function') renderer.setPixelRatio(1);
    if (typeof renderer.setSize === 'function') renderer.setSize(width, height, false);
    if (typeof renderer.setViewport === 'function') renderer.setViewport(0, 0, width, height);
    if (renderer.state && typeof renderer.state.reset === 'function') renderer.state.reset();
    if (typeof renderer.setScissorTest === 'function') renderer.setScissorTest(false);
    if (typeof renderer.setClearColor === 'function') renderer.setClearColor(0x000000, 0);
    if (typeof renderer.clear === 'function') renderer.clear(true, true, false);
  }

  _engineVFX = {
    canvas, ctx2d, camera, scene, exhaust,
    render(time, overrides = null) {
      const r = pickRenderer(canvas.width, canvas.height);
      if (!r) return;
      // pełny reset i przezroczyste czyszczenie
      resetRendererForVFX(r, canvas.width, canvas.height);

      // dynamiczny throttle
      const spd = Math.hypot(ship.vel.x, ship.vel.y);
      const moveGlowBase = Math.min(spd / 900, 0.6);
      const thrust = input.main > 0 ? input.main : 0;
      const boostAmpBase = (boost.effectDuration > 0)
        ? clamp(boost.effectTime / boost.effectDuration, 0, 1)
        : 0;
      const warpActiveAmp = (warp.state === 'active') ? smoothstep01(warp.entryProgress) : 0;
      const warpChargeAmp = (warp.state === 'charging')
        ? smoothstep01(Math.min(1, warp.charge/warp.chargeTime)) * 0.6
        : 0;
      const warpAmpBase  = Math.max(warpActiveAmp, warpChargeAmp);
      const moveGlow = (overrides && typeof overrides.moveGlowOverride === 'number')
        ? clamp(overrides.moveGlowOverride, 0, 1)
        : moveGlowBase;
      const throttleBase = Math.max(thrust, moveGlow * 0.8);
      const throttle = (overrides && typeof overrides.throttleOverride === 'number')
        ? clamp(overrides.throttleOverride, 0, 1)
        : throttleBase;
      const boostAmp = (overrides && typeof overrides.boostOverride === 'number')
        ? clamp(overrides.boostOverride, 0, 1)
        : boostAmpBase;
      const warpAmp = (overrides && typeof overrides.warpOverride === 'number')
        ? clamp(overrides.warpOverride, 0, 1)
        : warpAmpBase;

      exhaust.setThrottle(throttle);
      exhaust.setWarpBoost(Math.max(boostAmp, warpAmp));
      // Możesz dopasować temperaturę i bloom z poziomu opcji (D3):
      exhaust.setColorTemp(OPTIONS.vfx.colorTempK);
      exhaust.setBloomGain(OPTIONS.vfx.bloomGain);

      exhaust.update(time);
      r.render(scene, camera);

      // skopiuj do 2D
      ctx2d.clearRect(0, 0, canvas.width, canvas.height);
      ctx2d.drawImage(r.domElement, 0, 0, canvas.width, canvas.height);
    }
  };

  return _engineVFX;
}

// Prosty fallback 2D — żeby ZAWSZE coś było widać, gdy evfx==null
function drawEngineFallback2D() {
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';
  const g = ctx.createLinearGradient(0, 0, 0, 90);
  g.addColorStop(0, 'rgba(170,210,255,0.55)');
  g.addColorStop(1, 'rgba(170,210,255,0)');
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(-14, 0);
  ctx.quadraticCurveTo(0, 70, 14, 0);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawPhotonBeamLocal(alpha){
  const L = 200;
  ctx.save();
  ctx.lineCap = 'round';
  ctx.shadowBlur = 28;
  ctx.shadowColor = `rgba(230,250,255,${0.95 * alpha})`;
  ctx.strokeStyle = `rgba(255,255,255,${0.95 * alpha})`;
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(0, -L * 0.96);
  ctx.stroke();
  ctx.restore();

  const g = ctx.createLinearGradient(0, 0, 0, -L);
  g.addColorStop(0, `rgba(160,210,255,${0.25 * alpha})`);
  g.addColorStop(1, `rgba(160,210,255,0)`);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(-50, 0);
  ctx.quadraticCurveTo(0, -L * 0.5, 0, -L);
  ctx.quadraticCurveTo(0, -L * 0.5, 50, 0);
  ctx.closePath();
  ctx.fill();

  for (let i = 0; i < 4; i++) {
    const phase = ((vfxTime * 0.8) + i * 0.25) % 1;
    const y = -phase * L;
    const r = 20 + 40 * (1 - phase);
    ctx.strokeStyle = `rgba(200,240,255,${(1 - phase) * alpha})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, y, r, 0, Math.PI * 2);
    ctx.stroke();
  }

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.shadowBlur = 19.2;
  ctx.shadowColor = '#fff';
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(0, 0, 12, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function drawWarpChargeEffectLocal(progress, radius, spriteScale){
  if(progress <= 0) return;
  const eased = smoothstep01(progress);
  const baseAlpha = 0.3 + 0.5 * eased;
  const glowR = radius * (0.65 + 0.25 * eased);
  const ringR = radius * (0.9 + 0.35 * eased);
  const lineBase = (6 + 22 * eased) * spriteScale;
  const arcLine = (10 + 18 * eased) * spriteScale;

  ctx.save();
  ctx.globalCompositeOperation = 'lighter';

  const glow = ctx.createRadialGradient(0, 0, glowR * 0.35, 0, 0, glowR);
  glow.addColorStop(0, `rgba(186,232,255,${baseAlpha})`);
  glow.addColorStop(1, 'rgba(125,211,252,0)');
  ctx.fillStyle = glow;
  ctx.beginPath(); ctx.arc(0, 0, glowR, 0, Math.PI * 2); ctx.fill();

  ctx.lineWidth = lineBase;
  ctx.strokeStyle = `rgba(125,211,252,${0.35 + 0.4 * eased})`;
  ctx.beginPath(); ctx.arc(0, 0, ringR, 0, Math.PI * 2); ctx.stroke();

  const segments = 4;
  const arcLen = Math.PI * (0.22 + 0.4 * eased);
  ctx.lineWidth = arcLine;
  ctx.strokeStyle = `rgba(206,244,255,${0.45 + 0.45 * eased})`;
  for(let i=0;i<segments;i++){
    const offset = (vfxTime * 1.4 + i / segments) * Math.PI * 2;
    ctx.beginPath();
    ctx.arc(0, 0, ringR, offset, offset + arcLen);
    ctx.stroke();
  }

  ctx.restore();
}

function drawNeedleEngineVfxLocal(localPos, forward, options = {}) {
  const {
    widthScale = 1.5,
    lengthScale = 1,
    yNudge = -68,
    alpha = 1,
    overrides = null,
    fallback = true
  } = options || {};

  const safeWidth = Math.max(0.0001, widthScale);
  const safeLength = Math.max(0.0001, lengthScale);

  ctx.save();
  ctx.translate(localPos.x, localPos.y);
  ctx.scale(safeWidth, safeLength);
  ctx.rotate(Math.atan2(forward.y, forward.x) + Math.PI/2);
  ctx.globalCompositeOperation = 'lighter';
  const prevAlpha = ctx.globalAlpha;
  ctx.globalAlpha = prevAlpha * alpha;

  const evfx = getEngineVFX();
  if (evfx) {
    evfx.render(vfxTime, overrides);
    const w = evfx.canvas.width, h = evfx.canvas.height;
    ctx.drawImage(evfx.canvas, -w / 2, yNudge / safeLength, w, h);
  } else if (fallback) {
    drawEngineFallback2D();
  }

  ctx.globalAlpha = prevAlpha;
  ctx.restore();
}

function drawBoostBeam(pos, dir, cam, alpha){ const s=worldToScreen(pos.x,pos.y,cam); ctx.save(); ctx.translate(s.x,s.y); ctx.scale(camera.zoom,camera.zoom); ctx.rotate(Math.atan2(-dir.x, dir.y)); ctx.globalCompositeOperation='lighter'; drawPhotonBeamLocal(alpha); ctx.restore(); }

// =============== Main loop ===============
let lastTime = performance.now();
const PHYS_DT = 1/120;
let acc = 0;
let vfxTime = 0;
let prevState = null;
let firstFrameResolver = null;
function saveState(){ prevState = { pos:{...ship.pos}, angle: ship.angle, turretAngle: ship.turret.angle, turretAngle2: ship.turret2.angle, turretAngle3: ship.turret3.angle, turretAngle4: ship.turret4.angle, ciwsAngles: ship.ciws.map(c=>c.angle) }; }
saveState();
function loop(now){
  const frame = Math.min(0.033, (now - lastTime)/1000);
  lastTime = now;
  applyGamepad();
  if(PAUSED){ requestAnimationFrame(loop); return; }
  acc += frame;
  vfxTime += frame;
  saveState();
  let steps = 0;
  while(acc >= PHYS_DT && steps < 10){
    physicsStep(PHYS_DT);
    acc -= PHYS_DT; steps++;
  }
  const alpha = acc / PHYS_DT;
  frameId++;
  missionCompleteBanner.update(frame);
  // Shockwaves
  for(let i=shockwaves.length-1;i>=0;i--){
    const s = shockwaves[i];
    s.life += frame;
    const k = Math.min(1, s.life/s.maxLife);
    s.r = s.maxR * k;
    s.w = Math.max(1, (1-k) * (s.maxR*0.06));
    if(s.life >= s.maxLife) shockwaves.splice(i,1);
  }
  if(camera.shakeTime > 0){
    camera.shakeTime -= frame;
    if(camera.shakeTime <= 0) camera.shakeMag = 0;
  }
  zoomIndicator.update(frame);
  render(alpha, frame);
  if (overlay3D) {
    overlay3D.tick(frame);
  }
  if (firstFrameResolver) {
    firstFrameResolver();
    firstFrameResolver = null;
  }
  requestAnimationFrame(loop);
}

// =============== Render ===============
function worldToScreen(wx,wy,cam){ return { x: (wx - cam.x)*camera.zoom + W/2, y: (wy - cam.y)*camera.zoom + H/2 }; }

function stationPortWorld(st, idx){
  const off = st.ports[idx % st.ports.length];
  return { x: st.x + off.x, y: st.y + off.y };
}

function glowCircle(ctx, x, y, r, color){
  ctx.save();
  ctx.shadowColor = color;
  ctx.shadowBlur = r*0.5;
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawSunWithCorona(ctx, cam, t) {
  const s = worldToScreen(SUN.x, SUN.y, cam);
  const R = SUN.r * camera.zoom;

  ctx.save();
  ctx.translate(s.x, s.y);

  // --- miękka poświata daleko w tle (nebula-like) ---
  ctx.globalCompositeOperation = 'lighter';
  const hazeR = R * SUN.corona.haze;
  const gH = ctx.createRadialGradient(0,0, R*0.6, 0,0, hazeR);
  gH.addColorStop(0, 'rgba(255,220,120,0.25)');
  gH.addColorStop(1, 'rgba(50,80,140,0.00)');
  ctx.fillStyle = gH;
  ctx.beginPath(); ctx.arc(0,0,hazeR,0,Math.PI*2); ctx.fill();

  // --- korona: promieniste igły z lekkim szumem i pulsem ---
  const rays = SUN.corona.rays | 0;
  const baseLen = R * (1.0 + SUN.corona.length);
  const pulse = 1 + SUN.corona.pulse * Math.sin(t*1.6);
  const jitterAmp = SUN.corona.jitter;

  // deterministyczny „szum” bez biblioteki
  function n1(i, k=1) {
    const x = Math.sin((i*374761.0 + SUN.seed*1.123 + k)*0.0000131) * 43758.5453;
    return x - Math.floor(x);
  }

  ctx.beginPath();
  for (let i=0;i<rays;i++){
    const a = (i / rays) * Math.PI*2;
    const w = (Math.PI*2 / rays) * (0.6 + n1(i,2)*0.6);  // szerokość klina
    const j = (n1(i) - 0.5) * 2 * jitterAmp;
    const len = baseLen * (0.82 + 0.18*n1(i,3)) * pulse;
    const r1 = R * (1.02 + 0.03*n1(i,4));
    const r2 = len * (1 + j);

    const aL = a - w*0.5, aR = a + w*0.5;
    // mały klin (trójkąt) – od krawędzi tarczy na zewnątrz
    ctx.moveTo(Math.cos(aL)*r1, Math.sin(aL)*r1);
    ctx.lineTo(Math.cos(a)*r2,  Math.sin(a)*r2);
    ctx.lineTo(Math.cos(aR)*r1, Math.sin(aR)*r1);
  }
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,210,120,0.25)';
  ctx.shadowColor = 'rgba(255,235,170,0.9)';
  ctx.shadowBlur = Math.max(6, R*0.22);
  ctx.fill();

  // --- obwód korony (fresnel) ---
  const fresR = R * (1.2 + 0.06*Math.sin(t*1.1));
  const gF = ctx.createRadialGradient(0,0, fresR*0.7, 0,0, fresR);
  gF.addColorStop(0, 'rgba(255,240,180,0)');
  gF.addColorStop(1, 'rgba(255,235,170,0.32)');
  ctx.fillStyle = gF;
  ctx.beginPath(); ctx.arc(0,0, fresR, 0, Math.PI*2); ctx.fill();

  // --- tarcza gwiazdy (żółta z „rimem”) ---
  const g = ctx.createRadialGradient(0,0, R*0.1, 0,0, R);
  g.addColorStop(0, SUN.color.core);
  g.addColorStop(0.55, SUN.color.mid);
  g.addColorStop(1, SUN.color.rim);
  ctx.globalCompositeOperation = 'source-over';
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(0,0,R,0,Math.PI*2); ctx.fill();

  // delikatne „plamy” (granulacja) — kilka półprzezroczystych kół
  ctx.globalCompositeOperation = 'multiply';
  ctx.fillStyle = 'rgba(200,90,0,0.06)';
  for(let i=0;i<8;i++){
    const a = (i*0.79 + t*0.15) % (Math.PI*2);
    const rr = R*(0.12 + 0.15*n1(i,5));
    const d  = R*(0.15 + 0.55*n1(i,6));
    ctx.beginPath();
    ctx.arc(Math.cos(a)*d, Math.sin(a)*d, rr, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.restore();
}

function drawStationShadow(ctx, st, cam){
  const s = worldToScreen(st.x, st.y, cam);
  const toSun = { x: (SUN.x - st.x), y: (SUN.y - st.y) };
  const ang = Math.atan2(toSun.y, toSun.x) + Math.PI; // cień „od” Słońca
  const scale = stationScaleFor(st);
  const base = (st.baseR || st.r || 120) * scale;
  const off  = base * 1.2 * cam.zoom;
  const w = base * 1.6 * cam.zoom;
  const h = base * 0.7 * cam.zoom;

  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.rotate(ang);
  const g = ctx.createRadialGradient(off, 0, 0, off, 0, w);
  g.addColorStop(0.00, 'rgba(0,0,0,0.35)');
  g.addColorStop(1.00, 'rgba(0,0,0,0.00)');
  ctx.globalCompositeOperation = 'multiply';
  ctx.beginPath();
  ctx.ellipse(off, 0, w, h, 0, 0, Math.PI*2);
  ctx.fillStyle = g;
  ctx.fill();
  ctx.restore();
}

function drawStationVFX(ctx, st, x, y, r, t){
  ctx.save();
  ctx.translate(x, y);
  switch(st.style){
    case 'ringGate':
      ctx.strokeStyle = '#273447';
      ctx.lineWidth = Math.max(1, r*0.2);
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
      ctx.save(); ctx.rotate(t*0.6);
      for(let i=0;i<6;i++){ ctx.rotate(Math.PI/3); glowCircle(ctx, r*0.6, 0, r*0.12, '#6dd6ff'); }
      ctx.restore();
      glowCircle(ctx,0,0,r*0.3,'#6dd6ff');
      break;
    case 'hexHub':
      ctx.strokeStyle = '#273447';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<6;i++){ const a=i*Math.PI/3; const px=Math.cos(a)*r*0.6; const py=Math.sin(a)*r*0.6; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); }
      ctx.closePath(); ctx.stroke();
      break;
    case 'triRing':
      ctx.strokeStyle = '#273447'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(0,0,r*0.9,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,r*0.6,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(0,0,r*0.3,0,Math.PI*2); ctx.stroke();
      break;
    case 'solarPetals':
      ctx.save(); ctx.rotate(t*0.5);
      for(let i=0;i<8;i++){ ctx.rotate(Math.PI/4); ctx.fillStyle='#274a7d'; ctx.fillRect(r*0.3,-r*0.1,r*0.4,r*0.2); }
      ctx.restore();
      glowCircle(ctx,0,0,r*0.25,'#8fd0ff');
      break;
    case 'shipyard':
      ctx.save();
      for(let i=0;i<4;i++){ ctx.rotate(Math.PI/2); ctx.fillStyle='#344a74'; ctx.fillRect(r*0.2,-r*0.05,r*0.8,r*0.1); }
      ctx.restore();
      break;
    case 'tradeSpindle':
      ctx.fillStyle='#3b517d'; ctx.fillRect(-r*0.1,-r,r*0.2,r*2);
      for(let i=-3;i<=3;i++){ ctx.fillStyle='#6ea0ff'; ctx.fillRect(r*0.3, i*r*0.2 - r*0.05, r*0.3, r*0.1); ctx.fillRect(-r*0.6, i*r*0.2 - r*0.05, r*0.3, r*0.1); }
      break;
    default:
      ctx.fillStyle = '#273447';
      ctx.beginPath(); ctx.arc(0,0,r*0.6,0,Math.PI*2); ctx.fill();
      break;
  }

  if(st.shield && st.shield.val > 0){
    const frac = clamp(st.shield.val / st.shield.max, 0, 1);
    const pulse = (Math.sin(t * 1.6) + 1) * 0.5;
    const shieldR = r * (1.18 + 0.04 * pulse);
    const fresnel = ctx.createRadialGradient(0, 0, shieldR * 0.72, 0, 0, shieldR);
    fresnel.addColorStop(0, 'rgba(120,200,255,0)');
    fresnel.addColorStop(1, `rgba(120,200,255,${0.22 + 0.25 * frac})`);
    ctx.save();
    ctx.fillStyle = fresnel;
    ctx.globalAlpha = 0.45 + 0.25 * pulse * frac;
    ctx.beginPath(); ctx.arc(0,0, shieldR, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
    ctx.lineWidth = Math.max(3, r * 0.08);
    ctx.strokeStyle = `rgba(120,200,255,${0.32 + 0.4 * frac})`;
    ctx.beginPath(); ctx.arc(0,0, shieldR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  ctx.restore();
  ctx.strokeStyle = 'rgba(175,210,255,0.12)';
  ctx.lineWidth = Math.max(1, 2);
  ctx.beginPath(); ctx.arc(x, y, r*1.05, 0, Math.PI*2); ctx.stroke();
}

function drawPlanetLabels(ctx, cam){
  ctx.save();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  const fontSize = Math.round(clamp(18 * camera.zoom, 12, 30));
  ctx.font = `600 ${fontSize}px Inter,system-ui,monospace`;
  ctx.lineJoin = 'round';
  for(const pl of planets){
    if(!pl || !pl.label) continue;
    const screen = worldToScreen(pl.x, pl.y, cam);
    if(screen.x < -160 || screen.x > W + 160 || screen.y < -160 || screen.y > H + 160) continue;
    const offset = ((pl.r || 0) + 40) * camera.zoom;
    const y = screen.y - offset;
    ctx.save();
    ctx.shadowColor = 'rgba(12, 22, 42, 0.7)';
    ctx.shadowBlur = fontSize * 0.4;
    ctx.lineWidth = Math.max(2, fontSize * 0.18);
    ctx.strokeStyle = 'rgba(10, 20, 36, 0.85)';
    ctx.fillStyle = 'rgba(223, 231, 255, 0.95)';
    ctx.strokeText(pl.label, screen.x, y);
    ctx.fillText(pl.label, screen.x, y);
    ctx.restore();
  }
  ctx.restore();
}

function drawStars(cam){
  // jak daleko poza ekran ładować komórki
  const zoom = cam?.zoom ?? camera.zoom ?? 1;
  const marginW = (W/2)/zoom + 2000;
  const marginH = (H/2)/zoom + 2000;
  const minX = Math.floor((cam.x - marginW)/STAR_CELL);
  const maxX = Math.floor((cam.x + marginW)/STAR_CELL);
  const minY = Math.floor((cam.y - marginH)/STAR_CELL);
  const maxY = Math.floor((cam.y + marginH)/STAR_CELL);

  for(let iy=minY; iy<=maxY; iy++){
    for(let ix=minX; ix<=maxX; ix++){
      const cell = getCell(ix,iy);
      for(const s of cell.stars){
        const sx = (s.x - cam.x) * zoom + W/2;
        const sy = (s.y - cam.y) * zoom + H/2;
        if(sx < -50 || sx > W+50 || sy < -50 || sy > H+50) continue;

        if(warp.state==='active'){
          // Smugi przy warp
          const entry = smoothstep01(warp.entryProgress);
          const L = 24 * (0.25 + 0.75*entry) * (1 + 1.2*(warp.fuel/warp.fuelMax));
          const dx = -warp.dir.x * L * zoom;
          const dy = -warp.dir.y * L * zoom;
          ctx.strokeStyle = 'rgba(200,220,255,0.35)';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.moveTo(sx+dx, sy+dy); ctx.lineTo(sx, sy); ctx.stroke();
        } else {
          ctx.globalAlpha = s.bright;
          ctx.fillStyle = '#ffffff';
          const flicker = 0.8 + 0.2 * Math.random();
          const baseSize = s.size * flicker * zoom;
          const minSize = 0.6 * zoom;
          const sz = Math.max(minSize, baseSize);
          const drawSize = Math.max(1, Math.ceil(sz));
          ctx.fillRect(Math.round(sx), Math.round(sy), drawSize, drawSize);
          ctx.globalAlpha = 1;
        }
      }
    }
  }
  pruneStarCells();
}

function drawRangeRuler(ctx, cam){
  if (!DevFlags.showRuler) return;

  const cx = W / 2;
  const cy = H / 2;
  const zoom = cam?.zoom ?? camera.zoom ?? 1;

  ctx.save();
  ctx.globalAlpha = 0.5;
  ctx.lineWidth = 1;
  ctx.strokeStyle = '#6db6ff';

  const step = 500;
  const maxWorldR = Math.min(W, H) / zoom * 0.5 * 0.95;

  for (let r = step; r < maxWorldR; r += step) {
    const rr = r * zoom;
    ctx.beginPath();
    ctx.arc(cx, cy, rr, 0, Math.PI * 2);
    ctx.stroke();

    if (r % 1000 === 0) {
      ctx.fillStyle = '#cfe6ff';
      ctx.font = '11px monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${r}`, cx + rr + 4, cy);
    }
  }

  ctx.globalAlpha = 0.25;
  const axisR = maxWorldR * zoom;
  ctx.beginPath(); ctx.moveTo(cx - axisR, cy); ctx.lineTo(cx + axisR, cy); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx, cy - axisR); ctx.lineTo(cx, cy + axisR); ctx.stroke();

  ctx.restore();
}

function drawFrigateHull(ctx, npc, screenPos){
  const w = (npc.size?.w || npc.radius*2.2) * (camera.zoom || 1);
  const h = (npc.size?.h || npc.radius*0.9) * (camera.zoom || 1);
  ctx.save();
  ctx.globalAlpha = npc.fade ?? 1;
  ctx.translate(screenPos.x, screenPos.y);
  ctx.rotate(npc.angle || 0);
  ctx.fillStyle = npc.subType === 'laser' ? '#3c2d54' : '#284b36';
  ctx.strokeStyle = npc.friendly ? '#7cff91' : '#ff5c7c';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.rect(-w*0.5,-h*0.5,w,h);
  ctx.fill(); ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(0,0); ctx.lineTo(w*0.6,0);
  ctx.stroke();
  if(npc.subType==='laser'){
    ctx.strokeStyle='#f0f';
    ctx.beginPath();
    ctx.moveTo(w*0.1,-h*0.25); ctx.lineTo(w*0.5,-h*0.25);
    ctx.moveTo(w*0.1,h*0.25);  ctx.lineTo(w*0.5,h*0.25);
    ctx.stroke();
  }
  ctx.restore();
}

function drawDestroyer(ctx, npc, screenPos){
  const w = (npc.size?.w || 86) * camera.zoom;
  const h = (npc.size?.h || 26) * camera.zoom;
  ctx.save();
  ctx.translate(screenPos.x, screenPos.y);
  ctx.rotate(npc.angle);
  ctx.fillStyle = '#563c2c'; // Brązowy (Pirat)
  ctx.strokeStyle = '#ff5c7c';
  ctx.lineWidth = 2;
  
  // Kadłub
  ctx.beginPath();
  ctx.rect(-w*0.5, -h*0.5, w*0.8, h); 
  ctx.fill(); ctx.stroke();
  
  // Nadbudówka
  ctx.fillStyle = '#6e4d3d';
  ctx.beginPath();
  ctx.moveTo(w*0.1, -h*0.3); 
  ctx.lineTo(w*0.4, 0); 
  ctx.lineTo(w*0.1, h*0.3);
  ctx.fill();
  
  ctx.restore();
}

function drawBattleship(ctx, npc, screenPos){
  const w = (npc.size?.w || 140) * camera.zoom;
  const h = (npc.size?.h || 50) * camera.zoom;
  ctx.save();
  ctx.translate(screenPos.x, screenPos.y);
  ctx.rotate(npc.angle);
  ctx.fillStyle = '#462c1c'; // Ciemny brąz
  ctx.strokeStyle = '#ff5c7c'; // Czerwony obrys
  ctx.lineWidth = 3;

  // Główny kadłub (agresywny kształt)
  ctx.beginPath();
  ctx.moveTo(w*0.5, 0); 
  ctx.lineTo(w*0.3, h*0.5); 
  ctx.lineTo(-w*0.5, h*0.5);
  ctx.lineTo(-w*0.4, 0); 
  ctx.lineTo(-w*0.5, -h*0.5); 
  ctx.lineTo(w*0.3, -h*0.5);
  ctx.closePath();
  ctx.fill(); ctx.stroke();

  // Wieżyczki boczne (symboliczne)
  ctx.fillStyle = '#ff9b4b'; // Pomarańczowe
  ctx.fillRect(-w*0.2, -h*0.6, w*0.1, h*0.2); // Lewa burta
  ctx.fillRect(-w*0.2, h*0.4, w*0.1, h*0.2);  // Prawa burta

  ctx.restore();
}





  
function drawCapitalShipSprite(ctx, npc, screenPos, pixR){
  const profile = npc.capitalProfile || {};
  const lengthScale = Number.isFinite(profile.lengthScale) ? profile.lengthScale : 3.2;
  const widthScale = Number.isFinite(profile.widthScale) ? profile.widthScale : 1.2;
  const length = Math.max(60, pixR * lengthScale);
  const width = Math.max(30, pixR * widthScale);
  const dims = { length, width, halfL: length * 0.5, halfW: width * 0.5 };
  const hullColor = profile.hullColor || (npc.friendly ? '#5477bf' : '#c85a5a');
  const deckColor = profile.deckColor || '#1f2a46';
  const accentColor = profile.accentColor || '#9dc5ff';
  const engineColor = profile.engineColor || 'rgba(130,200,255,0.85)';
  const hangarGlow = profile.hangarGlow || 'rgba(160,200,255,0.35)';
  const spriteInfo = npc.capitalSprite || (profile.spriteSrc ? getCapitalShipSprite(profile.spriteSrc) : null);
  if (!npc.capitalSprite && spriteInfo) {
    npc.capitalSprite = spriteInfo;
  }
  const useSprite = !!(spriteInfo && spriteInfo.ready && !spriteInfo.error);

  ctx.save();
  ctx.globalAlpha = npc.fade ?? 1;
  ctx.translate(screenPos.x, screenPos.y);
  const spriteRotation = Number.isFinite(profile.spriteRotation) ? profile.spriteRotation : 0;
  ctx.rotate((npc.angle || 0) + spriteRotation);

  const halfL = length * 0.5;
  const halfW = width * 0.5;
  const radius = Math.max(width * 0.18, 18 * camera.zoom);
  let drawHullPath = null;

  if (useSprite) {
    const img = spriteInfo.image;
    const spriteScale = Number.isFinite(profile.spriteScale) ? profile.spriteScale : 1;
    const naturalW = spriteInfo.width || img.naturalWidth || 1;
    const naturalH = spriteInfo.height || img.naturalHeight || 1;
    const rawRotation = Number.isFinite(profile.spriteRotation) ? profile.spriteRotation : 0;
    const halfPi = Math.PI / 2;
    const approxSteps = Math.round(rawRotation / halfPi);
    const alignedToStep = Math.abs(rawRotation - approxSteps * halfPi) < 0.0001;
    const usesHeightForLength = alignedToStep && (Math.abs(approxSteps) % 2 === 1);
    const targetLength = length * spriteScale;
    const targetWidth = width * spriteScale;

    let scale;
    if (usesHeightForLength){
      scale = targetLength / Math.max(1, naturalH);
    } else {
      scale = targetLength / Math.max(1, naturalW);
    }
    let drawW = naturalW * scale;
    let drawH = naturalH * scale;

    if (targetWidth > 0){
      const crossSize = usesHeightForLength ? drawW : drawH;
      if (crossSize > targetWidth){
        const adjust = targetWidth / crossSize;
        drawW *= adjust;
        drawH *= adjust;
      }
    }

    const offset = profile.spriteOffset || { x: 0, y: 0 };
    ctx.drawImage(img, -drawW * 0.5 + offset.x, -drawH * 0.5 + offset.y, drawW, drawH);
  } else {
    ctx.fillStyle = hullColor;
    drawHullPath = () => {
      roundRect(ctx, -halfL, -halfW, length, width, radius);
    };
    drawHullPath();
    ctx.fill();

    ctx.fillStyle = deckColor;
    roundRect(ctx, -halfL * 0.78, -halfW * 0.55, length * 0.82, width * 0.58, radius * 0.7);
    ctx.fill();

    ctx.fillStyle = hangarGlow;
    roundRect(ctx, -length * 0.18, -halfW * 0.45, length * 0.36, width * 0.9, width * 0.18);
    ctx.fill();

    ctx.fillStyle = accentColor;
    ctx.fillRect(-halfL * 0.2, -halfW * 0.05, length * 0.4, width * 0.1);

  }

  const engineOffsets = Array.isArray(profile.engineOffsets) ? profile.engineOffsets : null;
  if (engineOffsets && engineOffsets.length){
    const speed = Math.hypot(npc.vx || 0, npc.vy || 0);
    const thrust = clamp(speed / Math.max(1, npc.maxSpeed || 1), 0, 1);
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.globalAlpha = 0.45 + thrust * 0.4;
    ctx.fillStyle = engineColor;
    const glowSize = profile.engineGlowSize || 0.26;
    for (const offset of engineOffsets){
      const local = capitalLocalFromNormalized(offset, dims);
      ctx.beginPath();
      ctx.ellipse(local.x, local.y, width * glowSize * 0.45, width * glowSize * 0.75, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  const shield = npc.shield;
  if (shield && shield.max > 0 && shield.val > 0){
    const shieldPct = clamp(shield.val / shield.max, 0, 1);
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.2 + shieldPct * 0.25;
    ctx.strokeStyle = `rgba(110,190,255,${0.35 + shieldPct * 0.4})`;
    ctx.lineWidth = Math.max(2, width * 0.12);
    ctx.beginPath();
    ctx.ellipse(0, 0, halfL * 1.12, halfW * 1.18, 0, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }

  if (npc.hitFlash > 0){
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = clamp(npc.hitFlash * 6, 0, 1);
    ctx.fillStyle = 'rgba(255,190,150,0.8)';
    if (drawHullPath){
      drawHullPath();
      ctx.fill();
    } else {
      ctx.fillRect(-halfL, -halfW, halfL * 2, halfW * 2);
    }
    ctx.restore();
  }

  ctx.restore();
}
// === DODAJ TĘ FUNKCJĘ DO KODU ===
function drawNPCPretty(ctx, npc, s) {
  // 1. Jeśli to duży statek (Capital Ship) używający sprite'a
  if (npc.isCapitalShip) {
    const pixR = (npc.radius || 20) * camera.zoom;
    drawCapitalShipSprite(ctx, npc, s, pixR);
    return;
  }

  // 2. Specjalne typy statków (rysowane proceduralnie)
  if (npc.type === 'destroyer') {
    drawDestroyer(ctx, npc, s);
    return;
  }
  if (npc.type === 'battleship') {
    drawBattleship(ctx, npc, s);
    return;
  }
  if (npc.type && (npc.type.includes('frigate') || npc.subType === 'laser')) {
    drawFrigateHull(ctx, npc, s);
    return;
  }

  // 3. Domyślny rysunek dla myśliwców (Fighter/Interceptor)
  const zoom = camera.zoom;
  ctx.save();
  ctx.translate(s.x, s.y);
  ctx.rotate(npc.angle);
  
  // Kolor zależny od nastawienia
  ctx.fillStyle = npc.color || (npc.friendly ? '#7cff91' : '#ff5c7c');
  
  // Rysowanie trójkąta (myśliwiec)
  const size = (npc.radius || 12) * zoom;
  ctx.beginPath();
  ctx.moveTo(size, 0);
  ctx.lineTo(-size * 0.6, size * 0.7);
  ctx.lineTo(-size * 0.3, 0);
  ctx.lineTo(-size * 0.6, -size * 0.7);
  ctx.closePath();
  ctx.fill();
  
  // Obrys
  ctx.lineWidth = 1.5;
  ctx.strokeStyle = 'rgba(0,0,0,0.4)';
  ctx.stroke();

  // Pasek HP nad jednostką (opcjonalnie, jeśli blisko kursora lub uszkodzony)
  if (npc.hp < npc.maxHp) {
    const hpPct = Math.max(0, npc.hp / npc.maxHp);
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(-size, -size - 6, size * 2, 3);
    ctx.fillStyle = '#22c55e';
    ctx.fillRect(-size, -size - 6, size * 2 * hpPct, 3);
  }

  // Tarcza (jeśli aktywna)
  if (npc.shield && npc.shield.val > 0) {
    const shieldPct = npc.shield.val / npc.shield.max;
    ctx.strokeStyle = `rgba(100, 200, 255, ${shieldPct * 0.6})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, size * 1.2, 0, Math.PI * 2);
    ctx.stroke();
  }

  ctx.restore();
}
function render(alpha, frameDt){
  canvas.style.cursor = 'default';
  //  cheats (np. nielimitowany warp)
  if (window.ApplyCheats) ApplyCheats();
  // Interpolacja stanu
  const interpPos = {
    x: prevState.pos.x + (ship.pos.x - prevState.pos.x) * alpha,
    y: prevState.pos.y + (ship.pos.y - prevState.pos.y) * alpha
  };
  const interpAngle = interpAngleShort(prevState.angle, ship.angle, alpha);
  const interpTurretAngle = interpAngleShort(prevState.turretAngle, ship.turret.angle, alpha);
  const interpTurretAngle2 = interpAngleShort(prevState.turretAngle2, ship.turret2.angle, alpha);
  const interpTurretAngle3 = interpAngleShort(prevState.turretAngle3, ship.turret3.angle, alpha);
  const interpTurretAngle4 = interpAngleShort(prevState.turretAngle4, ship.turret4.angle, alpha);
  const interpCIWSAngles = ship.ciws.map((c,i)=>interpAngleShort(prevState.ciwsAngles[i], c.angle, alpha));

  // Kamera
  if(camera.mode === 'ship'){
    camera.x = interpPos.x;
    camera.y = interpPos.y;
  } else if(camera.mode === 'focus'){
    const st = camera.focusStation;
    if(st){
      camera.x = st.x;
      camera.y = st.y;
    } else {
      camera.clearFocus();
      camera.x = interpPos.x;
      camera.y = interpPos.y;
    }
  } else if(camera.mode === 'infrastructure'){
    const st = camera.focusStation;
    if(!st){
      camera.clearFocus();
      camera.x = interpPos.x;
      camera.y = interpPos.y;
    }
  }
  const cam = { x: camera.x, y: camera.y, zoom: camera.zoom };
  if(!DevFlags.disableCameraShake && camera.shakeMag > 0){
    const t = camera.shakeTime / camera.shakeDur;
    const mag = camera.shakeMag * Math.max(0, t);
    cam.x += (Math.random()*2 - 1) * mag;
    cam.y += (Math.random()*2 - 1) * mag;
  }

  overlayView.center.x = cam.x;
  overlayView.center.y = cam.y;
  overlayView.viewport.w = W;
  overlayView.viewport.h = H;
  overlayView.zoom = cam.zoom;

  // aktualizuj wyświetlanie czasu
  gameTimeEl.textContent = formatGameTime(gameTime);
  updateFleetUI();
  updatePlanetRadar(ship, cam);

  // Czyścimy ekran
  ctx.clearRect(0,0,W,H);
  spaceBg?.drawSpaceBg?.(ctx, cam);
  if (warpBlackHoleFX) {
    configureWarpLensSource();
  }
  ensurePlanetStationsInit(stations);
  if (window.updatePlanets3D) updatePlanets3D(frameDt);
  // najpierw zaktualizuj pozycje stacji 3D...
  if (window.updateStations3D) window.updateStations3D(stations);
  // ...a potem wyrenderuj overlay sceny 3D
  if (window.updateWorld3D) updateWorld3D(frameDt, vfxTime);

  // Gwiazdy (proceduralne kafelki na całej mapie)
  drawStars(cam);

  // ★ SŁOŃCE Z KORONĄ
  drawSunWithCorona(ctx, cam, vfxTime);

  // scan waves
  for(const w of scanWaves){
    const s = worldToScreen(w.x, w.y, cam);
    ctx.strokeStyle = 'rgba(120,200,255,0.18)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, w.r * camera.zoom, 0, Math.PI*2); ctx.stroke();
  }

  ctx.globalCompositeOperation = 'source-over';
  ctx.imageSmoothingEnabled = true;
  if (window.drawPlanets3D)   drawPlanets3D(ctx, cam);      // planety
  if (window.drawStations3D)  drawStations3D(ctx, cam, worldToScreen); // STACJE 3D NAD PLANETAMI (sprite per-stacja)
  if (window.drawWorld3D)     drawWorld3D(ctx, cam, worldToScreen); // np. piracka stacja (spotlight)
  if(stationUI.editorMode && stationUI.station){
    const infraState = ensureInfrastructureState(stationUI.station);
    if(infraState) drawInfrastructureGrid(ctx, cam, stationUI.station, infraState);
  }
  drawInfrastructureInstances(ctx, cam);
  drawPlanetLabels(ctx, cam);
  drawRangeRuler(ctx, cam);
  if (window.drawSunDirection) drawSunDirection(ctx, cam);

  // Warp gates
  for(const key in warpRoutes){
    const route = warpRoutes[key];
    const perp = { x: -route.dir.y, y: route.dir.x };
    const w = 6*camera.zoom;
    const s1 = worldToScreen(route.start.x, route.start.y, cam);
    const s2 = worldToScreen(route.end.x, route.end.y, cam);
    ctx.strokeStyle = '#88aaff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(s1.x - perp.x*w, s1.y - perp.y*w);
    ctx.lineTo(s1.x + perp.x*w, s1.y + perp.y*w);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(s2.x - perp.x*w, s2.y - perp.y*w);
    ctx.lineTo(s2.x + perp.x*w, s2.y + perp.y*w);
    ctx.stroke();
  }

  // Shockwaves (na warstwie świata, pod HUD)
  for(const s of shockwaves){
    const sw = worldToScreen(s.x, s.y, cam);
    ctx.beginPath();
    ctx.lineWidth = s.w * camera.zoom;
    ctx.strokeStyle = s.color + (1 - s.life/s.maxLife) + ')';
    ctx.arc(sw.x, sw.y, s.r * camera.zoom, 0, Math.PI*2);
    ctx.stroke();
  }

  if (!window.USE_STATION_3D) {
    for (const st of stations){
      const s = worldToScreen(st.x, st.y, cam);
      const visR = (st.baseR || st.r) * stationScaleFor(st);
      const rr = visR * camera.zoom;

      drawStationShadow(ctx, st, cam);
      drawStationVFX(ctx, st, s.x, s.y, rr, gameTime);

      for (let i=0;i<st.ports.length;i++){
        const pw = stationPortWorld(st, i);
        const ps = worldToScreen(pw.x, pw.y, cam);
        ctx.fillStyle = '#60a5fa';
        ctx.beginPath(); ctx.arc(ps.x, ps.y, 4*camera.zoom, 0, Math.PI*2); ctx.fill();
      }
      ctx.fillStyle = '#dfe7ff'; ctx.font = `${12*camera.zoom}px monospace`;
      ctx.fillText('ST'+st.id, s.x - rr*0.35, s.y + 4*camera.zoom);
    }
  }

  if(mercMission && mercMission.weaponPlatforms){
    for(const platform of mercMission.weaponPlatforms){
      if(!platform || platform.removed) continue;
      const s = worldToScreen(platform.x, platform.y, cam);
      const size = platform.radius * 2 * camera.zoom;
      const baseAlpha = platform.destroyed ? Math.max(0, 1 - platform.deathTimer / 1.5) : 1;
      if(baseAlpha <= 0) continue;
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(platform.rotation);
      ctx.globalAlpha = baseAlpha;
      ctx.drawImage(platform.canvas, -size/2, -size/2, size, size);
      if(platform.hitFlash > 0){
        const flash = clamp(platform.hitFlash / 0.18, 0, 1);
        ctx.globalAlpha = flash * baseAlpha;
        const flashR = size * 0.34;
        ctx.fillStyle = 'rgba(255,215,150,0.6)';
        ctx.beginPath(); ctx.arc(0, 0, flashR, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();

      if(platform.shield && !platform.destroyed && platform.shield.val > 0){
        const frac = clamp(platform.shield.val / platform.shield.max, 0, 1);
        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.globalAlpha = 0.45 + 0.35 * frac;
        ctx.lineWidth = Math.max(1.2, 2.4 * camera.zoom);
        ctx.strokeStyle = 'rgba(120,200,255,0.8)';
        ctx.beginPath(); ctx.arc(0, 0, size*0.62, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }
    }
  }

  // Laser beams
  for(const p of particlePool){
    if(!p.active || !p.beam) continue;
    const s1 = worldToScreen(p.start.x, p.start.y, cam);
    const s2 = worldToScreen(p.end.x, p.end.y, cam);
    const alphaFactor = clamp(1 - p.age/Math.max(p.life, 0.0001), 0, 1);
    const baseAlpha = (p.alpha != null) ? p.alpha : 1;
    const fade = (p.fadeWithLife === false) ? baseAlpha : baseAlpha * alphaFactor;
    if(fade <= 0) continue;
    const outerWidthMul = (p.outerWidthMul != null) ? p.outerWidthMul : 1.4;
    const innerWidthMul = (p.innerWidthMul != null) ? p.innerWidthMul : 0.6;
    const glowBlur = ((p.glowBlur != null) ? p.glowBlur : 30) * camera.zoom;
    const glowColor = p.glowColor || 'rgba(120,180,255,0.9)';
    const colorOuter = p.colorOuter || 'rgba(160,210,255,0.7)';
    const colorInner = p.colorInner || 'rgba(220,240,255,1.0)';

    ctx.save();
    ctx.globalAlpha = fade;
    ctx.lineCap = 'round';
    ctx.shadowBlur = glowBlur;
    ctx.shadowColor = glowColor;
    ctx.strokeStyle = colorOuter;
    ctx.lineWidth = p.width * camera.zoom * outerWidthMul;
    ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.globalAlpha = fade;
    ctx.lineCap = 'butt';
    ctx.strokeStyle = colorInner;
    ctx.lineWidth = p.width * camera.zoom * innerWidthMul;
    ctx.beginPath(); ctx.moveTo(s1.x, s1.y); ctx.lineTo(s2.x, s2.y); ctx.stroke();
    ctx.restore();
  }

  // Pociski
  for(const b of bullets){
    const s = worldToScreen(b.x, b.y, cam);
    if(b.type === 'rail'){
      const a = Math.atan2(b.vy, b.vx);
      const lenPx = 28 * camera.zoom;
      const dx = Math.cos(a) * (lenPx*0.5);
      const dy = Math.sin(a) * (lenPx*0.5);

      // glow
      ctx.save();
      ctx.lineCap = 'round';
      ctx.shadowBlur = 20 * camera.zoom;
      ctx.shadowColor = 'rgba(140,200,255,0.9)';
      ctx.strokeStyle = 'rgba(160,210,255,0.6)';
      ctx.lineWidth = 12 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx, s.y - dy); ctx.lineTo(s.x + dx, s.y + dy); ctx.stroke();
      ctx.restore();

      // rdzeń
      ctx.lineCap = 'round';
      ctx.strokeStyle = 'rgba(240,255,255,1.0)';
      ctx.lineWidth = 4 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx*0.4, s.y - dy*0.4); ctx.lineTo(s.x + dx*0.9, s.y + dy*0.9); ctx.stroke();
      ctx.lineCap = 'butt';
    } else if(b.type === 'armata'){
      const a = Math.atan2(b.vy, b.vx);
      const lenPx = 36 * camera.zoom;
      const dx = Math.cos(a) * (lenPx * 0.6);
      const dy = Math.sin(a) * (lenPx * 0.6);

      ctx.save();
      ctx.lineCap = 'round';
      ctx.shadowBlur = 30 * camera.zoom;
      ctx.shadowColor = 'rgba(255,170,90,0.95)';
      ctx.strokeStyle = 'rgba(255,190,120,0.75)';
      ctx.lineWidth = 16 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx, s.y - dy); ctx.lineTo(s.x + dx, s.y + dy); ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.lineCap = 'round';
      ctx.strokeStyle = 'rgba(255,240,210,1.0)';
      ctx.lineWidth = 6 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(s.x - dx*0.3, s.y - dy*0.3); ctx.lineTo(s.x + dx*1.1, s.y + dy*1.1); ctx.stroke();
      ctx.restore();
    } else if(b.type === 'plasma'){
      const sp = worldToScreen(b.px, b.py, cam);
      ctx.save();
      ctx.lineCap = 'round';
      ctx.shadowBlur = 20 * camera.zoom;
      ctx.shadowColor = 'rgba(100,255,120,0.85)';
      ctx.strokeStyle = 'rgba(80,240,120,0.55)';
      ctx.lineWidth = 8 * camera.zoom;
      ctx.beginPath(); ctx.moveTo(sp.x, sp.y); ctx.lineTo(s.x, s.y); ctx.stroke();
      ctx.restore();
      ctx.beginPath(); ctx.fillStyle = '#9eff9a';
      ctx.arc(s.x, s.y, Math.max(2, b.r*camera.zoom*0.8), 0, Math.PI*2); ctx.fill();
    } else {
      ctx.beginPath(); ctx.fillStyle = '#ffd86b';
      ctx.arc(s.x, s.y, Math.max(1.5, b.r*camera.zoom), 0, Math.PI*2); ctx.fill();
    }
  }

  // NPC
  const npcDrawList = [];
  for (const npc of npcs){
    if (!npc || npc.dead) continue;
    npcDrawList.push(npc);
  }
  npcDrawList.sort((a, b) => (a.drawLayer || 0) - (b.drawLayer || 0));
  for (const npc of npcDrawList){
    const s = worldToScreen(npc.x, npc.y, cam);
    drawNPCPretty(ctx, npc, s);
  }

  // Particles (za statkiem) — zwykłe
  {
    let drawn = 0;
    for (const p of particlePool) {
      if (!p.active || p.flash || p.beam) continue;
      if (drawn >= MAX_PARTICLES_DRAW) break;
      drawn++;
      const s = worldToScreen(p.pos.x, p.pos.y, cam);
      const t = clamp(1 - p.age/p.life, 0, 1);
      ctx.globalAlpha = t;
      ctx.beginPath(); ctx.fillStyle = p.color;
      ctx.arc(s.x, s.y, p.size * camera.zoom, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // Efekt dopalacza
  const boostAlpha = (boost.effectDuration > 0)
    ? clamp(boost.effectTime / boost.effectDuration, 0, 1)
    : 0;
  if(boostAlpha>0){
    const e = ship.engines.main;
    const mainVisual = e.visualOffset || e.offset;
    const origin = add(interpPos, rotate(mainVisual, interpAngle));
    drawBoostBeam(origin, boost.effectDir, cam, boostAlpha);
  }

  let warpLensShouldDraw = false;
let warpLensOutputCanvas = null;

if (warpBlackHoleFX) {
  const isWarpActive   = (warp.state === 'active');
  const entryProgress  = isWarpActive ? clamp(warp.entryProgress, 0, 1) : 0;
  const warpIntensity  = isWarpActive ? smoothstep01(entryProgress) : 0;

  const lensThreshold  = getWarpLensThreshold();
  const desiredLensMode = (warpIntensity >= lensThreshold) ? 'full' : 'background';
  if (desiredLensMode !== warpLensMode) {
    warpLensMode  = desiredLensMode;
    warpLensSource = null;
  }
  if (!warpLensSource) {
    configureWarpLensSource();
  }

  const zoneAllowsWarpLens = zoneState.current?.wormholeVfx ?? false;
  const shouldRenderWarpLens = isWarpActive && warpIntensity > 0.001 && zoneAllowsWarpLens;
  warpBlackHoleFX.setEnabled(shouldRenderWarpLens && !!warpLensSource);

  if (shouldRenderWarpLens && warpLensSource) {
    const engineTail     = ship.visual?.mainEngine?.y ?? (ship.h * 0.5);
    const tailDepthExtra = warpLensParam('tailDepthExtra');
    const warpDepth      = engineTail + ship.h * tailDepthExtra;

    const tailOffset = rotate({ x: 0, y: warpDepth }, interpAngle);

    const s = {
      x: W / 2 + tailOffset.x * camera.zoom,
      y: H / 2 + tailOffset.y * camera.zoom
    };

    const radiusBase    = warpLensParam('radiusBase');
    const radiusScale   = warpLensParam('radiusScale');
    const massBase      = warpLensParam('massBase');
    const massScale     = warpLensParam('massScale');
    const softness      = Math.min(1, Math.max(0, warpLensParam('softness')));
    const opacityBase   = warpLensParam('opacityBase');
    const opacityScale  = warpLensParam('opacityScale');

    const baseRadius    = Math.max(0.01, radiusBase + radiusScale * warpIntensity);
    const referenceZoom = Math.max(0.0001, camera.defaultZoom || 1);
    const zoomFactor    = camera.zoom / referenceZoom;
    const radius        = Math.min(1, baseRadius * zoomFactor);

    const baseMass      = Math.max(0, (massBase + massScale * warpIntensity) * warpIntensity);
    const mass          = Math.min(0.6, baseMass * zoomFactor * zoomFactor);
    const opacity       = Math.min(1, Math.max(0, (opacityBase + opacityScale * warpIntensity) * warpIntensity));

    const forwardStretchParam  = warpLensParam('forwardStretch');
    const forwardStretchMajor  = forwardStretchParam >= 1
      ? forwardStretchParam
      : 1 + (1 - forwardStretchParam);

    // ogólny współczynnik rozciągnięcia soczewki (skalujemy go z intensywnością warp)
    const lensStretchFactor = 1 + (forwardStretchMajor - 1) * warpIntensity;

    // ⬇️ WAŻNE: ship.angle jest JUŻ w radianach, nie przeliczamy go na stopnie
    const lensAngle = ship.angle || 0;

    // renderujemy do wewnętrznego WebGL canvasa
    warpBlackHoleFX.render({
      centerX: s.x,
      centerY: s.y,
      mass,
      radius,
      softness,
      rotation: lensAngle,         // soczewka obrócona razem ze statkiem
      opacity,
      lensStretchForward: lensStretchFactor
    });

    // ⬇️ NOWE: przepisujemy wynik z WebGL na 2D canvas i pobieramy go
    let updated = false;
    if (typeof warpBlackHoleFX.updateOutputBuffer === 'function') {
      updated = warpBlackHoleFX.updateOutputBuffer();
    }

    warpLensOutputCanvas = (typeof warpBlackHoleFX.getOutputCanvas === 'function')
      ? warpBlackHoleFX.getOutputCanvas()
      : null;

    warpLensShouldDraw = !!(
      updated &&
      warpLensOutputCanvas &&
      warpLensOutputCanvas.width &&
      warpLensOutputCanvas.height
    );
  }
}

// rysowanie efektu na główny canvas – to możesz zostawić dokładnie tak:
if (warpLensShouldDraw && warpLensOutputCanvas && warpLensOutputCanvas.width && warpLensOutputCanvas.height) {
  ctx.save();
  ctx.globalCompositeOperation = 'source-over';
  ctx.drawImage(
    warpLensOutputCanvas,
    0, 0, warpLensOutputCanvas.width, warpLensOutputCanvas.height,
    0, 0, canvas.width, canvas.height
  );
  ctx.restore();
}


  hudRenderNav(ship, cam);
  hudRenderDMG(cam);
  hudRenderFloatingBars(ship, cam);
  // radar pings
  for(const ping of radarPings){
    const s = worldToScreen(ping.x, ping.y, cam);
    const t = ping.age/ping.life;
    ctx.strokeStyle = `rgba(120,200,255,${1-t})`;
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, 40 * t * camera.zoom, 0, Math.PI*2); ctx.stroke();
  }

  // scan indicator and lock
  if(scan.target && scan.targetType && mouse.overCanvas){
    const obj = scan.target;
    const s = worldToScreen(obj.x, obj.y, cam);
    const base = (obj.radius || obj.r || 60);
    const outerExtra = scan.targetType === 'station' ? 28 : 14;
    const innerExtra = scan.targetType === 'station' ? 12 : 8;
    const outerR = (base + outerExtra) * camera.zoom;
    const innerR = Math.max(2, (base + innerExtra) * camera.zoom);
    const color = scan.targetType === 'station'
      ? 'rgba(143,181,255,0.95)'
      : (obj.friendly ? 'rgba(96,192,255,0.95)' : 'rgba(255,160,122,0.95)');

    ctx.save();
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(2, 2.5 * Math.sqrt(camera.zoom));
    ctx.shadowBlur = 18 * camera.zoom;
    ctx.shadowColor = color;
    ctx.globalAlpha = 0.9;
    ctx.beginPath(); ctx.arc(s.x, s.y, outerR, 0, Math.PI*2); ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.globalAlpha = 0.55;
    ctx.setLineDash([6 * camera.zoom, 6 * camera.zoom]);
    ctx.beginPath(); ctx.arc(s.x, s.y, innerR, 0, Math.PI*2); ctx.stroke();
    ctx.restore();

    if(scan.targetType === 'station' && !stationUI.open){
      canvas.style.cursor = 'pointer';
    }
  }
  if(highlightedEnemies.length){
    for(const obj of highlightedEnemies){
      if(obj.dead) continue;
      const s = worldToScreen(obj.x, obj.y, cam);
      const rad = ((obj.radius||obj.r) + 12) * camera.zoom;
      ctx.strokeStyle = 'rgba(255,255,0,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
    }
  }
  if(lockedTargets.length){
    for(const obj of lockedTargets){
      if(obj.dead) continue;
      const s = worldToScreen(obj.x, obj.y, cam);
      const rad = ((obj.radius||obj.r) + 14) * camera.zoom;
      ctx.strokeStyle = 'rgba(255,80,80,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
    }
  } else if(lockedTarget){
    const obj = lockedTarget;
    const s = worldToScreen(obj.x, obj.y, cam);
    const rad = ((obj.radius||obj.r) + 14) * camera.zoom;
    ctx.strokeStyle = 'rgba(255,80,80,0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(s.x, s.y, rad, 0, Math.PI*2); ctx.stroke();
  }

  // ======= STATEK =======
  const shipS = worldToScreen(interpPos.x, interpPos.y, cam);
  const spriteScale = ship.visual?.spriteScale || 1;
  const visualW = ship.w * spriteScale;
  const visualH = ship.h * spriteScale;
  ctx.save(); ctx.translate(shipS.x, shipS.y); ctx.scale(camera.zoom, camera.zoom); ctx.rotate(interpAngle);

  let warpGlowProgress = 0;
  if(warp.state === 'charging'){
    warpGlowProgress = clamp(warp.charge / warp.chargeTime, 0, 1);
  } else if(warp.state === 'active' && warp.entryProgress < 1){
    warpGlowProgress = 1 - smoothstep01(warp.entryProgress);
  }
  if(warpGlowProgress > 0){
    const chargeRadius = Math.max(visualW, visualH) * 0.7;
    drawWarpChargeEffectLocal(warpGlowProgress, chargeRadius, spriteScale);
  }

  // --- KADŁUB: sprite lub fallback ---
  if (USE_SHIP_SPRITE && ship.spriteReady) {
    const scale = (ship.h / ship.spriteH) * spriteScale;
    const drawW = ship.spriteW * scale;
    const drawH = ship.spriteH * scale;

    ctx.save();
    ctx.globalAlpha = 0.33;
    ctx.filter = 'blur(2px)';
    ctx.drawImage(shipSprite, -drawW/2 + 6, -drawH/2 + 8, drawW, drawH);
    ctx.restore();

    ctx.drawImage(shipSprite, -drawW/2, -drawH/2, drawW, drawH);
  } else {
    ctx.fillStyle = 'rgba(3,8,18,0.8)';
    ctx.fillRect(-visualW/2 + 6*spriteScale, -visualH/2 + 8*spriteScale, visualW, visualH);
    const g = ctx.createLinearGradient(-visualW/2, -visualH/2, visualW/2, visualH/2);
    g.addColorStop(0, '#1d2740'); g.addColorStop(1, '#2d3b55');
    ctx.fillStyle = g;
    roundRect(ctx, -visualW/2, -visualH/2, visualW, visualH, 10 * spriteScale);
    ctx.fill();

    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1.5;
    roundRect(ctx, -visualW/2, -visualH/2, visualW, visualH, 10 * spriteScale);
    ctx.stroke();
    ctx.globalAlpha = 0.25;
    ctx.beginPath();
    ctx.moveTo(-visualW*0.35, -visualH*0.20); ctx.lineTo(visualW*0.35, -visualH*0.20);
    ctx.moveTo(-visualW*0.35,  visualH*0.20); ctx.lineTo(visualW*0.35,  visualH*0.20);
    ctx.stroke();
    ctx.globalAlpha = 1;
    ctx.restore();

    ctx.fillStyle = '#a8d1ff';
    ctx.beginPath();
    ctx.ellipse(0, -6*spriteScale, visualW*0.22, visualH*0.22, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.save();
    ctx.rotate(-interpAngle);
    const glare = ctx.createRadialGradient(0, -visualH*0.18, 6*spriteScale, 0, -visualH*0.18, visualW*0.5);
    glare.addColorStop(0, 'rgba(255,255,255,0.25)');
    glare.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = glare;
    ctx.beginPath();
    ctx.ellipse(0, -6*spriteScale, visualW*0.22, visualH*0.22, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  if (!(USE_SHIP_SPRITE && ship.spriteReady)) {
    for (const pod of ship.pods) {
      ctx.save();
      ctx.translate(pod.offset.x, pod.offset.y);
      const pg = ctx.createLinearGradient(-pod.w/2, -pod.h/2, pod.w/2, pod.h/2);
      pg.addColorStop(0, '#1d2740'); pg.addColorStop(1, '#2d3b55');
      ctx.fillStyle = pg;
      roundRect(ctx, -pod.w/2, -pod.h/2, pod.w, pod.h, 6 * spriteScale);
      ctx.fill();
      ctx.restore();
    }

    const mainE = ship.engines.main;
    ctx.save();
    const mainVisual = mainE.visualOffset || mainE.offset;
    ctx.translate(mainVisual.x, mainVisual.y);
    ctx.fillStyle = '#2a3a56';
    roundRect(ctx, -14*spriteScale, -9*spriteScale, 28*spriteScale, 18*spriteScale, 6*spriteScale);
    ctx.fill();
    ctx.save();
    ctx.globalAlpha = 0.8;
    ctx.shadowBlur = 20;
    ctx.shadowColor = 'rgba(150,200,255,0.9)';
    ctx.fillStyle = 'rgba(160,210,255,0.75)';
    roundRect(ctx, -8*spriteScale, -6*spriteScale, 16*spriteScale, 12*spriteScale, 4*spriteScale);
    ctx.fill();
    ctx.restore();
    ctx.restore();

    for (const k of ['sideLeft','sideRight','torqueLeft','torqueRight']) {
      const e = ship.engines[k];
      ctx.save();
      const vis = e.visualOffset || e.offset;
      ctx.translate(vis.x, vis.y);
      ctx.fillStyle = '#2f3b57';
      roundRect(ctx, -6*spriteScale, -6*spriteScale, 12*spriteScale, 12*spriteScale, 3*spriteScale);
      ctx.fill();
      ctx.restore();
    }

    if (ship.visual?.torqueThrusters?.length) {
      for (const thruster of ship.visual.torqueThrusters) {
        ctx.save();
        ctx.translate(thruster.offset.x, thruster.offset.y);
        if (thruster.side === 'left') ctx.scale(-1, 1);

        const podW = 16 * spriteScale;
        const podH = 28 * spriteScale;
        const nozzleW = 10 * spriteScale;
        const nozzleH = 14 * spriteScale;
        const podRadius = 5 * spriteScale;

        const podGradient = ctx.createLinearGradient(-podW/2, -podH/2, podW/2, podH/2);
        podGradient.addColorStop(0, '#1c263d');
        podGradient.addColorStop(1, '#2f3f62');
        ctx.fillStyle = podGradient;
        roundRect(ctx, -podW/2, -podH/2, podW, podH, podRadius);
        ctx.fill();
        ctx.lineWidth = 1.2;
        ctx.strokeStyle = 'rgba(10,18,32,0.6)';
        roundRect(ctx, -podW/2, -podH/2, podW, podH, podRadius);
        ctx.stroke();

        ctx.fillStyle = '#8fa7d6';
        roundRect(ctx, podW/2 - 2 * spriteScale, -nozzleH/2, nozzleW, nozzleH, 3 * spriteScale);
        ctx.fill();

        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        roundRect(ctx, -podW/2 + 2 * spriteScale, -podH*0.35, podW * 0.3, podH * 0.7, 3 * spriteScale);
        ctx.fill();

        ctx.restore();
      }
    }

    ctx.fillStyle = '#cbd6ff';
    for (const off of ship.sideGunsLeft) {
      ctx.save();
      ctx.translate(off.x, off.y);
      roundRect(ctx, -12*spriteScale, -3*spriteScale, 8*spriteScale, 6*spriteScale, 3*spriteScale);
      ctx.fill();
      ctx.restore();
    }
    for (const off of ship.sideGunsRight) {
      ctx.save();
      ctx.translate(off.x, off.y);
      roundRect(ctx, 4*spriteScale, -3*spriteScale, 8*spriteScale, 6*spriteScale, 3*spriteScale);
      ctx.fill();
      ctx.restore();
    }
  }

  // VFX bocznych silników momentu/strafe
  if (ship.visual?.torqueThrusters?.length) {
    const thrusters = ship.visual.torqueThrusters;
    const strafeLeft = clamp(input.leftSide ?? 0, 0, 1);
    const strafeRight = clamp(input.rightSide ?? 0, 0, 1);
    const torqueInput = clamp(input.torque ?? 0, -1, 1);
    const torqueIntensity = Math.abs(torqueInput);

    const activeThrusters = [];
    let globalIntensity = 0;

    for (const thruster of thrusters) {
      const strafeIntensity = thruster.side === 'left' ? strafeLeft : strafeRight;
      let thrusterIntensity = strafeIntensity;

      if (torqueIntensity > 0) {
        const isTop = thruster.offset.y < 0;
        const isBottom = thruster.offset.y > 0;

        if (torqueInput < 0) {
          const shouldFire = (thruster.side === 'right' && isTop) || (thruster.side === 'left' && isBottom);
          if (shouldFire) thrusterIntensity = Math.max(thrusterIntensity, torqueIntensity);
        } else if (torqueInput > 0) {
          const shouldFire = (thruster.side === 'left' && isTop) || (thruster.side === 'right' && isBottom);
          if (shouldFire) thrusterIntensity = Math.max(thrusterIntensity, torqueIntensity);
        }
      }

      thrusterIntensity = clamp(thrusterIntensity, 0, 1);
      if (thrusterIntensity <= 0) continue;

      activeThrusters.push({ thruster, intensity: thrusterIntensity });
      globalIntensity = Math.max(globalIntensity, thrusterIntensity);
    }

    if (globalIntensity > 0) {
      const overrides = {
        throttleOverride: globalIntensity,
        warpOverride: 0,
        boostOverride: 0,
        moveGlowOverride: 0
      };

      for (const { thruster, intensity } of activeThrusters) {
        const widthPxMin = thruster.vfxWidthMin != null
          ? thruster.vfxWidthMin
          : spriteScale * 128 * 0.42;
        const widthPxMax = thruster.vfxWidthMax != null
          ? thruster.vfxWidthMax
          : spriteScale * 128 * 0.82;
        const lengthPxMin = thruster.vfxLengthMin != null
          ? thruster.vfxLengthMin
          : spriteScale * 256 * 0.2;
        const lengthPxMax = thruster.vfxLengthMax != null
          ? thruster.vfxLengthMax
          : spriteScale * 256 * 0.4;

        const widthPx = lerp(widthPxMin, widthPxMax, intensity);
        const lengthPx = lerp(lengthPxMin, lengthPxMax, intensity);

        const widthScale = Math.max(0.0001, widthPx / 128);
        const lengthScale = Math.max(0.0001, lengthPx / 256);
        const alpha = 0.55 + intensity * 0.35;

        drawNeedleEngineVfxLocal(thruster.offset, thruster.forward, {
          widthScale,
          lengthScale,
          yNudge: thruster.yNudge,
          alpha,
          overrides
        });
      }
    }
  }

  // VFX głównego silnika – pod tarczą, wyrasta z dyszy
  {
    const e = ship.engines.main;
    const visualOffset = e.visualOffset || e.offset;
    const forward = { x: 0, y: -1 }; // lokalny "w dół statku"
    // szerokość zależna od gazu/ruchu
    const spd = Math.hypot(ship.vel.x, ship.vel.y);
    const moveGlow = Math.min(spd / 900, 0.6) * 0.8;
    const throttle = Math.max(input.main || 0, moveGlow);
    const widen = 2.4 + 0.6 * throttle; // 1.2..1.8
    drawNeedleEngineVfxLocal(visualOffset, forward, {
      widthScale: widen,
      lengthScale: 1,
      yNudge: -68 * spriteScale,
      alpha: 1
    });
  }

  // status circle (hull/shield/speed/rockets) behind shield
  {
    const hullFrac = ship.hull.val / ship.hull.max;
    const shieldFrac = ship.shield.val / ship.shield.max;
    const r = Math.max(visualW, visualH) * 0.6;
    ctx.save();
    ctx.rotate(-interpAngle);
    ctx.lineWidth = 4;
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 - Math.PI,true); ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 + Math.PI,false); ctx.stroke();
    ctx.strokeStyle = '#ef4444';
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 - Math.PI*hullFrac,true); ctx.stroke();
    ctx.strokeStyle = '#3b82f6';
    ctx.beginPath(); ctx.arc(0,0,r,-Math.PI/2,-Math.PI/2 + Math.PI*shieldFrac,false); ctx.stroke();
    ctx.fillStyle = '#dfe7ff';
    ctx.font = '10px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const speed = Math.round(Math.hypot(ship.vel.x, ship.vel.y));
    ctx.fillText(`${speed}`, 0, -r - 8);
    if(rocketAmmoMax > 0 && rocketAmmo < rocketAmmoMax) ctx.fillText(`${rocketAmmo}`, 0, r + 8);
    ctx.restore();
  }

  // tarcza
  const sp = ship.shield.val / ship.shield.max;
  if(sp > 0.005){
    const rr = Math.max(visualW, visualH) * 0.62;
    ctx.save();
    const fresnel = ctx.createRadialGradient(0,0, rr*0.78, 0,0, rr);
    fresnel.addColorStop(0, 'rgba(120,200,255,0)');
    fresnel.addColorStop(1, `rgba(120,200,255,${0.18 + 0.4*sp})`);
    ctx.fillStyle = fresnel;
    ctx.beginPath(); ctx.arc(0,0, rr, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    ctx.beginPath(); ctx.strokeStyle = `rgba(120,200,255,${0.18 + 0.4*sp})`;
    ctx.lineWidth = 3; ctx.arc(0,0, Math.max(visualW,visualH)*0.6, 0, Math.PI*2); ctx.stroke();
  }

  // CIWS turrets
  const ciwsBase = 8 * spriteScale, ciwsBarrelLen = 12 * spriteScale, ciwsBarrelH = 4 * spriteScale;
  const activeCIWS = (Game.player.weapons?.[HP.AUX]?.length || 0);
  ship.ciws.forEach((c,i)=>{
    if(i >= activeCIWS) return;
    const ang = interpCIWSAngles[i];
    const loadout = Game.player.weapons?.[HP.AUX]?.[i];
    const isLaser = loadout?.weapon?.id === 'laser_pd_mk1';
    const baseColor = isLaser ? '#7cc6ff' : '#b8bcc6';
    const barrelColor = isLaser ? '#e6f6ff' : '#d0d0d0';
    ctx.save();
    ctx.translate(c.offset.x, c.offset.y);
    ctx.rotate(ang - interpAngle);
    if(isLaser){
      ctx.shadowColor = 'rgba(90,180,255,0.4)';
      ctx.shadowBlur = 8 * spriteScale;
    }
    ctx.fillStyle = baseColor;
    roundRect(ctx, -ciwsBase/2, -ciwsBase/2, ciwsBase, ciwsBase, 2); ctx.fill();
    ctx.lineWidth = 1; ctx.strokeStyle = 'rgba(30,50,90,0.45)'; ctx.stroke();
    ctx.fillStyle = barrelColor;
    roundRect(ctx, ciwsBase/2, -ciwsBarrelH/2, ciwsBarrelLen, ciwsBarrelH, 2); ctx.fill(); ctx.stroke();
    ctx.restore();
  });

  // wieżyczki podwójne z recoilem
  const baseW = 16 * spriteScale,
        baseH = 24 * spriteScale,
        barrelLen = Math.max(14 * spriteScale, Math.round(visualH * 0.16)) / 2,
        barrelH = 6 * spriteScale,
        gap = 10 * spriteScale; // trochę dłuższe
  const turrets = [
    { t: ship.turret,  ang: interpTurretAngle },
    { t: ship.turret2, ang: interpTurretAngle2 },
    { t: ship.turret3, ang: interpTurretAngle3 },
    { t: ship.turret4, ang: interpTurretAngle4 }
  ];
  const mainWeaponLoadouts = Game.player.weapons?.[HP.MAIN] || [];
  turrets.forEach(({ t, ang }, index) => {
    ctx.save();
    ctx.translate(t.offset.x, t.offset.y);
    ctx.rotate(ang - interpAngle);
    const recoil = t.recoil * spriteScale;
    const loadout = mainWeaponLoadouts[index];
    const behavior = getMainWeaponBehaviorForWeaponId(loadout?.weapon?.id);
    const barrelsPerShot = Math.max(1, behavior.barrelsPerShot ?? BASE_MAIN_BEHAVIOR.barrelsPerShot);

    if(barrelsPerShot === 1){
      const weaponId = loadout?.weapon?.id;
      if(weaponId === 'heavy_autocannon' && heavyAutocannonSpriteReady){
        const naturalW = heavyAutocannonSprite.naturalWidth || 180;
        const naturalH = heavyAutocannonSprite.naturalHeight || 120;
        const scaleMul = spriteScale * 0.32;
        const drawW = naturalW * scaleMul;
        const drawH = naturalH * scaleMul;
        const pivotOffset = drawW * 0.52;
        const recoilOffset = recoil * 0.9;
        ctx.save();
        ctx.translate(-pivotOffset - recoilOffset, -drawH / 2);
        ctx.drawImage(heavyAutocannonSprite, 0, 0, drawW, drawH);
        ctx.restore();

        const glowRadius = drawH * 0.34;
        const glowLength = drawW * 0.32;
        ctx.save();
        ctx.translate(drawW * 0.36 - recoil * 0.55, 0);
        const gradient = ctx.createRadialGradient(0, 0, glowRadius * 0.2, 0, 0, glowRadius);
        gradient.addColorStop(0, 'rgba(255,214,160,0.55)');
        gradient.addColorStop(1, 'rgba(255,166,70,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, glowLength, glowRadius * 0.55, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();

        ctx.fillStyle = 'rgba(255,194,120,0.22)';
        ctx.beginPath();
        ctx.moveTo(drawW * 0.34 - recoil * 0.4, -drawH * 0.18);
        ctx.lineTo(drawW * 0.58 - recoil * 0.3, 0);
        ctx.lineTo(drawW * 0.34 - recoil * 0.4, drawH * 0.18);
        ctx.closePath();
        ctx.fill();
      } else {
        const housingW = 20 * spriteScale;
        const housingH = 30 * spriteScale;
        const barrelL = Math.max(20 * spriteScale, Math.round(visualH * 0.22));
        const barrelThickness = 8 * spriteScale;
        ctx.fillStyle = '#7f8fb7';
        roundRect(ctx, -housingW/2, -housingH/2, housingW, housingH, 6 * spriteScale); ctx.fill();
        ctx.lineWidth = 1.4; ctx.strokeStyle = 'rgba(24,38,68,0.55)'; ctx.stroke();
        ctx.fillStyle = '#aebce0';
        roundRect(ctx, -housingW/2 + 3 * spriteScale, -housingH/2 + 4 * spriteScale, housingW - 6 * spriteScale, housingH - 8 * spriteScale, 5 * spriteScale); ctx.fill();
        ctx.fillStyle = 'rgba(255,180,110,0.8)';
        roundRect(ctx, -housingW/2 + 2.5 * spriteScale, -2 * spriteScale, housingW * 0.42, 4 * spriteScale, 2 * spriteScale); ctx.fill();
        ctx.strokeStyle = 'rgba(24,38,68,0.55)';
        ctx.fillStyle = '#d9dde9';
        roundRect(ctx, 8 * spriteScale - recoil, -barrelThickness/2, barrelL, barrelThickness, 3 * spriteScale); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#f0b97a';
        ctx.beginPath();
        ctx.moveTo(8 * spriteScale - recoil + barrelL, -barrelThickness/2);
        ctx.lineTo(8 * spriteScale - recoil + barrelL + 6 * spriteScale, 0);
        ctx.lineTo(8 * spriteScale - recoil + barrelL, barrelThickness/2);
        ctx.closePath();
        ctx.fill();
      }
    } else {
      ctx.fillStyle = '#9ab7ff'; roundRect(ctx, -baseW/2, -baseH/2, baseW, baseH, 5 * spriteScale); ctx.fill();
      ctx.lineWidth = 1.2; ctx.strokeStyle = 'rgba(30,50,90,0.45)'; ctx.stroke();
      ctx.fillStyle = '#c0c0c0';
      roundRect(ctx, 6*spriteScale - recoil, -gap/2 - barrelH/2, barrelLen, barrelH, 3 * spriteScale); ctx.fill(); ctx.stroke();
      roundRect(ctx, 6*spriteScale - recoil,  gap/2 - barrelH/2, barrelLen, barrelH, 3 * spriteScale); ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  });
  ctx.restore(); // ship

  // scan arrows pointing to stations
  if(warp.state !== 'active'){
    const shieldR = Math.max(visualW, visualH) * 0.6;
    for(const a of scanArrows){
      const st = a.target;
      const dx = st.x - ship.pos.x;
      const dy = st.y - ship.pos.y;
      const ang = Math.atan2(dy, dx);
      const baseR = shieldR + 10;
      const ax = ship.pos.x + Math.cos(ang) * baseR;
      const ay = ship.pos.y + Math.sin(ang) * baseR;
      const s = worldToScreen(ax, ay, cam);
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(ang);
      const size = 18 * camera.zoom;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(120,200,255,0.9)';
      ctx.moveTo(0, -size*0.5);
      ctx.lineTo(size, 0);
      ctx.lineTo(0, size*0.5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      const tx = ship.pos.x + Math.cos(ang) * (baseR + 14);
      const ty = ship.pos.y + Math.sin(ang) * (baseR + 14);
      const ts = worldToScreen(tx, ty, cam);
      ctx.save();
      ctx.fillStyle = '#dfe7ff';
      ctx.font = `${12*camera.zoom}px monospace`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(`${Math.round(Math.hypot(dx,dy))}u`, ts.x, ts.y);
      ctx.restore();
    }
  }

  // mercenary mission arrow towards pirate station
  if(mercMission && mercMission.station){
    const st = mercMission.station;
    const dx = st.x - ship.pos.x;
    const dy = st.y - ship.pos.y;
    const dist = Math.hypot(dx, dy);
    if(dist > 1){
      const ang = Math.atan2(dy, dx);
      const shipScreen = worldToScreen(ship.pos.x, ship.pos.y, cam);
      const distScreen = dist * camera.zoom;
      const maxRadius = Math.max(160, Math.min(W, H) * 0.5 - 60);
      const baseMinRadius = (visualH * 0.5 + 80) * camera.zoom;
      const minRadius = Math.min(baseMinRadius, maxRadius);
      let arrowRadius = distScreen;
      arrowRadius = Math.max(arrowRadius, minRadius);
      arrowRadius = Math.min(arrowRadius, maxRadius);
      const ax = shipScreen.x + Math.cos(ang) * arrowRadius;
      const ay = shipScreen.y + Math.sin(ang) * arrowRadius;

        // shrink + auto-hide when close to station
        const HIDE_DIST = st.r + 600; // znikaj przy podejściu
        if (dist > HIDE_DIST) {
          const baseArrowLength = (ship.h / camera.zoom) * 0.45;
          const arrowLength = clamp(baseArrowLength, 18, 42);
          const arrowWidth = arrowLength * 0.26;
          const strokeW = clamp(2.5 / camera.zoom, 1.2, 5);

          ctx.save();
          ctx.translate(ax, ay);
          ctx.rotate(ang);
          ctx.beginPath();
          ctx.moveTo(arrowLength * 0.5, 0);
          ctx.lineTo(-arrowLength * 0.5, -arrowWidth * 0.5);
          ctx.lineTo(-arrowLength * 0.5, arrowWidth * 0.5);
          ctx.closePath();
          ctx.fillStyle = 'rgba(255,90,90,0.92)';
          ctx.shadowColor = 'rgba(255,120,120,0.6)';
          ctx.shadowBlur = 14;
          ctx.fill();
          ctx.lineWidth = strokeW;
          ctx.strokeStyle = 'rgba(10,0,0,0.55)';
          ctx.stroke();
          ctx.restore();

          const labelDist = arrowLength * 0.45;
          const labelX = ax + Math.cos(ang) * labelDist;
          const labelY = ay + Math.sin(ang) * labelDist;
          const fontSize = Math.round(clamp(16 / camera.zoom, 10, 26));
          ctx.save();
          ctx.fillStyle = '#ffd1d1';
          ctx.font = `bold ${fontSize}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'bottom';
          ctx.fillText('PIRACKA STACJA', labelX, labelY - 6);
          ctx.textBaseline = 'top';
          ctx.fillText(`${Math.round(dist)} u`, labelX, labelY + 6);
          ctx.restore();
        }
    }
  }

  // Particles typu "flash" na samym wierzchu
  {
    let drawn = 0;
    for (const p of particlePool) {
      if (!p.active || !p.flash) continue;
      if (drawn >= MAX_PARTICLES_DRAW) break;
      drawn++;
      const s = worldToScreen(p.pos.x, p.pos.y, cam);
      const t = clamp(1 - p.age/p.life, 0, 1);
      ctx.globalAlpha = t;
      ctx.save();
      ctx.shadowBlur = 20 * camera.zoom * (p.size/2);
      let shadowColor = p.color;
      if(p.color === '#bfe7ff') shadowColor = 'rgba(120,200,255,0.9)';
      if(p.color === '#ffd8c4') shadowColor = 'rgba(255,180,120,0.9)';
      if(p.color === '#7CFF7C' || p.color === '#a8ff9a') shadowColor = 'rgba(120,255,140,0.95)';
      if(p.color === '#ffffff') shadowColor = 'rgba(255,255,255,0.95)';
      ctx.shadowColor = shadowColor;
      ctx.beginPath(); ctx.fillStyle = p.color;
      ctx.arc(s.x, s.y, (p.size * 3) * camera.zoom, 0, Math.PI*2); ctx.fill();
      ctx.restore();
      ctx.beginPath(); ctx.fillStyle = p.color;
      ctx.arc(s.x, s.y, p.size * camera.zoom, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  if (HUD_SHOW_LEGACY) {
    // HUD
    ctx.fillStyle = '#dfe7ff'; ctx.font = '12px monospace';
    ctx.fillText(`HP: ${Math.round(ship.hull.val)}/${ship.hull.max}`, 12, H-100);
    ctx.fillText(`Shield: ${Math.round(ship.shield.val)}/${ship.shield.max}`, 12, H-84);
    const warpText = warp.state==='active' ? `ACTIVE`
                    : warp.state==='charging' ? `CHARGING ${(Math.min(1,warp.charge/warp.chargeTime)*100).toFixed(0)}%`
                    : 'READY';
    ctx.fillText(`Warp: ${warpText}`, 12, H-68);
    const fw = 200, fh = 10, ffrac = warp.fuel/warp.fuelMax;
    ctx.strokeStyle = 'rgba(255,255,255,0.14)'; ctx.strokeRect(12-1, H-52-fh, fw+2, fh+2);
    ctx.fillStyle = '#60a5fa'; ctx.fillRect(12, H-52-fh, fw*ffrac, fh);
    ctx.fillStyle = '#dfe7ff'; ctx.fillText(`${warp.fuel.toFixed(1)}s / ${warp.fuelMax}s`, 12 + fw + 8, H-42-fh);
    const boosting = boost.state==='active' && boost.fuel > 0;
    const fullyCharged = boost.fuel >= boost.fuelMax - 0.01;
    const boostText = boosting ? 'ACTIVE' : (fullyCharged ? 'READY' : 'REFILLING');
    ctx.fillText(`Boost: ${boostText} (${boost.fuel.toFixed(1)}/${boost.fuelMax})`, 12, H-44);
    const railTimerHUD = (Math.max(1, rail.barrelsPerShot || 2) > 1)
      ? Math.min(rail.cd[0], rail.cd[1])
      : rail.cd[0];
    ctx.fillText(`Rail: ${railTimerHUD>0?railTimerHUD.toFixed(2)+'s':'READY'}  Special: ${ship.special.cooldownTimer>0?ship.special.cooldownTimer.toFixed(1)+'s':'READY'}`, 12, H-28);

    // rocket ammo
    const bw = 160, bh = 10;
    const ammoFrac = rocketAmmoMax > 0 ? rocketAmmo / rocketAmmoMax : 0;
    ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.strokeRect(12-1, H-12-bh-12, bw+2, bh+2);
    ctx.fillStyle = '#3b82f6'; ctx.fillRect(12, H-12-bh-12, bw*ammoFrac, bh);
    ctx.fillStyle = '#dfe7ff'; ctx.fillText(`Rockets: ${rocketAmmo}`, 12 + bw + 8, H-12-bh-6-12);
  }

  if(mercMission && mercMission.station){
    const st = mercMission.station;
    const panelPadding = 24;
    const barW = 220;
    const barH = 10;
    let y = 36;
    const xRight = W - panelPadding;
    ctx.save();
    ctx.textAlign = 'right';
    ctx.fillStyle = '#ffd1d1';
    ctx.fillText('Piracka stacja', xRight, y);
    ctx.fillStyle = '#dfe7ff';
    y += 8;
    if(st.shield){
      const shieldFrac = clamp(st.shield.val / st.shield.max, 0, 1);
      ctx.fillText(`Osłony: ${Math.round(st.shield.val)}/${st.shield.max}`, xRight, y + 10);
      const bx = xRight - barW;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.strokeRect(bx - 1, y + 14, barW + 2, barH + 2);
      ctx.fillStyle = '#60a5fa';
      ctx.fillRect(bx, y + 15, barW * shieldFrac, barH);
      ctx.fillStyle = '#dfe7ff';
      y += 32;
    }
    const hullFrac = clamp(st.hp / st.maxHp, 0, 1);
    ctx.fillText(`Kadłub: ${Math.round(st.hp)}/${st.maxHp}`, xRight, y + 10);
    const bx = xRight - barW;
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.strokeRect(bx - 1, y + 14, barW + 2, barH + 2);
    ctx.fillStyle = '#ef4444';
    ctx.fillRect(bx, y + 15, barW * hullFrac, barH);
    y += 32;
    const platforms = mercMission.weaponPlatforms || [];
    if(platforms.length){
      ctx.fillStyle = '#ffd1d1';
      ctx.fillText('Platformy obronne', xRight, y);
      y += 8;
      for(const platform of platforms){
        const label = platform.label || 'Platforma';
        const entryBx = xRight - barW;
        if(platform.shield && platform.shield.max > 0){
          const shieldFrac = clamp(platform.shield.val / platform.shield.max, 0, 1);
          ctx.fillStyle = '#dfe7ff';
          ctx.fillText(`${label}: osłony ${Math.round(platform.shield.val)}/${platform.shield.max}`, xRight, y + 10);
          ctx.strokeStyle = 'rgba(255,255,255,0.12)';
          ctx.strokeRect(entryBx - 1, y + 14, barW + 2, barH + 2);
          ctx.fillStyle = '#60a5fa';
          ctx.fillRect(entryBx, y + 15, barW * shieldFrac, barH);
          y += 26;
        }
        const hpFrac = (platform.maxHp > 0) ? clamp(Math.max(0, platform.hp) / platform.maxHp, 0, 1) : 0;
        ctx.fillStyle = '#dfe7ff';
        ctx.fillText(`${label}: kadłub ${Math.max(0, Math.round(platform.hp))}/${platform.maxHp}`, xRight, y + 10);
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.strokeRect(entryBx - 1, y + 14, barW + 2, barH + 2);
        ctx.fillStyle = platform.destroyed ? '#4b5563' : '#f97316';
        ctx.fillRect(entryBx, y + 15, barW * hpFrac, barH);
        y += 28;
      }
    }
    ctx.restore();
  }

  if(showMap) drawSectorMap();
  renderStationUI();
  renderOptions();
  renderMissionJournal();
  renderZoneMessages();
  renderMissionCompleteBanner();
  mouse.click=false;
}

function renderZoneMessages(){
  if (!zoneState.messages.length) return;

  ctx.save();
  ctx.resetTransform();
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  const baseY = 70;
  const lineH = 32;

  zoneState.messages.forEach((msg, i) => {
    const progress = msg.maxLife - msg.life;
    const fadeIn = clamp(progress / 0.35, 0, 1);
    const fadeOut = clamp(msg.life / 0.5, 0, 1);
    const alpha = Math.min(fadeIn, fadeOut);
    if (alpha <= 0) return;

    const fontSize = 22;
    const y = baseY + i * lineH;
    ctx.font = `600 ${fontSize}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 12;
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(12, 20, 36, 0.7)';
    ctx.fillStyle = '#e5ecff';
    ctx.globalAlpha = alpha;

    ctx.strokeText(msg.text, W/2, y);
    ctx.fillText(msg.text, W/2, y);
  });

  ctx.restore();
}

function renderMissionCompleteBanner(){
  if(!missionCompleteBanner.active) return;
  const alpha = missionCompleteBanner.alpha();
  if(alpha <= 0) return;

  ctx.save();
  ctx.resetTransform();
  ctx.translate(W/2, H*0.32);
  const scale = 1 + 0.08 * Math.sin(missionCompleteBanner.progress() * Math.PI);
  ctx.scale(scale, scale);
  ctx.globalAlpha = alpha;

  const fontSize = Math.round(Math.min(W, H) * 0.08);
  ctx.font = `700 ${fontSize}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = 'rgba(80,180,255,0.85)';
  ctx.shadowBlur = Math.max(14, fontSize * 0.2);
  ctx.lineJoin = 'round';

  const strokeWidth = Math.max(2, fontSize * 0.05);
  ctx.lineWidth = strokeWidth;
  ctx.strokeStyle = 'rgba(10,20,40,0.6)';
  ctx.strokeText(missionCompleteBanner.text, 0, 0);

  ctx.fillStyle = '#ffffff';
  ctx.fillText(missionCompleteBanner.text, 0, 0);

  ctx.restore();
}

function drawSectorMap(){
  mapView.zoom += (mapView.targetZoom - mapView.zoom) * mapView.smoothness;

  const padding = Math.max(28, Math.min(W, H) * 0.05);
  const baseScale = Math.min((W - padding * 2) / WORLD.w, (H - padding * 2) / WORLD.h);
  const scale = baseScale * mapView.zoom;
  const mapW = WORLD.w * scale;
  const mapH = WORLD.h * scale;

  const clampPos = (value, content, view) => {
    if (content <= view - padding * 2) return (view - content) / 2;
    const min = view - content - padding;
    const max = padding;
    return clamp(value, min, max);
  };

  const targetX0 = clampPos(W / 2 - ship.pos.x * scale, mapW, W);
  const targetY0 = clampPos(H / 2 - ship.pos.y * scale, mapH, H);

  if (mapView.viewX == null || mapView.viewY == null) {
    mapView.viewX = targetX0;
    mapView.viewY = targetY0;
  } else {
    mapView.viewX += (targetX0 - mapView.viewX) * 0.18;
    mapView.viewY += (targetY0 - mapView.viewY) * 0.18;
  }

  const toScreen = (x, y) => ({
    x: mapView.viewX + x * scale,
    y: mapView.viewY + y * scale,
  });

  ctx.save();
  ctx.resetTransform();

  const bg = ctx.createLinearGradient(0, 0, 0, H);
  bg.addColorStop(0, 'rgba(6, 12, 24, 0.95)');
  bg.addColorStop(1, 'rgba(4, 8, 16, 0.82)');
  ctx.fillStyle = bg;
  ctx.fillRect(0, 0, W, H);

  const glow = ctx.createRadialGradient(W / 2, H / 2, Math.min(W, H) * 0.12, W / 2, H / 2, Math.max(W, H) * 0.7);
  glow.addColorStop(0, 'rgba(48, 168, 255, 0.2)');
  glow.addColorStop(1, 'rgba(48, 168, 255, 0)');
  ctx.fillStyle = glow;
  ctx.fillRect(0, 0, W, H);

  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  const gridStep = 4000;
  const startX = Math.floor(-mapView.viewX / (gridStep * scale)) * gridStep;
  const startY = Math.floor(-mapView.viewY / (gridStep * scale)) * gridStep;
  ctx.save();
  ctx.beginPath();
  for (let gx = startX; gx < WORLD.w; gx += gridStep) {
    const px = toScreen(gx, 0).x;
    if (px < padding || px > W - padding) continue;
    ctx.moveTo(px, padding);
    ctx.lineTo(px, H - padding);
  }
  for (let gy = startY; gy < WORLD.h; gy += gridStep) {
    const py = toScreen(0, gy).y;
    if (py < padding || py > H - padding) continue;
    ctx.moveTo(padding, py);
    ctx.lineTo(W - padding, py);
  }
  ctx.stroke();
  ctx.restore();

  ctx.strokeStyle = 'rgba(255,255,255,0.35)';
  ctx.lineWidth = 2;
  ctx.strokeRect(mapView.viewX, mapView.viewY, mapW, mapH);

  const drawGlowDot = (pos, radius, fill, stroke) => {
    ctx.save();
    ctx.shadowColor = fill;
    ctx.shadowBlur = radius * 2;
    ctx.fillStyle = fill;
    ctx.strokeStyle = stroke || fill;
    ctx.lineWidth = Math.max(1.5, radius * 0.25);
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  };

  const sunPos = toScreen(SUN.x, SUN.y);
  const sunRadius = Math.max(10, 12 * mapView.zoom);
  drawGlowDot(sunPos, sunRadius, 'rgba(255, 200, 92, 0.9)', 'rgba(255, 243, 191, 0.9)');

  if (ASTEROID_BELT) {
    const cx = sunPos.x;
    const cy = sunPos.y;
    const outerRx = ASTEROID_BELT.outer * scale;
    const outerRy = ASTEROID_BELT.outer * scale;
    const innerRx = ASTEROID_BELT.inner * scale;
    const innerRy = ASTEROID_BELT.inner * scale;
    ctx.save();
    ctx.strokeStyle = 'rgba(168, 182, 204, 0.55)';
    ctx.lineWidth = 3;
    ctx.globalAlpha = 0.7;
    ctx.beginPath(); ctx.ellipse(cx, cy, outerRx, outerRy, 0, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(cx, cy, innerRx, innerRy, 0, 0, Math.PI*2); ctx.stroke();
    ctx.restore();
  }

  if (Array.isArray(planets) && planets.length) {
    ctx.save();

    const markerRadius = Math.max(8, 10 * Math.sqrt(mapView.zoom));
    ctx.fillStyle = '#7dd3fc';
    for (const planet of planets) {
      const pos = toScreen(planet.x, planet.y);
      drawGlowDot(pos, markerRadius, 'rgba(96, 199, 255, 0.85)', 'rgba(175, 232, 255, 0.8)');
    }

    const labelFont = Math.max(12, Math.round(Math.min(W, H) * 0.022));
    ctx.font = `600 ${labelFont}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.lineWidth = Math.max(2, labelFont * 0.14);
    ctx.strokeStyle = 'rgba(8, 12, 22, 0.9)';
    ctx.fillStyle = '#e2ecff';

    for (const planet of planets) {
      const name = typeof planet.label === 'string' ? planet.label.trim() : '';
      if (!name) continue;
      const pos = toScreen(planet.x, planet.y);
      const labelY = pos.y + markerRadius + 8;
      ctx.strokeText(name, pos.x, labelY);
      ctx.fillText(name, pos.x, labelY);
    }

    ctx.restore();
  }

  ctx.save();
  ctx.fillStyle = '#75e1ff';
  ctx.strokeStyle = 'rgba(71, 191, 255, 0.5)';
  ctx.lineWidth = 2;
  for(const st of stations){
    const pos = toScreen(st.x, st.y);
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
  }
  ctx.restore();

  ctx.save();
  const shipPos = toScreen(ship.pos.x, ship.pos.y);
  const shipRadius = Math.max(7, 9 * Math.pow(mapView.zoom, 0.35));
  const angle = ship.angle || 0;
  ctx.translate(shipPos.x, shipPos.y);
  ctx.rotate(angle);
  ctx.fillStyle = '#ffffff';
  ctx.strokeStyle = 'rgba(255,255,255,0.8)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(shipRadius * 1.6, 0);
  ctx.lineTo(-shipRadius * 0.9, shipRadius * 0.9);
  ctx.lineTo(-shipRadius * 0.9, -shipRadius * 0.9);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  ctx.strokeStyle = '#ff8fa3';
  ctx.lineWidth = 3;
  for(const m of MISSIONS.active){
    if(m.status !== 'active' || !m.pos) continue;
    const pos = toScreen(m.pos.x, m.pos.y);
    const s = Math.max(9, 10 * Math.sqrt(mapView.zoom));
    ctx.beginPath();
    ctx.moveTo(pos.x - s, pos.y - s); ctx.lineTo(pos.x + s, pos.y + s);
    ctx.moveTo(pos.x - s, pos.y + s); ctx.lineTo(pos.x + s, pos.y - s);
    ctx.stroke();
  }

  ctx.save();
  const titleY = padding * 0.7;
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.font = `700 ${Math.max(18, Math.min(W, H) * 0.03)}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
  ctx.fillStyle = '#e8f1ff';
  ctx.shadowColor = 'rgba(42, 152, 255, 0.65)';
  ctx.shadowBlur = 16;
  ctx.fillText('Mapa Sektora', padding, titleY);

  ctx.font = `500 ${Math.max(13, Math.min(W, H) * 0.018)}px Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif`;
  ctx.shadowBlur = 0;
  ctx.fillStyle = 'rgba(232, 241, 255, 0.8)';
  ctx.fillText('Scroll — powiększenie · M — zamknij', padding, titleY + 28);
  ctx.restore();

  ctx.restore();
}

// =============== Helpers ===============
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
function roundRectScreen(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

function screenToWorld(sx, sy){
  return { x: camera.x + (sx - W/2)/camera.zoom, y: camera.y + (sy - H/2)/camera.zoom };
}

// --- MINI UI HELPERS (HUD) ---
let hudOffset = {x:40, y:46};
function hudBeginPanel(x=24, y=24, w=450, h=520){
  ctx.save();
  ctx.resetTransform();
  ctx.fillStyle='rgba(0,0,0,0.55)';
  ctx.fillRect(x, y, w, h);
  ctx.fillStyle='rgba(255,255,255,0.08)';
  ctx.fillRect(x, y, w, 24);
  ctx.translate(x+16, y+46);
  hudOffset.x = x+16;
  hudOffset.y = y+46;
  ctx.fillStyle='#E6F2FF';
  ctx.font='16px monospace';
}
function hudEndPanel(){ ctx.restore(); }
function uiTitle(t){ ctx.font='20px monospace'; ctx.fillText(t,0,0); ctx.translate(0,28); ctx.font='16px monospace'; }
function section(t){ ctx.translate(0,12); ctx.globalAlpha=0.8; ctx.fillText('— '+t,0,0); ctx.globalAlpha=1; ctx.translate(0,18); }
function uiText(t){ ctx.fillText(t,0,0); ctx.translate(0,18); }
function hudTabs(names, active){
  let x = 0, clicked = null;
  for (let i = 0; i < names.length; i++) {
    const key = names[i];
    const label = '[' + toTitleCaseFromKey(key) + ']';
    const w = ctx.measureText(label).width;
    const t = ctx.getTransform();
    const L = t.e + x, T = t.f - 14, R = L + w, B = T + 20;

    ctx.fillStyle = key===active ? '#fff' : '#a8c0ff';
    ctx.fillText(label, x, 0);

    const over = mouse.x>L && mouse.x<R && mouse.y>T && mouse.y<B;
    if (over) canvas.style.cursor = 'pointer';
    if (over && mouse.click) clicked = key;

    x += ctx.measureText(label+'  ').width;
  }
  ctx.translate(0, 28);
  ctx.fillStyle = '#E6F2FF';
  if (clicked){ stationUI.tab = clicked; mouse.click = false; }
}
function uiRowButton(label, btn){
  ctx.fillText(label, 0, 0);
  const w=96,h=20,x=320,y=-14;
  ctx.strokeStyle='#cfe3ff'; ctx.strokeRect(x,y,w,h); ctx.fillText(btn, x+10, 0);

  const t = ctx.getTransform();
  const L=t.e+x, T=t.f+y, R=L+w, B=T+h;
  const over = mouse.x>L && mouse.x<R && mouse.y>T && mouse.y<B;
  if (over) canvas.style.cursor = 'pointer';
  const clicked = over && mouse.click;

  ctx.translate(0,22);
  if (clicked) mouse.click = false;
  return clicked;
}
function slider(label, min,max, step, obj, key){
  ctx.fillText(`${label}: ${obj[key].toFixed(2)}`,0,0); ctx.translate(0,18);
  // do prostoty – klawiszami [ i ] zmieniasz ostatni slider; lub klik + ruch (opcjonalnie)
  // Możesz podpiąć realny input według swojej architektury.
}
function toast(t){ /* opcjonalnie dopisz do kolejki komunikatów HUD */ }
function applyShipStats(s){
  ship.hull.max = Math.round(ship.hull.max * s.hp);
  ship.hull.val = Math.min(ship.hull.val, ship.hull.max);

  const speedMul = s.speed;
  ship.engines.main.maxThrust      = Math.round(ship.engines.main.maxThrust * speedMul);
  ship.engines.sideLeft.maxThrust  = Math.round(ship.engines.sideLeft.maxThrust * speedMul);
  ship.engines.sideRight.maxThrust = Math.round(ship.engines.sideRight.maxThrust * speedMul);
  ship.engines.torqueLeft.maxThrust  = Math.round(ship.engines.torqueLeft.maxThrust * speedMul);
  ship.engines.torqueRight.maxThrust = Math.round(ship.engines.torqueRight.maxThrust * speedMul);

  ship.cargoCap = Math.round((ship.cargoCap || 20) * s.cargo);
}

function dist(x1,y1,x2,y2){ return Math.hypot(x2-x1, y2-y1); }
function limitSpeed(n, max){
  const vx = n.vel ? n.vel.x : n.vx;
  const vy = n.vel ? n.vel.y : n.vy;
  const v = Math.hypot(vx, vy);
  if(v>max){
    const s = max/v;
    if(n.vel){ n.vel.x*=s; n.vel.y*=s; }
    else { n.vx*=s; n.vy*=s; }
  }
}
function steerToward(n, tx, ty, dt, accel = n.accel, turnRate = n.turn) {
  const desired = Math.atan2(ty - n.y, tx - n.x);
  const diff = wrapAngle(desired - n.angle);
  const turn = clamp(diff, -turnRate * dt, turnRate * dt);
  n.angle = wrapAngle(n.angle + turn);
  n.vx += Math.cos(n.angle) * accel * dt;
  n.vy += Math.sin(n.angle) * accel * dt;
  limitSpeed(n, n.maxSpeed);
}

function chaseEvadeAI(n, target, opts = {}) {
  steerToward(n, target.pos.x, target.pos.y, 0.016);

  if (opts.strafe) {
    const side = (Math.random() < 0.5 ? -1 : 1);
    const ang = n.angle + side * Math.PI / 2;
    n.vx += Math.cos(ang) * n.accel * 0.004;
    n.vy += Math.sin(ang) * n.accel * 0.004;
  }
}

function dogfightAI(n, target) {
  chaseEvadeAI(n, target, { strafe: true });
}

function battleshipAI(n, target) {
  const d = Math.hypot(target.pos.x - n.x, target.pos.y - n.y);
  if (d < 600) {
    const ang = Math.atan2(n.y - target.pos.y, n.x - target.pos.x);
    n.vx += Math.cos(ang) * n.accel * 0.016;
    n.vy += Math.sin(ang) * n.accel * 0.016;
    limitSpeed(n, n.maxSpeed);
  } else {
    chaseEvadeAI(n, target);
  }
}

// === AI SPACE LOGIC PORT ===
function runAdvancedFighterAI(npc, dt) {
  // 1. Liczniki i Cleanup
  npc.gunCD = Math.max(0, (npc.gunCD || 0) - dt);
  npc.mslCD = Math.max(0, (npc.mslCD || 0) - dt);
  npc.breakOffTimer = Math.max(0, (npc.breakOffTimer || 0) - dt);
  if (npc.state === 'dogfight3D') npc.dogfightTime = (npc.dogfightTime || 0) + dt;
  else npc.dogfightTime = 0;

  // 2. Znajdź cel
  let target = (npc.forceTarget && !npc.forceTarget.dead) ? npc.forceTarget : null;
  let bestScore = -Infinity;

  const pirateEngageTarget = pickPirateEngageTarget(npc);
  const holdGuard = npc.isPirate && mercMission?.alertStage === 'guard' && npc.guardHold;

  const isFriendly = !!npc.friendly;
  const targetDogfightRange = 2500;
  const candidateIsEnemy = (candidate) => {
    if (!candidate || candidate.dead || candidate === npc) return false;
    const candidateFriendly = candidate === window.ship ? true : !!candidate.friendly;
    return candidateFriendly !== isFriendly;
  };

  const potentialTargets = (window.npcs || []).filter(candidateIsEnemy);
  if (candidateIsEnemy(window.ship)) potentialTargets.unshift(window.ship);

  if (!holdGuard && !pirateEngageTarget) {
    for (const t of potentialTargets) {
      const tx = t.pos ? t.pos.x : t.x;
      const ty = t.pos ? t.pos.y : t.y;
      const distSq = (tx - npc.x)**2 + (ty - npc.y)**2;
      if (distSq > 3000**2) continue;

      const dist = Math.sqrt(distSq);
      let score = -dist; // Im bliżej tym lepiej
      const fighterLike = t.fighter || t.type === 'drone' || t.type === 'fighter' || t.type === 'interceptor';
      if (fighterLike) {
        score += (dist < targetDogfightRange) ? 40000 : 1000;
      } else if (t.isCapitalShip || t === window.ship) {
        score += 1000;
      }

      if (score > bestScore) {
        bestScore = score;
        target = t;
      }
    }
  }

  if (!holdGuard && pirateEngageTarget) {
    target = pirateEngageTarget;
  }

  if (holdGuard) {
    target = null;
  }

  // 3. Decyzja o STANIE
  const targetX = target ? (target.pos ? target.pos.x : target.x) : 0;
  const targetY = target ? (target.pos ? target.pos.y : target.y) : 0;
  const distToTarget = target ? Math.hypot(targetX - npc.x, targetY - npc.y) : Infinity;
  
  let nextState = 'guard';

  const fighterLike = target && (target.fighter || target.type === 'drone');

  if (target) {
    if (!fighterLike && distToTarget < 900) {
      nextState = 'bombing';
    } else if (fighterLike && distToTarget < 600) {
      nextState = 'dogfight3D';
    } else if (distToTarget < 2600) {
      nextState = 'engage_formation';
    }
  }

  if (npc.state === 'bombing' && target && distToTarget < 1100) nextState = 'bombing';
  if (npc.state === 'dogfight3D' && target && distToTarget < 800) nextState = 'dogfight3D';

  npc.state = nextState;

  // --- REALIZACJA STANÓW ---

  // STAN 1: BOMBING RUN
  if (npc.state === 'bombing' && target) {
    if (!npc.bombardVec || npc.lastTargetId !== target.id) {
      const angle = Math.random() * Math.PI * 2; 
      npc.bombardVec = { x: Math.cos(angle), y: Math.sin(angle) };
      npc.bombardSide = 1; 
      npc.lastTargetId = target.id;
    }
    const lineLen = 1200; 
    const wayX = targetX + (npc.bombardVec.x * lineLen * npc.bombardSide);
    const wayY = targetY + (npc.bombardVec.y * lineLen * npc.bombardSide);

    if (Math.hypot(wayX - npc.x, wayY - npc.y) < 200) npc.bombardSide *= -1; 

    const dirToWay = norm({ x: wayX - npc.x, y: wayY - npc.y }); // FIX: passed obj
    const wantSpeed = npc.maxSpeed * 1.2; 
    const turned = clampTurnVec(npc.vx, npc.vy, dirToWay.x * wantSpeed, dirToWay.y * wantSpeed, dt, 180);
    npc.vx = turned.vx; npc.vy = turned.vy;
    npc.angle = Math.atan2(npc.vy, npc.vx);
    
    tryFireFighter(npc, target, dt);
    return; 
  }

  // STAN 2: DOGFIGHT
  if (npc.state === 'dogfight3D' && target) {
    if (!npc.subState) npc.subState = 'merge';

    if (npc.subState === 'merge') {
       const aim = getLeadAim(npc, target, 600);
       const dir = norm({x: aim.x - npc.x, y: aim.y - npc.y}); // FIX: passed obj
       const turned = clampTurnVec(npc.vx, npc.vy, dir.x * npc.maxSpeed, dir.y * npc.maxSpeed, dt, 320);
       npc.vx = turned.vx; npc.vy = turned.vy;
       npc.angle = Math.atan2(npc.vy, npc.vx);
       
       if (distToTarget < 200) {
         npc.subState = 'slash';
         npc.subTimer = 0.6;
         npc.slashSign = (Math.random() > 0.5) ? 1 : -1;
       }
       tryFireFighter(npc, target, dt);
       return;
    }
    // ... (uproszczony dogfight dla oszczędności miejsca, merge wystarczy)
    // domyślny dogfight fallback
    const aim = getLeadAim(npc, target, 600);
    const dir = norm({x: aim.x - npc.x, y: aim.y - npc.y}); // FIX
    const turned = clampTurnVec(npc.vx, npc.vy, dir.x * npc.maxSpeed, dir.y * npc.maxSpeed, dt, 280);
    npc.vx = turned.vx; npc.vy = turned.vy;
    npc.angle = Math.atan2(npc.vy, npc.vx);
    tryFireFighter(npc, target, dt);
    return;
  }

  // STAN 3: ENGAGE W FORMACJI (lider prowadzi, skrzydło może wejść w atak)
  if (npc.state === 'engage_formation' && target) {
    const leader = (npc.squad) ? npc.squad.leader : null;
    let anchorX = npc.x + Math.cos(npc.angle) * 80;
    let anchorY = npc.y + Math.sin(npc.angle) * 80;

    if (leader && leader !== npc && !leader.dead) {
      const offset = npc.formationOffset || npc.formationSlot || {x: -50, y: 50};
      const la = leader.angle || 0;
      const ox = offset.x * Math.cos(la) - offset.y * Math.sin(la);
      const oy = offset.x * Math.sin(la) + offset.y * Math.cos(la);
      anchorX = leader.x + ox;
      anchorY = leader.y + oy;
    }

    const formDir = norm({ x: anchorX - npc.x, y: anchorY - npc.y });
    const attackDir = norm({ x: targetX - npc.x, y: targetY - npc.y });
    const blended = norm({ x: formDir.x * 0.45 + attackDir.x * 0.55, y: formDir.y * 0.45 + attackDir.y * 0.55 });

    const turned = clampTurnVec(npc.vx, npc.vy, blended.x * npc.maxSpeed, blended.y * npc.maxSpeed, dt, 220);
    npc.vx = turned.vx;
    npc.vy = turned.vy;
    npc.angle = Math.atan2(npc.vy, npc.vx);

    tryFireFighter(npc, target, dt);

    if (!fighterLike && distToTarget < 1200) { npc.state = 'bombing'; return; }
    if (fighterLike && distToTarget < 950) { npc.state = 'dogfight3D'; return; }

    return;
  }

  // STAN 3: FORMACJA / GUARD
  // To jest fragment, którego szukałeś! Naprawiony.
  const leader = (npc.squad) ? npc.squad.leader : null;
  let destX, destY;

  if (leader && leader !== npc && !leader.dead) {
    // TUTAJ JEST POPRAWKA: Używamy npc.formationOffset LUB slotu
    const offset = npc.formationOffset || npc.formationSlot || {x: -50, y: 50};
    
    // Obracamy offset zgodnie z kątem lidera
    const la = leader.angle || 0;
    const ox = offset.x * Math.cos(la) - offset.y * Math.sin(la);
    const oy = offset.x * Math.sin(la) + offset.y * Math.cos(la);
    destX = leader.x + ox;
    destY = leader.y + oy;
  } else {
    // Fallback dla lidera lub bezpańskiego
    destX = npc.x + Math.cos(npc.angle) * 100;
    destY = npc.y + Math.sin(npc.angle) * 100;
  }

  const dirToForm = norm({x: destX - npc.x, y: destY - npc.y}); // FIX
  const distToForm = Math.hypot(destX - npc.x, destY - npc.y);
  
  const speedFactor = (leader) ? 1.1 : 0.5; 
  const wantSpeed = (distToForm > 100) ? npc.maxSpeed * speedFactor : npc.maxSpeed * 0.3;
  
  const turned = clampTurnVec(npc.vx, npc.vy, dirToForm.x * wantSpeed, dirToForm.y * wantSpeed, dt, 180);
  npc.vx = turned.vx;
  npc.vy = turned.vy;
  npc.angle = Math.atan2(npc.vy, npc.vx);
}

// Helper strzelania dla AI (używa definicji z AI SPACE)
function tryFire(npc, target, dt) {
  if(!target) return;
  
  // Pobierz definicję broni przypisanej do NPC
  const gunDef = AISPACE_GUNS[npc.gun] || AISPACE_GUNS.laserS;
  const range = gunDef.range || 400;
  const speed = gunDef.speed || 500;

  const targetX = target.pos ? target.pos.x : target.x;
  const targetY = target.pos ? target.pos.y : target.y;

  // Kąt do celu
  const angleToTarget = Math.atan2(targetY - npc.y, targetX - npc.x);
  const myAngle = Math.atan2(npc.vy, npc.vx);
  const diff = Math.abs(wrapAngle(angleToTarget - myAngle));
  const dist = Math.hypot(targetX - npc.x, targetY - npc.y);

  // Warunek strzału: w zasięgu + celownik na wrogu
  if (dist < range && diff < 0.4 && npc.gunCD <= 0) {
     const lead = getLeadAim(npc, target, speed);
     const dir = norm({x: lead.x - npc.x, y: lead.y - npc.y});
     
     // Rozrzut
     const spread = (gunDef.spread || 2) * (Math.PI/180);
     const a = Math.atan2(dir.y, dir.x) + (Math.random()-0.5)*spread;
     
     window.bullets.push({
        x: npc.x + Math.cos(a) * 12, 
        y: npc.y + Math.sin(a) * 12,
        vx: npc.vx + Math.cos(a) * speed,
        vy: npc.vy + Math.sin(a) * speed,
        life: range / speed,
        r: 3,
        color: gunDef.color || '#fff',
        owner: npc.friendly ? 'player' : 'npc',
        damage: gunDef.dmg || 10,
        type: 'plasma', // Używa standardowego renderera cząsteczek
        source: npc
     });
     
     // Cooldown z parametru rps (rounds per second)
     npc.gunCD = 1.0 / (gunDef.rps || 5);
  }
  
  // Rakiety (jeśli ma)
  if (npc.mslAmmo > 0 && npc.mslCD <= 0 && dist < 1000 && diff < 0.5) {
      const mslDef = AISPACE_MISSILES[npc.msl || 'AF'];
      const dir = norm({ x: targetX - npc.x, y: targetY - npc.y });
      const speedMsl = mslDef.speed || 300;
      window.bullets.push({
        x: npc.x, y: npc.y,
        vx: npc.vx + dir.x * speedMsl,
        vy: npc.vy + dir.y * speedMsl,
        life: mslDef.life || 4,
        r: 4,
        owner: npc.friendly ? 'player' : 'npc',
        damage: mslDef.dmg || 40,
        type: 'rocket',
        target: target, // Homing
        color: mslDef.color,
        turnRate: (mslDef.turn || SIDE_ROCKET_TURN_RATE) * Math.PI / 180,
        homingDelay: 0.2,
        explodeRadius: 40
      });
      npc.mslAmmo--;
      npc.mslCD = 4.0; // Długi reload rakiet
  }
}
function useRailPair(n, target){ /* sprawdź kąt i cooldown, odpal pary */ }
function useRocketsPair(n, target){ /* salwy */ }
function useCIWSPair(n, target){ /* krótka seria */ }
function maybeFireRockets(n, target){ /* warunkowo */ }
Object.defineProperty(PirateSim, 'units', {
  get: function() {
    // Zwraca tablicę: [Gracz, ...Wszystkie żywe NPC]
    // Dzięki temu AI może iterować po 'sim.units' i szukać celów
    return [ship, ...npcs.filter(n => !n.dead)];
  }
});

// 2. Podłącz funkcję strzelania AI do silnika gry
// Kiedy AI wywoła spawnBullet, my przekierujemy to do adaptera, który doda pocisk do gry
window.spawnBullet = function(sim, from, to, weapon) {
  if (window.spawnBulletAdapter) {
     window.spawnBulletAdapter(from, to, weapon);
  } else if (window.aiSpawnBullet) {
     window.aiSpawnBullet(sim, from, to, weapon);
  }
};
async function startGame(){
  if (gameStarted) return;
  gameStarted = true;
  if (mainMenuEl) mainMenuEl.classList.add('hidden');

  showLoadingOverlay(0, 'Przygotowanie świata');
  initStars(true);
  setLoadingProgress(18, 'Generowanie gwiazd');
  await nextFrame();

  initNPCs();
  setLoadingProgress(36, 'Planowanie tras NPC');
  await nextFrame();

  initFleet();
  setLoadingProgress(54, 'Kalibracja floty');
  await nextFrame();

  for(let i=0;i<120;i++) npcStep(PHYS_DT);
  setLoadingProgress(68, 'Symulacja startowa');

  await waitForSpaceBackgroundReady();
  setLoadingProgress(82, 'Tło gwiezdne gotowe');

  await waitForPlanetsReady();
  setLoadingProgress(92, 'Planety i stacje');

  const firstFramePromise = new Promise(resolve => { firstFrameResolver = resolve; });
  lastTime = performance.now();
  acc = 0;
  vfxTime = 0;
  uiRoot?.classList.remove('hidden');
  requestAnimationFrame(loop);

  await firstFramePromise;
  setLoadingProgress(100, 'Gotowe do lotu');
  await nextFrame();
  await new Promise(resolve => setTimeout(resolve, 180));
  hideLoadingOverlay();
  console.log('Gwiazdy: proceduralne kafelki 1024px na całej mapie. Silnik: warkocz jonowy, dopalacz: wiązka fotonów.');
}

if (newGameButton) {
  newGameButton.addEventListener('click', () => startGame());
}
if (loadGameButton) {
  loadGameButton.title = 'Wkrótce dostępne';
}
if (optionsButton) {
  optionsButton.title = 'Wkrótce dostępne';
}
if (supportGuardBtn) {
  supportGuardBtn.addEventListener('click', () => setSupportOrder('guard', { force: true }));
}
if (supportEngageBtn) {
  supportEngageBtn.addEventListener('click', () => setSupportOrder('engage', { force: true }));
}
if (supportSpawnButtons && supportSpawnButtons.forEach) {
  supportSpawnButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const key = btn.dataset.supportSpawn;
      spawnSupportShip(key);
      setSupportOrder('guard', { force: true });
    });
  });
}

function wireDevTools(){
  const saveLS = () => { window.__devtoolsSaveLS?.(); };
  const elUnlimited = document.getElementById('dt-unlimited-warp') || document.getElementById('toggleUnlimitedWarp');
  const elRuler     = document.getElementById('dt-show-ruler') || document.getElementById('toggleRuler');
  const elScale     = document.getElementById('dt-pirate-scale') || document.getElementById('pirScale');
  const elScaleVal  = document.getElementById('dt-pirate-scale-value') || document.getElementById('pirScaleVal');
  const elStation3DScale = document.getElementById('dt-station3d-scale') || document.getElementById('station3DScale');
  const elStation3DScaleVal = document.getElementById('dt-station3d-scale-value') || document.getElementById('station3DScaleVal');
  const elPlanet3D  = document.getElementById('dt-use-planet-stations');
  const elPir3D     = document.getElementById('dt-use-3d-pirate');
  const elSunDir    = document.getElementById('dt-show-sundir');

  if (elUnlimited) {
    elUnlimited.checked = !!DevFlags.unlimitedWarp;
    elUnlimited.addEventListener('change', e => {
      DevFlags.unlimitedWarp = e.target.checked;
      if (DevFlags.unlimitedWarp) warp.fuel = warp.fuelMax;
      const legacyUnlimited = document.getElementById('toggleUnlimitedWarp');
      if (legacyUnlimited) legacyUnlimited.checked = DevFlags.unlimitedWarp;
    });
  }
  if (elRuler) {
    elRuler.checked = !!DevFlags.showRuler;
    elRuler.addEventListener('change', e => {
      DevFlags.showRuler = e.target.checked;
      const legacyRuler = document.getElementById('toggleRuler');
      if (legacyRuler) legacyRuler.checked = DevFlags.showRuler;
    });
  }

  if (elSunDir) {
    elSunDir.checked = !!(window.DevFlags && DevFlags.showSunDir);
    elSunDir.addEventListener('change', e => {
      if (!window.DevFlags) window.DevFlags = {};
      DevFlags.showSunDir = !!e.target.checked;
      if (typeof scheduleRebuild3D === 'function') scheduleRebuild3D();
      saveLS();
    });
  }

  const applyScale = () => {
    if (!elScale) return;
    const v = parseFloat(elScale.value);
    DevTuning.pirateStationScale = isFinite(v) ? v : 1.0;
    if (window.DevConfig) {
      window.DevConfig.pirateScale = DevTuning.pirateStationScale;
    }
    const legacyScale = document.getElementById('pirScale');
    if (legacyScale) legacyScale.value = String(DevTuning.pirateStationScale);
    const legacyScaleVal = document.getElementById('pirScaleVal');
    if (legacyScaleVal) legacyScaleVal.textContent = '×' + DevTuning.pirateStationScale.toFixed(2);
    if (elScaleVal) elScaleVal.textContent = DevTuning.pirateStationScale.toFixed(2);
  };

  const applyStation3DScale = (inputValue) => {
    const parsed = Number(inputValue);
    const fallback = (Number.isFinite(parsed) && parsed > 0)
      ? parsed
      : DEFAULT_STATION_3D_SCALE;
    const value = fallback;
    DevTuning.pirateStationScale = value;
    Dev.station3DScale = value;
    if (window.DevConfig) {
      window.DevConfig.station3DScale = value;
    }
    if (window.USE_STATION_3D && typeof window.__setStation3DScale === 'function') {
      __setStation3DScale(value);
    }
    if (elStation3DScaleVal) elStation3DScaleVal.textContent = value.toFixed(2);
    const legacy = document.getElementById('station3DScale');
    const legacyVal = document.getElementById('station3DScaleVal');
    if (legacy) legacy.value = String(value);
    if (legacyVal) legacyVal.textContent = '×' + value.toFixed(2);
  };

  // Ustaw wartość z DevConfig (jeśli jest) i natychmiast zastosuj na starcie
  if (elStation3DScale) {
    const initialRaw =
      (window.DevConfig && Number.isFinite(DevConfig.station3DScale) && DevConfig.station3DScale) ||
      (Number.isFinite(+elStation3DScale.value) ? +elStation3DScale.value : NaN);
    const initial = (Number.isFinite(initialRaw) && initialRaw > 0)
      ? initialRaw
      : DEFAULT_STATION_3D_SCALE;
    elStation3DScale.value = String(initial);
    applyStation3DScale(initial);
    if (typeof scheduleRebuild3D === 'function') scheduleRebuild3D();
  }

  if (elScale) {
    if (!isFinite(parseFloat(elScale.value))) {
      elScale.value = String(DevTuning.pirateStationScale);
    }
    elScale.addEventListener('input', applyScale);
    elScale.addEventListener('change', applyScale);
    applyScale();
  } else if (elScaleVal) {
    elScaleVal.textContent = DevTuning.pirateStationScale.toFixed(2);
  }

  if (elStation3DScale) {
    if (!isFinite(parseFloat(elStation3DScale.value)) || parseFloat(elStation3DScale.value) <= 0) {
      elStation3DScale.value = String(DevTuning.pirateStationScale);
    }
    applyStation3DScale(elStation3DScale.value);
    elStation3DScale.addEventListener('input', e => applyStation3DScale(e.target.value));
    elStation3DScale.addEventListener('change', e => applyStation3DScale(e.target.value));
  } else if (elStation3DScaleVal) {
    elStation3DScaleVal.textContent = DevTuning.pirateStationScale.toFixed(2);
  }

    if (elPlanet3D) {
      const stored = typeof DevFlags.usePlanetStations3D === 'boolean'
        ? DevFlags.usePlanetStations3D
        : window.USE_PLANET_STATIONS_3D !== false;
      const enabled = stored !== false;
      DevFlags.usePlanetStations3D = enabled;
      window.USE_PLANET_STATIONS_3D = enabled;
      elPlanet3D.checked = enabled;
      elPlanet3D.addEventListener('change', (e) => {
        const value = !!e.target.checked;
        DevFlags.usePlanetStations3D = value;
        window.USE_PLANET_STATIONS_3D = value;
        if (Array.isArray(window.stations) && typeof window.updateStations3D === 'function') {
          window.updateStations3D(window.stations);
        }
        saveLS();
      });
    }

    if (elPir3D){
      if (typeof DevFlags.use3DPirateStation === 'boolean') {
        window.USE_STATION_3D = DevFlags.use3DPirateStation;
      }
      elPir3D.checked = window.USE_STATION_3D !== false;
      elPir3D.addEventListener('change', e=>{
        if (!window.DevFlags) window.DevFlags = {};
        DevFlags.use3DPirateStation = e.target.checked;
        window.USE_STATION_3D = e.target.checked;
        if (window.USE_STATION_3D && window.__setStation3DScale && typeof Dev.station3DScale === 'number') {
          __setStation3DScale(Dev.station3DScale);
        }
      });
    }
  }
  window.wireDevTools = wireDevTools;
  </script>

<!-- === DEVTOOLS (F10) =================================================== -->
<style>
  #devtools{position:fixed; right:16px; top:16px; width:340px; max-height:80vh;
    overflow:auto; padding:14px; border-radius:12px; background:rgba(10,14,25,.92);
    border:1px solid #1b2337; color:#dfe7ff; z-index:1000; font-family:Inter, system-ui, Segoe UI, Roboto, Arial; display:none}
  #devtools h3{margin:0 0 8px 0; font-size:16px; letter-spacing:.04em; text-transform:uppercase; color:#8fb5ff}
  #devtools .group{margin:12px 0; padding:10px; background:#0b0f1a; border:1px solid #1b2337; border-radius:10px}
  #devtools .row{display:flex; align-items:center; gap:8px; margin:6px 0}
  #devtools .row label{flex:1}
  #devtools input[type=range]{width:180px}
  #devtools .val{min-width:64px; text-align:right; font-variant-numeric: tabular-nums}
  #devtools .small{opacity:.7; font-size:12px}
  #devtools .pill{display:inline-block; padding:2px 8px; border:1px solid #2a3a5a; border-radius:999px; background:#0a1020}
  #devtools textarea{width:100%; height:90px; background:#0b1224; color:#dfe7ff; border:1px solid #2a3a5a; border-radius:8px; padding:8px}
  #devtools .muted{color:#9fb0d8}
  #devtools .dt-row{display:flex; gap:8px; margin-top:6px}
  #devtools .dt-col{display:flex; flex-direction:column}
  #devtools .dt-stack{display:flex; flex-direction:column}
  #devtools .dt-btn{padding:4px 8px; border:1px solid #2a3a5a; border-radius:8px; background:#0a1020; color:#dfe7ff; cursor:pointer}
  #devtools .dt-btn:hover{background:#18233c}
  #devtools .dt-label{font-size:12px; font-weight:600; letter-spacing:.04em; text-transform:uppercase; color:#9fb0d8}
</style>

<div id="devtools">
  <h3>DevTools</h3>

  <div class="group">
    <div class="row"><strong>Wszechświat</strong></div>
    <div class="row">
      <label>Słońce – promień 2D (R)</label>
      <input id="sunR2D" type="range" min="50" max="1500" step="1" value="823">
      <div class="val" id="sunR2DVal"></div>
    </div>
    <div class="row">
      <label>Słońce – promień 3D (R)</label>
      <input id="sunR3D" type="range" min="50" max="1500" step="1" value="399">
      <div class="val" id="sunR3DVal"></div>
    </div>
    <div class="row">
      <label>Planety – skala globalna (×)</label>
      <input id="planetScaleAll" type="range" min="0.5" max="3" step="0.01" value="1">
      <div class="val" id="planetScaleAllVal"></div>
    </div>
  </div>

  <div class="group" id="planetsGroup">
    <div class="row"><strong>Planety (R)</strong> <span class="small muted">(per-planeta)</span></div>
    <!-- Tu JS doda po 1 wierszu na planetę -->
  </div>

  <!-- === Dystanse od Słońca (AU → promień orbity) ======================== -->
  <div class="group" id="distancesGroup">
    <div class="row">
      <strong>Dystanse od Słońca</strong>
      <span class="small muted">(AU → promień orbity)</span>
    </div>
    <!-- Wiersze z suwakami będą dodane przez buildDistancesUI() -->
  </div>

  <div class="group">
    <div class="row"><strong>Stacje</strong></div>
    <div class="row">
      <label>Skala stacji pirackiej (×)</label>
      <input id="pirScale" type="range" min="0.4" max="12" step="0.01" value="6">
      <div class="val" id="pirScaleVal"></div>
    </div>
    <div class="row">
      <label>Skala stacji 3D (×)</label>
      <input id="station3DScale" type="range" min="0.2" max="12.0" step="0.05" value="2.70">
      <div class="val" id="station3DScaleVal"></div>
    </div>
    <div class="row">
      <label>Stacja 3D – rozmiar sprite (px)</label>
      <input id="stationSpritePx" type="number" min="64" max="4096" step="32" value="1024" style="width:96px;">
    </div>
    <div class="dt-row">
      <div class="dt-col">
        <div class="dt-label" style="margin-top:6px;">Skala per stacja</div>
        <div id="dt-stations-per-scale" class="dt-stack" style="gap:6px;"></div>
        <button id="dt-reset-station-scales" class="dt-btn" style="margin-top:6px;">Reset per stacja</button>
      </div>
    </div>
    <label style="display:flex;gap:6px;align-items:center;margin-top:8px">
      <input id="dt-use-planet-stations" type="checkbox" />
      Planet Stations 3D (overlay)
    </label>
    <label style="display:flex;gap:6px;align-items:center;margin-top:8px">
      <input id="dt-use-3d-pirate" type="checkbox" />
      3D Pirate Station (hide 2D)
    </label>
  </div>

  <div class="group" id="stationsFramesGroup">
    <div class="row"><strong>Stacje (kadr per stacja)</strong></div>
    <!-- Wiersze z suwakami per stacja będą dodane dynamicznie przez buildStationFramesUI() -->
  </div>

  <div class="group" id="warpVfxGroup">
    <div class="row"><strong>Warp Wormhole VFX</strong> <span class="small muted">(soczewka statku)</span></div>
    <div class="row">
      <label>Próg trybu pełnego</label>
      <input id="warpLensThreshold" type="range" min="0" max="1" step="0.01">
      <input id="warpLensThresholdNum" type="number" min="0" max="1" step="0.01" style="width:72px;">
      <div class="val" id="warpLensThresholdVal"></div>
    </div>
    <div class="row">
      <label>Promień bazowy</label>
      <input id="warpRadiusBase" type="range" min="0.05" max="0.6" step="0.005">
      <input id="warpRadiusBaseNum" type="number" min="0.05" max="0.6" step="0.005" style="width:72px;">
      <div class="val" id="warpRadiusBaseVal"></div>
    </div>
    <div class="row">
      <label>Promień — skala</label>
      <input id="warpRadiusScale" type="range" min="0" max="0.3" step="0.005">
      <input id="warpRadiusScaleNum" type="number" min="0" max="0.3" step="0.005" style="width:72px;">
      <div class="val" id="warpRadiusScaleVal"></div>
    </div>
    <div class="row">
      <label>Masa bazowa</label>
      <input id="warpMassBase" type="range" min="0" max="0.5" step="0.005">
      <input id="warpMassBaseNum" type="number" min="0" max="0.5" step="0.005" style="width:72px;">
      <div class="val" id="warpMassBaseVal"></div>
    </div>
    <div class="row">
      <label>Masa — skala</label>
      <input id="warpMassScale" type="range" min="0" max="0.6" step="0.005">
      <input id="warpMassScaleNum" type="number" min="0" max="0.6" step="0.005" style="width:72px;">
      <div class="val" id="warpMassScaleVal"></div>
    </div>
    <div class="row">
      <label>Miękkość krawędzi</label>
      <input id="warpSoftness" type="range" min="0" max="1" step="0.01">
      <input id="warpSoftnessNum" type="number" min="0" max="1" step="0.01" style="width:72px;">
      <div class="val" id="warpSoftnessVal"></div>
    </div>
    <div class="row">
      <label>Przezroczystość bazowa</label>
      <input id="warpOpacityBase" type="range" min="0" max="1" step="0.01">
      <input id="warpOpacityBaseNum" type="number" min="0" max="1" step="0.01" style="width:72px;">
      <div class="val" id="warpOpacityBaseVal"></div>
    </div>
    <div class="row">
      <label>Przezroczystość — skala</label>
      <input id="warpOpacityScale" type="range" min="0" max="1" step="0.01">
      <input id="warpOpacityScaleNum" type="number" min="0" max="1" step="0.01" style="width:72px;">
      <div class="val" id="warpOpacityScaleVal"></div>
    </div>
    <div class="row">
      <label>Wydłużenie wzdłuż lotu</label>
      <input id="warpLensForwardStretch" type="range" min="0.1" max="2" step="0.01">
      <input id="warpLensForwardStretchNum" type="number" min="0.1" max="2" step="0.01" style="width:72px;">
      <div class="val" id="warpLensForwardStretchVal"></div>
    </div>
    <div class="row">
      <label>Offset wzdłuż kadłuba</label>
      <input id="warpTailDepthExtra" type="range" min="-0.2" max="0.8" step="0.01">
      <input id="warpTailDepthExtraNum" type="number" min="-0.2" max="0.8" step="0.01" style="width:72px;">
      <div class="val" id="warpTailDepthExtraVal"></div>
    </div>
  </div>

  <div class="group">
    <div class="row">
      <label><input id="toggleRuler" type="checkbox"> Miarka (okręgi dystansu) <span class="pill">F11</span></label>
    </div>
    <div class="row">
      <label><input id="toggleUnlimitedWarp" type="checkbox"> Nielimitowany warp <span class="pill">F9</span></label>
    </div>
    <div class="row">
      <label><input id="dt-show-sundir" type="checkbox"> Pokaż kierunek słońca</label>
    </div>
    <div class="row">
      <label><input id="dt-disable-shake" type="checkbox"> Wyłącz wstrząsy kamery</label>
    </div>
  </div>

  <div class="group">
    <div class="row"><strong>Konfiguracja</strong></div>
    <div class="row">
      <button id="btnCopy">Kopiuj aktualną konfigurację</button>
      <button id="btnReset" style="margin-left:auto">Reset</button>
    </div>
    <div class="row"><textarea id="cfgOut" readonly></textarea></div>
    <div class="small muted">Skopiuj JSON i wklej do kodu (np. stałe R), gdy chcesz utrwalić w repo.</div>
  </div>

  <div class="small muted">F10 — pokaż/ukryj panel</div>
</div>
<!-- ====================================================================== -->

<script>
(function(){
  // Nie nadpisuj obiektu! Zachowaj referencję, bo gameplay trzyma do niej const.
  const __devtoolsDefaults = {
    showRuler: false,
    unlimitedWarp: false,
    showSunDir: false,
    use3DPirateStation: true,
    usePlanetStations3D: true,
    disableCameraShake: false
  };
  if (!window.DevFlags) window.DevFlags = {};
  for (const k in __devtoolsDefaults) {
    if (!(k in window.DevFlags)) window.DevFlags[k] = __devtoolsDefaults[k];
  }
  const DevFlags = window.DevFlags; // lokalny skrót do TEGO SAMEGO obiektu
  const DEFAULT_PIRATE_SCALE = (
    typeof window !== 'undefined' && typeof window.DEFAULT_STATION_SCALE === 'number'
  ) ? window.DEFAULT_STATION_SCALE : 6;
  const DEFAULT_STATION3D_SCALE = (
    typeof window !== 'undefined' && typeof window.DEFAULT_STATION_3D_SCALE === 'number'
  ) ? window.DEFAULT_STATION_3D_SCALE : 2.70;

  const Dev = window.Dev = window.Dev || {};
  const DevTuning = window.DevTuning = Object.assign({
    pirateStationScale: DEFAULT_PIRATE_SCALE
  }, window.DevTuning || {});

  if (!Number.isFinite(Dev.station3DScale) || Dev.station3DScale <= 0) {
    Dev.station3DScale = DEFAULT_STATION3D_SCALE;
  }

  // Klasyczny skrypt nie widzi stałych z ESM — korzystaj z window.* w runtime.
  // === Wczytaj podstawowe obiekty gry (muszą już istnieć globalnie): SUN, planets, initPlanets3D ===
  // Zakładamy: let SUN = {...}, let planets = [...]; render pętla już działa.

  // ---- Stan & persistencja ------------------------------------------------
  const DevConfig = {
    sunR2D: 823,               // liczba — promień Słońca (warstwa 2D)
    sunR3D: 399,               // liczba — promień Słońca (warstwa 3D)
    planetRById: {},           // { [id or name]: R }
    planetOrbitAUById: {
      mercury: 0.84,
      venus: 1.41,
      earth: 2.07,
      mars: 2.86,
      jupiter: 5.2,
      saturn: 9.58,
      uranus: 19.2,
      neptune: 30
    },      // { [id or name]: AU }
    // Nie zależ od momentu ładowania modułów – czytaj z window w runtime.
    planetScaleAll: (typeof window.DEFAULT_PLANET_SCALE === 'number' ? window.DEFAULT_PLANET_SCALE : 1),                  // mnożnik globalny ×R
    pirateScale: DEFAULT_PIRATE_SCALE,           // mnożnik rysowania stacji pirackiej
    station3DScale: DEFAULT_STATION3D_SCALE,     // mnożnik nakładki 3D
    stationSpriteSize: 1024,
    stationSpriteFrame: 1.25,
    stationSpriteFrameById: {},
    stationScaleById: { earth: 1.14 },
  };
  window.DevConfig = DevConfig;

  const WarpLensDefaults = (window.__WARP_LENS_DEFAULTS && typeof window.__WARP_LENS_DEFAULTS === 'object')
    ? window.__WARP_LENS_DEFAULTS
    : {
        threshold: 0,
        radiusBase: 0.350,
        radiusScale: 0.01,
        massBase: 0.32,
        massScale: 0.365,
        softness: 0.6,
        opacityBase: 0.55,
        opacityScale: 0.73,
        tailDepthExtra: -0.2,
        forwardStretch: 1.0
      };
  if (!window.__WARP_LENS_DEFAULTS) {
    window.__WARP_LENS_DEFAULTS = WarpLensDefaults;
  }
  const DevVFX = window.DevVFX = window.DevVFX || {};
  DevVFX.warpLens = Object.assign({}, WarpLensDefaults, DevVFX.warpLens || {});

  // ---- Elementy UI --------------------------------------------------------
  const el = (id)=>document.getElementById(id);
  const ui = {};
  const uiIds = {
    root: 'devtools',
    sunR2D: 'sunR2D',
    sunR2DVal: 'sunR2DVal',
    sunR3D: 'sunR3D',
    sunR3DVal: 'sunR3DVal',
    planetScaleAll: 'planetScaleAll',
    planetScaleAllVal: 'planetScaleAllVal',
    pirScale: 'pirScale',
    pirScaleVal: 'pirScaleVal',
    station3DScale: 'station3DScale',
    station3DScaleVal: 'station3DScaleVal',
    stationSpritePx: 'stationSpritePx',
    stationsFramesGroup: 'stationsFramesGroup',
    planetsGroup: 'planetsGroup',
    distancesGroup: 'distancesGroup',
    cbRuler: 'toggleRuler',
    cbUnlimited: 'toggleUnlimitedWarp',
    cbSunDir: 'dt-show-sundir',
    cbShake: 'dt-disable-shake',
    cbPlanetStations3D: 'dt-use-planet-stations',
    cbPirate3D: 'dt-use-3d-pirate',
    btnCopy: 'btnCopy',
    btnReset: 'btnReset',
    cfgOut: 'cfgOut'
  };

  function refreshUIRefs(){
    for (const [key, id] of Object.entries(uiIds)) {
      ui[key] = el(id);
    }
  }

  refreshUIRefs();
  window.__refreshDevUIRefs = refreshUIRefs;

  const warpLensUI = {
    threshold: { slider: el('warpLensThreshold'), number: el('warpLensThresholdNum'), label: el('warpLensThresholdVal'), decimals: 2 },
    radiusBase: { slider: el('warpRadiusBase'), number: el('warpRadiusBaseNum'), label: el('warpRadiusBaseVal'), decimals: 3 },
    radiusScale: { slider: el('warpRadiusScale'), number: el('warpRadiusScaleNum'), label: el('warpRadiusScaleVal'), decimals: 3 },
    massBase: { slider: el('warpMassBase'), number: el('warpMassBaseNum'), label: el('warpMassBaseVal'), decimals: 3 },
    massScale: { slider: el('warpMassScale'), number: el('warpMassScaleNum'), label: el('warpMassScaleVal'), decimals: 3 },
    softness: { slider: el('warpSoftness'), number: el('warpSoftnessNum'), label: el('warpSoftnessVal'), decimals: 2 },
    opacityBase: { slider: el('warpOpacityBase'), number: el('warpOpacityBaseNum'), label: el('warpOpacityBaseVal'), decimals: 2 },
    opacityScale: { slider: el('warpOpacityScale'), number: el('warpOpacityScaleNum'), label: el('warpOpacityScaleVal'), decimals: 2 },
    forwardStretch: { slider: el('warpLensForwardStretch'), number: el('warpLensForwardStretchNum'), label: el('warpLensForwardStretchVal'), decimals: 2 },
    tailDepthExtra: { slider: el('warpTailDepthExtra'), number: el('warpTailDepthExtraNum'), label: el('warpTailDepthExtraVal'), decimals: 2 }
  };
  ui.warpLens = warpLensUI;

  const warpLensRanges = {
    threshold: { min: 0, max: 1 },
    radiusBase: { min: 0.01, max: 1 },
    radiusScale: { min: 0, max: 0.6 },
    massBase: { min: 0, max: 1 },
    massScale: { min: 0, max: 1 },
    softness: { min: 0, max: 1 },
    opacityBase: { min: 0, max: 1 },
    opacityScale: { min: 0, max: 1 },
    forwardStretch: { min: 0.1, max: 3 },
    tailDepthExtra: { min: -1, max: 1 }
  };

  function sanitizeWarpLensValue(key, raw){
    const defaults = WarpLensDefaults;
    const range = warpLensRanges[key] || {};
    let v = Number(raw);
    if (!Number.isFinite(v)) v = defaults[key];
    if (typeof range.min === 'number') v = Math.max(range.min, v);
    if (typeof range.max === 'number') v = Math.min(range.max, v);
    return v;
  }

  function setWarpLensField(key, value){
    const ctrl = warpLensUI[key];
    if (!ctrl) return;
    const decimals = typeof ctrl.decimals === 'number' ? ctrl.decimals : 2;
    const formatted = value.toFixed(decimals);
    if (ctrl.slider) ctrl.slider.value = String(value);
    if (ctrl.number) ctrl.number.value = formatted;
    if (ctrl.label) ctrl.label.textContent = formatted;
  }

  function reflectWarpLensToUI(){
    for (const key in warpLensUI){
      const value = DevVFX.warpLens?.[key];
      const defaults = WarpLensDefaults;
      const v = Number.isFinite(value) ? value : defaults[key];
      setWarpLensField(key, v);
    }
  }

  function applyWarpLensValue(key, raw){
    const value = sanitizeWarpLensValue(key, raw);
    if (!DevVFX.warpLens) DevVFX.warpLens = {};
    DevVFX.warpLens[key] = value;
    setWarpLensField(key, value);
    saveLS();
    reflectToCfg();
  }

  // ---- Inicjalne odczyty z gry -------------------------------------------
  function bootstrapFromGame(){
    const sun = window.SUN;
    if (sun) {
      if (DevConfig.sunR2D == null) DevConfig.sunR2D = sun.r;
      if (DevConfig.sunR3D == null) {
        const base3D = (typeof sun.r3D === 'number') ? sun.r3D : sun.r;
        DevConfig.sunR3D = base3D;
      }
    }
    // domyślne per-planeta (key = name lub id)
    const planetList = Array.isArray(window.planets) ? window.planets : [];
    for (const p of planetList) {
      const key = (p.name || p.id || String(p.index)||'').toString().toLowerCase();
      const baseR = p.baseR ?? p.r;
      if (baseR != null && !Number.isFinite(DevConfig.planetRById[key])) {
        DevConfig.planetRById[key] = baseR;
      }
    }
  }

  function stationKey(st) {
    if (!st) return null;
    if (st.id != null) return String(st.id).toLowerCase();
    if (st.name) return String(st.name).toLowerCase();
    return null;
  }

  // ---- Persistencja -------------------------------------------------------
  function loadLS(){
    try {
      const cfg = JSON.parse(localStorage.getItem('devConfig')||'null');
      if (cfg && typeof cfg==='object'){
        Object.assign(DevConfig, cfg);
        if (typeof DevConfig.pirateScale === 'number') {
          DevTuning.pirateStationScale = DevConfig.pirateScale;
        }
        if (typeof DevConfig.station3DScale === 'number') {
          if (DevConfig.station3DScale > 0) {
            Dev.station3DScale = DevConfig.station3DScale;
          } else {
            DevConfig.station3DScale = DEFAULT_STATION3D_SCALE;
            Dev.station3DScale = DEFAULT_STATION3D_SCALE;
          }
        }
      }
    } catch {}
    // devFlags w osobnym bloku – defensywnie:
    let saved = null;
    try { saved = JSON.parse(localStorage.getItem('devFlags') || 'null'); } catch {}
    if (saved && typeof saved === 'object') {
      // Mutacja ISTNIEJĄCEGO obiektu, bez utraty referencji
      Object.assign(window.DevFlags, saved);
    }
    if (typeof DevFlags.usePlanetStations3D !== 'boolean') {
      DevFlags.usePlanetStations3D = true;
    }
    if (typeof DevFlags.disableCameraShake !== 'boolean') {
      DevFlags.disableCameraShake = false;
    }
    try {
      const savedVfx = JSON.parse(localStorage.getItem('devVfx') || 'null');
      if (savedVfx && typeof savedVfx === 'object') {
        const savedLens = savedVfx.warpLens;
        if (savedLens && typeof savedLens === 'object') {
          DevVFX.warpLens = Object.assign({}, WarpLensDefaults, savedLens);
        }
      }
    } catch {}
    if (typeof window !== 'undefined') {
      window.USE_PLANET_STATIONS_3D = DevFlags.usePlanetStations3D !== false;
    }
    if (!DevConfig.planetOrbitAUById || typeof DevConfig.planetOrbitAUById !== 'object') {
      DevConfig.planetOrbitAUById = {};
    }
    if (typeof DevConfig.planetScaleAll !== 'number') {
      DevConfig.planetScaleAll = (typeof window.DEFAULT_PLANET_SCALE === 'number' ? window.DEFAULT_PLANET_SCALE : 1);
    }
    if (typeof DevConfig.pirateScale !== 'number') {
      DevConfig.pirateScale = DevTuning.pirateStationScale;
    }
    if (typeof DevConfig.station3DScale !== 'number' || DevConfig.station3DScale <= 0) {
      const fallback = (Dev.station3DScale > 0) ? Dev.station3DScale : DEFAULT_STATION3D_SCALE;
      DevConfig.station3DScale = fallback;
    }
    if (typeof DevConfig.stationSpriteSize !== 'number') {
      let saved = NaN;
      try {
        saved = Number(localStorage.getItem('stationSpriteSize'));
      } catch {}
      DevConfig.stationSpriteSize = Number.isFinite(saved) ? saved : 512;
    }
    if (typeof DevConfig.stationSpriteFrame !== 'number') {
      let saved = NaN;
      try {
        saved = Number(localStorage.getItem('stationSpriteFrame'));
      } catch {}
      DevConfig.stationSpriteFrame = Number.isFinite(saved) ? saved : 1.25;
    }
    if (!DevConfig.stationSpriteFrameById || typeof DevConfig.stationSpriteFrameById !== 'object') {
      try {
        DevConfig.stationSpriteFrameById = JSON.parse(localStorage.getItem('stationSpriteFrameById') || '{}') || {};
      } catch {
        DevConfig.stationSpriteFrameById = {};
      }
    }
    if (!DevConfig.stationScaleById || typeof DevConfig.stationScaleById !== 'object') {
      DevConfig.stationScaleById = {};
    }
    const legacySun = Number.isFinite(DevConfig.sunR) ? +DevConfig.sunR : null;
    if (!Number.isFinite(DevConfig.sunR2D) && legacySun != null) {
      DevConfig.sunR2D = legacySun;
    }
    if (!Number.isFinite(DevConfig.sunR3D) && legacySun != null) {
      DevConfig.sunR3D = legacySun;
    }
    if (!Number.isFinite(DevConfig.sunR2D)) {
      DevConfig.sunR2D = null;
    }
    if (!Number.isFinite(DevConfig.sunR3D) && Number.isFinite(DevConfig.sunR2D)) {
      DevConfig.sunR3D = DevConfig.sunR2D;
    }
    delete DevConfig.sunR;
    if (window.__setStation3DScale && window.USE_STATION_3D) {
      window.__lastStationScale = 1;
      __setStation3DScale(Dev.station3DScale);
    }
  }
  function saveLS(){
    localStorage.setItem('devConfig', JSON.stringify(DevConfig));
    localStorage.setItem('devFlags', JSON.stringify(DevFlags));
    try { localStorage.setItem('devVfx', JSON.stringify({ warpLens: DevVFX.warpLens })); } catch {}
  }
  window.__devtoolsSaveLS = saveLS;

  // ---- Rebuild 3D (throttle) ---------------------------------------------
  let rebuildTimer = null;
  function scheduleRebuild3D(){
    if (rebuildTimer) cancelAnimationFrame(rebuildTimer);
    rebuildTimer = requestAnimationFrame(()=> {
      // aktualizujemy struktury gry na podstawie DevConfig
      const gameSun = window.SUN || { r: 823, r3D: 399 }; 

const numericSun2D = Number.isFinite(DevConfig.sunR2D) ? DevConfig.sunR2D : gameSun.r;
      const appliedSun2D = Math.max(1, Math.round(numericSun2D || 0));
      SUN.r = appliedSun2D;
      const numericSun3D = Number.isFinite(DevConfig.sunR3D) ? DevConfig.sunR3D : appliedSun2D;
      const appliedSun3D = Math.max(1, Math.round(numericSun3D || 0));
      SUN.r3D = appliedSun3D;
      const defaultScale = (typeof window.DEFAULT_PLANET_SCALE === 'number' ? window.DEFAULT_PLANET_SCALE : 1);
      const scaleAll = Number.isFinite(+DevConfig.planetScaleAll) && +DevConfig.planetScaleAll > 0
        ? +DevConfig.planetScaleAll
        : defaultScale;
      const planetList = Array.isArray(window.planets) ? window.planets : [];
      for (const p of planetList) {
        const key = (p.name || p.id || String(p.index)||'').toString().toLowerCase();
        const base = DevConfig.planetRById[key] ?? p.baseR ?? p.r;
        if (base != null) {
          p.baseR = base;
          p.r = Math.max(1, Math.round(base * scaleAll));
        }
      }
      // Odbudowa warstwy 3D
      if (typeof initPlanets3D === 'function') {
        const sunFor3D = Object.assign({}, SUN, { r: appliedSun3D });
        if (!Number.isFinite(sunFor3D.r3D)) sunFor3D.r3D = appliedSun3D;
        initPlanets3D(planetList, sunFor3D);
      }
    });
  }

  // ---- Rysowanie miarki ---------------------------------------------------
  window.drawRangeRings = function drawRangeRings(ctx, cam){
    drawRangeRuler(ctx, cam);
  };

  function drawSunDirection(ctx, cam){
    if (!DevFlags.showSunDir) return;
    const planets = Array.isArray(window.planets) ? window.planets : null;
    const sun = (window.SUN || SUN);
    if (!planets || !sun) return;

    const camX = cam?.x ?? 0;
    const camY = cam?.y ?? 0;
    const zoom = cam?.zoom ?? 1;
    const halfW = canvas.width / 2;
    const halfH = canvas.height / 2;

    ctx.save();
    ctx.strokeStyle = '#66c2ff';
    ctx.fillStyle = '#cfe3ff';
    ctx.lineWidth = Math.max(1, 2 * zoom);
    ctx.font = `${Math.max(10, Math.round(12 * zoom))}px monospace`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'alphabetic';

    const dash = Math.max(6, 12 * zoom);
    const labelOffset = 6 * zoom;
    const arrowSize = Math.max(8, 14 * zoom);

    for (const planet of planets) {
      if (!planet || typeof planet.x !== 'number' || typeof planet.y !== 'number') continue;

      const dx = (sun.x ?? 0) - planet.x;
      const dy = (sun.y ?? 0) - planet.y;
      const dist = Math.hypot(dx, dy);
      if (!isFinite(dist) || dist <= 0.0001) continue;

      const ux = dx / dist;
      const uy = dy / dist;

      const sx = (planet.x - camX) * zoom + halfW;
      const sy = (planet.y - camY) * zoom + halfH;

      const segWorld = Math.min(Math.max(dist * 0.25, 80), 240);
      const len = segWorld * zoom;
      const ex = sx + ux * len;
      const ey = sy + uy * len;

      ctx.setLineDash([dash, dash]);
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(ex, ey);
      ctx.stroke();

      ctx.setLineDash([]);

      const ang = Math.atan2(uy, ux);
      ctx.beginPath();
      ctx.moveTo(ex, ey);
      ctx.lineTo(ex - Math.cos(ang - 0.4) * arrowSize, ey - Math.sin(ang - 0.4) * arrowSize);
      ctx.lineTo(ex - Math.cos(ang + 0.4) * arrowSize, ey - Math.sin(ang + 0.4) * arrowSize);
      ctx.closePath();
      ctx.fillStyle = '#66c2ff';
      ctx.fill();

      ctx.fillStyle = '#cfe3ff';
      ctx.fillText('Sun →', ex + labelOffset, ey - labelOffset);
    }

    ctx.restore();
  }
  window.drawSunDirection = drawSunDirection;

  // ---- Cheat: unlimited warp ---------------------------------------------
  window.devtoolsApplyCheats = function devtoolsApplyCheats(){
    const f = window.DevFlags || {};
    if (!f.unlimitedWarp) return;
    const s = window.ship;
    if (s && s.warp){
      if ('cooldown' in s.warp) s.warp.cooldown = 0;
      if ('charge'   in s.warp) s.warp.charge   = s.warp.chargeMax ?? s.warp.maxCharge ?? 1;
      if ('energy'   in s.warp) s.warp.energy   = s.warp.energyMax ?? s.warp.maxEnergy ?? 1;
    }
    if (typeof window.warpCooldown === 'number') window.warpCooldown = 0;
    if (typeof window.warpEnergy === 'number' && typeof window.warpEnergyMax === 'number'){
      window.warpEnergy = window.warpEnergyMax;
    }
  };

  // ---- Hook na stację piracką (rysowanie) --------------------------------
  // W drawStation*(...) gdzie skalujesz sprite/canvas po st.r — zamień na:
  //   const R = st.r * (st.style==='pirate' || st.name?.toLowerCase().includes('pir') ? DevConfig.pirateScale : 1);
  // Jeśli jest osobna funkcja wyliczająca promień — użyj jej (patrz Krok 4: „diff”).

  // ---- UI init ------------------------------------------------------------
  function buildPlanetsUI(){
    refreshUIRefs();
    const root = ui.planetsGroup;
    if (!root) return;
    // wyczyść stare
    root.querySelectorAll('.row.p').forEach(n=>n.remove());

    const planetList = Array.isArray(window.planets) ? window.planets : null;
    if (!planetList || planetList.length === 0){
      if (!buildPlanetsUI._retryTimer){
        buildPlanetsUI._retryTimer = setTimeout(()=>{
          buildPlanetsUI._retryTimer = null;
          buildPlanetsUI();
        }, 500);
      }
      return;
    }
    if (buildPlanetsUI._retryTimer){
      clearTimeout(buildPlanetsUI._retryTimer);
      buildPlanetsUI._retryTimer = null;
    }

    // wylicz bazowe promienie dla UI i dołóż po 1 wierszu per planeta
    const planetDefaults = new Map();
    for (const p of planetList){
      const key = (p.name || p.id || String(p.index)||'').toString().toLowerCase();
      const stored = DevConfig.planetRById[key];
      const base = Number.isFinite(stored)
        ? stored
        : (Number.isFinite(p.baseR)
          ? p.baseR
          : (Number.isFinite(p.r) ? p.r : 100));
      planetDefaults.set(key, base);
      if (!Number.isFinite(stored)) {
        DevConfig.planetRById[key] = base;
      }
      const row = document.createElement('div');
      row.className = 'row p';
      row.innerHTML = `
        <label>${p.name||('Planet '+(p.id??''))}</label>
        <input data-k="${key}" class="plR" type="range" min="20" max="10000" step="1">
        <div class="val" id="val_${key}"></div>
      `;
      root.appendChild(row);
    }
    // podpinki
    root.querySelectorAll('input.plR').forEach(inp=>{
      const k = inp.dataset.k;
      const initial = planetDefaults.get(k);
      const value = Number.isFinite(initial) ? initial : 100;
      inp.value = value;
      el('val_'+k).textContent = value;
      inp.addEventListener('input', ()=>{
        DevConfig.planetRById[k] = +inp.value;
        el('val_'+k).textContent = inp.value;
        saveLS(); scheduleRebuild3D(); reflectToCfg();
      });
    });
  }

  function reflectToUI(){
    refreshUIRefs();
    DevConfig.pirateScale = DevTuning.pirateStationScale;
    DevConfig.station3DScale = Dev.station3DScale;
    if (ui.sunR2D) {
      const value2D = Number.isFinite(DevConfig.sunR2D) ? DevConfig.sunR2D|0 : SUN.r|0;
      ui.sunR2D.value = value2D;
      if (ui.sunR2DVal) ui.sunR2DVal.textContent = value2D;
    }
    if (ui.sunR3D) {
      const fallback3D = Number.isFinite(DevConfig.sunR2D) ? DevConfig.sunR2D : gameSun.r;
      const value3D = Number.isFinite(DevConfig.sunR3D) ? DevConfig.sunR3D|0 : fallback3D|0;
      ui.sunR3D.value = value3D;
      if (ui.sunR3DVal) ui.sunR3DVal.textContent = value3D;
    }
    ui.planetScaleAll.value = DevConfig.planetScaleAll; ui.planetScaleAllVal.textContent = '×'+(+DevConfig.planetScaleAll).toFixed(2);
    ui.pirScale.value = DevConfig.pirateScale; ui.pirScaleVal.textContent = '×'+(+DevConfig.pirateScale).toFixed(2);
    if (ui.station3DScale) {
      ui.station3DScale.value = DevConfig.station3DScale;
      if (ui.station3DScaleVal) ui.station3DScaleVal.textContent = '×'+(+DevConfig.station3DScale).toFixed(2);
    }
    if (ui.stationSpritePx) ui.stationSpritePx.value = DevConfig.stationSpriteSize|0;
    ui.cbRuler.checked = DevFlags.showRuler;
    ui.cbUnlimited.checked = DevFlags.unlimitedWarp;
    if (ui.cbSunDir) ui.cbSunDir.checked = DevFlags.showSunDir;
    if (ui.cbShake) ui.cbShake.checked = DevFlags.disableCameraShake;
    if (ui.cbPlanetStations3D) ui.cbPlanetStations3D.checked = DevFlags.usePlanetStations3D !== false;
    if (ui.cbPirate3D) ui.cbPirate3D.checked = DevFlags.use3DPirateStation;
    reflectWarpLensToUI();
  }
  function reflectToCfg(){
    const out = {
      sunR2D: Number.isFinite(DevConfig.sunR2D) ? DevConfig.sunR2D|0 : SUN.r|0,
      sunR3D: Number.isFinite(DevConfig.sunR3D)
        ? DevConfig.sunR3D|0
        : (Number.isFinite(DevConfig.sunR2D) ? DevConfig.sunR2D|0 : SUN.r|0),
      planetRById: DevConfig.planetRById,
      planetScaleAll: +DevConfig.planetScaleAll,
      pirateScale: +DevConfig.pirateScale,
      station3DScale: +DevConfig.station3DScale,
      stationSpriteSize: +DevConfig.stationSpriteSize,
      stationSpriteFrame: +DevConfig.stationSpriteFrame,
      stationSpriteFrameById: DevConfig.stationSpriteFrameById,
      planetOrbitAUById: collectAUForExport(),
      stationScaleById: DevConfig.stationScaleById,
      warpLens: collectWarpLensForExport()
    };
    ui.cfgOut.value = JSON.stringify(out, null, 2);
  }
  window.__devtoolsReflectToCfg = reflectToCfg;

  function collectWarpLensForExport(){
    const out = {};
    const defaults = WarpLensDefaults;
    const lens = DevVFX.warpLens || {};
    for (const key in defaults){
      const raw = lens[key];
      const value = Number.isFinite(raw) ? raw : defaults[key];
      out[key] = +value;
    }
    return out;
  }

  function getBaseOrbit(){
    const winOrbit = (typeof window !== 'undefined' && typeof window.BASE_ORBIT === 'number')
      ? window.BASE_ORBIT
      : NaN;
    if (Number.isFinite(winOrbit) && winOrbit > 0) {
      return winOrbit;
    }
    const localOrbit = (typeof BASE_ORBIT === 'number') ? BASE_ORBIT : NaN;
    if (Number.isFinite(localOrbit) && localOrbit > 0) {
      return localOrbit;
    }
    return NaN;
  }

  function fmtU(worldDist){
    if (typeof worldDist !== 'number' || !Number.isFinite(worldDist)) return '?';
    const abs = Math.abs(worldDist);
    if (abs >= 100000) return worldDist.toFixed(0);
    if (abs >= 10000)  return worldDist.toFixed(1);
    if (abs >= 1000)   return worldDist.toFixed(1);
    if (abs >= 100)    return worldDist.toFixed(2);
    if (abs >= 1)      return worldDist.toFixed(2);
    if (abs >= 0.01)   return worldDist.toFixed(2);
    return worldDist.toExponential(2).replace('+', '');
  }
  function keyFor(p){
    return (p.name || p.id || String(p.index) || '').toString().toLowerCase();
  }
  function formatAUValue(worldDist){
    const baseOrbit = getBaseOrbit();
    if (!Number.isFinite(baseOrbit) || baseOrbit <= 0) return 0;
    return worldDist / baseOrbit;
  }
  function collectAUForExport(){
    const map = {};
    if (!Array.isArray(window.planets) || !window.SUN) return map;
    const sun = window.SUN;
    const sx = +sun.x || 0, sy = +sun.y || 0;
    for (const p of window.planets){
      const k = keyFor(p);
      let au = DevConfig.planetOrbitAUById?.[k];
      if (!(au > 0)) {
        const dWorld = Math.hypot((p.x||0)-sx, (p.y||0)-sy);
        au = formatAUValue(dWorld);
      }
      map[k] = +(+au).toFixed(2);
    }
    return map;
  }
  function buildStationFramesUI() {
    refreshUIRefs();
    const root = ui.stationsFramesGroup;
    if (!root) return;
    root.querySelectorAll('.row.sf').forEach(n => n.remove());

    const list = Array.isArray(window.stations) ? window.stations : [];
    for (const st of list) {
      const name = st?.name || `Stacja ${st?.id ?? ''}`;
      const key = stationKey(st);
      if (!key) continue;
      const isPirate = (String(st?.style || '').toLowerCase() === 'pirate') ||
        /pir(?:ate)?/i.test(String(st?.name || '')) ||
        st?.isPirate === true;
      if (isPirate) continue;

      const row = document.createElement('div');
      row.className = 'row sf';
      row.style.alignItems = 'center';
      const initial = Number(DevConfig.stationSpriteFrameById[key]);
      const value = Number.isFinite(initial) ? initial : (Number(DevConfig.stationSpriteFrame) || 1.25);
      const safeValue = Math.max(0.1, Math.min(3.0, value));
      row.innerHTML = `
      <label style="min-width:140px">${name}</label>
      <input class="sfSlider" data-k="${key}" type="range" min="0.1" max="3.0" step="0.01" value="${safeValue}">
      <input class="sfNum" data-k="${key}" type="number" min="0.1" max="3.0" step="0.01" value="${safeValue}"
             style="width:72px; margin-left:8px">
      <span class="val" style="min-width:60px; text-align:right">×${(+safeValue).toFixed(2)}</span>
    `;
      root.appendChild(row);

      const slider = row.querySelector('input.sfSlider');
      const num = row.querySelector('input.sfNum');
      const val = row.querySelector('.val');
      const apply = (vRaw) => {
        let v = Number(vRaw);
        if (!Number.isFinite(v)) v = 1.25;
        v = Math.max(0.1, Math.min(3.0, v));
        DevConfig.stationSpriteFrameById[key] = v;
        if (num) num.value = String(v);
        if (slider) slider.value = String(v);
        if (val) val.textContent = '×' + v.toFixed(2);
        try { localStorage.setItem('stationSpriteFrameById', JSON.stringify(DevConfig.stationSpriteFrameById)); } catch {}
        __devtoolsReflectToCfg?.();
        __devtoolsSaveLS?.();
      };
      slider?.addEventListener('input', e => apply(e.target.value));
      slider?.addEventListener('change', e => apply(e.target.value));
      num?.addEventListener('input', e => apply(e.target.value));
      num?.addEventListener('change', e => apply(e.target.value));
    }
  }
  function buildDistancesUI(){
    refreshUIRefs();
    const root = ui.distancesGroup;
    if (!root) return;
    root.querySelectorAll('.row.dist').forEach(n => n.remove());
    if (!Array.isArray(window.planets) || !window.SUN) return;
    for (const p of window.planets){
      const k = keyFor(p);
      const dWorld = Math.hypot((p.x||0)-SUN.x, (p.y||0)-SUN.y);
      const dAU = (DevConfig.planetOrbitAUById?.[k] ?? formatAUValue(dWorld));
      const row = document.createElement('div');
      row.className = 'row dist';
      row.innerHTML = `
        <label style="min-width:80px">${p.name||('Planet '+(p.id??''))}</label>
        <input data-k="${k}" class="plAU" type="range" min="0" max="60" step="0.01">
        <input data-k="${k}" class="plAUVal" type="number" min="0" max="60" step="0.01" style="width:72px; margin:0 6px;">
        <div class="val" id="au_val_${k}" style="min-width:160px; text-align:right; font-variant-numeric: tabular-nums;"></div>
      `;
      root.appendChild(row);
      const inp = row.querySelector('input.plAU');
      const inpVal = row.querySelector('input.plAUVal');
      if (!DevConfig.planetOrbitAUById) DevConfig.planetOrbitAUById = {};
      inp.value = dAU;
      if (inpVal) inpVal.value = (+dAU).toFixed(2);
      const slot = document.getElementById('au_val_'+k);
      const renderVal = (au)=>{
        let num = Number(au);
        if (!Number.isFinite(num)) num = 0;
        const baseOrbit = getBaseOrbit();
        const worldR = Number.isFinite(baseOrbit) ? num * baseOrbit : NaN;
        if (slot) slot.textContent = `${num.toFixed(2)} AU (${fmtU(worldR)} u)`;
        if (inpVal) inpVal.value = num.toFixed(2);
      };
      renderVal(dAU);
      inp.addEventListener('input', ()=>{
        const au = +inp.value;
        setPlanetOrbitAU(k, au);
        renderVal(au);
        saveLS();
        reflectToCfg();
        if (inpVal) inpVal.value = au.toFixed(2);
      });
      if (inpVal) {
        const applyAU = ()=>{
          let au = Number(inpVal.value);
          if (!Number.isFinite(au)) return;
          au = Math.max(0, Math.min(60, au));
          inp.value = String(au);
          setPlanetOrbitAU(k, au);
          renderVal(au);
          saveLS();
          reflectToCfg();
        };
        inpVal.addEventListener('change', applyAU);
        inpVal.addEventListener('keyup', (e)=>{ if (e.key === 'Enter') applyAU(); });
      }
    }
  }
  function setPlanetOrbitAU(key, au){
    DevConfig.planetOrbitAUById = DevConfig.planetOrbitAUById || {};
    DevConfig.planetOrbitAUById[key] = +au;
    applyOrbitOverrides();
  }
  function applyOrbitOverrides(){
    if (!Array.isArray(window.planets) || !window.SUN) return;
    const baseOrbit = getBaseOrbit();
    const Sx = +window.SUN.x||0, Sy = +window.SUN.y||0;
    const map = DevConfig.planetOrbitAUById || {};
    for (const p of window.planets){
      const k = keyFor(p);
      const au = +map[k];
      if (!(au>0)) continue;
      const R = Number.isFinite(baseOrbit) ? au * baseOrbit : au;
      const ang = Math.atan2((p.y||0)-Sy, (p.x||0)-Sx);
      p.devOrbitOverrideR = R;
      if ('orbitRadius' in p) p.orbitRadius = R;
      if (p.orbit && 'radius' in p.orbit) p.orbit.radius = R;
      if ('orbitR' in p) p.orbitR = R;
      p.x = Sx + Math.cos(ang)*R;
      p.y = Sy + Math.sin(ang)*R;
    }
    if (typeof scheduleRebuild3D === 'function') scheduleRebuild3D();
  }
  function refreshDistancesReadout(){
    if (!Array.isArray(window.planets) || !window.SUN) return;
    const baseOrbit = getBaseOrbit();
    for (const p of window.planets){
      const k = keyFor(p);
      const slot = document.getElementById('au_val_'+k);
      if (!slot) continue;
      const dWorld = Math.hypot((p.x||0)-SUN.x, (p.y||0)-SUN.y);
      const au = DevConfig.planetOrbitAUById?.[k] ?? formatAUValue(dWorld);
      const distWorld = Number.isFinite(baseOrbit) ? au * baseOrbit : NaN;
      slot.textContent = `${(+au).toFixed(2)} AU (${fmtU(distWorld)} u)`;
    }
  }

  // listeners
  if (ui.sunR2D) {
    ui.sunR2D.addEventListener('input', () => {
      const val = +ui.sunR2D.value;
      DevConfig.sunR2D = val;
      if (ui.sunR2DVal) ui.sunR2DVal.textContent = ui.sunR2D.value;
      saveLS();
      scheduleRebuild3D();
      reflectToCfg();
    });
  }
  if (ui.sunR3D) {
    ui.sunR3D.addEventListener('input', () => {
      const val = +ui.sunR3D.value;
      DevConfig.sunR3D = val;
      if (ui.sunR3DVal) ui.sunR3DVal.textContent = ui.sunR3D.value;
      saveLS();
      scheduleRebuild3D();
      reflectToCfg();
    });
  }
  ui.planetScaleAll.addEventListener('input', ()=>{ DevConfig.planetScaleAll = +ui.planetScaleAll.value; ui.planetScaleAllVal.textContent = '×'+(+DevConfig.planetScaleAll).toFixed(2); saveLS(); scheduleRebuild3D(); reflectToCfg(); });
  ui.pirScale.addEventListener('input', ()=>{
    DevTuning.pirateStationScale = +ui.pirScale.value;
    DevConfig.pirateScale = DevTuning.pirateStationScale;
    ui.pirScaleVal.textContent = '×'+(+DevConfig.pirateScale).toFixed(2);
    saveLS();
    reflectToCfg();
  });
  if (ui.stationSpritePx) {
    const applySpriteSize = () => {
      let v = Math.round(Number(ui.stationSpritePx.value));
      if (!Number.isFinite(v)) v = 512;
      v = Math.max(64, Math.min(4096, v));
      ui.stationSpritePx.value = String(v);
      DevConfig.stationSpriteSize = v;
      try { localStorage.setItem('stationSpriteSize', String(v)); } catch {}
      saveLS();
      reflectToCfg();
    };
    ui.stationSpritePx.addEventListener('change', applySpriteSize);
    ui.stationSpritePx.addEventListener('input', applySpriteSize);
  }
  for (const [key, ctrl] of Object.entries(warpLensUI)) {
    if (!ctrl) continue;
    if (ctrl.slider) {
      ctrl.slider.addEventListener('input', () => applyWarpLensValue(key, ctrl.slider.value));
      ctrl.slider.addEventListener('change', () => applyWarpLensValue(key, ctrl.slider.value));
    }
    if (ctrl.number) {
      const commit = () => applyWarpLensValue(key, ctrl.number.value);
      ctrl.number.addEventListener('change', commit);
      ctrl.number.addEventListener('keyup', (e)=>{ if (e.key === 'Enter') commit(); });
    }
  }
  ui.cbRuler.addEventListener('change', ()=>{ DevFlags.showRuler = ui.cbRuler.checked; saveLS(); });
  ui.cbUnlimited.addEventListener('change', ()=>{ DevFlags.unlimitedWarp = ui.cbUnlimited.checked; saveLS(); });
  if (ui.cbSunDir) {
    ui.cbSunDir.addEventListener('change', ()=>{
      DevFlags.showSunDir = ui.cbSunDir.checked;
      saveLS();
    });
  }
  if (ui.cbShake) {
    ui.cbShake.addEventListener('change', ()=>{
      DevFlags.disableCameraShake = ui.cbShake.checked;
      if (DevFlags.disableCameraShake) {
        camera.shakeMag = 0;
        camera.shakeTime = 0;
        camera.shakeDur = 0;
      }
      saveLS();
    });
  }
  if (ui.cbPlanetStations3D) {
    ui.cbPlanetStations3D.addEventListener('change', () => {
      DevFlags.usePlanetStations3D = ui.cbPlanetStations3D.checked;
      window.USE_PLANET_STATIONS_3D = ui.cbPlanetStations3D.checked;
      if (Array.isArray(window.stations) && typeof window.updateStations3D === 'function') {
        window.updateStations3D(window.stations);
      }
      saveLS();
    });
  }
  if (ui.cbPirate3D) {
    ui.cbPirate3D.addEventListener('change', ()=>{
      DevFlags.use3DPirateStation = ui.cbPirate3D.checked;
      window.USE_STATION_3D = ui.cbPirate3D.checked;
      if (window.USE_STATION_3D && window.__setStation3DScale && typeof Dev.station3DScale === 'number') {
        __setStation3DScale(Dev.station3DScale);
      }
      saveLS();
    });
  }

  ui.btnCopy.addEventListener('click', async ()=>{
    try { await navigator.clipboard.writeText(ui.cfgOut.value); ui.btnCopy.textContent='Skopiowano!'; setTimeout(()=>ui.btnCopy.textContent='Kopiuj aktualną konfigurację', 1200); } catch{}
  });
  ui.btnReset.addEventListener('click', ()=>{
    localStorage.removeItem('devConfig'); localStorage.removeItem('devFlags'); localStorage.removeItem('stationSpriteSize');
    localStorage.removeItem('stationSpriteFrame'); localStorage.removeItem('stationSpriteFrameById');
    localStorage.removeItem('devVfx');
    location.reload();
  });

  // skróty klawiaturowe
  window.addEventListener('keydown', (e)=>{
    if (e.key === 'F10'){ ui.root.style.display = (ui.root.style.display==='none' || !ui.root.style.display) ? 'block' : 'none'; }
    if (e.key === 'F11'){ DevFlags.showRuler = !DevFlags.showRuler; ui.cbRuler.checked = DevFlags.showRuler; saveLS(); }
    if (e.key === 'F9' ){ DevFlags.unlimitedWarp = !DevFlags.unlimitedWarp; ui.cbUnlimited.checked = DevFlags.unlimitedWarp; saveLS(); }
    if (e.key === 'F8' ){ 
      DevFlags.showSunDir = !DevFlags.showSunDir; 
      if (ui.cbSunDir) ui.cbSunDir.checked = DevFlags.showSunDir; 
      const el = document.getElementById('dt-show-sundir'); 
      if (el) el.checked = DevFlags.showSunDir; 
      saveLS(); 
    }
  });

  // boot
  loadLS();
  bootstrapFromGame();
  if (!DevConfig.planetOrbitAUById || typeof DevConfig.planetOrbitAUById !== 'object') {
    DevConfig.planetOrbitAUById = {};
  }

  refreshUIRefs();

  // Planety (R)
  buildPlanetsUI();

  // Sekcja: Dystanse od Słońca (AU → promień orbity)
  buildDistancesUI();

  // Sekcja: Kadr sprite per stacja
  buildStationFramesUI();

  // Odbicie stanu
  reflectToUI();
  reflectToCfg();

  // Rebuild 3D po zmianach
  scheduleRebuild3D();

  // Przywróć zapisane AU i przelicz promienie orbit
  applyOrbitOverrides();

  // Aktualizuj readout AU/world-units w panelu
  refreshDistancesReadout();
  setInterval(refreshDistancesReadout, 250);
  setInterval(buildStationFramesUI, 2000);

  // Upewnij się, że panel można włączyć na starcie (dev wygoda)
  // ui.root.style.display = 'block';


if (document.readyState === 'loading') {
      window.addEventListener('DOMContentLoaded', wireDevTools);
    } else {
      wireDevTools();
    }
  })();
  </script>

<script>
  // === DevTools: API + handler skali stacji 3D ===
  (function(){
    const DEFAULT_STATION3D_SCALE = (
      typeof window.DEFAULT_STATION_3D_SCALE === 'number' && window.DEFAULT_STATION_3D_SCALE > 0
    ) ? window.DEFAULT_STATION_3D_SCALE : 2.70;

    // API dostępne globalnie — zapisuje skalę w dwóch miejscach, aby
    // 1) logika 3D miała natychmiastową wartość, 2) devtools mógł ją odczytać.
    if (!window.__setStation3DScale) {
      window.__setStation3DScale = (v) => {
        const raw = Number(v);
        const fallback = DEFAULT_STATION3D_SCALE;
        const n = (Number.isFinite(raw) && raw > 0) ? raw : fallback;
        window.Dev       = window.Dev       || {};
        window.DevTuning = window.DevTuning || {};
        window.Dev.station3DScale           = n;
        window.DevTuning.pirateStationScale = n;
        const cfg = window.DevConfig;
        if (cfg && typeof cfg === 'object') cfg.station3DScale = n;
        try { localStorage.setItem('station3DScale', String(n)); } catch {}
      };
    }

    // Podpięcie suwaka i wyświetlacza wartości (×1.00, ×1.25 itd.)
    const s  = document.getElementById('station3DScale');
    const sv = document.getElementById('station3DScaleVal');
    if (s) {
      // inicjalizacja z LS (opcjonalnie)
      const saved = Number(localStorage.getItem('station3DScale'));
      if (Number.isFinite(saved) && saved > 0) {
        s.value = String(saved);
        if (sv) sv.textContent = '×' + saved.toFixed(2);
        window.__setStation3DScale(saved);
      } else {
        const def = DEFAULT_STATION3D_SCALE;
        s.value = String(def);
        if (sv) sv.textContent = '×' + def.toFixed(2);
        window.__setStation3DScale(def);
      }

      s.addEventListener('input', () => {
        const v = +s.value;
        window.__setStation3DScale(v);
        if (sv) sv.textContent = '×' + v.toFixed(2);
        if (window.DevConfig && typeof window.DevConfig === 'object') {
          window.DevConfig.station3DScale = v;
        }
        window.__devtoolsSaveLS?.();
        window.__devtoolsReflectToCfg?.();
      });
    }
  })();

  (function setupPerStationScales(){
    const root = document.getElementById('dt-stations-per-scale');
    if (!root) return;

    if (!window.DevConfig) window.DevConfig = {};
    if (!window.DevConfig.stationScaleById || typeof window.DevConfig.stationScaleById !== 'object') {
      window.DevConfig.stationScaleById = {};
    }

    function currentStations() {
      if (Array.isArray(window.stations) && window.stations.length) return window.stations;
      if (Array.isArray(window.planets)) {
        return window.planets.map((pl) => ({ id: pl.id || pl.name || '', planet: pl }));
      }
      return [];
    }

    function makeRow(st) {
      const id = String(st?.id || st?.planet?.id || st?.planet?.name || '').toLowerCase();
      if (!id) return null;

      const map = typeof window.getStationScales === 'function' ? window.getStationScales() : null;
      const rawInitial = (window.DevConfig.stationScaleById && window.DevConfig.stationScaleById[id])
        ?? (map ? map[id] : undefined)
        ?? 1;
      const initial = Number(rawInitial) || 1;

      const wrap = document.createElement('div');
      wrap.className = 'dt-row';
      wrap.style.alignItems = 'center';

      const label = document.createElement('div');
      label.className = 'dt-col';
      label.style.minWidth = '120px';
      label.textContent = id[0].toUpperCase() + id.slice(1);

      const col = document.createElement('div');
      col.className = 'dt-col';
      col.style.flex = '1';

      const range = document.createElement('input');
      range.type = 'range';
      range.min = '0.2';
      range.max = '5';
      range.step = '0.01';
      range.value = String(initial);
      range.id = `dt-scale-station-${id}`;

      const val = document.createElement('span');
      val.style.marginLeft = '8px';
      val.textContent = initial.toFixed(2);

      const num = document.createElement('input');
      num.type = 'number';
      num.min = '0.2';
      num.max = '5';
      num.step = '0.01';
      num.value = String(initial);
      num.id = `dt-scale-station-${id}-num`;
      num.style.width = '72px';
      num.style.marginLeft = '8px';

      const apply = (vRaw) => {
        let v = Number(vRaw);
        if (!Number.isFinite(v)) v = 1;
        v = Math.max(0.2, Math.min(5, v));
        if (!window.DevConfig || typeof window.DevConfig !== 'object') window.DevConfig = {};
        if (!window.DevConfig.stationScaleById || typeof window.DevConfig.stationScaleById !== 'object') {
          window.DevConfig.stationScaleById = {};
        }
        window.DevConfig.stationScaleById[id] = v;
        range.value = String(v);
        num.value = String(v);
        val.textContent = v.toFixed(2);
        if (typeof window.setStationScale === 'function') window.setStationScale(id, v);
        window.__devtoolsSaveLS?.();
      };

      range.addEventListener('input', () => apply(range.value));
      num.addEventListener('input', () => apply(num.value));
      num.addEventListener('change', () => apply(num.value));
      num.addEventListener('keyup', (e) => { if (e.key === 'Enter') apply(num.value); });

      col.appendChild(range);
      col.appendChild(num);
      col.appendChild(val);
      wrap.appendChild(label);
      wrap.appendChild(col);
      return wrap;
    }

    function rebuild() {
      root.innerHTML = '';
      const list = currentStations();
      const seen = new Set();
      for (const st of list) {
        const row = makeRow(st);
        if (!row) continue;
        const input = row.querySelector('input[type="range"]');
        const key = input ? input.id : null;
        if (!key || seen.has(key)) continue;
        seen.add(key);
        root.appendChild(row);
      }
    }

    const btnReset = document.getElementById('dt-reset-station-scales');
    if (btnReset) {
      btnReset.addEventListener('click', () => {
        if (!window.DevConfig) window.DevConfig = {};
        window.DevConfig.stationScaleById = {};
        window.__devtoolsSaveLS?.();
        if (typeof window.__saveDevLS === 'function') window.__saveDevLS();
        rebuild();
        if (Array.isArray(window.stations) && typeof window.updateStations3D === 'function') {
          window.updateStations3D(window.stations);
        }
      });
    }

    rebuild();
    let tries = 0;
    const t = setInterval(() => {
      tries++;
      const count = root.querySelectorAll('input[type="range"]').length;
      const stationCount = Array.isArray(window.stations) ? window.stations.length : 0;
      if (stationCount > count || (count === 0 && tries < 120)) {
        rebuild();
      }
      if (tries >= 120) clearInterval(t);
    }, 500);

    if (typeof window.__saveDevLS !== 'function') {
      window.__saveDevLS = function __saveDevLSFallback(){
        try {
          const data = { DevFlags: window.DevFlags, DevTuning: window.DevTuning, DevConfig: window.DevConfig };
          localStorage.setItem('#__dev', JSON.stringify(data));
        } catch (err) {
          console.warn('DevTools: failed to persist station scales', err);
        }
      };
    }

  })();
</script>

</body>
</html>
