<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Destruction Engine V53 - Three.js Hybrid</title>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #080808;
            color: #ccc;
            font-family: 'Segoe UI', monospace;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: auto;
            background: rgba(15, 25, 40, 0.95);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #446;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
        }

        h3 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .key {
            color: #4db8ff;
            font-weight: bold;
        }

        .warn {
            color: #55ff55;
        }

        .feature {
            color: #ffaa00;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            color: #888;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        #perfPanel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
            pointer-events: none;
            background: rgba(5, 10, 20, 0.92);
            padding: 12px 16px;
            border-radius: 8px;
            border: 1px solid #335;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.7);
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 12px;
            color: #aab;
            min-width: 220px;
            transition: opacity 0.3s;
        }

        #perfPanel.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #perfPanel .perf-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #667;
            margin-bottom: 6px;
        }

        #perfPanel .perf-fps {
            font-size: 28px;
            font-weight: bold;
            line-height: 1;
            margin-bottom: 4px;
        }

        #perfPanel .perf-fps.good {
            color: #4f8;
        }

        #perfPanel .perf-fps.ok {
            color: #fd4;
        }

        #perfPanel .perf-fps.bad {
            color: #f44;
        }

        #perfPanel .perf-row {
            display: flex;
            justify-content: space-between;
            padding: 1px 0;
        }

        #perfPanel .perf-label {
            color: #778;
        }

        #perfPanel .perf-val {
            color: #bbc;
            font-weight: bold;
        }

        #perfPanel .perf-bar-bg {
            height: 3px;
            background: #223;
            border-radius: 2px;
            margin: 2px 0;
            overflow: hidden;
        }

        #perfPanel .perf-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s;
        }

        #perfPanel .perf-sep {
            border-top: 1px solid #223;
            margin: 5px 0;
        }

        #perfGraph {
            margin-top: 6px;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h3>Hybrid Engine V52 (Fixed)</h3>
        <div><span class="key">[W / S]</span> - Silnik</div>
        <div><span class="key">[A / D]</span> - Obrót</div>
        <div><span class="key">[LPM]</span> - <b>PRZECIĄGNIJ: ASTEROIDA</b></div>
        <div><span class="key">[PPM]</span> - <b>LASER TNĄCY</b></div>
        <div><span class="key">[Spacja]</span> - Reset</div>
        <div style="margin-top: 10px; font-size: 13px;">
            <span class="feature">Hybrid Physics:</span><br>
            Low Impulse -> Rigid Body Bounce<br>
            High Impulse -> Soft Body Crush<br>
            <span class="warn">Yield Point: 1,000J</span>
        </div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #446;">
            <span class="feature">WŁASNY SPRITE:</span><br>
            <input type="file" id="shipPicker" accept="image/*" style="margin-top: 5px; font-size: 12px; color: #ccc;">
        </div>
    </div>
    <div id="status">Inicjalizacja...</div>
    <div id="perfPanel">
        <div class="perf-title">WYDAJNOŚĆ <span style="float:right;color:#556">[P] toggle</span></div>
        <div class="perf-fps good" id="perfFps">--</div>
        <div style="color:#556;font-size:10px;margin-bottom:6px" id="perfFrameTime">-- ms/frame</div>
        <div class="perf-sep"></div>
        <div class="perf-row"><span class="perf-label">Fizyka</span><span class="perf-val" id="perfPhysics">--</span>
        </div>
        <div class="perf-bar-bg">
            <div class="perf-bar" id="barPhysics" style="width:0%;background:#4af"></div>
        </div>
        <div class="perf-row"><span class="perf-label"> └ Kolizje</span><span class="perf-val"
                id="perfCollisions">--</span></div>
        <div class="perf-bar-bg">
            <div class="perf-bar" id="barCollisions" style="width:0%;background:#f84"></div>
        </div>
        <div class="perf-row"><span class="perf-label"> └ Deformacja</span><span class="perf-val"
                id="perfDeform">--</span></div>
        <div class="perf-bar-bg">
            <div class="perf-bar" id="barDeform" style="width:0%;background:#8f4"></div>
        </div>
        <div class="perf-row"><span class="perf-label">Rysowanie</span><span class="perf-val" id="perfDraw">--</span>
        </div>
        <div class="perf-bar-bg">
            <div class="perf-bar" id="barDraw" style="width:0%;background:#f4f"></div>
        </div>
        <div class="perf-sep"></div>
        <div class="perf-row"><span class="perf-label">Entities</span><span class="perf-val" id="perfEntities">--</span>
        </div>
        <div class="perf-row"><span class="perf-label">Shardy (aktywne)</span><span class="perf-val"
                id="perfShards">--</span></div>
        <div class="perf-row"><span class="perf-label">Debris</span><span class="perf-val" id="perfDebris">--</span>
        </div>
        <div class="perf-row"><span class="perf-label">Kontakty/klatka</span><span class="perf-val"
                id="perfContacts">--</span></div>
        <canvas id="perfGraph" width="220" height="40"></canvas>
    </div>
    <div id="game-root" style="position:relative;width:100vw;height:100vh;overflow:hidden;background:#080808;">
        <canvas id="webgl-layer" style="position:absolute;top:0;left:0;z-index:0;width:100%;height:100%;"></canvas>
        <canvas id="c" style="position:absolute;top:0;left:0;z-index:1;"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const camera = { x: 0, y: 0, zoom: 0.5 };

        // --- PERFORMANCE PROFILER ---
        const Perf = {
            // Timing accumulators (reset every update interval)
            physicsTime: 0,
            collisionTime: 0,
            deformTime: 0,
            drawTime: 0,
            frameCount: 0,
            contactsThisFrame: 0,
            contactsAccum: 0,

            // Displayed values (updated every interval)
            fps: 0,
            avgFrameTime: 0,
            dPhysics: 0,
            dCollisions: 0,
            dDeform: 0,
            dDraw: 0,
            dEntities: 0,
            dShards: 0,
            dDebris: 0,
            dContacts: 0,

            // Frame time history for graph
            history: new Float32Array(110),
            histIdx: 0,

            // DOM refs (cached)
            els: null,
            graphCtx: null,
            visible: true,
            lastUpdate: 0,
            updateInterval: 500, // ms between display refreshes

            init() {
                this.els = {
                    fps: document.getElementById('perfFps'),
                    frameTime: document.getElementById('perfFrameTime'),
                    physics: document.getElementById('perfPhysics'),
                    collisions: document.getElementById('perfCollisions'),
                    deform: document.getElementById('perfDeform'),
                    draw: document.getElementById('perfDraw'),
                    entities: document.getElementById('perfEntities'),
                    shards: document.getElementById('perfShards'),
                    debris: document.getElementById('perfDebris'),
                    contacts: document.getElementById('perfContacts'),
                    barPhysics: document.getElementById('barPhysics'),
                    barCollisions: document.getElementById('barCollisions'),
                    barDeform: document.getElementById('barDeform'),
                    barDraw: document.getElementById('barDraw'),
                    panel: document.getElementById('perfPanel'),
                };
                const graphCanvas = document.getElementById('perfGraph');
                this.graphCtx = graphCanvas.getContext('2d');
                this.history.fill(16.67);
            },

            toggle() {
                this.visible = !this.visible;
                this.els.panel.classList.toggle('hidden', !this.visible);
            },

            startFrame() {
                this.contactsThisFrame = 0;
            },

            recordFrameTime(totalMs) {
                this.history[this.histIdx % this.history.length] = totalMs;
                this.histIdx++;
                this.frameCount++;
            },

            flush(now) {
                if (now - this.lastUpdate < this.updateInterval) return;
                const n = this.frameCount || 1;
                this.fps = Math.round(1000 / ((now - this.lastUpdate) / n));
                this.avgFrameTime = (now - this.lastUpdate) / n;
                this.dPhysics = this.physicsTime / n;
                this.dCollisions = this.collisionTime / n;
                this.dDeform = this.deformTime / n;
                this.dDraw = this.drawTime / n;
                this.dContacts = this.contactsAccum / n;

                // Count objects
                let totalShards = 0;
                for (const e of entities) {
                    if (e.hexGrid) {
                        const sh = e.hexGrid.shards;
                        for (let i = 0, l = sh.length; i < l; i++) {
                            if (sh[i].active && !sh[i].isDebris) totalShards++;
                        }
                    }
                }
                this.dEntities = entities.length;
                this.dShards = totalShards;
                this.dDebris = DestructorSystem.debris.length;

                this.updateDOM();
                this.drawGraph();

                // Reset accumulators
                this.physicsTime = 0;
                this.collisionTime = 0;
                this.deformTime = 0;
                this.drawTime = 0;
                this.contactsAccum = 0;
                this.frameCount = 0;
                this.lastUpdate = now;
            },

            updateDOM() {
                if (!this.visible) return;
                const e = this.els;
                // FPS number + color
                e.fps.textContent = this.fps;
                e.fps.className = 'perf-fps ' + (this.fps >= 55 ? 'good' : this.fps >= 30 ? 'ok' : 'bad');
                e.frameTime.textContent = this.avgFrameTime.toFixed(1) + ' ms/frame';

                // Timing rows
                e.physics.textContent = this.dPhysics.toFixed(2) + ' ms';
                e.collisions.textContent = this.dCollisions.toFixed(2) + ' ms';
                e.deform.textContent = this.dDeform.toFixed(2) + ' ms';
                e.draw.textContent = this.dDraw.toFixed(2) + ' ms';

                // Bars (scale: 16.67ms = 100%)
                const barScale = 100 / 16.67;
                e.barPhysics.style.width = Math.min(100, this.dPhysics * barScale).toFixed(0) + '%';
                e.barCollisions.style.width = Math.min(100, this.dCollisions * barScale).toFixed(0) + '%';
                e.barDeform.style.width = Math.min(100, this.dDeform * barScale).toFixed(0) + '%';
                e.barDraw.style.width = Math.min(100, this.dDraw * barScale).toFixed(0) + '%';

                // Counts
                e.entities.textContent = this.dEntities;
                e.shards.textContent = this.dShards;
                e.debris.textContent = this.dDebris;
                e.contacts.textContent = Math.round(this.dContacts);
            },

            drawGraph() {
                if (!this.visible) return;
                const gCtx = this.graphCtx;
                const w = 220, h = 40;
                gCtx.clearRect(0, 0, w, h);

                // Background
                gCtx.fillStyle = '#0a0e18';
                gCtx.fillRect(0, 0, w, h);

                // 60fps line (16.67ms)
                const y60 = h - (16.67 / 50) * h;
                gCtx.strokeStyle = '#2a3a2a';
                gCtx.lineWidth = 1;
                gCtx.setLineDash([3, 3]);
                gCtx.beginPath();
                gCtx.moveTo(0, y60);
                gCtx.lineTo(w, y60);
                gCtx.stroke();
                gCtx.setLineDash([]);

                // 30fps line (33.33ms)
                const y30 = h - (33.33 / 50) * h;
                gCtx.strokeStyle = '#3a2a2a';
                gCtx.beginPath();
                gCtx.setLineDash([3, 3]);
                gCtx.moveTo(0, y30);
                gCtx.lineTo(w, y30);
                gCtx.stroke();
                gCtx.setLineDash([]);

                // Frame time bars
                const len = this.history.length;
                const barW = w / len;
                const startIdx = this.histIdx;
                for (let i = 0; i < len; i++) {
                    const idx = (startIdx + i) % len;
                    const ms = this.history[idx];
                    const barH = Math.min(h, (ms / 50) * h);
                    const x = i * barW;

                    // Color based on frame time
                    if (ms < 17) gCtx.fillStyle = '#2a6a3a';
                    else if (ms < 33) gCtx.fillStyle = '#6a6a2a';
                    else gCtx.fillStyle = '#6a2a2a';

                    gCtx.fillRect(x, h - barH, barW - 0.5, barH);
                }
            }
        };

        function worldToScreen(wx, wy, cam) {
            return {
                x: (wx - cam.x) * cam.zoom + width / 2,
                y: (wy - cam.y) * cam.zoom + height / 2
            };
        }

        function screenToWorld(sx, sy, cam) {
            return {
                x: (sx - width / 2) / cam.zoom + cam.x,
                y: (sy - height / 2) / cam.zoom + cam.y
            };
        }

        const DESTRUCTOR_CONFIG = {
            gridDivisions: 10,
            shardHP: 100,
            armorThreshold: 0.4,
            maxDeform: 120.0,
            tearThreshold: 180.0,
            bendingRadius: 100.0,
            playerStartingMass: 800000,
            friction: 0.99,
            shardMass: 10.0,
            visualRotationOffset: 0,
            yieldPoint: 200.0,
            restitution: 0.05,
            plasticity: 0.00002,
            collisionDeformScale: 1.0, // startowo 0.25
            collisionSearchRadius: 5,  // ile kratek wokół sprawdzamy w mapie (większe = lepsze przy dużych deformacjach)
            collisionIterations: 4,
            crushMinSpeed: 1.5,          // minimalna prędkość kontaktu dla deformacji (m/s w twoich jednostkach)
            crushPenetrationMin: 0.15,   // minimalna penetracja, żeby zacząć wgniatanie "na docisk"
            crushVelK: 0.15,             // jak mocno prędkość względna wgniata (stara wersja miała ~0.15)
            crushPenK: 10.0,             // jak mocno penetracja wgniata (docisk)
            shearK: 0.06,                // jak mocno "szorowanie" gniecie (składowa styczna)
            crushSeparation: 0.25,       // mniejsza separacja = dłuższy kontakt = płynniejsze wgniatanie
            crushImpulseScale: 0.45,     // ile impulsu zostaje przy niszczeniu (mniej = mniej "odbijania" celu)
            dummyMass: 20000,       // Masa kukły
            debrisMass: 50,         // Masa odłamków
            asteroidMass: 1000000,  // Masa asteroidy
            asteroidSpeedMult: 10,  // Mnożnik prędkości asteroidy
            asteroidMaxSpeed: 4000, // Limit prędkości asteroidy
            asteroidHPMult: 10,     // Mnożnik HP szardów asteroidy

            recoverSpeed: 1.0,      // Szybkość powrotu do kształtu (elastyczność wizualna)
            repairRate: 100,        // Szybkość naprawy HP (klawisz R)
            visualLerpSpeed: 5.0,   // Płynność animacji deformacji

            softBodyTension: 0.15,  // Napięcie powierzchniowe (0.0 - 1.0)
            tearSensitivity: 0.15,  // Wrażliwość na strzępienie krawędzi
            maxFray: 15.0,          // Maksymalne postrzępienie (px)
            deformMul: 0.6,         // Mnożnik deformacji od uderzenia
            inflictedDamageMult: 1.0, // Mnożnik obrażeń od siły uderzenia

            beamWidth: 12,          // Szerokość lasera
            beamForce: 400,         // Siła odepchnięcia lasera

            playerSpeed: 600,       // Siła silników gracza
            playerTurnAccel: 10.0,  // Przyspieszenie obrotu
            playerMaxTurn: 2.5,     // Maksymalna prędkość obrotu
            zoomSpeed: 0.001        // Czułość zoomu
        };

        // --- PRECOMPUTED CONSTANTS (hoisted out of hot loops) ---
        const HEX_R = DESTRUCTOR_CONFIG.gridDivisions;
        const HEX_HEIGHT = Math.sqrt(3) * HEX_R;
        const HEX_SPACING = HEX_R * 1.5;
        const HIT_RAD_SQ = (HEX_R * 1.3) ** 2;
        const HIT_RAD = HEX_R * 1.3;
        const BENDING_RAD_SQ = DESTRUCTOR_CONFIG.bendingRadius * DESTRUCTOR_CONFIG.bendingRadius;

        // Precomputed offset lists for collision neighborhood searches (avoid nested loops + string keys in hot path)
        const _SEARCH_OFFSETS_CACHE = Object.create(null);
        function getSearchOffsets(radius) {
            const r = radius | 0;
            let arr = _SEARCH_OFFSETS_CACHE[r];
            if (arr) return arr;
            const list = [];
            const r2 = r * r;
            for (let dc = -r; dc <= r; dc++) {
                for (let dr = -r; dr <= r; dr++) {
                    if (dc * dc + dr * dr <= r2) {
                        list.push(dc, dr);
                    }
                }
            }
            // Int8Array is enough for our typical radii (<= 16); Int16Array fallback if bigger
            arr = (r <= 127) ? new Int8Array(list) : new Int16Array(list);
            _SEARCH_OFFSETS_CACHE[r] = arr;
            return arr;
        }


        // ====================================================================
        // THREE.JS HEX RENDERER — Instanced GPU rendering of hex shards
        // ====================================================================
        const HexRenderer = {
            renderer: null,
            scene: null,
            camera: null,
            entityMeshes: new Map(),
            _dummy: null, // reusable Object3D for matrix computation

            HEX_VERTEX: `
                attribute vec2 aGridPos;
                attribute float aHPRatio;
                attribute float aStress;

                uniform vec2 uSpriteSize;

                varying vec2 vSpriteUV;
                varying float vHPRatio;
                varying float vStress;

                void main() {
                    vHPRatio = aHPRatio;
                    vStress = aStress;
                    // UV into sprite based on original grid position (not deformed)
                    vSpriteUV = (aGridPos + position.xy) / uSpriteSize;

                    // instanceMatrix handles: translate(gridX+deformX-cx, gridY+deformY-cy)
                    // modelMatrix handles: entity world position + rotation
                    vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(position.xy, 0.0, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,

            HEX_FRAGMENT: `
                uniform sampler2D uArmorTex;
                uniform sampler2D uDamagedTex;
                uniform float uArmorThreshold;
                uniform float uHasArmorTex;
                uniform float uHasDamagedTex;
                uniform float uIsProjectile;
                uniform vec3 uColor;

                varying vec2 vSpriteUV;
                varying float vHPRatio;
                varying float vStress;

                void main() {
                    // Discard outside sprite bounds
                    if (vSpriteUV.x < -0.01 || vSpriteUV.x > 1.01 ||
                        vSpriteUV.y < -0.01 || vSpriteUV.y > 1.01) discard;

                    vec3 color;
                    float alpha = 1.0;

                    if (uIsProjectile > 0.5) {
                        color = uColor;
                    } else {
                        // Base: damaged texture or dark fallback
                        vec4 damaged = vec4(0.133, 0.133, 0.133, 1.0);
                        if (uHasDamagedTex > 0.5) {
                            damaged = texture2D(uDamagedTex, vSpriteUV);
                        }
                        color = damaged.rgb;
                        alpha = damaged.a;

                        // Armor overlay blended by HP
                        if (uHasArmorTex > 0.5) {
                            float armorAlpha = 0.0;
                            if (vHPRatio > uArmorThreshold) {
                                armorAlpha = (vHPRatio - uArmorThreshold) / (1.0 - uArmorThreshold);
                            }
                            if (armorAlpha > 0.01) {
                                vec4 armor = texture2D(uArmorTex, vSpriteUV);
                                color = mix(color, armor.rgb, armorAlpha * armor.a);
                                alpha = max(alpha, armor.a * armorAlpha);
                            }
                        }
                    }

                    // Stress glow (deformation heat)
                    if (vStress > 5.0) {
                        float ratio = min(1.0, vStress / 100.0);
                        color = mix(color, vec3(1.0, ratio * 0.4, 0.0), ratio * 0.6);
                    }

                    if (alpha < 0.01) discard;
                    gl_FragColor = vec4(color, alpha);
                }
            `,

            init() {
                const webglCanvas = document.getElementById('webgl-layer');
                this.renderer = new THREE.WebGLRenderer({
                    canvas: webglCanvas,
                    alpha: true,
                    antialias: false,
                    powerPreference: 'high-performance'
                });
                this.renderer.setSize(width, height);
                this.renderer.setClearColor(0x080808, 1);
                this.renderer.setPixelRatio(1);

                this.scene = new THREE.Scene();
                // OrthographicCamera — top/bottom flipped to match Canvas 2D Y-down
                this.camera = new THREE.OrthographicCamera(
                    -width / 2, width / 2,
                    -height / 2, height / 2,
                    0.1, 10000
                );
                this.camera.position.z = 1000;

                this._dummy = new THREE.Object3D();
            },

            createEntityMesh(entity) {
                if (!entity.hexGrid) return null;
                const grid = entity.hexGrid;
                const shards = grid.shards;
                const count = shards.length;

                // Base hex geometry (6 segments = hexagon, overlap 1.08)
                const hexGeo = new THREE.CircleGeometry(HEX_R * 1.08, 6);

                // Textures from shard image sources (canvas elements)
                const firstShard = shards[0];
                let armorTex = null, damagedTex = null;
                if (firstShard && firstShard.img) {
                    armorTex = new THREE.CanvasTexture(firstShard.img);
                    armorTex.flipY = false;
                    armorTex.minFilter = THREE.LinearFilter;
                    armorTex.magFilter = THREE.LinearFilter;
                }
                if (firstShard && firstShard.damagedImg) {
                    damagedTex = new THREE.CanvasTexture(firstShard.damagedImg);
                    damagedTex.flipY = false;
                    damagedTex.minFilter = THREE.LinearFilter;
                    damagedTex.magFilter = THREE.LinearFilter;
                }

                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        uSpriteSize: { value: new THREE.Vector2(grid.srcWidth, grid.srcHeight) },
                        uArmorTex: { value: armorTex || new THREE.Texture() },
                        uDamagedTex: { value: damagedTex || new THREE.Texture() },
                        uArmorThreshold: { value: DESTRUCTOR_CONFIG.armorThreshold },
                        uHasArmorTex: { value: armorTex ? 1.0 : 0.0 },
                        uHasDamagedTex: { value: damagedTex ? 1.0 : 0.0 },
                        uIsProjectile: { value: entity.isProjectile ? 1.0 : 0.0 },
                        uColor: { value: new THREE.Color(firstShard?.color || '#ffcc00') }
                    },
                    vertexShader: this.HEX_VERTEX,
                    fragmentShader: this.HEX_FRAGMENT,
                    transparent: true,
                    depthWrite: false,
                    depthTest: false,
                    side: THREE.DoubleSide
                });

                const mesh = new THREE.InstancedMesh(hexGeo, material, count);
                mesh.frustumCulled = false;

                // Custom per-instance attributes
                const gridPosArr = new Float32Array(count * 2);
                const hpArr = new Float32Array(count);
                const stressArr = new Float32Array(count);

                for (let i = 0; i < count; i++) {
                    const s = shards[i];
                    gridPosArr[i * 2] = s.gridX;
                    gridPosArr[i * 2 + 1] = s.gridY;

                    // IMPORTANT: initialize visual state from current simulation state.
                    // This avoids 1-frame "undamaged sprite" flicker when meshes are rebuilt after splits.
                    const hpRatio = (s.maxHp > 0) ? (s.hp / s.maxHp) : 0.0;
                    hpArr[i] = Math.max(0.0, Math.min(1.0, hpRatio));

                    const dx = s.deformation ? s.deformation.x : 0.0;
                    const dy = s.deformation ? s.deformation.y : 0.0;
                    stressArr[i] = Math.sqrt(dx * dx + dy * dy);
                }

                mesh.geometry.setAttribute('aGridPos',
                    new THREE.InstancedBufferAttribute(gridPosArr, 2));
                mesh.geometry.setAttribute('aHPRatio',
                    new THREE.InstancedBufferAttribute(hpArr, 1));
                mesh.geometry.setAttribute('aStress',
                    new THREE.InstancedBufferAttribute(stressArr, 1));

                // Set initial instance matrices
                const centerX = grid.srcWidth / 2;
                const centerY = grid.srcHeight / 2;
                const pivotX = grid.pivot ? grid.pivot.x : 0;
                const pivotY = grid.pivot ? grid.pivot.y : 0;
                const dummy = this._dummy;

                for (let i = 0; i < count; i++) {
                    const s = shards[i];
                    if (s.active && !s.isDebris) {
                        dummy.position.set(
                            s.gridX + s.deformation.x - centerX - pivotX,
                            s.gridY + s.deformation.y - centerY - pivotY, 0);
                    } else {
                        dummy.position.set(0, 0, -99999);
                    }
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);
                }
                mesh.instanceMatrix.needsUpdate = true;

                // Entity world transform
                mesh.position.set(entity.x, entity.y, 0);
                mesh.rotation.z = entity.angle + DESTRUCTOR_CONFIG.visualRotationOffset;

                this.scene.add(mesh);

                const data = {
                    mesh,
                    shards,
                    centerX,
                    centerY,
                    hpAttr: mesh.geometry.getAttribute('aHPRatio'),
                    stressAttr: mesh.geometry.getAttribute('aStress')
                };
                this.entityMeshes.set(entity, data);
                return data;
            },

            updateEntityMesh(entity) {
                let data = this.entityMeshes.get(entity);
                if (!data) return;

                // Detect if shards array was replaced (by split/rebuild)
                if (data.shards !== entity.hexGrid.shards) {
                    this.scene.remove(data.mesh);
                    data.mesh.geometry.dispose();
                    this.entityMeshes.delete(entity);

                    // Recreate and continue updating in the same frame (prevents any transient visual mismatch).
                    data = this.createEntityMesh(entity);
                    if (!data) return;
                }

                const { mesh, shards, centerX, centerY, hpAttr, stressAttr } = data;
                const dummy = this._dummy;
                const pivotX = entity.hexGrid.pivot ? entity.hexGrid.pivot.x : 0;
                const pivotY = entity.hexGrid.pivot ? entity.hexGrid.pivot.y : 0;

                for (let i = 0; i < shards.length; i++) {
                    const s = shards[i];
                    if (s.active && !s.isDebris) {
                        dummy.position.set(
                            s.gridX + s.deformation.x - centerX - pivotX,
                            s.gridY + s.deformation.y - centerY - pivotY, 0);
                        dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix);
                        hpAttr.array[i] = s.hp / s.maxHp;
                        const dx = s.deformation.x, dy = s.deformation.y;
                        stressAttr.array[i] = Math.sqrt(dx * dx + dy * dy);
                    } else {
                        dummy.position.set(0, 0, -99999);
                        dummy.updateMatrix();
                        mesh.setMatrixAt(i, dummy.matrix);
                    }
                }

                mesh.instanceMatrix.needsUpdate = true;
                hpAttr.needsUpdate = true;
                stressAttr.needsUpdate = true;

                // Entity world transform
                mesh.position.set(entity.x, entity.y, 0);
                mesh.rotation.z = entity.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
            },

            syncCamera() {
                const cam = camera;
                const z = cam.zoom;
                const halfW = width / (2 * z);
                const halfH = height / (2 * z);
                this.camera.left = -halfW;
                this.camera.right = halfW;
                this.camera.top = -halfH;   // flipped Y to match canvas
                this.camera.bottom = halfH;
                this.camera.position.set(cam.x, cam.y, 1000);
                this.camera.lookAt(cam.x, cam.y, 0);
                this.camera.updateProjectionMatrix();
            },

            update(entitiesArr) {
                this.syncCamera();
                const alive = new Set(entitiesArr);

                // Remove meshes for deleted entities
                for (const [ent, data] of this.entityMeshes) {
                    if (!alive.has(ent)) {
                        this.scene.remove(data.mesh);
                        data.mesh.geometry.dispose();
                        this.entityMeshes.delete(ent);
                    }
                }

                // Create/update meshes
                for (const ent of entitiesArr) {
                    if (!ent.hexGrid) continue;
                    if (!this.entityMeshes.has(ent)) {
                        this.createEntityMesh(ent);
                    }
                    this.updateEntityMesh(ent);
                }
            },

            render() {
                if (this.renderer) {
                    this.renderer.render(this.scene, this.camera);
                }
            },

            resize() {
                if (this.renderer) this.renderer.setSize(width, height);
            }
        };

        class HexShard {
            constructor(img, damagedImg, gridX, gridY, radius, c, r, color = null) {
                this.img = img;
                this.damagedImg = damagedImg;
                this.gridX = gridX;
                this.gridY = gridY;
                this.radius = radius;
                this.c = c;
                this.r = r;
                this.color = color;
                this.active = true;
                this.isDebris = false;
                this.maxHp = DESTRUCTOR_CONFIG.shardHP;
                this.hp = this.maxHp;
                this.deformation = { x: 0, y: 0 };
                this.targetDeformation = { x: 0, y: 0 };

                // --- NOWOŚĆ: Tablica deformacji wierzchołków (efekt strzępienia) ---
                this.frays = [];
                for (let i = 0; i < 6; i++) this.frays.push({ x: 0, y: 0 });
                // ------------------------------------------------------------------

                this.worldX = 0; this.worldY = 0;
                this.dvx = 0; this.dvy = 0; this.drot = 0;
                this.alpha = 1;
                this.angle = 0;
                this.scale = 1.0;
                this.neighbors = [];
                this.verts = [];
                for (let i = 0; i < 6; i++) {
                    const a = i * Math.PI / 3;
                    this.verts.push({ x: Math.cos(a) * radius, y: Math.sin(a) * radius });
                }
            }
            repair(dt) {
                if (!this.active || this.isDebris) return;
                const recoverSpeed = DESTRUCTOR_CONFIG.recoverSpeed;
                this.targetDeformation.x *= (1.0 - Math.min(1.0, recoverSpeed * dt));
                this.targetDeformation.y *= (1.0 - Math.min(1.0, recoverSpeed * dt));

                // Opcjonalnie: Powolne naprawianie strzępienia (bardzo wolne, żeby ślady walki zostawały)
                // Jeśli chcesz trwałe zniszczenia, usuń poniższą pętlę.
                /*
                for(let i=0; i<6; i++) {
                    this.frays[i].x *= 0.99;
                    this.frays[i].y *= 0.99;
                }
                */

                this.hp = Math.min(this.maxHp, this.hp + DESTRUCTOR_CONFIG.repairRate * dt);
            }
            updateAnimation(dt) {
                const lerpSpeed = DESTRUCTOR_CONFIG.visualLerpSpeed;
                const dx = this.targetDeformation.x - this.deformation.x;
                const dy = this.targetDeformation.y - this.deformation.y;
                if (Math.abs(dx) > 0.05 || Math.abs(dy) > 0.05) {
                    this.deformation.x += dx * lerpSpeed * dt;
                    this.deformation.y += dy * lerpSpeed * dt;
                    return true;
                }
                return false;
            }
            applyDeformation(vecX, vecY) {
                this.targetDeformation.x += vecX;
                this.targetDeformation.y += vecY;

                const maxD = DESTRUCTOR_CONFIG.maxDeform;
                const tx = this.targetDeformation.x;
                const ty = this.targetDeformation.y;
                const d2 = tx * tx + ty * ty;

                if (d2 > maxD * maxD) {
                    const s = maxD / Math.sqrt(d2);
                    this.targetDeformation.x *= s;
                    this.targetDeformation.y *= s;
                }

                // tear check (zostaje)
                const tt = DESTRUCTOR_CONFIG.tearThreshold;
                if (this.targetDeformation.x ** 2 + this.targetDeformation.y ** 2 > tt * tt) this.hp = 0;
            }
            becomeDebris(impulseX, impulseY, parentEntity, scale = 1.0) {
                if (this.isDebris) return;
                this.scale = scale;
                const px = parentEntity.x;
                const py = parentEntity.y;
                const rotation = parentEntity.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const c = Math.cos(rotation);
                const s = Math.sin(rotation);
                const centerX = parentEntity.hexGrid.srcWidth / 2;
                const centerY = parentEntity.hexGrid.srcHeight / 2;
                const pX = parentEntity.hexGrid.pivot ? parentEntity.hexGrid.pivot.x : 0;
                const pY = parentEntity.hexGrid.pivot ? parentEntity.hexGrid.pivot.y : 0;
                const startLx = (this.gridX - centerX) + this.deformation.x - pX;
                const startLy = (this.gridY - centerY) + this.deformation.y - pY;
                this.worldX = px + (startLx * scale) * c - (startLy * scale) * s;
                this.worldY = py + (startLx * scale) * s + (startLy * scale) * c;
                let vx = parentEntity.vx || 0;
                let vy = parentEntity.vy || 0;
                const angVel = parentEntity.angVel || 0;
                const rx = (startLx * scale) * c - (startLy * scale) * s;
                const ry = (startLx * scale) * s + (startLy * scale) * c;
                vx += -angVel * ry;
                vy += angVel * rx;
                this.dvx = vx + impulseX + (this.deformation.x * 3.0);
                this.dvy = vy + impulseY + (this.deformation.y * 3.0);
                this.drot = (Math.random() - 0.5) * 8.0;
                this.angle = rotation;
                this.alpha = 1.0;
                this.isDebris = true;
                this.active = true;
                DestructorSystem.debris.push(this);
                if (parentEntity.mass) {
                    parentEntity.mass -= DESTRUCTOR_CONFIG.shardMass;
                    if (parentEntity.mass < 10) parentEntity.mass = 10;
                }
            }
            updateDebris(dt) {
                this.worldX += this.dvx * dt;
                this.worldY += this.dvy * dt;
                this.angle += this.drot * dt;
                this.dvx *= DESTRUCTOR_CONFIG.friction;
                this.dvy *= DESTRUCTOR_CONFIG.friction;
                this.alpha -= dt * 0.2;
                if (this.alpha <= 0) this.active = false;
            }
            drawDebris(ctx, camera) {
                if (!this.active || !this.isDebris) return;
                const p = worldToScreen(this.worldX, this.worldY, camera);
                if (p.x < -100 || p.x > ctx.canvas.width + 100 || p.y < -100 || p.y > ctx.canvas.height + 100) return;
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(this.angle);
                const s = camera.zoom * (this.scale || 1.0);
                ctx.scale(s, s);
                ctx.globalAlpha = Math.max(0, this.alpha);
                this._drawHexPath(ctx);
                ctx.clip();
                if (this.damagedImg) ctx.drawImage(this.damagedImg, -this.gridX, -this.gridY);
                else if (this.img) ctx.drawImage(this.img, -this.gridX, -this.gridY);
                else { ctx.fillStyle = '#444'; ctx.fill(); }
                ctx.restore();
            }
            drawShape(ctx) {
                // (Ta metoda pozostaje bez zmian, ale wklejam dla kontekstu)
                ctx.save();
                ctx.translate(this.gridX + this.deformation.x, this.gridY + this.deformation.y);
                this._drawHexPath(ctx); // To wywoła naszą nową funkcję
                ctx.save();
                ctx.clip();
                if (this.color) { ctx.fillStyle = this.color; ctx.fill(); }
                else {
                    if (this.damagedImg) ctx.drawImage(this.damagedImg, -this.gridX, -this.gridY);
                    else { ctx.fillStyle = '#222'; ctx.fill(); }
                    if (this.img) {
                        const hpRatio = this.hp / this.maxHp;
                        const threshold = DESTRUCTOR_CONFIG.armorThreshold;
                        let armorAlpha = 0;
                        if (hpRatio > threshold) armorAlpha = (hpRatio - threshold) / (1.0 - threshold);
                        if (armorAlpha > 0.01) {
                            ctx.globalAlpha = armorAlpha;
                            ctx.drawImage(this.img, -this.gridX, -this.gridY);
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                ctx.restore();
                const stressSq = this.deformation.x * this.deformation.x + this.deformation.y * this.deformation.y;
                if (stressSq > 25.0) { // 5.0^2
                    const stress = Math.sqrt(stressSq);
                    const ratio = Math.min(1.0, stress / DESTRUCTOR_CONFIG.tearThreshold);
                    const alpha = ratio * 0.6;
                    ctx.fillStyle = `rgba(255, ${Math.floor(ratio * 100)}, 0, ${alpha})`;
                    ctx.fill();
                }
                ctx.restore();
            }

            _drawHexPath(ctx) {
                ctx.beginPath();
                const overlap = 1.08;

                // --- NOWOŚĆ: Rysowanie z uwzględnieniem strzępów (this.frays) ---
                // Pierwszy punkt
                let fx = this.verts[0].x + this.frays[0].x;
                let fy = this.verts[0].y + this.frays[0].y;
                ctx.moveTo(fx * overlap, fy * overlap);

                // Reszta punktów
                for (let i = 1; i < 6; i++) {
                    fx = this.verts[i].x + this.frays[i].x;
                    fy = this.verts[i].y + this.frays[i].y;
                    ctx.lineTo(fx * overlap, fy * overlap);
                }
                // ----------------------------------------------------------------
                ctx.closePath();
            }
        }

        const DestructorSystem = {
            debris: [],
            splitQueue: [],
            _tick: 0,
            update(dt, entities) {
                // Swap-and-pop for O(1) debris removal instead of O(n) splice
                const debris = this.debris;
                for (let i = debris.length - 1; i >= 0; i--) {
                    debris[i].updateDebris(dt);
                    if (!debris[i].active) {
                        debris[i] = debris[debris.length - 1];
                        debris.pop();
                    }
                }
                this._tick++;

                const t0col = performance.now();
                this.simulateElasticity(entities, dt);

                const iterations = DESTRUCTOR_CONFIG.collisionIterations || 4; // możesz zacząć od 3-4
                for (let i = 0; i < iterations; i++) {
                    const doDamage = (i === 0); // damage na pierwszej iteracji: kontakt jeszcze istnieje
                    this.resolveCollisions(entities, dt, doDamage);
                }
                Perf.collisionTime += performance.now() - t0col;
                if (this._tick % 10 === 0 && this.splitQueue.length > 0) this.processSplits(entities);
            },

            updateVisualDeformation(entities, dt) {
                for (const e of entities) {
                    if (e.hexGrid) {
                        let moving = false;
                        for (const s of e.hexGrid.shards) {
                            if (!s.active || s.isDebris) continue;
                            if (s.updateAnimation(dt)) moving = true;
                        }
                        if (moving) e.hexGrid.cacheDirty = true;
                    }
                }
            },

            simulateElasticity(entities, dt) {
                const tension = DESTRUCTOR_CONFIG.softBodyTension;
                if (tension <= 0) return;

                // frame-rate independent krok
                const k = 1.0 - Math.exp(-tension * dt * 60);

                for (const e of entities) {
                    if (!e.hexGrid) continue;

                    for (const s of e.hexGrid.shards) {
                        if (!s.active || s.isDebris) continue;

                        for (const n of s.neighbors) {
                            if (!n.active || n.isDebris) continue;

                            // żeby nie liczyć pary 2x (prosty warunek deterministyczny)
                            if (n.c < s.c || (n.c === s.c && n.r <= s.r)) continue;

                            const ax = s.targetDeformation.x;
                            const ay = s.targetDeformation.y;
                            const bx = n.targetDeformation.x;
                            const by = n.targetDeformation.y;

                            const avgX = (ax + bx) * 0.5;
                            const avgY = (ay + by) * 0.5;

                            s.targetDeformation.x += (avgX - ax) * k;
                            s.targetDeformation.y += (avgY - ay) * k;

                            n.targetDeformation.x += (avgX - bx) * k;
                            n.targetDeformation.y += (avgY - by) * k;
                        }
                    }

                    e.hexGrid.cacheDirty = true;
                }
            },

            repair(entities, dt) {
                for (const e of entities) {
                    if (e.hexGrid && e.hexGrid.shards) {
                        let anyFix = false;
                        for (const s of e.hexGrid.shards) {
                            if (s.active && !s.isDebris) {
                                if (Math.abs(s.deformation.x) > 0.1 || Math.abs(s.deformation.y) > 0.1 || s.hp < s.maxHp) {
                                    s.repair(dt);
                                    anyFix = true;
                                }
                            }
                        }
                        if (anyFix) e.hexGrid.cacheDirty = true;
                    }
                }
            },

            distributeStructuralDamage(entity, impactLocalX, impactLocalY, forceX, forceY, damageScale = 1.0) {
                const radius = DESTRUCTOR_CONFIG.bendingRadius;
                const radiusSq = BENDING_RAD_SQ;
                const invRadius = 1.0 / radius;
                const deformMul = DESTRUCTOR_CONFIG.deformMul;
                let anyDestroyed = false;

                const pivotX = entity.hexGrid.pivot ? entity.hexGrid.pivot.x : 0;
                const pivotY = entity.hexGrid.pivot ? entity.hexGrid.pivot.y : 0;
                const adjustedImpactX = impactLocalX + pivotX;
                const adjustedImpactY = impactLocalY + pivotY;

                // Parametry strzępienia - precomputed
                const tearSensitivity = DESTRUCTOR_CONFIG.tearSensitivity;
                const maxFray = DESTRUCTOR_CONFIG.maxFray;
                const maxFraySq = maxFray * maxFray;

                // Precompute force magnitude and direction ONCE (nie w pętli!)
                const forceMagSq = forceX * forceX + forceY * forceY;
                const forceMag = Math.sqrt(forceMagSq);
                const doFray = (damageScale > 0) && (forceMag > 2.0);
                const fnx = doFray ? forceX / forceMag : 0;
                const fny = doFray ? forceY / forceMag : 0;
                const hpDmgBase = (Math.abs(forceX) + Math.abs(forceY)) * DESTRUCTOR_CONFIG.inflictedDamageMult * damageScale;

                const cx = entity.hexGrid.srcWidth * 0.5;
                const cy = entity.hexGrid.srcHeight * 0.5;

                // FAST PATH: iterate only cells around impact (instead of scanning all shards)
                const cols = entity.hexGrid.cols;
                const rows = entity.hexGrid.rows;
                const grid = entity.hexGrid.grid;

                const invHexSpacing = 1.0 / HEX_SPACING;
                const invHexHeight = 1.0 / HEX_HEIGHT;

                const impactGX = adjustedImpactX + cx;
                const impactGY = adjustedImpactY + cy;

                const approxC = Math.round(impactGX * invHexSpacing);
                const approxR = Math.round(impactGY * invHexHeight);

                const cellRadC = Math.ceil(radius * invHexSpacing) + 2;
                const cellRadR = Math.ceil(radius * invHexHeight) + 2;

                if (grid && cols && rows) {
                    let c0 = approxC - cellRadC;
                    let c1 = approxC + cellRadC;
                    let r0 = approxR - cellRadR;
                    let r1 = approxR + cellRadR;

                    if (c0 < 0) c0 = 0;
                    if (r0 < 0) r0 = 0;
                    if (c1 >= cols) c1 = cols - 1;
                    if (r1 >= rows) r1 = rows - 1;

                    for (let r = r0; r <= r1; r++) {
                        const rowBase = r * cols;
                        for (let c = c0; c <= c1; c++) {
                            const shard = grid[rowBase + c];
                            if (!shard || !shard.active || shard.isDebris) continue;

                            const dx = (shard.gridX - cx) - adjustedImpactX;
                            const dy = (shard.gridY - cy) - adjustedImpactY;
                            const d2 = dx * dx + dy * dy;
                            if (d2 >= radiusSq) continue;

                            const dist = Math.sqrt(d2);
                            const factor = 1 - dist * invRadius;
                            if (factor <= 0) continue;
                            const influence = factor * factor * (3 - 2 * factor);

                            // Softbody deformation
                            shard.applyDeformation(forceX * influence * deformMul, forceY * influence * deformMul);

                            // Efekt strzępienia (shredding)
                            if (doFray) {
                                const tearBase = forceMag * influence * tearSensitivity;
                                for (let i = 0; i < 6; i++) {
                                    const randomTear = Math.random() * tearBase;
                                    const f = shard.frays[i];
                                    f.x += fnx * randomTear + (Math.random() - 0.5) * randomTear * 0.5;
                                    f.y += fny * randomTear + (Math.random() - 0.5) * randomTear * 0.5;

                                    const fraySq = f.x * f.x + f.y * f.y;
                                    if (fraySq > maxFraySq) {
                                        const scale = maxFray / Math.sqrt(fraySq);
                                        f.x *= scale;
                                        f.y *= scale;
                                    }
                                }
                            }

                            if (damageScale > 0) {
                                shard.hp -= hpDmgBase * influence;
                                if (shard.hp <= 0) {
                                    this.destroyShard(entity, shard, { x: entity.vx, y: entity.vy });
                                    anyDestroyed = true;
                                }
                            }
                        }
                    }
                } else {
                    // Fallback (should rarely happen)
                    const shards = entity.hexGrid.shards;
                    for (let si = 0, sLen = shards.length; si < sLen; si++) {
                        const shard = shards[si];
                        if (!shard.active || shard.isDebris) continue;

                        const dx = (shard.gridX - cx) - adjustedImpactX;
                        const dy = (shard.gridY - cy) - adjustedImpactY;
                        const d2 = dx * dx + dy * dy;
                        if (d2 < radiusSq) {
                            const dist = Math.sqrt(d2);
                            const factor = 1 - dist * invRadius;
                            if (factor <= 0) continue;
                            const influence = factor * factor * (3 - 2 * factor);

                            // Softbody deformation
                            shard.applyDeformation(forceX * influence * deformMul, forceY * influence * deformMul);

                            // Efekt strzępienia (shredding)
                            if (doFray) {
                                const tearBase = forceMag * influence * tearSensitivity;
                                for (let i = 0; i < 6; i++) {
                                    const randomTear = Math.random() * tearBase;
                                    const f = shard.frays[i];
                                    f.x += fnx * randomTear + (Math.random() - 0.5) * randomTear * 0.5;
                                    f.y += fny * randomTear + (Math.random() - 0.5) * randomTear * 0.5;

                                    const fraySq = f.x * f.x + f.y * f.y;
                                    if (fraySq > maxFraySq) {
                                        const scale = maxFray / Math.sqrt(fraySq);
                                        f.x *= scale;
                                        f.y *= scale;
                                    }
                                }
                            }

                            if (damageScale > 0) {
                                shard.hp -= hpDmgBase * influence;
                                if (shard.hp <= 0) {
                                    this.destroyShard(entity, shard, { x: entity.vx, y: entity.vy });
                                    anyDestroyed = true;
                                }
                            }
                        }
                    }
                }

                if (damageScale > 0 && anyDestroyed) this.splitQueue.push(entity);
                entity.hexGrid.cacheDirty = true;
            },

            resolveCollisions(entities, dt, doDamage) {
                const len = entities.length;
                for (let i = 0; i < len; i++) {
                    const A = entities[i];
                    if (!A.hexGrid) continue;
                    const ax = A.x, ay = A.y;
                    const ar = A.radius || 100;
                    for (let j = i + 1; j < len; j++) {
                        const B = entities[j];
                        if (!B.hexGrid) continue;
                        if (A.owner === B || B.owner === A) continue;
                        const dx = ax - B.x, dy = ay - B.y;
                        const radSum = ar + (B.radius || 100);
                        if (dx * dx + dy * dy > radSum * radSum) continue;
                        this.collideEntities(A, B, dt, doDamage);
                    }
                }
            },

            // --- HYBRID COLLISION SOLVER (V36 Detection + V46 Impulse Physics) ---
            // Reusable contacts buffer to avoid GC pressure (pre-allocated objects — no per-frame GC)
            _contactsBuf: Array.from({ length: 8 }, () => ({
                shardA: null, shardB: null,
                worldAx: 0, worldAy: 0,
                worldBx: 0, worldBy: 0,
                normalX: 0, normalY: 0,
                penetration: 0
            })),
            _contactsCount: 0,

            collideEntities(A, B, dt, doDamage) {
                // OPTIMIZATION: Smaller object iterates (from destructor.js)
                // Swap so that 'iterator' has fewer shards — much fewer hex lookups
                let iterator = A, gridHolder = B;
                if (A.hexGrid.shards.length > B.hexGrid.shards.length) {
                    iterator = B;
                    gridHolder = A;
                }

                const massA = A.mass || 100;
                const massB = B.mass || 100;
                const angIter = iterator.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const angGrid = gridHolder.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const cosI = Math.cos(angIter), sinI = Math.sin(angIter);
                const cosG = Math.cos(angGrid), sinG = Math.sin(angGrid);
                // Inverse rotation for gridHolder: cos(-x)=cos(x), sin(-x)=-sin(x)
                const cosG_inv = cosG, sinG_inv = -sinG;

                const cxI = iterator.hexGrid.srcWidth * 0.5;
                const cyI = iterator.hexGrid.srcHeight * 0.5;
                const cxG = gridHolder.hexGrid.srcWidth * 0.5;
                const cyG = gridHolder.hexGrid.srcHeight * 0.5;
                const pivotIx = iterator.hexGrid.pivot ? iterator.hexGrid.pivot.x : 0;
                const pivotIy = iterator.hexGrid.pivot ? iterator.hexGrid.pivot.y : 0;
                const pivotGx = gridHolder.hexGrid.pivot ? gridHolder.hexGrid.pivot.x : 0;
                const pivotGy = gridHolder.hexGrid.pivot ? gridHolder.hexGrid.pivot.y : 0;

                // --- BOUNDS INTERSECTION (from destructor.js) ---
                // Compute bounding box of iterator in gridHolder's local grid space
                const iterRadius = iterator.radius || 100;
                const ix = iterator.x, iy = iterator.y;
                const gx = gridHolder.x, gy = gridHolder.y;

                // corners implicit (avoid per-frame allocations)

                let minC = Infinity, maxC = -Infinity, minR = Infinity, maxR = -Infinity;
                const invHexSpacing = 1.0 / HEX_SPACING;
                const invHexHeight = 1.0 / HEX_HEIGHT;


                // Ile sąsiednich komórek sprawdzamy w mapie (musi być >= przesunięcie od deformacji / spacing)
                const searchR = (DESTRUCTOR_CONFIG.collisionSearchRadius ?? 4);
                for (let k = 0; k < 4; k++) {
                    const sx = (k === 0 || k === 3) ? -iterRadius : iterRadius;
                    const sy = (k < 2) ? -iterRadius : iterRadius;
                    // Iterator local -> world
                    const wx = ix + sx;
                    const wy = iy + sy;
                    // World -> gridHolder local
                    const dx = wx - gx;
                    const dy = wy - gy;
                    const hlx = dx * cosG_inv - dy * sinG_inv;
                    const hly = dx * sinG_inv + dy * cosG_inv;
                    const gridBx = hlx + cxG + pivotGx;
                    const gridBy = hly + cyG + pivotGy;
                    // Grid index
                    const c = Math.floor(gridBx * invHexSpacing);
                    const r = Math.floor(gridBy * invHexHeight);
                    if (c < minC) minC = c;
                    if (c > maxC) maxC = c;
                    if (r < minR) minR = r;
                    if (r > maxR) maxR = r;
                }

                // Padding for rotation + deform error
                const pad = searchR + 2;
                minC -= pad; maxC += pad; minR -= pad; maxR += pad;

                // --- COLLISION DETECTION ---
                let contactsCount = 0;
                const maxContacts = 8;
                const contacts = this._contactsBuf;

                // Fast grids (flattened) — avoids string keys + reduces GC pressure
                const holderGrid = gridHolder.hexGrid.grid;
                const iterGrid = iterator.hexGrid.grid;
                const holderCols = gridHolder.hexGrid.cols || 0;
                const holderRows = gridHolder.hexGrid.rows || 0;
                const iterCols = iterator.hexGrid.cols || 0;
                const iterRows = iterator.hexGrid.rows || 0;

                // Precompute inverse transform for gridHolder->world->iterator
                const cosI_inv = cosI, sinI_inv = -sinI;

                // NOWOŚĆ: Skalowanie deformacji do kolizji
                const cds = DESTRUCTOR_CONFIG.collisionDeformScale ?? 1.0;

                // Clamp search window to holder grid (huge speed-up; outside is always empty)
                if (holderGrid && holderCols && holderRows) {
                    if (minC < 0) minC = 0;
                    if (minR < 0) minR = 0;
                    if (maxC >= holderCols) maxC = holderCols - 1;
                    if (maxR >= holderRows) maxR = holderRows - 1;
                    if (minC > maxC || minR > maxR) return;
                }

                const offsets = getSearchOffsets(searchR);

                for (let r = minR; r <= maxR; r++) {
                    const rowBase = r * holderCols;
                    for (let c = minC; c <= maxC; c++) {
                        const shardG = holderGrid ? holderGrid[rowBase + c] : null;
                        if (!shardG || !shardG.active || shardG.isDebris) continue;

                        const defGx = shardG.deformation.x * cds;
                        const defGy = shardG.deformation.y * cds;

                        // gridHolder shard -> world
                        const relGx = (shardG.gridX - cxG) + defGx - pivotGx;
                        const relGy = (shardG.gridY - cyG) + defGy - pivotGy;
                        const worldGx = gx + relGx * cosG - relGy * sinG;
                        const worldGy = gy + relGx * sinG + relGy * cosG;

                        // world -> iterator local grid
                        const dx = worldGx - ix;
                        const dy = worldGy - iy;
                        const localIx = dx * cosI_inv - dy * sinI_inv;
                        const localIy = dx * sinI_inv + dy * cosI_inv;
                        const gridIx = localIx + cxI + pivotIx;
                        const gridIy = localIy + cyI + pivotIy;

                        const approxC_I = Math.round(gridIx * invHexSpacing);
                        const approxR_I = Math.round(gridIy * invHexHeight);

                        // Quick reject if far outside iterator grid
                        if (iterGrid && iterCols && iterRows) {
                            if (approxC_I < -searchR || approxC_I >= iterCols + searchR ||
                                approxR_I < -searchR || approxR_I >= iterRows + searchR) {
                                continue;
                            }
                        }

                        // Search in iterator grid (neighborhood offsets)
                        for (let oi = 0; oi < offsets.length; oi += 2) {
                            const ic = approxC_I + offsets[oi];
                            const ir = approxR_I + offsets[oi + 1];
                            if (ic < 0 || ir < 0 || ic >= iterCols || ir >= iterRows) continue;

                            const shardI = iterGrid ? iterGrid[ic + ir * iterCols] : null;
                            if (!shardI || !shardI.active || shardI.isDebris) continue;

                            const defIx = shardI.deformation.x * cds;
                            const defIy = shardI.deformation.y * cds;

                            const gi = shardI.gridX + defIx;
                            const giy = shardI.gridY + defIy;
                            const ddx = gi - gridIx, ddy = giy - gridIy;
                            if (ddx * ddx + ddy * ddy < HIT_RAD_SQ) {
                                // Compute world position of iterator shard
                                const relIx = (shardI.gridX - cxI) + defIx - pivotIx;
                                const relIy = (shardI.gridY - cyI) + defIy - pivotIy;
                                const worldIx = ix + relIx * cosI - relIy * sinI;
                                const worldIy = iy + relIx * sinI + relIy * cosI;

                                const normalX = worldIx - worldGx;
                                const normalY = worldIy - worldGy;
                                const hexDistSq = normalX * normalX + normalY * normalY;
                                const hexDist = Math.sqrt(hexDistSq);

                                // Map shardA/shardB consistently: A is always first entity arg
                                const isSwapped = (iterator !== A);
                                const cObj = contacts[contactsCount];
                                cObj.shardA = isSwapped ? shardG : shardI;
                                cObj.shardB = isSwapped ? shardI : shardG;
                                cObj.worldAx = isSwapped ? worldGx : worldIx;
                                cObj.worldAy = isSwapped ? worldGy : worldIy;
                                cObj.worldBx = isSwapped ? worldIx : worldGx;
                                cObj.worldBy = isSwapped ? worldIy : worldGy;
                                cObj.normalX = isSwapped ? -normalX : normalX;
                                cObj.normalY = isSwapped ? -normalY : normalY;
                                cObj.penetration = Math.max(0, HIT_RAD - hexDist);

                                contactsCount++;
                                if (contactsCount >= maxContacts) break;
                            }
                        }
                        if (contactsCount >= maxContacts) break;
                    }
                    if (contactsCount >= maxContacts) break;
                }

                if (contactsCount === 0) return;

                Perf.contactsAccum += contactsCount;

                const sA = contacts[0].shardA;
                const hitB = contacts[0].shardB;

                let worldHitX = 0;
                let worldHitY = 0;
                let nx = 0;
                let ny = 0;
                let penetration = 0;

                for (let ci = 0; ci < contactsCount; ci++) {
                    const contact = contacts[ci];
                    worldHitX += (contact.worldAx + contact.worldBx) * 0.5;
                    worldHitY += (contact.worldAy + contact.worldBy) * 0.5;
                    nx += contact.normalX;
                    ny += contact.normalY;
                    if (contact.penetration > penetration) penetration = contact.penetration;
                }

                const invCount = 1.0 / contactsCount;
                worldHitX *= invCount;
                worldHitY *= invCount;

                let normalLenSq = nx * nx + ny * ny;
                if (normalLenSq < 1e-12) {
                    nx = A.x - B.x;
                    ny = A.y - B.y;
                    normalLenSq = nx * nx + ny * ny;
                    if (normalLenSq < 1e-12) normalLenSq = 1;
                }
                const invNormalLen = 1.0 / Math.sqrt(normalLenSq);
                nx *= invNormalLen;
                ny *= invNormalLen;

                // --- 2. V46 PHYSICS SOLVER (Rigid Body Impulse) ---

                const cxA = A.hexGrid.srcWidth * 0.5;
                const cyA = A.hexGrid.srcHeight * 0.5;
                const cxB = B.hexGrid.srcWidth * 0.5;
                const cyB = B.hexGrid.srcHeight * 0.5;
                const pivotAx = A.hexGrid.pivot ? A.hexGrid.pivot.x : 0;
                const pivotAy = A.hexGrid.pivot ? A.hexGrid.pivot.y : 0;
                const pivotBx = B.hexGrid.pivot ? B.hexGrid.pivot.x : 0;
                const pivotBy = B.hexGrid.pivot ? B.hexGrid.pivot.y : 0;


                // Wektory ramienia siły
                const rAx = worldHitX - A.x;
                const rAy = worldHitY - A.y;
                const rBx = worldHitX - B.x;
                const rBy = worldHitY - B.y;

                // Prędkości w punkcie zderzenia
                const vAx = A.vx - A.angVel * rAy;
                const vAy = A.vy + A.angVel * rAx;
                const vBx = B.vx - B.angVel * rBy;
                const vBy = B.vy + B.angVel * rBx;

                const dvx = vAx - vBx;
                const dvy = vAy - vBy;

                // Baza kontaktu (normalna + styczna)
                const velAlongNormal = dvx * nx + dvy * ny;
                const tx = -ny, ty = nx;
                const velTangent = dvx * tx + dvy * ty;

                const invMassA = 1 / massA;
                const invMassB = 1 / massB;

                const slop = 0.01;
                const pen = Math.max(0, penetration - slop);

                // ---- 1) IMPULS RIGID BODY (tylko gdy obiekty się zbliżają) ----
                let isDestruction = false;
                let impactForceTest = 0;

                if (velAlongNormal < 0) {
                    const restitutionBase = DESTRUCTOR_CONFIG.restitution;
                    const inertiaScale = 0.5;
                    const effectiveRadiusA = Math.max(1, A.radius || Math.max(cxA, cyA, 1));
                    const effectiveRadiusB = Math.max(1, B.radius || Math.max(cxB, cyB, 1));
                    const invIa = 1 / (inertiaScale * massA * effectiveRadiusA * effectiveRadiusA);
                    const invIb = 1 / (inertiaScale * massB * effectiveRadiusB * effectiveRadiusB);

                    const rnA = rAx * ny - rAy * nx;
                    const rnB = rBx * ny - rBy * nx;

                    const normalDenom = invMassA + invMassB + rnA * rnA * invIa + rnB * rnB * invIb;
                    if (Number.isFinite(normalDenom) && normalDenom > 1e-8) {

                        // Testowy impuls dla restitution podstawowego (do sprawdzenia yield)
                        let jTest = -(1 + restitutionBase) * velAlongNormal;
                        jTest /= normalDenom;
                        impactForceTest = Math.abs(jTest);

                        const yieldPoint = DESTRUCTOR_CONFIG.yieldPoint;
                        isDestruction = impactForceTest > yieldPoint;

                        // Brak odbicia przy destrukcji
                        const restitutionEff = isDestruction ? 0.0 : restitutionBase;

                        // Impuls właściwy
                        let j = -(1 + restitutionEff) * velAlongNormal;
                        j /= normalDenom;

                        // Opcjonalnie: pochłonięcie części impulsu, żeby nie "wystrzeliwać" celu (bardziej car-crash)
                        if (isDestruction) {
                            const crushImpulseScale = DESTRUCTOR_CONFIG.crushImpulseScale ?? 0.45;
                            j *= crushImpulseScale;
                        }

                        const impulseX = j * nx;
                        const impulseY = j * ny;

                        A.vx += impulseX * invMassA;
                        A.vy += impulseY * invMassA;
                        B.vx -= impulseX * invMassB;
                        B.vy -= impulseY * invMassB;

                        A.angVel += rnA * j * invIa;
                        B.angVel -= rnB * j * invIb;

                        // Tarcie (dla niszczenia nie schodzimy do zera, żeby było "scrape")
                        let jt = -velTangent;
                        const tangentDenom = invMassA + invMassB + (rAx * ty - rAy * tx) ** 2 * invIa + (rBx * ty - rBy * tx) ** 2 * invIb;
                        if (Number.isFinite(tangentDenom) && tangentDenom > 1e-8) jt /= tangentDenom;
                        else jt = 0;

                        const mu = 0.5;
                        const maxFriction = Math.abs(j) * mu;
                        if (Math.abs(jt) > maxFriction) jt = -maxFriction * Math.sign(velTangent);

                        const frictionScale = isDestruction ? 0.25 : 0.8;
                        jt *= frictionScale;

                        const fImpulseX = jt * tx;
                        const fImpulseY = jt * ty;

                        A.vx += fImpulseX * invMassA;
                        A.vy += fImpulseY * invMassA;
                        B.vx -= fImpulseX * invMassB;
                        B.vy -= fImpulseY * invMassB;

                        A.angVel += (rAx * ty - rAy * tx) * jt * invIa;
                        B.angVel -= (rBx * ty - rBy * tx) * jt * invIb;
                    }
                }

                // ---- 2) SOFTBODY CRUSH (ciągłe wgniatanie) ----
                // Startujemy zgniatanie gdy:
                // - yield został przekroczony (duży impuls) LUB
                // - nadal mamy wyraźną penetrację (dociśnięcie, nawet przy małej prędkości)
                const penMin = DESTRUCTOR_CONFIG.crushPenetrationMin ?? 0.15;
                const crushActive = isDestruction || (pen > penMin);

                const impactSpeed = Math.hypot(dvx, dvy);
                const minCrushSpeed = DESTRUCTOR_CONFIG.crushMinSpeed ?? 1.5;
                const allowCrush = (impactSpeed > minCrushSpeed) || (pen > penMin);

                if (crushActive && allowCrush) {
                    const angA = A.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                    const angB = B.angle + DESTRUCTOR_CONFIG.visualRotationOffset;

                    // Skalowanie pod iteracje solvera (żeby 4 iteracje nie dawały 4x większego wgniatania)
                    const iterScale = 1.0 / (DESTRUCTOR_CONFIG.collisionIterations || 1);
                    const dtScale = dt * 60 * iterScale;

                    const totalMass = massA + massB;
                    const ratioA = massB / totalMass;
                    const ratioB = massA / totalMass;

                    // Kontakt w lokalnych układach (uwzględnij aktualną deformację)
                    const relX_A = (sA.gridX - cxA) + sA.deformation.x - pivotAx;
                    const relY_A = (sA.gridY - cyA) + sA.deformation.y - pivotAy;
                    const relX_B = (hitB.gridX - cxB) + hitB.deformation.x - pivotBx;
                    const relY_B = (hitB.gridY - cyB) + hitB.deformation.y - pivotBy;

                    const ca_inv = Math.cos(-angA), sa_inv = Math.sin(-angA);
                    const cb_inv = Math.cos(-angB), sb_inv = Math.sin(-angB);

                    const velK = DESTRUCTOR_CONFIG.crushVelK ?? 0.15;
                    const penK = DESTRUCTOR_CONFIG.crushPenK ?? 10.0;
                    const shearK = DESTRUCTOR_CONFIG.shearK ?? 0.06;

                    // (A dostaje -dv, B dostaje +dv) + dokładka od penetracji (docisk)
                    let forceAx = (-dvx * ca_inv - -dvy * sa_inv) * velK * dtScale;
                    let forceAy = (-dvx * sa_inv + -dvy * ca_inv) * velK * dtScale;

                    let forceBx = (dvx * cb_inv - dvy * sb_inv) * velK * dtScale;
                    let forceBy = (dvx * sb_inv + dvy * cb_inv) * velK * dtScale;

                    // Penetracja -> wgniatanie wzdłuż normalnej (nie zależy od prędkości)
                    if (pen > 0) {
                        const penForce = pen * penK * dtScale;

                        // A: +n (normal jest od B do A)
                        const wPenAx = nx * penForce;
                        const wPenAy = ny * penForce;

                        // B: -n
                        const wPenBx = -nx * penForce;
                        const wPenBy = -ny * penForce;

                        forceAx += wPenAx * ca_inv - wPenAy * sa_inv;
                        forceAy += wPenAx * sa_inv + wPenAy * ca_inv;

                        forceBx += wPenBx * cb_inv - wPenBy * sb_inv;
                        forceBy += wPenBx * sb_inv + wPenBy * cb_inv;
                    }

                    // Shear -> wyginanie przy "szorowaniu"
                    if (Math.abs(velTangent) > 0.1) {
                        const shear = velTangent * shearK * dtScale;

                        const wShearAx = tx * shear;
                        const wShearAy = ty * shear;
                        const wShearBx = -tx * shear;
                        const wShearBy = -ty * shear;

                        forceAx += wShearAx * ca_inv - wShearAy * sa_inv;
                        forceAy += wShearAx * sa_inv + wShearAy * ca_inv;

                        forceBx += wShearBx * cb_inv - wShearBy * sb_inv;
                        forceBy += wShearBx * sb_inv + wShearBy * cb_inv;
                    }

                    // Skala deformacji zależna od tego czy przekroczyliśmy yield
                    const crushScale = isDestruction ? 1.0 : 0.35;
                    const dmgScale = doDamage ? 1.0 : 0.0;

                    this.distributeStructuralDamage(
                        A, relX_A, relY_A,
                        forceAx * (ratioA * 2) * crushScale,
                        forceAy * (ratioA * 2) * crushScale,
                        dmgScale
                    );
                    this.distributeStructuralDamage(
                        B, relX_B, relY_B,
                        forceBx * (ratioB * 2) * crushScale,
                        forceBy * (ratioB * 2) * crushScale,
                        dmgScale
                    );
                }

                // --- 3. SEPARATION ---
                const percent = crushActive ? (DESTRUCTOR_CONFIG.crushSeparation ?? 0.25) : 0.8;
                if (penetration > slop) {
                    const correctionMag = Math.max(penetration - slop, 0.0) / (invMassA + invMassB) * percent;
                    const cx = nx * correctionMag;
                    const cy = ny * correctionMag;
                    A.x += cx * invMassA;
                    A.y += cy * invMassA;
                    B.x -= cx * invMassB;
                    B.y -= cy * invMassB;
                }
            },

            // eraseShard: Gumka — wytnij dziurę z cache bez pełnego redraw (from destructor.js)
            eraseShard(entity, shard) {
                if (!entity.hexGrid || !entity.hexGrid.cacheCtx) return;
                const ctx = entity.hexGrid.cacheCtx;
                ctx.save();
                ctx.globalCompositeOperation = 'destination-out';
                ctx.translate(shard.gridX + shard.deformation.x, shard.gridY + shard.deformation.y);
                ctx.beginPath();
                const r = shard.radius * 1.15;
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                ctx.globalCompositeOperation = 'source-over';
            },

            destroyShard(entity, shard, velVector) {
                shard.hp = 0;
                const ctx = entity.hexGrid.cacheCtx;
                if (ctx) {
                    ctx.save();
                    ctx.translate(shard.gridX + shard.deformation.x, shard.gridY + shard.deformation.y);
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(0, 0, shard.radius * 1.05, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    ctx.globalCompositeOperation = 'source-over';
                }
                const deformVelX = shard.deformation.x * 2.0;
                const deformVelY = shard.deformation.y * 2.0;
                shard.becomeDebris(velVector.x * 0.3 + deformVelX, velVector.y * 0.3 + deformVelY, entity, 1.0);
            },
            processSplits(entities) {
                const queue = [...new Set(this.splitQueue)];
                this.splitQueue = [];
                for (const entity of queue) {
                    if (!entity.hexGrid || !entities.includes(entity)) continue;
                    const groups = this.findIslands(entity.hexGrid);
                    if (groups.length <= 1) continue;
                    groups.sort((a, b) => b.length - a.length);
                    const mainGroup = groups[0];
                    const looseGroups = groups.slice(1);
                    this.rebuildEntityGrid(entity, mainGroup);
                    for (const group of looseGroups) {
                        if (group.length < 3) {
                            for (const s of group) this.destroyShard(entity, s, { x: entity.vx, y: entity.vy });
                            continue;
                        }
                        this.spawnWreckEntity(entity, group, entities);
                    }
                }
            },
            findIslands(grid) {
                const activeShards = grid.shards.filter(s => s.active && !s.isDebris);
                if (activeShards.length === 0) return [];
                const map = {};
                for (const s of activeShards) map[s.c + "," + s.r] = s;
                const visited = new Set();
                const groups = [];
                for (const seed of activeShards) {
                    if (visited.has(seed)) continue;
                    const group = [];
                    const stack = [seed];
                    visited.add(seed);
                    while (stack.length > 0) {
                        const curr = stack.pop();
                        group.push(curr);
                        if (curr.neighbors) {
                            for (const neighbor of curr.neighbors) {
                                if (neighbor && neighbor.active && !neighbor.isDebris && !visited.has(neighbor)) {
                                    visited.add(neighbor);
                                    stack.push(neighbor);
                                }
                            }
                        }
                    }
                    groups.push(group);
                }
                return groups;
            },
            getNeighborCoords(c, r) {
                const odd = (c % 2 !== 0);
                const offsets = odd
                    ? [[0, -1], [0, 1], [-1, 0], [-1, 1], [1, 0], [1, 1]]
                    : [[0, -1], [0, 1], [-1, -1], [-1, 0], [1, -1], [1, 0]];
                return offsets.map(o => ({ c: c + o[0], r: r + o[1] }));
            },
            rebuildEntityGrid(entity, shards) {
                const cols = entity.hexGrid.cols || Math.ceil(entity.hexGrid.srcWidth / HEX_SPACING);
                const rows = entity.hexGrid.rows || Math.ceil(entity.hexGrid.srcHeight / HEX_HEIGHT);
                const map = {};
                const grid = new Array(cols * rows);

                for (let i = 0; i < shards.length; i++) {
                    const s = shards[i];
                    map[s.c + "," + s.r] = s;
                    if (s.c >= 0 && s.c < cols && s.r >= 0 && s.r < rows) {
                        grid[s.c + s.r * cols] = s;
                    }
                }

                entity.hexGrid.shards = shards;
                entity.hexGrid.map = map;
                entity.hexGrid.grid = grid;
                entity.hexGrid.cols = cols;
                entity.hexGrid.rows = rows;
                entity.hexGrid.cacheDirty = true;
                entity.mass = shards.length * DESTRUCTOR_CONFIG.shardMass;
            },
            spawnWreckEntity(parent, shards, entities) {
                // 1. Obliczanie środka masy (Pivot)
                let sumX = 0, sumY = 0;
                for (const s of shards) {
                    sumX += (s.gridX + s.deformation.x);
                    sumY += (s.gridY + s.deformation.y);
                }
                const avgX = sumX / shards.length;
                const avgY = sumY / shards.length;

                const cx = parent.hexGrid.srcWidth / 2;
                const cy = parent.hexGrid.srcHeight / 2;
                const relX = avgX - cx;
                const relY = avgY - cy;

                // --- FIX: OBLICZANIE NOWEGO PROMIENIA (RADIUS) ---
                // Sprawdzamy jak daleko najdalszy heks leży od nowego środka (avgX, avgY)
                let maxDistSq = 0;
                for (const s of shards) {
                    const dx = (s.gridX + s.deformation.x) - avgX;
                    const dy = (s.gridY + s.deformation.y) - avgY;
                    const d2 = dx * dx + dy * dy;
                    if (d2 > maxDistSq) maxDistSq = d2;
                }
                const newRadius = Math.sqrt(maxDistSq) + DESTRUCTOR_CONFIG.gridDivisions * 2.0;
                // --------------------------------------------------

                const ang = parent.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const c = Math.cos(ang);
                const s = Math.sin(ang);
                const worldX = parent.x + relX * c - relY * s;
                const worldY = parent.y + relX * s + relY * c;

                // Grid dimensions for fast lookups (kept from parent)
                const cols = parent.hexGrid.cols || Math.ceil(parent.hexGrid.srcWidth / HEX_SPACING);
                const rows = parent.hexGrid.rows || Math.ceil(parent.hexGrid.srcHeight / HEX_HEIGHT);

                const wreck = {
                    x: worldX, y: worldY,
                    vx: parent.vx, vy: parent.vy,
                    angle: parent.angle, angVel: parent.angVel,

                    radius: newRadius, // <--- TUTAJ PRZYPISUJEMY OBLICZONY PROMIEŃ

                    mass: shards.length * DESTRUCTOR_CONFIG.shardMass,
                    isWreck: true,
                    hexGrid: {
                        shards: shards,
                        map: {},
                        grid: new Array(cols * rows),
                        cols,
                        rows,
                        srcWidth: parent.hexGrid.srcWidth,
                        srcHeight: parent.hexGrid.srcHeight,
                        cacheCanvas: parent.hexGrid.cacheCanvas.cloneNode(),
                        cacheCtx: null,
                        cacheDirty: true,
                        pivot: { x: relX, y: relY }
                    }
                };
                wreck.hexGrid.cacheCtx = wreck.hexGrid.cacheCanvas.getContext('2d');
                const wGrid = wreck.hexGrid.grid;
                for (let i = 0; i < shards.length; i++) {
                    const hs = shards[i];
                    wreck.hexGrid.map[hs.c + "," + hs.r] = hs;
                    if (hs.c >= 0 && hs.c < cols && hs.r >= 0 && hs.r < rows) {
                        wGrid[hs.c + hs.r * cols] = hs;
                    }
                }
                entities.push(wreck);
            },
            cutByBeam(entity, p1, p2, beamWidth) {
                if (!entity.hexGrid) return;
                const ang = -(entity.angle + DESTRUCTOR_CONFIG.visualRotationOffset);
                const cos = Math.cos(ang);
                const sin = Math.sin(ang);
                const ex = entity.x;
                const ey = entity.y;
                const dx1 = p1.x - ex; const dy1 = p1.y - ey;
                const dx2 = p2.x - ex; const dy2 = p2.y - ey;
                const l1x = dx1 * cos - dy1 * sin; const l1y = dx1 * sin + dy1 * cos;
                const l2x = dx2 * cos - dy2 * sin; const l2y = dx2 * sin + dy2 * cos;
                const cx = entity.hexGrid.srcWidth / 2;
                const cy = entity.hexGrid.srcHeight / 2;
                const pivotX = entity.hexGrid.pivot ? entity.hexGrid.pivot.x : 0;
                const pivotY = entity.hexGrid.pivot ? entity.hexGrid.pivot.y : 0;
                const lineStart = { x: l1x + cx + pivotX, y: l1y + cy + pivotY };
                const lineEnd = { x: l2x + cx + pivotX, y: l2y + cy + pivotY };
                const minX = Math.min(lineStart.x, lineEnd.x) - beamWidth * 2;
                const maxX = Math.max(lineStart.x, lineEnd.x) + beamWidth * 2;
                const minY = Math.min(lineStart.y, lineEnd.y) - beamWidth * 2;
                const maxY = Math.max(lineStart.y, lineEnd.y) + beamWidth * 2;
                const lineVecX = lineEnd.x - lineStart.x;
                const lineVecY = lineEnd.y - lineStart.y;
                const lineLenSq = lineVecX * lineVecX + lineVecY * lineVecY;
                const perpX = -lineVecY;
                const perpY = lineVecX;
                const perpLen = Math.sqrt(perpX * perpX + perpY * perpY) || 1;
                const pushDirX = perpX / perpLen;
                const pushDirY = perpY / perpLen;
                const rotBack = -ang;
                const cosB = Math.cos(rotBack);
                const sinB = Math.sin(rotBack);
                let anyHit = false;
                for (const shard of entity.hexGrid.shards) {
                    if (!shard.active || shard.isDebris) continue;
                    const px = shard.gridX + shard.deformation.x;
                    const py = shard.gridY + shard.deformation.y;
                    if (px < minX || px > maxX || py < minY || py > maxY) continue;
                    let t = ((px - lineStart.x) * lineVecX + (py - lineStart.y) * lineVecY) / lineLenSq;
                    t = Math.max(0, Math.min(1, t));
                    const closestX = lineStart.x + t * lineVecX;
                    const closestY = lineStart.y + t * lineVecY;
                    const distSq = (px - closestX) ** 2 + (py - closestY) ** 2;
                    if (distSq < (beamWidth + shard.radius * 1.2) ** 2) {
                        const cross = (px - lineStart.x) * lineVecY - (py - lineStart.y) * lineVecX;
                        const side = cross > 0 ? 1 : -1;
                        const worldImpulseLocalX = pushDirX * side * DESTRUCTOR_CONFIG.beamForce;
                        const worldImpulseLocalY = pushDirY * side * DESTRUCTOR_CONFIG.beamForce;
                        const wImpX = worldImpulseLocalX * cosB - worldImpulseLocalY * sinB;
                        const wImpY = worldImpulseLocalX * sinB + worldImpulseLocalY * cosB;
                        this.destroyShard(entity, shard, { x: entity.vx + wImpX * 0.05, y: entity.vy + wImpY * 0.05 });
                        entity.hexGrid.cacheDirty = true;
                        anyHit = true;
                    }
                }
                if (anyHit) this.splitQueue.push(entity);
            },
            draw(ctx, camera) {
                for (const d of this.debris) {
                    d.drawDebris(ctx, camera);
                }
            }
        };

        function createProjectileImage() {
            const size = 64;
            const c = document.createElement('canvas');
            c.width = size; c.height = size;
            const ctx = c.getContext('2d');
            const grad = ctx.createRadialGradient(size / 2, size / 2, 4, size / 2, size / 2, size / 2);
            grad.addColorStop(0, '#ffffaa');
            grad.addColorStop(0.4, '#ffaa00');
            grad.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 3, 0, Math.PI * 2);
            ctx.stroke();
            return c;
        }
        const projectileImg = createProjectileImage();

        function createProceduralShipImage(color) {
            const c = document.createElement('canvas');
            c.width = 160; c.height = 300;
            const x = c.getContext('2d');
            x.fillStyle = color || '#445566';
            x.fillRect(40, 20, 80, 260);
            x.fillStyle = '#667788';
            x.fillRect(20, 180, 120, 80);
            x.fillStyle = '#33ccff';
            x.fillRect(60, 40, 40, 40);
            return c;
        }

        function createDebrisObstacle() {
            const c = document.createElement('canvas');
            c.width = 80; c.height = 80;
            const x = c.getContext('2d');
            x.fillStyle = '#554433';
            x.beginPath();
            x.arc(40, 40, 35, 0, Math.PI * 2);
            x.fill();
            return c;
        }

        function createAsteroidImage(radius) {
            const c = document.createElement('canvas');
            c.width = radius * 2; c.height = radius * 2;
            const ctx = c.getContext('2d');
            const cx = radius; const cy = radius;
            ctx.fillStyle = '#665544';
            ctx.beginPath();
            for (let a = 0; a < Math.PI * 2; a += 0.4) {
                const r = radius * (0.8 + Math.random() * 0.2);
                const x = cx + Math.cos(a) * r;
                const y = cy + Math.sin(a) * r;
                if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#554433' : '#776655';
                const s = Math.random() * radius * 0.4;
                const x = Math.random() * c.width;
                const y = Math.random() * c.height;
                if (Math.hypot(x - cx, y - cy) < radius * 0.7) {
                    ctx.beginPath(); ctx.arc(x, y, s, 0, Math.PI * 2); ctx.fill();
                }
            }
            return c;
        }

        function initHexBody(entity, image, damagedImage, isProjectile = false, massOverride = null) {
            const w = Math.ceil(image.width / 2) * 2;
            const h = Math.ceil(image.height / 2) * 2;
            const r = DESTRUCTOR_CONFIG.gridDivisions;
            const hexHeight = Math.sqrt(3) * r;
            let data = null;
            let ctx = null;
            const cvs = document.createElement('canvas');
            cvs.width = w; cvs.height = h;
            ctx = cvs.getContext('2d');
            let dmgCvs = null;
            if (damagedImage) {
                dmgCvs = document.createElement('canvas');
                dmgCvs.width = w; dmgCvs.height = h;
                dmgCvs.getContext('2d').drawImage(damagedImage, 0, 0, w, h);
            }
            try {
                ctx.drawImage(image, 0, 0, w, h);
                data = ctx.getImageData(0, 0, w, h).data;
            } catch (e) { }
            const shards = [];
            const map = {};
            const cols = Math.ceil(w / (r * 1.5));
            const rows = Math.ceil(h / hexHeight);
            // Fast lookup grid (flattened 2D) — avoids string keys in hot paths
            const grid = new Array(cols * rows);
            for (let c = 0; c < cols; c++) {
                for (let ro = 0; ro < rows; ro++) {
                    const x = c * r * 1.5;
                    let y = ro * hexHeight;
                    if (c % 2 !== 0) y += hexHeight / 2;
                    const px = Math.floor(x);
                    const py = Math.floor(y);
                    if (px >= 0 && px < w && py >= 0 && py < h) {
                        const alpha = data[(py * w + px) * 4 + 3];
                        if (alpha > 40) {
                            const color = isProjectile ? '#ffcc00' : null;
                            const s = new HexShard(isProjectile ? null : cvs, dmgCvs, x, y, r, c, ro, color);
                            shards.push(s);
                            grid[c + ro * cols] = s;
                            map[c + "," + ro] = s;
                        }
                    }
                }
            }

            // --- PRE-CALCULATE NEIGHBORS (Softbody optimization) ---
            // Use numeric grid lookups (no string keys)
            for (const s of shards) {
                const nCoords = DestructorSystem.getNeighborCoords(s.c, s.r);
                for (let ni = 0; ni < nCoords.length; ni++) {
                    const nc = nCoords[ni];
                    if (nc.c < 0 || nc.c >= cols || nc.r < 0 || nc.r >= rows) continue;
                    const ns = grid[nc.c + nc.r * cols];
                    if (ns) s.neighbors.push(ns);
                }
            }
            // -------------------------------------------------------

            const cacheCvs = document.createElement('canvas');
            cacheCvs.width = w; cacheCvs.height = h;
            const cCtx = cacheCvs.getContext('2d');
            if (isProjectile) {
                cCtx.drawImage(image, 0, 0);
            } else {
                for (const s of shards) {
                    s.drawShape(cCtx);
                }
            }
            entity.hexGrid = {
                shards,
                map,
                grid,
                cols,
                rows,
                srcWidth: w,
                srcHeight: h,
                cacheCanvas: cacheCvs,
                cacheCtx: cCtx,
                cacheDirty: false
            };
            entity.radius = Math.max(w, h) / 2;
            entity.isProjectile = isProjectile;
            if (massOverride) {
                entity.mass = massOverride;
            } else {
                entity.mass = shards.length * DESTRUCTOR_CONFIG.shardMass;
            }
        }

        // drawHexBody — now a no-op stub; Three.js HexRenderer handles all entity rendering.
        // Kept for API compatibility (physics code references cacheDirty etc.)
        function drawHexBody(ctx, entity, camera) {
            // Three.js rendering is handled by HexRenderer.update() + HexRenderer.render()
        }

        let entities = [];
        const SHIP_URL = 'https://raw.githubusercontent.com/bazylowybazyl/statki/refs/heads/main/assets/capital_ship_rect_v1.png';
        const DAMAGED_URL = 'https://raw.githubusercontent.com/bazylowybazyl/statki/refs/heads/main/assets/damaged.png';
        const player = { x: -1200, y: 0, vx: 0, vy: 0, angle: 0, angVel: 0, radius: 100 };
        const dummy = { x: 1200, y: 0, vx: 0, vy: 0, angle: Math.PI, angVel: 0, radius: 100 };
        let mouse = { x: 0, y: 0, down: false, dragStart: null, dragCurrent: null };
        const keys = {};

        function init() {
            const shipImg = new Image();
            const damagedImg = new Image();
            shipImg.crossOrigin = "Anonymous";
            damagedImg.crossOrigin = "Anonymous";
            let loaded = 0;
            const onLoaded = () => {
                loaded++;
                if (loaded === 2) {
                    statusEl.textContent = "Obrazy załadowane.";
                    setupScene(shipImg, damagedImg);
                }
            };
            shipImg.onload = onLoaded;
            damagedImg.onload = onLoaded;
            shipImg.onerror = () => useFallback();
            damagedImg.onerror = () => useFallback();
            shipImg.src = SHIP_URL;
            damagedImg.src = DAMAGED_URL;
        }

        function setupScene(img, dmgImg) {
            initHexBody(player, img, dmgImg, false, 800000);
            initHexBody(dummy, img, dmgImg, false, DESTRUCTOR_CONFIG.dummyMass);
            entities.push(player, dummy);
            const debrisImg = new Image();
            debrisImg.src = createDebrisObstacle().toDataURL();
            debrisImg.onload = () => {
                for (let i = 0; i < 5; i++) {
                    const d = {
                        x: -400 + i * 150,
                        y: 0,
                        vx: 0, vy: 0, angle: Math.random(), angVel: 0, radius: 40
                    };
                    initHexBody(d, debrisImg, null, false, DESTRUCTOR_CONFIG.debrisMass);
                    entities.push(d);
                }
            };
            loop();
        }

        function useFallback() {
            statusEl.textContent = "Błąd sieci/CORS. Uruchamianie generatora awaryjnego...";
            const procImg = createProceduralShipImage('#445566');
            const procDmg = createProceduralShipImage('#222222');
            const img = new Image();
            img.onload = () => {
                const imgD = new Image();
                imgD.onload = () => setupScene(img, imgD);
                imgD.src = procDmg.toDataURL();
            };
            img.src = procImg.toDataURL();
        }

        function resetSim() {
            entities = [];
            player.x = -1200; player.y = 0; player.vx = 0; player.vy = 0; player.angle = 0;
            dummy.x = 1200; dummy.y = 0; dummy.vx = 0; dummy.vy = 0; dummy.angle = Math.PI;
            init();
            DestructorSystem.debris = [];
        }

        function fireAsteroid(startPos, endPos) {
            const dx = endPos.x - startPos.x;
            const dy = endPos.y - startPos.y;
            const len = Math.hypot(dx, dy);
            // ZWIĘKSZONO PRĘDKOŚĆ 2X
            const speed = Math.min(len * DESTRUCTOR_CONFIG.asteroidSpeedMult, DESTRUCTOR_CONFIG.asteroidMaxSpeed);
            const dirX = len > 0 ? dx / len : 0;
            const dirY = len > 0 ? dy / len : 1;
            const radius = 60;
            const asteroidImg = new Image();
            asteroidImg.src = createAsteroidImage(radius).toDataURL();
            const ast = {
                x: startPos.x,
                y: startPos.y,
                vx: dirX * speed,
                vy: dirY * speed,
                angle: Math.random() * Math.PI * 2,
                angVel: (Math.random() - 0.5) * 5,
                radius: radius
            };
            asteroidImg.onload = () => {
                // ZWIĘKSZONO MASĘ (1 000 000)
                initHexBody(ast, asteroidImg, null, false, DESTRUCTOR_CONFIG.asteroidMass);

                // ZWIĘKSZONO ŻYCIE (x10)
                if (ast.hexGrid) {
                    for (const s of ast.hexGrid.shards) {
                        s.maxHp *= DESTRUCTOR_CONFIG.asteroidHPMult;
                        s.hp = s.maxHp;
                    }
                }
                entities.push(ast);
            };
        }

        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.code === 'Space') resetSim();
            if (e.code === 'KeyR') DestructorSystem.repair(entities, 0.1);
            if (e.code === 'KeyP') Perf.toggle();
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            if (mouse.down) {
                mouse.dragCurrent = { x: mouse.x, y: mouse.y };
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                mouse.down = true;
                mouse.dragStart = { x: mouse.x, y: mouse.y };
                mouse.dragCurrent = { x: mouse.x, y: mouse.y };
            }
            if (e.button === 2) mouse.right = true;
        });
        window.addEventListener('mouseup', (e) => {
            if (e.button === 0 && mouse.dragStart) {
                const worldStart = screenToWorld(mouse.dragStart.x, mouse.dragStart.y, camera);
                const worldEnd = screenToWorld(mouse.dragCurrent.x, mouse.dragCurrent.y, camera);
                if (Math.hypot(mouse.dragStart.x - mouse.dragCurrent.x, mouse.dragStart.y - mouse.dragCurrent.y) > 10) {
                    fireAsteroid(worldStart, worldEnd);
                }
                mouse.down = false;
                mouse.dragStart = null;
                mouse.dragCurrent = null;
            }
            if (e.button === 2) mouse.right = false;
        });
        window.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSpeed = DESTRUCTOR_CONFIG.zoomSpeed;
            camera.zoom -= e.deltaY * zoomSpeed * camera.zoom;
            camera.zoom = Math.max(0.2, Math.min(camera.zoom, 3.0));
        }, { passive: false });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            HexRenderer.resize();
        });

        function updatePhysics(dt) {
            const t0 = performance.now();

            const speed = DESTRUCTOR_CONFIG.playerSpeed;
            if (keys['w']) {
                player.vx += Math.cos(player.angle) * speed * dt;
                player.vy += Math.sin(player.angle) * speed * dt;
            }
            if (keys['s']) {
                player.vx -= Math.cos(player.angle) * (speed * 0.5) * dt;
                player.vy -= Math.sin(player.angle) * (speed * 0.5) * dt;
            }
            const turnAcceleration = DESTRUCTOR_CONFIG.playerTurnAccel;
            const maxTurnSpeed = DESTRUCTOR_CONFIG.playerMaxTurn;

            if (keys['a']) {
                player.angVel -= turnAcceleration * dt;
            } else if (keys['d']) {
                player.angVel += turnAcceleration * dt;
            }

            player.vx *= 0.99;
            player.vy *= 0.99;
            player.angVel *= 0.92;

            if (Math.abs(player.angVel) > maxTurnSpeed) {
                player.angVel = Math.sign(player.angVel) * maxTurnSpeed;
            }

            dummy.vx *= 0.99;
            dummy.vy *= 0.99;
            dummy.angVel *= 0.95;

            const tDeform0 = performance.now();
            DestructorSystem.updateVisualDeformation(entities, dt);
            Perf.deformTime += performance.now() - tDeform0;

            const aliveEntities = [];
            for (const e of entities) {
                e.x += e.vx * dt;
                e.y += e.vy * dt;
                if (e.angVel) e.angle += e.angVel * dt;

                if (e.isProjectile && (e.dead || Math.hypot(e.x - player.x, e.y - player.y) > 5000)) {
                    continue;
                }
                aliveEntities.push(e);
            }
            if (aliveEntities.length !== entities.length) {
                entities.length = 0;
                entities.push(...aliveEntities);
            }

            if (mouse.right) {
                const mWorld = screenToWorld(mouse.x, mouse.y, camera);
                const dx = mWorld.x - player.x;
                const dy = mWorld.y - player.y;
                const len = Math.hypot(dx, dy);
                const ndx = dx / len;
                const ndy = dy / len;
                const beamLen = 3000;
                const p1 = { x: player.x, y: player.y };
                const p2 = { x: player.x + ndx * beamLen, y: player.y + ndy * beamLen };
                for (const target of entities) {
                    if (!target.hexGrid) continue;
                    DestructorSystem.cutByBeam(target, p1, p2, DESTRUCTOR_CONFIG.beamWidth);
                }
            }

            DestructorSystem.update(dt, entities);

            Perf.physicsTime += performance.now() - t0;
        }

        function draw() {
            const tDraw0 = performance.now();

            // --- Camera tracking ---
            const midX = (player.x + dummy.x) / 2;
            const midY = (player.y + dummy.y) / 2;
            camera.x += (midX - camera.x) * 0.1;
            camera.y += (midY - camera.y) * 0.1;

            // --- Canvas 2D: clear (transparent — background is CSS/WebGL) ---
            ctx.clearRect(0, 0, width, height);

            const gw = 100 * camera.zoom;
            const offX = (width / 2 - camera.x * camera.zoom) % gw;
            const offY = (height / 2 - camera.y * camera.zoom) % gw;
            ctx.strokeStyle = 'rgba(30, 30, 30, 0.6)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = offX; x < width; x += gw) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
            for (let y = offY; y < height; y += gw) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
            ctx.stroke();

            // --- Canvas 2D: debris (still on Canvas for now) ---
            DestructorSystem.draw(ctx, camera);

            // --- THREE.JS: update + render all hex entities ---
            HexRenderer.update(entities);
            HexRenderer.render();

            // --- Canvas 2D overlays: laser beam ---
            if (mouse.right) {
                const mWorld = screenToWorld(mouse.x, mouse.y, camera);
                const dx = mWorld.x - player.x;
                const dy = mWorld.y - player.y;
                const len = Math.hypot(dx, dy);
                if (len > 0.01) {
                    const ndx = dx / len;
                    const ndy = dy / len;
                    const beamLen = 3000;
                    const p1 = { x: player.x, y: player.y };
                    const p2 = { x: player.x + ndx * beamLen, y: player.y + ndy * beamLen };
                    const s1 = worldToScreen(p1.x, p1.y, camera);
                    const s2 = worldToScreen(p2.x, p2.y, camera);
                    ctx.save();
                    ctx.beginPath();
                    ctx.moveTo(s1.x, s1.y);
                    ctx.lineTo(s2.x, s2.y);
                    ctx.lineWidth = 5 * camera.zoom;
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // --- Canvas 2D overlays: drag arrow ---
            if (mouse.down && mouse.dragStart && mouse.dragCurrent) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(mouse.dragStart.x, mouse.dragStart.y);
                ctx.lineTo(mouse.dragCurrent.x, mouse.dragCurrent.y);
                ctx.strokeStyle = '#ffff00';
                ctx.fillStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                const angle = Math.atan2(mouse.dragCurrent.y - mouse.dragStart.y, mouse.dragCurrent.x - mouse.dragStart.x);
                ctx.translate(mouse.dragCurrent.x, mouse.dragCurrent.y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, -5);
                ctx.lineTo(-10, 5);
                ctx.fill();
                ctx.restore();
            }

            Perf.drawTime += performance.now() - tDraw0;
        }

        let lastTime = 0;
        function loop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1) || 0.016;
            lastTime = timestamp;

            const frameStart = performance.now();
            Perf.startFrame();

            updatePhysics(dt);
            draw();

            const frameEnd = performance.now();
            Perf.recordFrameTime(frameEnd - frameStart);
            Perf.flush(frameEnd);

            requestAnimationFrame(loop);
        }

        Perf.init();
        HexRenderer.init();
        init();
        document.getElementById('shipPicker').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                const img = new Image();
                img.onload = function () {
                    player.hexGrid = null;
                    const damagedImg = new Image();
                    damagedImg.src = DAMAGED_URL;
                    damagedImg.onload = () => {
                        initHexBody(player, img, damagedImg, false, DESTRUCTOR_CONFIG.playerStartingMass);
                        player.vx = 0;
                        player.vy = 0;
                        statusEl.textContent = "Wczytano nowy sprite: " + file.name;
                    };
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
    </script>
</body>

</html>