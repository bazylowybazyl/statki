<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Destruction Engine V52 - True Hybrid (Fixed)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #080808;
            color: #ccc;
            font-family: 'Segoe UI', monospace;
            user-select: none;
        }

        canvas {
            display: block;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: auto;
            background: rgba(15, 25, 40, 0.95);
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #446;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.6);
        }

        h3 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .key {
            color: #4db8ff;
            font-weight: bold;
        }

        .warn {
            color: #55ff55;
        }

        .feature {
            color: #ffaa00;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #888;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #333;
        }
    </style>
</head>

<body>
    <div id="ui">
        <h3>Hybrid Engine V52 (Fixed)</h3>
        <div><span class="key">[W / S]</span> - Silnik</div>
        <div><span class="key">[A / D]</span> - Obrót</div>
        <div><span class="key">[LPM]</span> - <b>PRZECIĄGNIJ: ASTEROIDA</b></div>
        <div><span class="key">[PPM]</span> - <b>LASER TNĄCY</b></div>
        <div><span class="key">[Spacja]</span> - Reset</div>
        <div style="margin-top: 10px; font-size: 13px;">
            <span class="feature">Hybrid Physics:</span><br>
            Low Impulse -> Rigid Body Bounce<br>
            High Impulse -> Soft Body Crush<br>
            <span class="warn">Yield Point: 1,000J</span>
        </div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #446;">
            <span class="feature">WŁASNY SPRITE:</span><br>
            <input type="file" id="shipPicker" accept="image/*" style="margin-top: 5px; font-size: 12px; color: #ccc;">
        </div>
    </div>
    <div id="status">Inicjalizacja...</div>
    <canvas id="c"></canvas>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        const camera = { x: 0, y: 0, zoom: 0.5 };

        function worldToScreen(wx, wy, cam) {
            return {
                x: (wx - cam.x) * cam.zoom + width / 2,
                y: (wy - cam.y) * cam.zoom + height / 2
            };
        }

        function screenToWorld(sx, sy, cam) {
            return {
                x: (sx - width / 2) / cam.zoom + cam.x,
                y: (sy - height / 2) / cam.zoom + cam.y
            };
        }

        const DESTRUCTOR_CONFIG = {
            gridDivisions: 16,
            shardHP: 500,
            armorThreshold: 0.4,
            maxDeform: 60.0,
            tearThreshold: 100.0,
            bendingRadius: 200.0,
            playerStartingMass: 800000,
            friction: 0.99,
            shardMass: 10.0,
            visualRotationOffset:0,
            yieldPoint: 1000.0,
            restitution: 0.05,
            plasticity: 0.00002
        };

        class HexShard {
            constructor(img, damagedImg, gridX, gridY, radius, c, r, color = null) {
                this.img = img;
                this.damagedImg = damagedImg;
                this.gridX = gridX;
                this.gridY = gridY;
                this.radius = radius;
                this.c = c;
                this.r = r;
                this.color = color;
                this.active = true;
                this.isDebris = false;
                this.maxHp = DESTRUCTOR_CONFIG.shardHP;
                this.hp = this.maxHp;
                this.deformation = { x: 0, y: 0 };
                this.targetDeformation = { x: 0, y: 0 };

                // --- NOWOŚĆ: Tablica deformacji wierzchołków (efekt strzępienia) ---
                this.frays = [];
                for (let i = 0; i < 6; i++) this.frays.push({ x: 0, y: 0 });
                // ------------------------------------------------------------------

                this.worldX = 0; this.worldY = 0;
                this.dvx = 0; this.dvy = 0; this.drot = 0;
                this.alpha = 1;
                this.angle = 0;
                this.scale = 1.0;
                this.neighbors = [];
                this.verts = [];
                for (let i = 0; i < 6; i++) {
                    const a = i * Math.PI / 3;
                    this.verts.push({ x: Math.cos(a) * radius, y: Math.sin(a) * radius });
                }
            }
            repair(dt) {
                if (!this.active || this.isDebris) return;
                const recoverSpeed = 1.5;
                this.targetDeformation.x *= (1.0 - Math.min(1.0, recoverSpeed * dt));
                this.targetDeformation.y *= (1.0 - Math.min(1.0, recoverSpeed * dt));

                // Opcjonalnie: Powolne naprawianie strzępienia (bardzo wolne, żeby ślady walki zostawały)
                // Jeśli chcesz trwałe zniszczenia, usuń poniższą pętlę.
                /*
                for(let i=0; i<6; i++) {
                    this.frays[i].x *= 0.99;
                    this.frays[i].y *= 0.99;
                }
                */

                this.hp = Math.min(this.maxHp, this.hp + 200 * dt);
            }
            updateAnimation(dt) {
                const lerpSpeed = 5.0;
                const dx = this.targetDeformation.x - this.deformation.x;
                const dy = this.targetDeformation.y - this.deformation.y;
                if (Math.abs(dx) > 0.05 || Math.abs(dy) > 0.05) {
                    this.deformation.x += dx * lerpSpeed * dt;
                    this.deformation.y += dy * lerpSpeed * dt;
                    return true;
                }
                return false;
            }
            applyDeformation(vecX, vecY) {
                this.targetDeformation.x += vecX;
                this.targetDeformation.y += vecY;
                const dist = Math.hypot(this.targetDeformation.x, this.targetDeformation.y);
                if (dist > DESTRUCTOR_CONFIG.tearThreshold) this.hp = 0;
            }
            becomeDebris(impulseX, impulseY, parentEntity, scale = 1.0) {
                if (this.isDebris) return;
                this.scale = scale;
                const px = parentEntity.x;
                const py = parentEntity.y;
                const rotation = parentEntity.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const c = Math.cos(rotation);
                const s = Math.sin(rotation);
                const centerX = parentEntity.hexGrid.srcWidth / 2;
                const centerY = parentEntity.hexGrid.srcHeight / 2;
                const pX = parentEntity.hexGrid.pivot ? parentEntity.hexGrid.pivot.x : 0;
                const pY = parentEntity.hexGrid.pivot ? parentEntity.hexGrid.pivot.y : 0;
                const startLx = (this.gridX - centerX) + this.deformation.x - pX;
                const startLy = (this.gridY - centerY) + this.deformation.y - pY;
                this.worldX = px + (startLx * scale) * c - (startLy * scale) * s;
                this.worldY = py + (startLx * scale) * s + (startLy * scale) * c;
                let vx = parentEntity.vx || 0;
                let vy = parentEntity.vy || 0;
                const angVel = parentEntity.angVel || 0;
                const rx = (startLx * scale) * c - (startLy * scale) * s;
                const ry = (startLx * scale) * s + (startLy * scale) * c;
                vx += -angVel * ry;
                vy += angVel * rx;
                this.dvx = vx + impulseX + (this.deformation.x * 3.0);
                this.dvy = vy + impulseY + (this.deformation.y * 3.0);
                this.drot = (Math.random() - 0.5) * 8.0;
                this.angle = rotation;
                this.alpha = 1.0;
                this.isDebris = true;
                this.active = true;
                DestructorSystem.debris.push(this);
                if (parentEntity.mass) {
                    parentEntity.mass -= DESTRUCTOR_CONFIG.shardMass;
                    if (parentEntity.mass < 10) parentEntity.mass = 10;
                }
            }
            updateDebris(dt) {
                this.worldX += this.dvx * dt;
                this.worldY += this.dvy * dt;
                this.angle += this.drot * dt;
                this.dvx *= DESTRUCTOR_CONFIG.friction;
                this.dvy *= DESTRUCTOR_CONFIG.friction;
                this.alpha -= dt * 0.2;
                if (this.alpha <= 0) this.active = false;
            }
            drawDebris(ctx, camera) {
                if (!this.active || !this.isDebris) return;
                const p = worldToScreen(this.worldX, this.worldY, camera);
                if (p.x < -100 || p.x > ctx.canvas.width + 100 || p.y < -100 || p.y > ctx.canvas.height + 100) return;
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(this.angle);
                const s = camera.zoom * (this.scale || 1.0);
                ctx.scale(s, s);
                ctx.globalAlpha = Math.max(0, this.alpha);
                this._drawHexPath(ctx);
                ctx.clip();
                if (this.damagedImg) ctx.drawImage(this.damagedImg, -this.gridX, -this.gridY);
                else if (this.img) ctx.drawImage(this.img, -this.gridX, -this.gridY);
                else { ctx.fillStyle = '#444'; ctx.fill(); }
                ctx.restore();
            }
            drawShape(ctx) {
                // (Ta metoda pozostaje bez zmian, ale wklejam dla kontekstu)
                ctx.save();
                ctx.translate(this.gridX + this.deformation.x, this.gridY + this.deformation.y);
                this._drawHexPath(ctx); // To wywoła naszą nową funkcję
                ctx.save();
                ctx.clip();
                if (this.color) { ctx.fillStyle = this.color; ctx.fill(); }
                else {
                    if (this.damagedImg) ctx.drawImage(this.damagedImg, -this.gridX, -this.gridY);
                    else { ctx.fillStyle = '#222'; ctx.fill(); }
                    if (this.img) {
                        const hpRatio = this.hp / this.maxHp;
                        const threshold = DESTRUCTOR_CONFIG.armorThreshold;
                        let armorAlpha = 0;
                        if (hpRatio > threshold) armorAlpha = (hpRatio - threshold) / (1.0 - threshold);
                        if (armorAlpha > 0.01) {
                            ctx.globalAlpha = armorAlpha;
                            ctx.drawImage(this.img, -this.gridX, -this.gridY);
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                ctx.restore();
                const stress = Math.hypot(this.deformation.x, this.deformation.y);
                if (stress > 5.0) {
                    const ratio = Math.min(1.0, stress / DESTRUCTOR_CONFIG.tearThreshold);
                    const alpha = ratio * 0.6;
                    ctx.fillStyle = `rgba(255, ${Math.floor(ratio * 100)}, 0, ${alpha})`;
                    ctx.fill();
                }
                ctx.restore();
            }

            _drawHexPath(ctx) {
                ctx.beginPath();
                const overlap = 1.08;

                // --- NOWOŚĆ: Rysowanie z uwzględnieniem strzępów (this.frays) ---
                // Pierwszy punkt
                let fx = this.verts[0].x + this.frays[0].x;
                let fy = this.verts[0].y + this.frays[0].y;
                ctx.moveTo(fx * overlap, fy * overlap);

                // Reszta punktów
                for (let i = 1; i < 6; i++) {
                    fx = this.verts[i].x + this.frays[i].x;
                    fy = this.verts[i].y + this.frays[i].y;
                    ctx.lineTo(fx * overlap, fy * overlap);
                }
                // ----------------------------------------------------------------
                ctx.closePath();
            }
        }

        const DestructorSystem = {
            debris: [],
            splitQueue: [],
            _tick: 0,
            update(dt, entities) {
                for (let i = this.debris.length - 1; i >= 0; i--) {
                    const d = this.debris[i];
                    d.updateDebris(dt);
                    if (!d.active) this.debris.splice(i, 1);
                }
                this._tick++;

                // V36 Feature: Softbody propagation
                this.simulateElasticity(entities);
                const iterations = 4;
                for (let i = 0; i < iterations; i++) {
                    this.resolveCollisions(entities, dt);
                }
                if (this._tick % 10 === 0 && this.splitQueue.length > 0) this.processSplits(entities);
            },

            updateVisualDeformation(entities, dt) {
                for (const e of entities) {
                    if (e.hexGrid) {
                        let moving = false;
                        for (const s of e.hexGrid.shards) {
                            if (!s.active || s.isDebris) continue;
                            if (s.updateAnimation(dt)) moving = true;
                        }
                        if (moving) e.hexGrid.cacheDirty = true;
                    }
                }
            },

            simulateElasticity(entities) {
                const tension = 0.0; // Wewnętrzne "trzęsienie się" poszycia
                if (tension <= 0) return;
                for (const e of entities) {
                    if (!e.hexGrid) continue;
                    for (const s of e.hexGrid.shards) {
                        if (!s.active || s.isDebris) continue;
                        if (s.neighbors.length === 0) continue;
                        if (Math.abs(s.deformation.x) > 0.1 || Math.abs(s.deformation.y) > 0.1) {
                            for (const n of s.neighbors) {
                                if (!n.active || n.isDebris) continue;
                                const dx = s.deformation.x - n.deformation.x;
                                const dy = s.deformation.y - n.deformation.y;
                                const transferX = dx * tension;
                                const transferY = dy * tension;
                                n.deformation.x += transferX;
                                n.deformation.y += transferY;
                            }
                            e.hexGrid.cacheDirty = true;
                        }
                    }
                }
            },

            repair(entities, dt) {
                for (const e of entities) {
                    if (e.hexGrid && e.hexGrid.shards) {
                        let anyFix = false;
                        for (const s of e.hexGrid.shards) {
                            if (s.active && !s.isDebris) {
                                if (Math.abs(s.deformation.x) > 0.1 || Math.abs(s.deformation.y) > 0.1 || s.hp < s.maxHp) {
                                    s.repair(dt);
                                    anyFix = true;
                                }
                            }
                        }
                        if (anyFix) e.hexGrid.cacheDirty = true;
                    }
                }
            },

            distributeStructuralDamage(entity, impactLocalX, impactLocalY, forceX, forceY) {
                const radius = DESTRUCTOR_CONFIG.bendingRadius;
                const radiusSq = radius * radius;
                const deformMul = 0.6;
                let anyDestroyed = false;
                const pivotX = entity.hexGrid.pivot ? entity.hexGrid.pivot.x : 0;
                const pivotY = entity.hexGrid.pivot ? entity.hexGrid.pivot.y : 0;
                const adjustedImpactX = impactLocalX + pivotX;
                const adjustedImpactY = impactLocalY + pivotY;

                // Parametry strzępienia
                const tearSensitivity = 0.15; // Jak łatwo metal się drze
                const maxFray = 15.0;         // Maksymalne przesunięcie wierzchołka (piksele)

                for (const shard of entity.hexGrid.shards) {
                    if (!shard.active || shard.isDebris) continue;
                    const cx = entity.hexGrid.srcWidth / 2;
                    const cy = entity.hexGrid.srcHeight / 2;
                    const shardLx = shard.gridX - cx;
                    const shardLy = shard.gridY - cy;
                    const dx = shardLx - adjustedImpactX;
                    const dy = shardLy - adjustedImpactY;
                    const d2 = dx * dx + dy * dy;
                    if (d2 < radiusSq) {
                        const dist = Math.sqrt(d2);
                        const factor = Math.max(0, (1 - dist / radius));
                        const influence = factor * factor * (3 - 2 * factor);

                        // 1. Softbody (V36 logic) - to co było
                        shard.applyDeformation(forceX * influence * deformMul, forceY * influence * deformMul);

                        // --- NOWOŚĆ: EFEKT STRZĘPIENIA (SHREDDING) ---
                        // Aplikujemy tylko jeśli siła jest duża
                        const forceMag = Math.hypot(forceX, forceY);
                        if (forceMag > 2.0) {
                            // Normalizujemy wektor siły (kierunek uderzenia)
                            const nx = forceX / forceMag;
                            const ny = forceY / forceMag;

                            for (let i = 0; i < 6; i++) {
                                // Każdy wierzchołek dostaje losowe przesunięcie w kierunku siły
                                // influence sprawia, że bliżej centrum uderzenia drze się mocniej
                                const randomTear = Math.random() * forceMag * influence * tearSensitivity;

                                // Dodajemy szum (żeby nie przesuwały się równo, tylko "szarpały")
                                shard.frays[i].x += nx * randomTear + (Math.random() - 0.5) * randomTear * 0.5;
                                shard.frays[i].y += ny * randomTear + (Math.random() - 0.5) * randomTear * 0.5;

                                // Limit maksymalnego rozdarcia (żeby heks nie eksplodował graficznie na pół ekranu)
                                // Ale pozwalamy na lekkie wyjście poza limit dla efektu "wow"
                                const currentFray = Math.hypot(shard.frays[i].x, shard.frays[i].y);
                                if (currentFray > maxFray) {
                                    const scale = maxFray / currentFray;
                                    shard.frays[i].x *= scale;
                                    shard.frays[i].y *= scale;
                                }
                            }
                        }
                        // ---------------------------------------------

                        shard.hp -= (Math.abs(forceX) + Math.abs(forceY)) * influence * 0.1;
                        if (shard.hp <= 0) {
                            this.destroyShard(entity, shard, { x: entity.vx, y: entity.vy });
                            anyDestroyed = true;
                        }
                    }
                }
                if (anyDestroyed) this.splitQueue.push(entity);
                entity.hexGrid.cacheDirty = true;
            },

            resolveCollisions(entities, dt) {
                for (let i = 0; i < entities.length; i++) {
                    const A = entities[i];
                    if (!A.hexGrid) continue;
                    for (let j = i + 1; j < entities.length; j++) {
                        const B = entities[j];
                        if (!B.hexGrid) continue;
                        if (A.owner === B || B.owner === A) continue;
                        const distSq = (A.x - B.x) ** 2 + (A.y - B.y) ** 2;
                        const radSum = (A.radius || 100) + (B.radius || 100);
                        if (distSq > radSum ** 2) continue;
                        this.collideEntities(A, B, dt);
                    }
                }
            },

            // --- HYBRID COLLISION SOLVER (V36 Detection + V46 Impulse Physics) ---
            collideEntities(A, B, dt) {
                const r = DESTRUCTOR_CONFIG.gridDivisions;

                // 1. V36 DETEKCJA (Precyzyjna mapa heksów)
                const massA = A.mass || 100;
                const massB = B.mass || 100;
                const angA = A.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const angB = B.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const ca = Math.cos(angA), sa = Math.sin(angA);
                const cb = Math.cos(angB), sb = Math.sin(angB);
                const cb_inv = Math.cos(-angB), sb_inv = Math.sin(-angB);

                const cxA = A.hexGrid.srcWidth / 2;
                const cyA = A.hexGrid.srcHeight / 2;
                const cxB = B.hexGrid.srcWidth / 2;
                const cyB = B.hexGrid.srcHeight / 2;
                const pivotAx = A.hexGrid.pivot ? A.hexGrid.pivot.x : 0;
                const pivotAy = A.hexGrid.pivot ? A.hexGrid.pivot.y : 0;
                const pivotBx = B.hexGrid.pivot ? B.hexGrid.pivot.x : 0;
                const pivotBy = B.hexGrid.pivot ? B.hexGrid.pivot.y : 0;

                const hitRadSq = (r * 1.3) ** 2;

                const contacts = [];
                const maxContacts = 8;

                // Sprawdzamy kolizję heksów
                for (const shardA of A.hexGrid.shards) {
                    if (!shardA.active || shardA.isDebris) continue;

                    const relX = (shardA.gridX - cxA) + shardA.deformation.x - pivotAx;
                    const relY = (shardA.gridY - cyA) + shardA.deformation.y - pivotAy;
                    const worldAx = A.x + relX * ca - relY * sa;
                    const worldAy = A.y + relX * sa + relY * ca;

                    const dx = worldAx - B.x;
                    const dy = worldAy - B.y;
                    const localBx = dx * cb_inv - dy * sb_inv;
                    const localBy = dx * sb_inv + dy * cb_inv;
                    const gridBx = localBx + cxB + pivotBx;
                    const gridBy = localBy + cyB + pivotBy;

                    // Mapa dla dużych obiektów
                    const h = r * Math.sqrt(3);
                    const approxC = Math.round(gridBx / (r * 1.5));
                    const approxR = Math.round(gridBy / h);

                    // Szukamy w mapie B
                    for (let dc = -2; dc <= 2; dc++) {
                        for (let dr = -2; dr <= 2; dr++) {
                            const key = (approxC + dc) + "," + (approxR + dr);
                            const shardB = B.hexGrid.map[key];
                            if (shardB && shardB.active && !shardB.isDebris) {
                                const gx = shardB.gridX + shardB.deformation.x;
                                const gy = shardB.gridY + shardB.deformation.y;
                                if ((gx - gridBx) ** 2 + (gy - gridBy) ** 2 < hitRadSq) {
                                    const relBX = gx - cxB - pivotBx;
                                    const relBY = gy - cyB - pivotBy;
                                    const worldBx = B.x + relBX * cb - relBY * sb;
                                    const worldBy = B.y + relBX * sb + relBY * cb;
                                    const normalX = worldAx - worldBx;
                                    const normalY = worldAy - worldBy;
                                    const hexDist = Math.hypot(normalX, normalY);

                                    contacts.push({
                                        shardA,
                                        shardB,
                                        worldAx,
                                        worldAy,
                                        worldBx,
                                        worldBy,
                                        normalX,
                                        normalY,
                                        penetration: Math.max(0, r * 1.3 - hexDist),
                                    });

                                    if (contacts.length >= maxContacts) break;
                                }
                            }
                        }
                        if (contacts.length >= maxContacts) break;
                    }
                    if (contacts.length >= maxContacts) break;
                }

                if (contacts.length === 0) return;

                const primaryContact = contacts[0];
                const sA = primaryContact.shardA;
                const hitB = primaryContact.shardB;

                let worldHitX = 0;
                let worldHitY = 0;
                let nx = 0;
                let ny = 0;
                let penetration = 0;

                for (const contact of contacts) {
                    worldHitX += (contact.worldAx + contact.worldBx) * 0.5;
                    worldHitY += (contact.worldAy + contact.worldBy) * 0.5;
                    nx += contact.normalX;
                    ny += contact.normalY;
                    penetration = Math.max(penetration, contact.penetration);
                }

                worldHitX /= contacts.length;
                worldHitY /= contacts.length;

                let normalLen = Math.hypot(nx, ny);
                if (normalLen < 1e-6) {
                    nx = A.x - B.x;
                    ny = A.y - B.y;
                    normalLen = Math.hypot(nx, ny) || 1;
                }
                nx /= normalLen;
                ny /= normalLen;

                // --- 2. V46 PHYSICS SOLVER (Rigid Body Impulse) ---

                // Wektory ramienia siły
                const rAx = worldHitX - A.x;
                const rAy = worldHitY - A.y;
                const rBx = worldHitX - B.x;
                const rBy = worldHitY - B.y;

                // Prędkości w punkcie zderzenia
                const vAx = A.vx - A.angVel * rAy;
                const vAy = A.vy + A.angVel * rAx;
                const vBx = B.vx - B.angVel * rBy;
                const vBy = B.vy + B.angVel * rBx;

                const dvx = vAx - vBx;
                const dvy = vAy - vBy;

                // Prędkość wzdłuż normalnej
                const velAlongNormal = dvx * nx + dvy * ny;

                // Jeśli obiekty się oddalają, nie reagujemy
                if (velAlongNormal > 0) return;

                // Obliczanie skalara impulsu (j)
                const restitution = DESTRUCTOR_CONFIG.restitution;
                const invMassA = 1 / massA;
                const invMassB = 1 / massB;
                const inertiaScale = 0.5;
                const effectiveRadiusA = Math.max(1, A.radius || Math.max(cxA, cyA, 1));
                const effectiveRadiusB = Math.max(1, B.radius || Math.max(cxB, cyB, 1));
                const invIa = 1 / (inertiaScale * massA * effectiveRadiusA * effectiveRadiusA);
                const invIb = 1 / (inertiaScale * massB * effectiveRadiusB * effectiveRadiusB);

                const rnA = rAx * ny - rAy * nx;
                const rnB = rBx * ny - rBy * nx;

                let j = -(1 + restitution) * velAlongNormal;
                const normalDenom = invMassA + invMassB + rnA * rnA * invIa + rnB * rnB * invIb;
                if (!Number.isFinite(normalDenom) || normalDenom <= 1e-8) return;
                j /= normalDenom;

                // --- FIX: DEFINICJA isDestruction ZANIM UŻYJEMY JEJ W TARCIU ---
                const impactForce = Math.abs(j);
                const yieldPoint = DESTRUCTOR_CONFIG.yieldPoint;
                const isDestruction = impactForce > yieldPoint;
                // -------------------------------------------------------------

                // Aplikacja impulsu (RIGID BODY - ODBICIE)
                const impulseX = j * nx;
                const impulseY = j * ny;

                A.vx += impulseX * invMassA;
                A.vy += impulseY * invMassA;
                B.vx -= impulseX * invMassB;
                B.vy -= impulseY * invMassB;

                A.angVel += rnA * j * invIa;
                B.angVel -= rnB * j * invIb;

                // Tarcie
                let tx = -ny, ty = nx;
                const velTangent = dvx * tx + dvy * ty;
                let jt = -velTangent;
                const tangentDenom = invMassA + invMassB + (rAx * ty - rAy * tx) ** 2 * invIa + (rBx * ty - rBy * tx) ** 2 * invIb;
                if (!Number.isFinite(tangentDenom) || tangentDenom <= 1e-8) {
                    jt = 0;
                } else {
                    jt /= tangentDenom;
                }
                const mu = 0.5;
                if (Math.abs(jt) > j * mu) jt = -j * mu * Math.sign(velTangent);

                // Tutaj isDestruction jest już zdefiniowane!
                const frictionScale = isDestruction ? 0.05 : 0.8;
                const scaledJt = jt * frictionScale;

                const fImpulseX = scaledJt * tx;
                const fImpulseY = scaledJt * ty;

                A.vx += fImpulseX * invMassA;
                A.vy += fImpulseY * invMassA;
                B.vx -= fImpulseX * invMassB;
                B.vy -= fImpulseY * invMassB;

                A.angVel += (rAx * ty - rAy * tx) * scaledJt * invIa;
                B.angVel -= (rBx * ty - rBy * tx) * scaledJt * invIb;

                // --- 3. HYBRID THRESHOLD (Yield Point) - POPRAWIONE WEKTORY ---
                if (isDestruction) {
                    // Obliczamy nadmiar energii, który pójdzie w deformację
                    const excessForce = (impactForce - yieldPoint) * DESTRUCTOR_CONFIG.plasticity;

                    const totalInvMass = invMassA + invMassB;
                    const damageShareA = invMassA / totalInvMass;
                    const damageShareB = invMassB / totalInvMass;

                    // Środki eksplozji deformacji (lokalne dla każdego obiektu)
                    const relX_A = (sA.gridX - cxA) + sA.deformation.x - pivotAx;
                    const relY_A = (sA.gridY - cyA) + sA.deformation.y - pivotAy;
                    const relX_B = (hitB.gridX - cxB) + hitB.deformation.x - pivotBx;
                    const relY_B = (hitB.gridY - cyB) + hitB.deformation.y - pivotBy;

                    // Obracamy wektor normalnej zderzenia do układu lokalnego statków
                    const ca_inv = Math.cos(-angA), sa_inv = Math.sin(-angA);
                    const forceAx_Local = (nx * excessForce * damageShareA) * ca_inv - (ny * excessForce * damageShareA) * sa_inv;
                    const forceAy_Local = (nx * excessForce * damageShareA) * sa_inv + (ny * excessForce * damageShareA) * ca_inv;

                    const cb_inv2 = Math.cos(-angB), sb_inv2 = Math.sin(-angB);
                    const forceBx_Local = (-nx * excessForce * damageShareB) * cb_inv2 - (-ny * excessForce * damageShareB) * sb_inv2;
                    const forceBy_Local = (-nx * excessForce * damageShareB) * sb_inv2 + (-ny * excessForce * damageShareB) * cb_inv2;

                    // Aplikujemy deformację
                    this.distributeStructuralDamage(A, relX_A, relY_A, forceAx_Local, forceAy_Local);
                    this.distributeStructuralDamage(B, relX_B, relY_B, forceBx_Local, forceBy_Local);
                }

                // --- 4. SEPARATION ---
                const percent = 0.8;
                const slop = 0.01;
                if (penetration > slop) {
                    const correctionMag = Math.max(penetration - slop, 0.0) / (invMassA + invMassB) * percent;
                    const cx = nx * correctionMag;
                    const cy = ny * correctionMag;
                    A.x += cx * invMassA;
                    A.y += cy * invMassA;
                    B.x -= cx * invMassB;
                    B.y -= cy * invMassB;
                }
            },

            destroyShard(entity, shard, velVector) {
                shard.hp = 0;
                const ctx = entity.hexGrid.cacheCtx;
                if (ctx) {
                    ctx.save();
                    ctx.translate(shard.gridX, shard.gridY);
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(0, 0, shard.radius * 1.05, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    ctx.globalCompositeOperation = 'source-over';
                }
                const deformVelX = shard.deformation.x * 2.0;
                const deformVelY = shard.deformation.y * 2.0;
                shard.becomeDebris(velVector.x * 0.3 + deformVelX, velVector.y * 0.3 + deformVelY, entity, 1.0);
            },
            processSplits(entities) {
                const queue = [...new Set(this.splitQueue)];
                this.splitQueue = [];
                for (const entity of queue) {
                    if (!entity.hexGrid || !entities.includes(entity)) continue;
                    const groups = this.findIslands(entity.hexGrid);
                    if (groups.length <= 1) continue;
                    groups.sort((a, b) => b.length - a.length);
                    const mainGroup = groups[0];
                    const looseGroups = groups.slice(1);
                    this.rebuildEntityGrid(entity, mainGroup);
                    for (const group of looseGroups) {
                        if (group.length < 3) {
                            for (const s of group) this.destroyShard(entity, s, { x: entity.vx, y: entity.vy });
                            continue;
                        }
                        this.spawnWreckEntity(entity, group, entities);
                    }
                }
            },
            findIslands(grid) {
                const activeShards = grid.shards.filter(s => s.active && !s.isDebris);
                if (activeShards.length === 0) return [];
                const map = {};
                for (const s of activeShards) map[s.c + "," + s.r] = s;
                const visited = new Set();
                const groups = [];
                for (const seed of activeShards) {
                    if (visited.has(seed)) continue;
                    const group = [];
                    const stack = [seed];
                    visited.add(seed);
                    while (stack.length > 0) {
                        const curr = stack.pop();
                        group.push(curr);
                        if (curr.neighbors) {
                            for (const neighbor of curr.neighbors) {
                                if (neighbor && neighbor.active && !neighbor.isDebris && !visited.has(neighbor)) {
                                    visited.add(neighbor);
                                    stack.push(neighbor);
                                }
                            }
                        }
                    }
                    groups.push(group);
                }
                return groups;
            },
            getNeighborCoords(c, r) {
                const odd = (c % 2 !== 0);
                const offsets = odd
                    ? [[0, -1], [0, 1], [-1, 0], [-1, 1], [1, 0], [1, 1]]
                    : [[0, -1], [0, 1], [-1, -1], [-1, 0], [1, -1], [1, 0]];
                return offsets.map(o => ({ c: c + o[0], r: r + o[1] }));
            },
            rebuildEntityGrid(entity, shards) {
                const map = {};
                for (const s of shards) map[s.c + "," + s.r] = s;
                entity.hexGrid.shards = shards;
                entity.hexGrid.map = map;
                entity.hexGrid.cacheDirty = true;
                entity.mass = shards.length * DESTRUCTOR_CONFIG.shardMass;
            },
            spawnWreckEntity(parent, shards, entities) {
                // 1. Obliczanie środka masy (Pivot)
                let sumX = 0, sumY = 0;
                for (const s of shards) {
                    sumX += (s.gridX + s.deformation.x);
                    sumY += (s.gridY + s.deformation.y);
                }
                const avgX = sumX / shards.length;
                const avgY = sumY / shards.length;

                const cx = parent.hexGrid.srcWidth / 2;
                const cy = parent.hexGrid.srcHeight / 2;
                const relX = avgX - cx;
                const relY = avgY - cy;

                // --- FIX: OBLICZANIE NOWEGO PROMIENIA (RADIUS) ---
                // Sprawdzamy jak daleko najdalszy heks leży od nowego środka (avgX, avgY)
                let maxDistSq = 0;
                for (const s of shards) {
                    const dx = (s.gridX + s.deformation.x) - avgX;
                    const dy = (s.gridY + s.deformation.y) - avgY;
                    const d2 = dx * dx + dy * dy;
                    if (d2 > maxDistSq) maxDistSq = d2;
                }
                const newRadius = Math.sqrt(maxDistSq) + DESTRUCTOR_CONFIG.gridDivisions * 2.0;
                // --------------------------------------------------

                const ang = parent.angle + DESTRUCTOR_CONFIG.visualRotationOffset;
                const c = Math.cos(ang);
                const s = Math.sin(ang);
                const worldX = parent.x + relX * c - relY * s;
                const worldY = parent.y + relX * s + relY * c;

                const wreck = {
                    x: worldX, y: worldY,
                    vx: parent.vx, vy: parent.vy,
                    angle: parent.angle, angVel: parent.angVel,

                    radius: newRadius, // <--- TUTAJ PRZYPISUJEMY OBLICZONY PROMIEŃ

                    mass: shards.length * DESTRUCTOR_CONFIG.shardMass,
                    isWreck: true,
                    hexGrid: {
                        shards: shards,
                        map: {},
                        srcWidth: parent.hexGrid.srcWidth,
                        srcHeight: parent.hexGrid.srcHeight,
                        cacheCanvas: parent.hexGrid.cacheCanvas.cloneNode(),
                        cacheCtx: null,
                        cacheDirty: true,
                        pivot: { x: relX, y: relY }
                    }
                };
                wreck.hexGrid.cacheCtx = wreck.hexGrid.cacheCanvas.getContext('2d');
                for (const s of shards) wreck.hexGrid.map[s.c + "," + s.r] = s;
                entities.push(wreck);
            },
            cutByBeam(entity, p1, p2, beamWidth) {
                if (!entity.hexGrid) return;
                const ang = -(entity.angle + DESTRUCTOR_CONFIG.visualRotationOffset);
                const cos = Math.cos(ang);
                const sin = Math.sin(ang);
                const ex = entity.x;
                const ey = entity.y;
                const dx1 = p1.x - ex; const dy1 = p1.y - ey;
                const dx2 = p2.x - ex; const dy2 = p2.y - ey;
                const l1x = dx1 * cos - dy1 * sin; const l1y = dx1 * sin + dy1 * cos;
                const l2x = dx2 * cos - dy2 * sin; const l2y = dx2 * sin + dy2 * cos;
                const cx = entity.hexGrid.srcWidth / 2;
                const cy = entity.hexGrid.srcHeight / 2;
                const pivotX = entity.hexGrid.pivot ? entity.hexGrid.pivot.x : 0;
                const pivotY = entity.hexGrid.pivot ? entity.hexGrid.pivot.y : 0;
                const lineStart = { x: l1x + cx + pivotX, y: l1y + cy + pivotY };
                const lineEnd = { x: l2x + cx + pivotX, y: l2y + cy + pivotY };
                const minX = Math.min(lineStart.x, lineEnd.x) - beamWidth * 2;
                const maxX = Math.max(lineStart.x, lineEnd.x) + beamWidth * 2;
                const minY = Math.min(lineStart.y, lineEnd.y) - beamWidth * 2;
                const maxY = Math.max(lineStart.y, lineEnd.y) + beamWidth * 2;
                const lineVecX = lineEnd.x - lineStart.x;
                const lineVecY = lineEnd.y - lineStart.y;
                const lineLenSq = lineVecX * lineVecX + lineVecY * lineVecY;
                const perpX = -lineVecY;
                const perpY = lineVecX;
                const perpLen = Math.sqrt(perpX * perpX + perpY * perpY) || 1;
                const pushDirX = perpX / perpLen;
                const pushDirY = perpY / perpLen;
                const rotBack = -ang;
                const cosB = Math.cos(rotBack);
                const sinB = Math.sin(rotBack);
                let anyHit = false;
                for (const shard of entity.hexGrid.shards) {
                    if (!shard.active || shard.isDebris) continue;
                    const px = shard.gridX + shard.deformation.x;
                    const py = shard.gridY + shard.deformation.y;
                    if (px < minX || px > maxX || py < minY || py > maxY) continue;
                    let t = ((px - lineStart.x) * lineVecX + (py - lineStart.y) * lineVecY) / lineLenSq;
                    t = Math.max(0, Math.min(1, t));
                    const closestX = lineStart.x + t * lineVecX;
                    const closestY = lineStart.y + t * lineVecY;
                    const distSq = (px - closestX) ** 2 + (py - closestY) ** 2;
                    if (distSq < (beamWidth + shard.radius * 1.2) ** 2) {
                        const cross = (px - lineStart.x) * lineVecY - (py - lineStart.y) * lineVecX;
                        const side = cross > 0 ? 1 : -1;
                        const worldImpulseLocalX = pushDirX * side * 400;
                        const worldImpulseLocalY = pushDirY * side * 400;
                        const wImpX = worldImpulseLocalX * cosB - worldImpulseLocalY * sinB;
                        const wImpY = worldImpulseLocalX * sinB + worldImpulseLocalY * cosB;
                        this.destroyShard(entity, shard, { x: entity.vx + wImpX * 0.05, y: entity.vy + wImpY * 0.05 });
                        entity.hexGrid.cacheDirty = true;
                        anyHit = true;
                    }
                }
                if (anyHit) this.splitQueue.push(entity);
            },
            draw(ctx, camera) {
                for (const d of this.debris) {
                    d.drawDebris(ctx, camera);
                }
            }
        };

        function createProjectileImage() {
            const size = 64;
            const c = document.createElement('canvas');
            c.width = size; c.height = size;
            const ctx = c.getContext('2d');
            const grad = ctx.createRadialGradient(size / 2, size / 2, 4, size / 2, size / 2, size / 2);
            grad.addColorStop(0, '#ffffaa');
            grad.addColorStop(0.4, '#ffaa00');
            grad.addColorStop(1, 'rgba(255, 100, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 3, 0, Math.PI * 2);
            ctx.stroke();
            return c;
        }
        const projectileImg = createProjectileImage();

        function createProceduralShipImage(color) {
            const c = document.createElement('canvas');
            c.width = 160; c.height = 300;
            const x = c.getContext('2d');
            x.fillStyle = color || '#445566';
            x.fillRect(40, 20, 80, 260);
            x.fillStyle = '#667788';
            x.fillRect(20, 180, 120, 80);
            x.fillStyle = '#33ccff';
            x.fillRect(60, 40, 40, 40);
            return c;
        }

        function createDebrisObstacle() {
            const c = document.createElement('canvas');
            c.width = 80; c.height = 80;
            const x = c.getContext('2d');
            x.fillStyle = '#554433';
            x.beginPath();
            x.arc(40, 40, 35, 0, Math.PI * 2);
            x.fill();
            return c;
        }

        function createAsteroidImage(radius) {
            const c = document.createElement('canvas');
            c.width = radius * 2; c.height = radius * 2;
            const ctx = c.getContext('2d');
            const cx = radius; const cy = radius;
            ctx.fillStyle = '#665544';
            ctx.beginPath();
            for (let a = 0; a < Math.PI * 2; a += 0.4) {
                const r = radius * (0.8 + Math.random() * 0.2);
                const x = cx + Math.cos(a) * r;
                const y = cy + Math.sin(a) * r;
                if (a === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            for (let i = 0; i < 30; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#554433' : '#776655';
                const s = Math.random() * radius * 0.4;
                const x = Math.random() * c.width;
                const y = Math.random() * c.height;
                if (Math.hypot(x - cx, y - cy) < radius * 0.7) {
                    ctx.beginPath(); ctx.arc(x, y, s, 0, Math.PI * 2); ctx.fill();
                }
            }
            return c;
        }

        function initHexBody(entity, image, damagedImage, isProjectile = false, massOverride = null) {
            const w = Math.ceil(image.width / 2) * 2;
            const h = Math.ceil(image.height / 2) * 2;
            const r = DESTRUCTOR_CONFIG.gridDivisions;
            const hexHeight = Math.sqrt(3) * r;
            let data = null;
            let ctx = null;
            const cvs = document.createElement('canvas');
            cvs.width = w; cvs.height = h;
            ctx = cvs.getContext('2d');
            let dmgCvs = null;
            if (damagedImage) {
                dmgCvs = document.createElement('canvas');
                dmgCvs.width = w; dmgCvs.height = h;
                dmgCvs.getContext('2d').drawImage(damagedImage, 0, 0, w, h);
            }
            try {
                ctx.drawImage(image, 0, 0, w, h);
                data = ctx.getImageData(0, 0, w, h).data;
            } catch (e) { }
            const shards = [];
            const map = {};
            const cols = Math.ceil(w / (r * 1.5));
            const rows = Math.ceil(h / hexHeight);
            for (let c = 0; c < cols; c++) {
                for (let ro = 0; ro < rows; ro++) {
                    const x = c * r * 1.5;
                    let y = ro * hexHeight;
                    if (c % 2 !== 0) y += hexHeight / 2;
                    const px = Math.floor(x);
                    const py = Math.floor(y);
                    if (px >= 0 && px < w && py >= 0 && py < h) {
                        const alpha = data[(py * w + px) * 4 + 3];
                        if (alpha > 40) {
                            const color = isProjectile ? '#ffcc00' : null;
                            const s = new HexShard(isProjectile ? null : cvs, dmgCvs, x, y, r, c, ro, color);
                            shards.push(s);
                            map[c + "," + ro] = s;
                        }
                    }
                }
            }

            // --- PRE-CALCULATE NEIGHBORS (Softbody optimization) ---
            for (const s of shards) {
                const nCoords = DestructorSystem.getNeighborCoords(s.c, s.r);
                for (const nc of nCoords) {
                    const k = nc.c + "," + nc.r;
                    if (map[k]) s.neighbors.push(map[k]);
                }
            }
            // -------------------------------------------------------

            const cacheCvs = document.createElement('canvas');
            cacheCvs.width = w; cacheCvs.height = h;
            const cCtx = cacheCvs.getContext('2d');
            if (isProjectile) {
                cCtx.drawImage(image, 0, 0);
            } else {
                for (const s of shards) {
                    s.drawShape(cCtx);
                }
            }
            entity.hexGrid = {
                shards,
                map,
                srcWidth: w,
                srcHeight: h,
                cacheCanvas: cacheCvs,
                cacheCtx: cCtx,
                cacheDirty: false
            };
            entity.radius = Math.max(w, h) / 2;
            entity.isProjectile = isProjectile;
            if (massOverride) {
                entity.mass = massOverride;
            } else {
                entity.mass = shards.length * DESTRUCTOR_CONFIG.shardMass;
            }
        }

        function drawHexBody(ctx, entity, camera) {
            if (!entity.hexGrid) return;
            const p = worldToScreen(entity.x, entity.y, camera);
            const zoom = camera.zoom;
            if (entity.hexGrid.cacheDirty) {
                const cCtx = entity.hexGrid.cacheCtx;
                cCtx.clearRect(0, 0, entity.hexGrid.srcWidth, entity.hexGrid.srcHeight);
                if (entity.isProjectile) {
                    cCtx.drawImage(projectileImg, 0, 0);
                } else {
                    // --- ZMIANA TUTAJ: RYSOWANIE WARSTWOWE ---

                    // KROK 1: Rysujemy "zdrowe" heksy (te, które się prawie nie ruszają)
                    // One będą na spodzie.
                    for (const s of entity.hexGrid.shards) {
                        if (s.active && !s.isDebris) {
                            // Sprawdzamy czy heks jest wygięty
                            const deformation = Math.hypot(s.deformation.x, s.deformation.y);
                            // Rysujemy tylko jeśli deformacja jest mała (< 2 piksele)
                            if (deformation < 2.0) {
                                s.drawShape(cCtx);
                            }
                        }
                    }

                    // KROK 2: Rysujemy "uszkodzone" heksy (te mocno wygięte)
                    // Rysujemy je JAKO DRUGIE, więc będą NA WIERZCHU
                    for (const s of entity.hexGrid.shards) {
                        if (s.active && !s.isDebris) {
                            const deformation = Math.hypot(s.deformation.x, s.deformation.y);
                            // Rysujemy tylko jeśli deformacja jest duża (>= 2 piksele)
                            if (deformation >= 2.0) {
                                s.drawShape(cCtx);
                            }
                        }
                    }
                    // ----------------------------------------
                }
                entity.hexGrid.cacheDirty = false;
            }
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(entity.angle + DESTRUCTOR_CONFIG.visualRotationOffset);
            ctx.scale(zoom, zoom);
            if (entity.hexGrid.pivot) {
                ctx.translate(-entity.hexGrid.pivot.x, -entity.hexGrid.pivot.y);
            }
            const dw = entity.hexGrid.srcWidth;
            const dh = entity.hexGrid.srcHeight;
            ctx.drawImage(entity.hexGrid.cacheCanvas, -dw / 2, -dh / 2);
            ctx.restore();
        }

        let entities = [];
        const SHIP_URL = 'https://raw.githubusercontent.com/bazylowybazyl/statki/refs/heads/main/assets/capital_ship_rect_v1.png';
        const DAMAGED_URL = 'https://raw.githubusercontent.com/bazylowybazyl/statki/refs/heads/main/assets/damaged.png';
        const player = { x: -1200, y: 0, vx: 0, vy: 0, angle: 0, angVel: 0, radius: 100 };
        const dummy = { x: 1200, y: 0, vx: 0, vy: 0, angle: Math.PI, angVel: 0, radius: 100 };
        let mouse = { x: 0, y: 0, down: false, dragStart: null, dragCurrent: null };
        const keys = {};

        function init() {
            const shipImg = new Image();
            const damagedImg = new Image();
            shipImg.crossOrigin = "Anonymous";
            damagedImg.crossOrigin = "Anonymous";
            let loaded = 0;
            const onLoaded = () => {
                loaded++;
                if (loaded === 2) {
                    statusEl.textContent = "Obrazy załadowane.";
                    setupScene(shipImg, damagedImg);
                }
            };
            shipImg.onload = onLoaded;
            damagedImg.onload = onLoaded;
            shipImg.onerror = () => useFallback();
            damagedImg.onerror = () => useFallback();
            shipImg.src = SHIP_URL;
            damagedImg.src = DAMAGED_URL;
        }

        function setupScene(img, dmgImg) {
            initHexBody(player, img, dmgImg, false, 800000);
            initHexBody(dummy, img, dmgImg, false, 20000);
            entities.push(player, dummy);
            const debrisImg = new Image();
            debrisImg.src = createDebrisObstacle().toDataURL();
            debrisImg.onload = () => {
                for (let i = 0; i < 5; i++) {
                    const d = {
                        x: -400 + i * 150,
                        y: 0,
                        vx: 0, vy: 0, angle: Math.random(), angVel: 0, radius: 40
                    };
                    initHexBody(d, debrisImg, null, false, 50);
                    entities.push(d);
                }
            };
            loop();
        }

        function useFallback() {
            statusEl.textContent = "Błąd sieci/CORS. Uruchamianie generatora awaryjnego...";
            const procImg = createProceduralShipImage('#445566');
            const procDmg = createProceduralShipImage('#222222');
            const img = new Image();
            img.onload = () => {
                const imgD = new Image();
                imgD.onload = () => setupScene(img, imgD);
                imgD.src = procDmg.toDataURL();
            };
            img.src = procImg.toDataURL();
        }

        function resetSim() {
            entities = [];
            player.x = -1200; player.y = 0; player.vx = 0; player.vy = 0; player.angle = 0;
            dummy.x = 1200; dummy.y = 0; dummy.vx = 0; dummy.vy = 0; dummy.angle = Math.PI;
            init();
            DestructorSystem.debris = [];
        }

        function fireAsteroid(startPos, endPos) {
            const dx = endPos.x - startPos.x;
            const dy = endPos.y - startPos.y;
            const len = Math.hypot(dx, dy);
            // ZWIĘKSZONO PRĘDKOŚĆ 2X
            const speed = Math.min(len * 10, 4000);
            const dirX = len > 0 ? dx / len : 0;
            const dirY = len > 0 ? dy / len : 1;
            const radius = 60;
            const asteroidImg = new Image();
            asteroidImg.src = createAsteroidImage(radius).toDataURL();
            const ast = {
                x: startPos.x,
                y: startPos.y,
                vx: dirX * speed,
                vy: dirY * speed,
                angle: Math.random() * Math.PI * 2,
                angVel: (Math.random() - 0.5) * 5,
                radius: radius
            };
            asteroidImg.onload = () => {
                // ZWIĘKSZONO MASĘ (1 000 000)
                initHexBody(ast, asteroidImg, null, false, 1000000);

                // ZWIĘKSZONO ŻYCIE (x10)
                if (ast.hexGrid) {
                    for (const s of ast.hexGrid.shards) {
                        s.maxHp *= 10;
                        s.hp = s.maxHp;
                    }
                }
                entities.push(ast);
            };
        }

        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.code === 'Space') resetSim();
            if (e.code === 'KeyR') DestructorSystem.repair(entities, 0.1);
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            if (mouse.down) {
                mouse.dragCurrent = { x: mouse.x, y: mouse.y };
            }
        });

        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                mouse.down = true;
                mouse.dragStart = { x: mouse.x, y: mouse.y };
                mouse.dragCurrent = { x: mouse.x, y: mouse.y };
            }
            if (e.button === 2) mouse.right = true;
        });
        window.addEventListener('mouseup', (e) => {
            if (e.button === 0 && mouse.dragStart) {
                const worldStart = screenToWorld(mouse.dragStart.x, mouse.dragStart.y, camera);
                const worldEnd = screenToWorld(mouse.dragCurrent.x, mouse.dragCurrent.y, camera);
                if (Math.hypot(mouse.dragStart.x - mouse.dragCurrent.x, mouse.dragStart.y - mouse.dragCurrent.y) > 10) {
                    fireAsteroid(worldStart, worldEnd);
                }
                mouse.down = false;
                mouse.dragStart = null;
                mouse.dragCurrent = null;
            }
            if (e.button === 2) mouse.right = false;
        });
        window.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSpeed = 0.001;
            camera.zoom -= e.deltaY * zoomSpeed * camera.zoom;
            camera.zoom = Math.max(0.2, Math.min(camera.zoom, 3.0));
        }, { passive: false });

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        });

        function updatePhysics(dt) {
            const speed = 600;
            if (keys['w']) {
                player.vx += Math.cos(player.angle) * speed * dt;
                player.vy += Math.sin(player.angle) * speed * dt;
            }
            if (keys['s']) {
                player.vx -= Math.cos(player.angle) * (speed * 0.5) * dt;
                player.vy -= Math.sin(player.angle) * (speed * 0.5) * dt;
            }
            const turnAcceleration = 10.0;
            const maxTurnSpeed = 2.5;

            if (keys['a']) {
                player.angVel -= turnAcceleration * dt;
            } else if (keys['d']) {
                player.angVel += turnAcceleration * dt;
            }

            player.vx *= 0.99;
            player.vy *= 0.99;
            player.angVel *= 0.92;

            if (Math.abs(player.angVel) > maxTurnSpeed) {
                player.angVel = Math.sign(player.angVel) * maxTurnSpeed;
            }

            dummy.vx *= 0.99;
            dummy.vy *= 0.99;
            dummy.angVel *= 0.95;

            DestructorSystem.updateVisualDeformation(entities, dt);

            const aliveEntities = [];
            for (const e of entities) {
                e.x += e.vx * dt;
                e.y += e.vy * dt;
                if (e.angVel) e.angle += e.angVel * dt;

                if (e.isProjectile && (e.dead || Math.hypot(e.x - player.x, e.y - player.y) > 5000)) {
                    continue;
                }
                aliveEntities.push(e);
            }
            if (aliveEntities.length !== entities.length) {
                entities.length = 0;
                entities.push(...aliveEntities);
            }

            if (mouse.right) {
                const mWorld = screenToWorld(mouse.x, mouse.y, camera);
                const dx = mWorld.x - player.x;
                const dy = mWorld.y - player.y;
                const len = Math.hypot(dx, dy);
                const ndx = dx / len;
                const ndy = dy / len;
                const beamLen = 3000;
                const p1 = { x: player.x, y: player.y };
                const p2 = { x: player.x + ndx * beamLen, y: player.y + ndy * beamLen };
                for (const target of entities) {
                    if (!target.hexGrid) continue;
                    DestructorSystem.cutByBeam(target, p1, p2, 12);
                }
            }

            DestructorSystem.update(dt, entities);
        }

        function draw() {
            ctx.fillStyle = '#080808';
            ctx.fillRect(0, 0, width, height);

            const midX = (player.x + dummy.x) / 2;
            const midY = (player.y + dummy.y) / 2;
            camera.x += (midX - camera.x) * 0.1;
            camera.y += (midY - camera.y) * 0.1;

            const gw = 100 * camera.zoom;
            const offX = (width / 2 - camera.x * camera.zoom) % gw;
            const offY = (height / 2 - camera.y * camera.zoom) % gw;
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = offX; x < width; x += gw) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
            for (let y = offY; y < height; y += gw) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
            ctx.stroke();

            DestructorSystem.draw(ctx, camera);

            for (const e of entities) {
                drawHexBody(ctx, e, camera);
            }

            if (mouse.right) {
                const mWorld = screenToWorld(mouse.x, mouse.y, camera);
                const dx = mWorld.x - player.x;
                const dy = mWorld.y - player.y;
                const len = Math.hypot(dx, dy);
                const ndx = dx / len;
                const ndy = dy / len;
                const beamLen = 3000;
                const p1 = { x: player.x, y: player.y };
                const p2 = { x: player.x + ndx * beamLen, y: player.y + ndy * beamLen };
                const s1 = worldToScreen(p1.x, p1.y, camera);
                const s2 = worldToScreen(p2.x, p2.y, camera);
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(s1.x, s1.y);
                ctx.lineTo(s2.x, s2.y);
                ctx.lineWidth = 5 * camera.zoom;
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';
                ctx.stroke();
                ctx.restore();
            }

            if (mouse.down && mouse.dragStart && mouse.dragCurrent) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(mouse.dragStart.x, mouse.dragStart.y);
                ctx.lineTo(mouse.dragCurrent.x, mouse.dragCurrent.y);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                const angle = Math.atan2(mouse.dragCurrent.y - mouse.dragStart.y, mouse.dragCurrent.x - mouse.dragStart.x);
                ctx.translate(mouse.dragCurrent.x, mouse.dragCurrent.y);
                ctx.rotate(angle);
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, -5);
                ctx.lineTo(-10, 5);
                ctx.fill();
                ctx.restore();
            }
        }

        let lastTime = 0;
        function loop(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1) || 0.016;
            lastTime = timestamp;
            updatePhysics(dt);
            draw();
            requestAnimationFrame(loop);
        }

        init();
        document.getElementById('shipPicker').addEventListener('change', function (e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (event) {
                const img = new Image();
                img.onload = function () {
                    player.hexGrid = null;
                    const damagedImg = new Image();
                    damagedImg.src = DAMAGED_URL;
                    damagedImg.onload = () => {
                        initHexBody(player, img, damagedImg, false, DESTRUCTOR_CONFIG.playerStartingMass);
                        player.vx = 0;
                        player.vy = 0;
                        statusEl.textContent = "Wczytano nowy sprite: " + file.name;
                    };
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
    </script>
</body>

</html>
