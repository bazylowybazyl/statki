<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Destruktor Hybrid WebGPU PoC</title>
  <style>
    body { margin:0; overflow:hidden; background:#070b13; color:#cfe3ff; font:13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #hud { position:absolute; top:12px; left:12px; padding:12px; border:1px solid #30435f; background:rgba(10,20,40,.9); border-radius:8px; max-width:520px; }
    #hud h3 { margin:0 0 8px 0; font-size:14px; color:#fff; }
    #hud button { margin:2px 4px 2px 0; background:#16253e; color:#dce8ff; border:1px solid #3c567f; border-radius:6px; padding:5px 8px; cursor:pointer; }
    #hud button:hover { background:#1c3154; }
    #stats { white-space:pre; margin-top:8px; color:#a8c1e9; }
    #bench { margin-top:8px; white-space:pre; color:#8fd3aa; font-size:12px; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="hud">
    <h3>Hybrid Physics WebGPU PoC (WGSL compute + CPU fallback)</h3>
    <div>PPM: duży impuls (plastic/yield) | LPM: mały impuls (rigid bounce) | [R] reset | [B] benchmark</div>
    <div style="margin-top:6px;">Backend: <b id="backend">init...</b></div>
    <div id="stats"></div>
    <div id="bench"></div>
    <div style="margin-top:8px;color:#88a9da;">Uwaga: render 2D i collision solve pozostają na CPU, compute (WGSL) obsługuje integrację/deformation pass shardów.</div>
  </div>
  <canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const backendEl = document.getElementById('backend');
  const statsEl = document.getElementById('stats');
  const benchEl = document.getElementById('bench');
  let W = canvas.width = innerWidth;
  let H = canvas.height = innerHeight;

  const CFG = {
    dtFixed: 1 / 120,
    shardRadius: 9,
    restitution: 0.08,
    friction: 0.992,
    yieldPoint: 1000,
    plasticity: 0.00003,
    tearThreshold: 65,
    maxHp: 480,
    debrisDrag: 0.988,
  };

  class HexShard {
    constructor(entityId, gridX, gridY) {
      this.entityId = entityId;
      this.gridX = gridX;
      this.gridY = gridY;
      this.worldX = 0;
      this.worldY = 0;
      this.vx = 0;
      this.vy = 0;
      this.hp = CFG.maxHp;
      this.active = 1;
      this.isDebris = 0;
      this.deformX = 0;
      this.deformY = 0;
      this.targetDefX = 0;
      this.targetDefY = 0;
      this.neighbors = [];
    }
  }

  function makeEntity(id, x, y, cols, rows) {
    const e = { id, x, y, vx: 0, vy: 0, mass: cols * rows * 12, radius: Math.max(cols, rows) * CFG.shardRadius * 1.3, shards: [] };
    const map = new Map();
    const hexW = CFG.shardRadius * 1.5;
    const hexH = CFG.shardRadius * Math.sqrt(3);
    let idx = 0;
    for (let c = 0; c < cols; c++) {
      for (let r = 0; r < rows; r++) {
        const offset = (c & 1) ? hexH * 0.5 : 0;
        const sx = c * hexW;
        const sy = r * hexH + offset;
        const s = new HexShard(id, sx, sy);
        map.set(`${c},${r}`, { shard: s, c, r, i: idx++ });
        e.shards.push(s);
      }
    }
    const oddOff = [[0,-1],[0,1],[-1,0],[-1,1],[1,0],[1,1]];
    const evenOff = [[0,-1],[0,1],[-1,-1],[-1,0],[1,-1],[1,0]];
    for (const [key, v] of map) {
      const offs = (v.c & 1) ? oddOff : evenOff;
      for (const o of offs) {
        const n = map.get(`${v.c+o[0]},${v.r+o[1]}`);
        if (n) v.shard.neighbors.push(n.shard);
      }
    }
    return e;
  }

  function resetScene(type = 'duel') {
    const entities = [];
    if (type === 'duel') {
      const a = makeEntity(0, W * 0.35, H * 0.5, 10, 9);
      const b = makeEntity(1, W * 0.65, H * 0.5, 10, 9);
      a.vx = 60; b.vx = -60;
      entities.push(a, b);
    } else {
      for (let i = 0; i < 8; i++) {
        const e = makeEntity(i, W * 0.15 + i * (W * 0.1), H * (0.25 + (i & 1) * 0.4), 8, 8);
        e.vx = (i & 1) ? -35 : 35;
        entities.push(e);
      }
    }
    const shards = entities.flatMap(e => e.shards);
    for (const e of entities) {
      for (const s of e.shards) {
        s.worldX = e.x + s.gridX;
        s.worldY = e.y + s.gridY;
      }
    }
    return { entities, shards, t: 0, sceneName: type };
  }

  function collisionStepCPU(state, dt) {
    const ents = state.entities;
    for (let i = 0; i < ents.length; i++) {
      const A = ents[i];
      A.x += A.vx * dt; A.y += A.vy * dt;
      for (let j = i + 1; j < ents.length; j++) {
        const B = ents[j];
        const dx = B.x - A.x, dy = B.y - A.y;
        const dist = Math.hypot(dx, dy) || 0.001;
        const overlap = (A.radius + B.radius) - dist;
        if (overlap <= 0) continue;
        const nx = dx / dist, ny = dy / dist;
        const rvx = A.vx - B.vx, rvy = A.vy - B.vy;
        const vRelN = rvx * nx + rvy * ny;
        const invMassA = 1 / Math.max(A.mass, 1), invMassB = 1 / Math.max(B.mass, 1);
        const jImp = -(1 + CFG.restitution) * vRelN / (invMassA + invMassB);
        const ix = jImp * nx, iy = jImp * ny;
        A.vx += ix * invMassA; A.vy += iy * invMassA;
        B.vx -= ix * invMassB; B.vy -= iy * invMassB;

        const impactForce = Math.abs(jImp) / Math.max(dt, 1e-4);
        if (impactForce > CFG.yieldPoint) {
          const excess = (impactForce - CFG.yieldPoint) * CFG.plasticity;
          applyDamage(A, nx, ny, excess);
          applyDamage(B, -nx, -ny, excess);
        }

        const corr = overlap * 0.45;
        A.x -= nx * corr * invMassA * 20;
        A.y -= ny * corr * invMassA * 20;
        B.x += nx * corr * invMassB * 20;
        B.y += ny * corr * invMassB * 20;
      }
      A.vx *= CFG.friction; A.vy *= CFG.friction;
    }
  }

  function applyDamage(entity, nx, ny, amount) {
    const px = entity.x, py = entity.y;
    for (const s of entity.shards) {
      if (!s.active || s.isDebris) continue;
      const dx = s.worldX - px, dy = s.worldY - py;
      const falloff = Math.max(0, 1 - (Math.hypot(dx, dy) / (entity.radius * 0.7)));
      if (falloff <= 0) continue;
      s.targetDefX += nx * amount * 150 * falloff;
      s.targetDefY += ny * amount * 150 * falloff;
      s.hp -= amount * 2500 * falloff;
      if (Math.hypot(s.targetDefX, s.targetDefY) > CFG.tearThreshold || s.hp <= 0) {
        s.active = 0;
        s.isDebris = 1;
        s.vx = entity.vx + nx * (90 + Math.random() * 30);
        s.vy = entity.vy + ny * (90 + Math.random() * 30);
      }
    }
  }

  class CPUBackend {
    constructor() { this.name = 'CPU fallback'; }
    async init(state) { this.state = state; }
    async step(dt) {
      const shards = this.state.shards;
      for (const s of shards) {
        if (!s.active && s.isDebris) {
          s.worldX += s.vx * dt;
          s.worldY += s.vy * dt;
          s.vx *= CFG.debrisDrag;
          s.vy *= CFG.debrisDrag;
          s.hp -= dt * 20;
          if (s.hp <= -80) s.isDebris = 0;
        } else if (s.active) {
          s.deformX += (s.targetDefX - s.deformX) * Math.min(1, dt * 6);
          s.deformY += (s.targetDefY - s.deformY) * Math.min(1, dt * 6);
          s.targetDefX *= (1 - Math.min(1, dt * 1.2));
          s.targetDefY *= (1 - Math.min(1, dt * 1.2));
        }
      }
    }
    async syncFromGPU() {}
  }

  class WebGPUBackend {
    constructor() { this.name = 'WebGPU compute (WGSL)'; this.frame = 0; }
    async init(state) {
      this.state = state;
      if (!navigator.gpu) throw new Error('navigator.gpu niedostępne');
      this.adapter = await navigator.gpu.requestAdapter();
      if (!this.adapter) throw new Error('Brak adaptera WebGPU');
      this.device = await this.adapter.requestDevice();
      this.shardCount = state.shards.length;
      this.stride = 12;
      this.data = new Float32Array(this.shardCount * this.stride);
      this.gpuBuffer = this.device.createBuffer({ size: this.data.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
      this.readBuffer = this.device.createBuffer({ size: this.data.byteLength, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });
      this.paramBuffer = this.device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

      const module = this.device.createShaderModule({
        code: `
struct Params { dt: f32, drag: f32, relax: f32, pad: f32 };
@group(0) @binding(0) var<storage, read_write> shards: array<vec4<f32>>;
@group(0) @binding(1) var<uniform> params: Params;
@compute @workgroup_size(128)
fn main(@builtin(global_invocation_id) id: vec3<u32>) {
  let i = id.x;
  let base = i * 3u;
  if (base + 2u >= arrayLength(&shards)) { return; }
  var a = shards[base + 0u]; // worldX worldY velX velY
  var b = shards[base + 1u]; // hp active isDebris _
  var c = shards[base + 2u]; // deformX deformY targetX targetY

  if (b.y < 0.5 && b.z > 0.5) {
    a.x = a.x + a.z * params.dt;
    a.y = a.y + a.w * params.dt;
    a.z = a.z * params.drag;
    a.w = a.w * params.drag;
    b.x = b.x - params.dt * 20.0;
    if (b.x <= -80.0) { b.z = 0.0; }
  } else if (b.y > 0.5) {
    c.x = c.x + (c.z - c.x) * params.relax;
    c.y = c.y + (c.w - c.y) * params.relax;
    c.z = c.z * (1.0 - params.dt * 1.2);
    c.w = c.w * (1.0 - params.dt * 1.2);
  }

  shards[base + 0u] = a;
  shards[base + 1u] = b;
  shards[base + 2u] = c;
}`
      });

      this.pipeline = this.device.createComputePipeline({ layout: 'auto', compute: { module, entryPoint: 'main' } });
      this.bind = this.device.createBindGroup({ layout: this.pipeline.getBindGroupLayout(0), entries: [
        { binding: 0, resource: { buffer: this.gpuBuffer } },
        { binding: 1, resource: { buffer: this.paramBuffer } },
      ]});
      this.pushCPUToGPU();
    }

    pushCPUToGPU() {
      const shards = this.state.shards;
      for (let i = 0; i < shards.length; i++) {
        const s = shards[i];
        const b = i * this.stride;
        this.data[b+0] = s.worldX; this.data[b+1] = s.worldY; this.data[b+2] = s.vx; this.data[b+3] = s.vy;
        this.data[b+4] = s.hp; this.data[b+5] = s.active; this.data[b+6] = s.isDebris; this.data[b+7] = 0;
        this.data[b+8] = s.deformX; this.data[b+9] = s.deformY; this.data[b+10] = s.targetDefX; this.data[b+11] = s.targetDefY;
      }
      this.device.queue.writeBuffer(this.gpuBuffer, 0, this.data);
    }

    async step(dt) {
      this.pushCPUToGPU();
      const relax = Math.min(1, dt * 6);
      this.device.queue.writeBuffer(this.paramBuffer, 0, new Float32Array([dt, CFG.debrisDrag, relax, 0]));
      const enc = this.device.createCommandEncoder();
      const pass = enc.beginComputePass();
      pass.setPipeline(this.pipeline);
      pass.setBindGroup(0, this.bind);
      const groups = Math.ceil(this.shardCount / 128);
      pass.dispatchWorkgroups(groups);
      pass.end();

      if ((this.frame++ % 4) === 0) {
        enc.copyBufferToBuffer(this.gpuBuffer, 0, this.readBuffer, 0, this.data.byteLength);
      }
      this.device.queue.submit([enc.finish()]);
      if ((this.frame % 4) === 1) await this.syncFromGPU();
    }

    async syncFromGPU() {
      await this.readBuffer.mapAsync(GPUMapMode.READ);
      const mapped = new Float32Array(this.readBuffer.getMappedRange());
      const shards = this.state.shards;
      for (let i = 0; i < shards.length; i++) {
        const s = shards[i];
        const b = i * this.stride;
        s.worldX = mapped[b+0]; s.worldY = mapped[b+1]; s.vx = mapped[b+2]; s.vy = mapped[b+3];
        s.hp = mapped[b+4]; s.active = mapped[b+5] > 0.5 ? 1 : 0; s.isDebris = mapped[b+6] > 0.5 ? 1 : 0;
        s.deformX = mapped[b+8]; s.deformY = mapped[b+9]; s.targetDefX = mapped[b+10]; s.targetDefY = mapped[b+11];
      }
      this.readBuffer.unmap();
    }
  }

  let state = resetScene('duel');
  let backend = null;
  let last = performance.now();
  let acc = 0;
  let frame = 0;
  const timings = { cpu: 0, gpu: 0, render: 0 };

  async function makeBackend() {
    try {
      const b = new WebGPUBackend();
      await b.init(state);
      backendEl.textContent = b.name;
      return b;
    } catch (err) {
      const b = new CPUBackend();
      await b.init(state);
      backendEl.textContent = `${b.name} (${err.message})`;
      return b;
    }
  }

  function syncAttachedShards() {
    for (const e of state.entities) {
      for (const s of e.shards) {
        if (s.active && !s.isDebris) {
          s.worldX = e.x + s.gridX + s.deformX;
          s.worldY = e.y + s.gridY + s.deformY;
        }
      }
    }
  }

  function draw() {
    const t0 = performance.now();
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = '#0a1222';
    ctx.fillRect(0, 0, W, H);

    for (const s of state.shards) {
      if (!s.active && !s.isDebris) continue;
      ctx.beginPath();
      ctx.arc(s.worldX, s.worldY, CFG.shardRadius * 0.72, 0, Math.PI * 2);
      if (s.isDebris) ctx.fillStyle = 'rgba(255,130,50,0.7)';
      else {
        const stress = Math.hypot(s.deformX, s.deformY);
        const r = Math.min(255, 80 + stress * 6);
        const g = Math.max(80, 200 - stress * 4);
        ctx.fillStyle = `rgb(${r},${g},220)`;
      }
      ctx.fill();
    }
    timings.render += performance.now() - t0;
  }

  function pointerImpulse(x, y, force) {
    for (const e of state.entities) {
      for (const s of e.shards) {
        if (!s.active || s.isDebris) continue;
        const dx = s.worldX - x, dy = s.worldY - y;
        const d = Math.hypot(dx, dy);
        if (d > 160) continue;
        const fall = 1 - d / 160;
        s.targetDefX += (dx / Math.max(d, 1)) * force * fall * 0.03;
        s.targetDefY += (dy / Math.max(d, 1)) * force * fall * 0.03;
        if (force > CFG.yieldPoint) {
          s.hp -= fall * force * 0.06;
          if (s.hp <= 0) {
            s.active = 0; s.isDebris = 1;
            s.vx = dx * 0.7 + (Math.random() - 0.5) * 30;
            s.vy = dy * 0.7 + (Math.random() - 0.5) * 30;
          }
        }
      }
    }
  }

  async function runBenchmark() {
    const scenes = [
      { name: 'A: 2 encje x 90 shardów', type: 'duel', frames: 320 },
      { name: 'B: 8 encji x 64 shardy', type: 'cluster', frames: 320 }
    ];
    let out = 'Benchmark (fixed dt=1/120):\n';
    for (const sc of scenes) {
      state = resetScene(sc.type);
      const cpu = new CPUBackend();
      await cpu.init(state);
      let tCpu = 0;
      for (let i = 0; i < sc.frames; i++) {
        const t0 = performance.now();
        collisionStepCPU(state, CFG.dtFixed);
        syncAttachedShards();
        await cpu.step(CFG.dtFixed);
        tCpu += performance.now() - t0;
      }

      state = resetScene(sc.type);
      let tGpu = NaN;
      try {
        const gpu = new WebGPUBackend();
        await gpu.init(state);
        tGpu = 0;
        for (let i = 0; i < sc.frames; i++) {
          const t0 = performance.now();
          collisionStepCPU(state, CFG.dtFixed);
          syncAttachedShards();
          await gpu.step(CFG.dtFixed);
          tGpu += performance.now() - t0;
        }
      } catch (_err) {
        tGpu = NaN;
      }
      const cpuMs = (tCpu / sc.frames).toFixed(3);
      const gpuMs = Number.isNaN(tGpu) ? 'n/a' : (tGpu / sc.frames).toFixed(3);
      const cpuFps = (1000 / (tCpu / sc.frames)).toFixed(1);
      const gpuFps = Number.isNaN(tGpu) ? 'n/a' : (1000 / (tGpu / sc.frames)).toFixed(1);
      out += `${sc.name}\n  CPU: ${cpuMs} ms/frame (~${cpuFps} FPS)\n  GPU: ${gpuMs} ms/frame (~${gpuFps} FPS)\n`;
    }
    benchEl.textContent = out;
  }

  canvas.addEventListener('mousedown', (e) => {
    const heavy = e.button === 2;
    pointerImpulse(e.clientX, e.clientY, heavy ? 1800 : 350);
  });
  canvas.addEventListener('contextmenu', (e) => e.preventDefault());
  addEventListener('keydown', async (e) => {
    if (e.key.toLowerCase() === 'r') {
      state = resetScene(state.sceneName);
      backend = await makeBackend();
    }
    if (e.key.toLowerCase() === 'b') runBenchmark();
    if (e.key === '1') { state = resetScene('duel'); backend = await makeBackend(); }
    if (e.key === '2') { state = resetScene('cluster'); backend = await makeBackend(); }
  });
  addEventListener('resize', () => { W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

  async function frameLoop(now) {
    const delta = Math.min(0.05, (now - last) / 1000);
    last = now;
    acc += delta;
    while (acc >= CFG.dtFixed) {
      const t0 = performance.now();
      collisionStepCPU(state, CFG.dtFixed);
      timings.cpu += performance.now() - t0;
      syncAttachedShards();
      const t1 = performance.now();
      await backend.step(CFG.dtFixed);
      timings.gpu += performance.now() - t1;
      state.t += CFG.dtFixed;
      acc -= CFG.dtFixed;
    }
    draw();
    if ((frame++ % 30) === 0) {
      const alive = state.shards.filter(s => s.active && !s.isDebris).length;
      const debris = state.shards.filter(s => s.isDebris).length;
      statsEl.textContent =
`scene=${state.sceneName} shards=${state.shards.length} alive=${alive} debris=${debris}
CPU collision avg: ${(timings.cpu / Math.max(1, frame)).toFixed(3)} ms/frame
backend step avg: ${(timings.gpu / Math.max(1, frame)).toFixed(3)} ms/frame
render avg: ${(timings.render / Math.max(1, frame)).toFixed(3)} ms/frame`;
    }
    requestAnimationFrame(frameLoop);
  }

  (async () => {
    backend = await makeBackend();
    requestAnimationFrame(frameLoop);
  })();
})();
</script>
</body>
</html>
