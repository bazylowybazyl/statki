*** Begin Patch
*** Update File: planet3d.proc.js
@@
-const PLANET_VERT = `attribute vec3 tangent;
+const PLANET_VERT = `
 
     // Terrain generation parameters
     uniform int type;
     uniform float radius;
     uniform float amplitude;
@@
-    varying vec3 fragTangent;
-    varying vec3 fragBitangent;
+    varying vec3 fragTangent;
+    varying vec3 fragBitangent;
 
     void main() {
       // Calculate terrain height
       float h = terrainHeight(
         type,
@@
-      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
-      fragPosition = position;
-      fragNormal = normal;
-      fragTangent = tangent;
-      fragBitangent = cross(normal, tangent);
+      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
+      fragPosition = position;
+      // Sfera: normalna w przestrzeni obiektu ≈ znormalizowana pozycja
+      vec3 N = normalize(position);
+      fragNormal = N;
+      // Zbudujmy bazę TBN w shaderze (bez atrybutu tangent z geometrii)
+      vec3 up = (abs(N.y) > 0.99) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0);
+      vec3 T = normalize(cross(up, N));
+      vec3 B = normalize(cross(N, T));
+      fragTangent = T;
+      fragBitangent = B;
     }`;
*** End Patch
*** Begin Patch
*** Update File: planet3d.proc.js
@@
       r.toneMapping = THREE.ACESFilmicToneMapping;
       r.toneMappingExposure = 1.1;
       r.outputColorSpace = THREE.SRGBColorSpace;
-      if (!this.composer || this._renderer !== r) {
+      const hasPP = (typeof EffectComposer !== 'undefined') &&
+                    (typeof RenderPass !== 'undefined') &&
+                    (typeof UnrealBloomPass !== 'undefined');
+      if (hasPP && (!this.composer || this._renderer !== r)) {
         this._renderer = r;
         this.composer = new EffectComposer(r);
         this.composer.setSize(this.canvas.width, this.canvas.height);
         const rp = new RenderPass(this.scene, this.camera);
         this.bloom = new UnrealBloomPass(new THREE.Vector2(this.canvas.width, this.canvas.height), 1.14, 1.04, 0.0);
         this.composer.addPass(rp);
         this.composer.addPass(this.bloom);
-      }
-      this.composer.render();
+      }
+      if (this.composer) {
+        this.composer.render();
+      } else {
+        // Fallback bez postprocessingu (żeby nie było czarnego środka)
+        r.render(this.scene, this.camera);
+      }
       this.ctx2d.clearRect(0,0,this.canvas.width,this.canvas.height);
       this.ctx2d.drawImage(r.domElement,0,0);
     }
   }
*** End Patch
